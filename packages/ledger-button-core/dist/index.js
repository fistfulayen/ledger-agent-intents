var $8 = Object.defineProperty;
var pD = (r) => {
  throw TypeError(r);
};
var R8 = (r, e, t) => e in r ? $8(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var h = (r, e, t) => R8(r, typeof e != "symbol" ? e + "" : e, t), L0 = (r, e, t) => e.has(r) || pD("Cannot " + t);
var m = (r, e, t) => (L0(r, e, "read from private field"), t ? t.call(r) : e.get(r)), L = (r, e, t) => e.has(r) ? pD("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(r) : e.set(r, t), D = (r, e, t, n) => (L0(r, e, "write to private field"), n ? n.call(r, t) : e.set(r, t), t), R = (r, e, t) => (L0(r, e, "access private method"), t);
var gD = (r, e, t, n) => ({
  set _(i) {
    D(r, e, i, t);
  },
  get _() {
    return m(r, e, n);
  }
});
var As = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function KI(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
function P8(r) {
  if (Object.prototype.hasOwnProperty.call(r, "__esModule")) return r;
  var e = r.default;
  if (typeof e == "function") {
    var t = function n() {
      return this instanceof n ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(r).forEach(function(n) {
    var i = Object.getOwnPropertyDescriptor(r, n);
    Object.defineProperty(t, n, i.get ? i : {
      enumerable: !0,
      get: function() {
        return r[n];
      }
    });
  }), t;
}
var mD = {};
/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var yD;
function N8() {
  if (yD) return mD;
  yD = 1;
  var r;
  return (function(e) {
    (function(t) {
      var n = typeof globalThis == "object" ? globalThis : typeof As == "object" ? As : typeof self == "object" ? self : typeof this == "object" ? this : c(), i = s(e);
      typeof n.Reflect < "u" && (i = s(n.Reflect, i)), t(i, n), typeof n.Reflect > "u" && (n.Reflect = e);
      function s(u, l) {
        return function(d, f) {
          Object.defineProperty(u, d, { configurable: !0, writable: !0, value: f }), l && l(d, f);
        };
      }
      function o() {
        try {
          return Function("return this;")();
        } catch {
        }
      }
      function a() {
        try {
          return (0, eval)("(function() { return this; })()");
        } catch {
        }
      }
      function c() {
        return o() || a();
      }
    })(function(t, n) {
      var i = Object.prototype.hasOwnProperty, s = typeof Symbol == "function", o = s && typeof Symbol.toPrimitive < "u" ? Symbol.toPrimitive : "@@toPrimitive", a = s && typeof Symbol.iterator < "u" ? Symbol.iterator : "@@iterator", c = typeof Object.create == "function", u = { __proto__: [] } instanceof Array, l = !c && !u, d = {
        // create an object in dictionary mode (a.k.a. "slow" mode in v8)
        create: c ? function() {
          return Rr(/* @__PURE__ */ Object.create(null));
        } : u ? function() {
          return Rr({ __proto__: null });
        } : function() {
          return Rr({});
        },
        has: l ? function(U, G) {
          return i.call(U, G);
        } : function(U, G) {
          return G in U;
        },
        get: l ? function(U, G) {
          return i.call(U, G) ? U[G] : void 0;
        } : function(U, G) {
          return U[G];
        }
      }, f = Object.getPrototypeOf(Function), p = typeof Map == "function" && typeof Map.prototype.entries == "function" ? Map : jr(), y = typeof Set == "function" && typeof Set.prototype.entries == "function" ? Set : tr(), g = typeof WeakMap == "function" ? WeakMap : bn(), v = s ? Symbol.for("@reflect-metadata:registry") : void 0, _ = ae(), w = fe(_);
      function E(U, G, W, se) {
        if (z(W)) {
          if (!Re(U))
            throw new TypeError();
          if (!Xe(G))
            throw new TypeError();
          return J(U, G);
        } else {
          if (!Re(U))
            throw new TypeError();
          if (!de(G))
            throw new TypeError();
          if (!de(se) && !z(se) && !ce(se))
            throw new TypeError();
          return ce(se) && (se = void 0), W = Ie(W), O(U, G, W, se);
        }
      }
      t("decorate", E);
      function I(U, G) {
        function W(se, $) {
          if (!de(se))
            throw new TypeError();
          if (!z($) && !vt($))
            throw new TypeError();
          K(U, G, se, $);
        }
        return W;
      }
      t("metadata", I);
      function S(U, G, W, se) {
        if (!de(W))
          throw new TypeError();
        return z(se) || (se = Ie(se)), K(U, G, W, se);
      }
      t("defineMetadata", S);
      function T(U, G, W) {
        if (!de(G))
          throw new TypeError();
        return z(W) || (W = Ie(W)), x(U, G, W);
      }
      t("hasMetadata", T);
      function b(U, G, W) {
        if (!de(G))
          throw new TypeError();
        return z(W) || (W = Ie(W)), k(U, G, W);
      }
      t("hasOwnMetadata", b);
      function C(U, G, W) {
        if (!de(G))
          throw new TypeError();
        return z(W) || (W = Ie(W)), B(U, G, W);
      }
      t("getMetadata", C);
      function P(U, G, W) {
        if (!de(G))
          throw new TypeError();
        return z(W) || (W = Ie(W)), A(U, G, W);
      }
      t("getOwnMetadata", P);
      function Z(U, G) {
        if (!de(U))
          throw new TypeError();
        return z(G) || (G = Ie(G)), F(U, G);
      }
      t("getMetadataKeys", Z);
      function Y(U, G) {
        if (!de(U))
          throw new TypeError();
        return z(G) || (G = Ie(G)), j(U, G);
      }
      t("getOwnMetadataKeys", Y);
      function q(U, G, W) {
        if (!de(G))
          throw new TypeError();
        if (z(W) || (W = Ie(W)), !de(G))
          throw new TypeError();
        z(W) || (W = Ie(W));
        var se = Ve(
          G,
          W,
          /*Create*/
          !1
        );
        return z(se) ? !1 : se.OrdinaryDeleteMetadata(U, G, W);
      }
      t("deleteMetadata", q);
      function J(U, G) {
        for (var W = U.length - 1; W >= 0; --W) {
          var se = U[W], $ = se(G);
          if (!z($) && !ce($)) {
            if (!Xe($))
              throw new TypeError();
            G = $;
          }
        }
        return G;
      }
      function O(U, G, W, se) {
        for (var $ = U.length - 1; $ >= 0; --$) {
          var V = U[$], Te = V(G, W, se);
          if (!z(Te) && !ce(Te)) {
            if (!de(Te))
              throw new TypeError();
            se = Te;
          }
        }
        return se;
      }
      function x(U, G, W) {
        var se = k(U, G, W);
        if (se)
          return !0;
        var $ = an(G);
        return ce($) ? !1 : x(U, $, W);
      }
      function k(U, G, W) {
        var se = Ve(
          G,
          W,
          /*Create*/
          !1
        );
        return z(se) ? !1 : Se(se.OrdinaryHasOwnMetadata(U, G, W));
      }
      function B(U, G, W) {
        var se = k(U, G, W);
        if (se)
          return A(U, G, W);
        var $ = an(G);
        if (!ce($))
          return B(U, $, W);
      }
      function A(U, G, W) {
        var se = Ve(
          G,
          W,
          /*Create*/
          !1
        );
        if (!z(se))
          return se.OrdinaryGetOwnMetadata(U, G, W);
      }
      function K(U, G, W, se) {
        var $ = Ve(
          W,
          se,
          /*Create*/
          !0
        );
        $.OrdinaryDefineOwnMetadata(U, G, W, se);
      }
      function F(U, G) {
        var W = j(U, G), se = an(U);
        if (se === null)
          return W;
        var $ = F(se, G);
        if ($.length <= 0)
          return W;
        if (W.length <= 0)
          return $;
        for (var V = new y(), Te = [], Ce = 0, ge = W; Ce < ge.length; Ce++) {
          var ue = ge[Ce], Ee = V.has(ue);
          Ee || (V.add(ue), Te.push(ue));
        }
        for (var Ae = 0, Je = $; Ae < Je.length; Ae++) {
          var ue = Je[Ae], Ee = V.has(ue);
          Ee || (V.add(ue), Te.push(ue));
        }
        return Te;
      }
      function j(U, G) {
        var W = Ve(
          U,
          G,
          /*create*/
          !1
        );
        return W ? W.OrdinaryOwnMetadataKeys(U, G) : [];
      }
      function re(U) {
        if (U === null)
          return 1;
        switch (typeof U) {
          case "undefined":
            return 0;
          case "boolean":
            return 2;
          case "string":
            return 3;
          case "symbol":
            return 4;
          case "number":
            return 5;
          case "object":
            return U === null ? 1 : 6;
          default:
            return 6;
        }
      }
      function z(U) {
        return U === void 0;
      }
      function ce(U) {
        return U === null;
      }
      function he(U) {
        return typeof U == "symbol";
      }
      function de(U) {
        return typeof U == "object" ? U !== null : typeof U == "function";
      }
      function xe(U, G) {
        switch (re(U)) {
          case 0:
            return U;
          case 1:
            return U;
          case 2:
            return U;
          case 3:
            return U;
          case 4:
            return U;
          case 5:
            return U;
        }
        var W = "string", se = Tt(U, o);
        if (se !== void 0) {
          var $ = se.call(U, W);
          if (de($))
            throw new TypeError();
          return $;
        }
        return Ze(U);
      }
      function Ze(U, G) {
        var W, se;
        {
          var $ = U.toString;
          if (Ue($)) {
            var se = $.call(U);
            if (!de(se))
              return se;
          }
          var W = U.valueOf;
          if (Ue(W)) {
            var se = W.call(U);
            if (!de(se))
              return se;
          }
        }
        throw new TypeError();
      }
      function Se(U) {
        return !!U;
      }
      function be(U) {
        return "" + U;
      }
      function Ie(U) {
        var G = xe(U);
        return he(G) ? G : be(G);
      }
      function Re(U) {
        return Array.isArray ? Array.isArray(U) : U instanceof Object ? U instanceof Array : Object.prototype.toString.call(U) === "[object Array]";
      }
      function Ue(U) {
        return typeof U == "function";
      }
      function Xe(U) {
        return typeof U == "function";
      }
      function vt(U) {
        switch (re(U)) {
          case 3:
            return !0;
          case 4:
            return !0;
          default:
            return !1;
        }
      }
      function at(U, G) {
        return U === G || U !== U && G !== G;
      }
      function Tt(U, G) {
        var W = U[G];
        if (W != null) {
          if (!Ue(W))
            throw new TypeError();
          return W;
        }
      }
      function xr(U) {
        var G = Tt(U, a);
        if (!Ue(G))
          throw new TypeError();
        var W = G.call(U);
        if (!de(W))
          throw new TypeError();
        return W;
      }
      function rs(U) {
        return U.value;
      }
      function di(U) {
        var G = U.next();
        return G.done ? !1 : G;
      }
      function on(U) {
        var G = U.return;
        G && G.call(U);
      }
      function an(U) {
        var G = Object.getPrototypeOf(U);
        if (typeof U != "function" || U === f || G !== f)
          return G;
        var W = U.prototype, se = W && Object.getPrototypeOf(W);
        if (se == null || se === Object.prototype)
          return G;
        var $ = se.constructor;
        return typeof $ != "function" || $ === U ? G : $;
      }
      function ee() {
        var U;
        !z(v) && typeof n.Reflect < "u" && !(v in n.Reflect) && typeof n.Reflect.defineMetadata == "function" && (U = we(n.Reflect));
        var G, W, se, $ = new g(), V = {
          registerProvider: Te,
          getProvider: ge,
          setProvider: Ee
        };
        return V;
        function Te(Ae) {
          if (!Object.isExtensible(V))
            throw new Error("Cannot add provider to a frozen registry.");
          switch (!0) {
            case U === Ae:
              break;
            case z(G):
              G = Ae;
              break;
            case G === Ae:
              break;
            case z(W):
              W = Ae;
              break;
            case W === Ae:
              break;
            default:
              se === void 0 && (se = new y()), se.add(Ae);
              break;
          }
        }
        function Ce(Ae, Je) {
          if (!z(G)) {
            if (G.isProviderFor(Ae, Je))
              return G;
            if (!z(W)) {
              if (W.isProviderFor(Ae, Je))
                return G;
              if (!z(se))
                for (var ft = xr(se); ; ) {
                  var Mt = di(ft);
                  if (!Mt)
                    return;
                  var Pr = rs(Mt);
                  if (Pr.isProviderFor(Ae, Je))
                    return on(ft), Pr;
                }
            }
          }
          if (!z(U) && U.isProviderFor(Ae, Je))
            return U;
        }
        function ge(Ae, Je) {
          var ft = $.get(Ae), Mt;
          return z(ft) || (Mt = ft.get(Je)), z(Mt) && (Mt = Ce(Ae, Je), z(Mt) || (z(ft) && (ft = new p(), $.set(Ae, ft)), ft.set(Je, Mt))), Mt;
        }
        function ue(Ae) {
          if (z(Ae))
            throw new TypeError();
          return G === Ae || W === Ae || !z(se) && se.has(Ae);
        }
        function Ee(Ae, Je, ft) {
          if (!ue(ft))
            throw new Error("Metadata provider not registered.");
          var Mt = ge(Ae, Je);
          if (Mt !== ft) {
            if (!z(Mt))
              return !1;
            var Pr = $.get(Ae);
            z(Pr) && (Pr = new p(), $.set(Ae, Pr)), Pr.set(Je, ft);
          }
          return !0;
        }
      }
      function ae() {
        var U;
        return !z(v) && de(n.Reflect) && Object.isExtensible(n.Reflect) && (U = n.Reflect[v]), z(U) && (U = ee()), !z(v) && de(n.Reflect) && Object.isExtensible(n.Reflect) && Object.defineProperty(n.Reflect, v, {
          enumerable: !1,
          configurable: !1,
          writable: !1,
          value: U
        }), U;
      }
      function fe(U) {
        var G = new g(), W = {
          isProviderFor: function(ue, Ee) {
            var Ae = G.get(ue);
            return z(Ae) ? !1 : Ae.has(Ee);
          },
          OrdinaryDefineOwnMetadata: Te,
          OrdinaryHasOwnMetadata: $,
          OrdinaryGetOwnMetadata: V,
          OrdinaryOwnMetadataKeys: Ce,
          OrdinaryDeleteMetadata: ge
        };
        return _.registerProvider(W), W;
        function se(ue, Ee, Ae) {
          var Je = G.get(ue), ft = !1;
          if (z(Je)) {
            if (!Ae)
              return;
            Je = new p(), G.set(ue, Je), ft = !0;
          }
          var Mt = Je.get(Ee);
          if (z(Mt)) {
            if (!Ae)
              return;
            if (Mt = new p(), Je.set(Ee, Mt), !U.setProvider(ue, Ee, W))
              throw Je.delete(Ee), ft && G.delete(ue), new Error("Wrong provider for target.");
          }
          return Mt;
        }
        function $(ue, Ee, Ae) {
          var Je = se(
            Ee,
            Ae,
            /*Create*/
            !1
          );
          return z(Je) ? !1 : Se(Je.has(ue));
        }
        function V(ue, Ee, Ae) {
          var Je = se(
            Ee,
            Ae,
            /*Create*/
            !1
          );
          if (!z(Je))
            return Je.get(ue);
        }
        function Te(ue, Ee, Ae, Je) {
          var ft = se(
            Ae,
            Je,
            /*Create*/
            !0
          );
          ft.set(ue, Ee);
        }
        function Ce(ue, Ee) {
          var Ae = [], Je = se(
            ue,
            Ee,
            /*Create*/
            !1
          );
          if (z(Je))
            return Ae;
          for (var ft = Je.keys(), Mt = xr(ft), Pr = 0; ; ) {
            var Ln = di(Mt);
            if (!Ln)
              return Ae.length = Pr, Ae;
            var sm = rs(Ln);
            try {
              Ae[Pr] = sm;
            } catch (om) {
              try {
                on(Mt);
              } finally {
                throw om;
              }
            }
            Pr++;
          }
        }
        function ge(ue, Ee, Ae) {
          var Je = se(
            Ee,
            Ae,
            /*Create*/
            !1
          );
          if (z(Je) || !Je.delete(ue))
            return !1;
          if (Je.size === 0) {
            var ft = G.get(Ee);
            z(ft) || (ft.delete(Ae), ft.size === 0 && G.delete(ft));
          }
          return !0;
        }
      }
      function we(U) {
        var G = U.defineMetadata, W = U.hasOwnMetadata, se = U.getOwnMetadata, $ = U.getOwnMetadataKeys, V = U.deleteMetadata, Te = new g(), Ce = {
          isProviderFor: function(ge, ue) {
            var Ee = Te.get(ge);
            return !z(Ee) && Ee.has(ue) ? !0 : $(ge, ue).length ? (z(Ee) && (Ee = new y(), Te.set(ge, Ee)), Ee.add(ue), !0) : !1;
          },
          OrdinaryDefineOwnMetadata: G,
          OrdinaryHasOwnMetadata: W,
          OrdinaryGetOwnMetadata: se,
          OrdinaryOwnMetadataKeys: $,
          OrdinaryDeleteMetadata: V
        };
        return Ce;
      }
      function Ve(U, G, W) {
        var se = _.getProvider(U, G);
        if (!z(se))
          return se;
        if (W) {
          if (_.setProvider(U, G, w))
            return w;
          throw new Error("Illegal state.");
        }
      }
      function jr() {
        var U = {}, G = [], W = (
          /** @class */
          (function() {
            function Ce(ge, ue, Ee) {
              this._index = 0, this._keys = ge, this._values = ue, this._selector = Ee;
            }
            return Ce.prototype["@@iterator"] = function() {
              return this;
            }, Ce.prototype[a] = function() {
              return this;
            }, Ce.prototype.next = function() {
              var ge = this._index;
              if (ge >= 0 && ge < this._keys.length) {
                var ue = this._selector(this._keys[ge], this._values[ge]);
                return ge + 1 >= this._keys.length ? (this._index = -1, this._keys = G, this._values = G) : this._index++, { value: ue, done: !1 };
              }
              return { value: void 0, done: !0 };
            }, Ce.prototype.throw = function(ge) {
              throw this._index >= 0 && (this._index = -1, this._keys = G, this._values = G), ge;
            }, Ce.prototype.return = function(ge) {
              return this._index >= 0 && (this._index = -1, this._keys = G, this._values = G), { value: ge, done: !0 };
            }, Ce;
          })()
        ), se = (
          /** @class */
          (function() {
            function Ce() {
              this._keys = [], this._values = [], this._cacheKey = U, this._cacheIndex = -2;
            }
            return Object.defineProperty(Ce.prototype, "size", {
              get: function() {
                return this._keys.length;
              },
              enumerable: !0,
              configurable: !0
            }), Ce.prototype.has = function(ge) {
              return this._find(
                ge,
                /*insert*/
                !1
              ) >= 0;
            }, Ce.prototype.get = function(ge) {
              var ue = this._find(
                ge,
                /*insert*/
                !1
              );
              return ue >= 0 ? this._values[ue] : void 0;
            }, Ce.prototype.set = function(ge, ue) {
              var Ee = this._find(
                ge,
                /*insert*/
                !0
              );
              return this._values[Ee] = ue, this;
            }, Ce.prototype.delete = function(ge) {
              var ue = this._find(
                ge,
                /*insert*/
                !1
              );
              if (ue >= 0) {
                for (var Ee = this._keys.length, Ae = ue + 1; Ae < Ee; Ae++)
                  this._keys[Ae - 1] = this._keys[Ae], this._values[Ae - 1] = this._values[Ae];
                return this._keys.length--, this._values.length--, at(ge, this._cacheKey) && (this._cacheKey = U, this._cacheIndex = -2), !0;
              }
              return !1;
            }, Ce.prototype.clear = function() {
              this._keys.length = 0, this._values.length = 0, this._cacheKey = U, this._cacheIndex = -2;
            }, Ce.prototype.keys = function() {
              return new W(this._keys, this._values, $);
            }, Ce.prototype.values = function() {
              return new W(this._keys, this._values, V);
            }, Ce.prototype.entries = function() {
              return new W(this._keys, this._values, Te);
            }, Ce.prototype["@@iterator"] = function() {
              return this.entries();
            }, Ce.prototype[a] = function() {
              return this.entries();
            }, Ce.prototype._find = function(ge, ue) {
              if (!at(this._cacheKey, ge)) {
                this._cacheIndex = -1;
                for (var Ee = 0; Ee < this._keys.length; Ee++)
                  if (at(this._keys[Ee], ge)) {
                    this._cacheIndex = Ee;
                    break;
                  }
              }
              return this._cacheIndex < 0 && ue && (this._cacheIndex = this._keys.length, this._keys.push(ge), this._values.push(void 0)), this._cacheIndex;
            }, Ce;
          })()
        );
        return se;
        function $(Ce, ge) {
          return Ce;
        }
        function V(Ce, ge) {
          return ge;
        }
        function Te(Ce, ge) {
          return [Ce, ge];
        }
      }
      function tr() {
        var U = (
          /** @class */
          (function() {
            function G() {
              this._map = new p();
            }
            return Object.defineProperty(G.prototype, "size", {
              get: function() {
                return this._map.size;
              },
              enumerable: !0,
              configurable: !0
            }), G.prototype.has = function(W) {
              return this._map.has(W);
            }, G.prototype.add = function(W) {
              return this._map.set(W, W), this;
            }, G.prototype.delete = function(W) {
              return this._map.delete(W);
            }, G.prototype.clear = function() {
              this._map.clear();
            }, G.prototype.keys = function() {
              return this._map.keys();
            }, G.prototype.values = function() {
              return this._map.keys();
            }, G.prototype.entries = function() {
              return this._map.entries();
            }, G.prototype["@@iterator"] = function() {
              return this.keys();
            }, G.prototype[a] = function() {
              return this.keys();
            }, G;
          })()
        );
        return U;
      }
      function bn() {
        var U = 16, G = d.create(), W = se();
        return (
          /** @class */
          (function() {
            function ge() {
              this._key = se();
            }
            return ge.prototype.has = function(ue) {
              var Ee = $(
                ue,
                /*create*/
                !1
              );
              return Ee !== void 0 ? d.has(Ee, this._key) : !1;
            }, ge.prototype.get = function(ue) {
              var Ee = $(
                ue,
                /*create*/
                !1
              );
              return Ee !== void 0 ? d.get(Ee, this._key) : void 0;
            }, ge.prototype.set = function(ue, Ee) {
              var Ae = $(
                ue,
                /*create*/
                !0
              );
              return Ae[this._key] = Ee, this;
            }, ge.prototype.delete = function(ue) {
              var Ee = $(
                ue,
                /*create*/
                !1
              );
              return Ee !== void 0 ? delete Ee[this._key] : !1;
            }, ge.prototype.clear = function() {
              this._key = se();
            }, ge;
          })()
        );
        function se() {
          var ge;
          do
            ge = "@@WeakMap@@" + Ce();
          while (d.has(G, ge));
          return G[ge] = !0, ge;
        }
        function $(ge, ue) {
          if (!i.call(ge, W)) {
            if (!ue)
              return;
            Object.defineProperty(ge, W, { value: d.create() });
          }
          return ge[W];
        }
        function V(ge, ue) {
          for (var Ee = 0; Ee < ue; ++Ee)
            ge[Ee] = Math.random() * 255 | 0;
          return ge;
        }
        function Te(ge) {
          if (typeof Uint8Array == "function") {
            var ue = new Uint8Array(ge);
            return typeof crypto < "u" ? crypto.getRandomValues(ue) : typeof msCrypto < "u" ? msCrypto.getRandomValues(ue) : V(ue, ge), ue;
          }
          return V(new Array(ge), ge);
        }
        function Ce() {
          var ge = Te(U);
          ge[6] = ge[6] & 79 | 64, ge[8] = ge[8] & 191 | 128;
          for (var ue = "", Ee = 0; Ee < U; ++Ee) {
            var Ae = ge[Ee];
            (Ee === 4 || Ee === 6 || Ee === 8) && (ue += "-"), Ae < 16 && (ue += "0"), ue += Ae.toString(16).toLowerCase();
          }
          return ue;
        }
      }
      function Rr(U) {
        return U.__ = void 0, delete U.__, U;
      }
    });
  })(r || (r = {})), mD;
}
N8();
class it extends Error {
  /**
   * @param message Human-readable error message
   * @param name Error name/type (default: 'LedgerButtonError')
   * @param context Optional additional context or metadata
   */
  constructor(t, n = "LedgerButtonError", i) {
    super(t);
    /** Optional context or metadata for debugging */
    h(this, "context");
    /** Timestamp when the error was created */
    h(this, "timestamp");
    this.name = n, this.context = i, this.timestamp = /* @__PURE__ */ new Date(), Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
  }
  /**
   * Serialize the error to a plain object (useful for logging or transport)
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      context: this.context,
      timestamp: this.timestamp,
      stack: this.stack
    };
  }
}
class uo extends it {
  constructor(e, t) {
    super(e, "DeviceConnectionError", t);
  }
}
class B8 extends it {
  constructor(e, t) {
    super(e, "SignTransactionError", t);
  }
}
class qI extends it {
  constructor(e, t) {
    super(e, "AccountNotSelectedError", t);
  }
}
class pge extends it {
  constructor(e, t) {
    super(e, "FailToOpenAppError", t);
  }
}
class gge extends it {
  constructor(e, t) {
    super(e, "LedgerSyncError", t);
  }
}
class TB extends it {
  constructor(e, t) {
    super(e, "LedgerSyncAuthContextMissingError", t);
  }
}
class mge extends it {
  constructor(e, t) {
    super(e, "LedgerSyncNoSessionIdError", t);
  }
}
class yge extends it {
  constructor(e, t) {
    super(e, "LedgerSyncConnectionFailedError", t);
  }
}
class L8 extends it {
  constructor(e, t) {
    super(e, "LedgerKeyringProtocolError", t);
  }
}
class U8 extends it {
  constructor(e, t) {
    super(e, "StorageIDBOpenError", t);
  }
}
class F8 extends it {
  constructor(e, t) {
    super(e, "StorageIDBNotInitializedError", t);
  }
}
class um extends it {
  constructor(e, t) {
    super(e, "StorageIDBStoreError", t);
  }
}
class If extends it {
  constructor(e, t) {
    super(e, "StorageIDBGetError", t);
  }
}
class M8 extends it {
  constructor(e, t) {
    super(e, "StorageIDBRemoveError", t);
  }
}
class V8 extends it {
  constructor(e, t) {
    super(e, "DeviceNotSupportedError", t);
  }
}
class vge extends it {
  constructor(e, t) {
    super(e, "DeviceDisconnectedError", t);
  }
}
class WI extends it {
  constructor(e, t) {
    super(e, "IncorrectSeedError", t);
  }
}
class kB extends it {
  constructor(e, t) {
    super(e, "BlindSigningDisabledError", t);
  }
}
class ZI extends it {
  constructor(e, t) {
    super(e, "UserRejectedTransactionError", t);
  }
}
class z8 extends it {
  constructor(e, t = { networks: [] }) {
    super(e, "NoCompatibleAccountsError", t);
  }
}
class j8 extends it {
  constructor(e, t) {
    super(e, "NoAccountInSyncError", t);
  }
}
class H8 extends it {
  constructor(e, t) {
    super(e, "FailedToFetchEncryptedAccountsError", t);
  }
}
class G8 extends it {
  constructor(e = "No account selected in context") {
    super(e, "NoSelectedAccountError");
  }
}
class K8 extends it {
  constructor(e, t) {
    super(e, "AccountNotFoundError", t);
  }
}
class lm extends it {
  constructor(e, t) {
    super(e, "BroadcastTransactionError", t);
  }
}
class Cf extends it {
  constructor(e, t) {
    super(e, "NetworkError", t);
  }
}
let q8 = class {
  constructor(e, t, n, i, s) {
    h(this, "cla");
    h(this, "ins");
    h(this, "p1");
    h(this, "p2");
    h(this, "data");
    this.cla = e, this.ins = t, this.p1 = n, this.p2 = i, this.data = s ?? new Uint8Array();
  }
  getRawApdu() {
    const e = Uint8Array.from([this.cla, this.ins, this.p1, this.p2, this.data.length]), t = new Uint8Array(e.length + this.data.length);
    return t.set(e, 0), this.data.length > 0 && t.set(this.data, e.length), t;
  }
};
function br(r) {
  return typeof r == "string" && /^0x[0-9a-fA-F]*$/.test(r);
}
function _r(r) {
  var t;
  if (r.startsWith("0x") && (r = r.slice(2)), r.length === 0) return new Uint8Array();
  if (r.length % 2 !== 0 && (r = "0" + r), /^[0-9a-fA-F]*$/.test(r) === !1) return null;
  const e = (t = r.match(/.{1,2}/g)) == null ? void 0 : t.map((n) => parseInt(n, 16));
  return !e || e.some(isNaN) ? null : new Uint8Array(e);
}
function It(r, e = !0) {
  return `${e ? "0x" : ""}${Array.from(r, (t) => t.toString(16).padStart(2, "0")).join("")}`;
}
let U0 = class {
  constructor(e, t = Is) {
    h(this, "_tag", "ValueOverflow");
    h(this, "originalError");
    h(this, "message");
    this.message = `Value overflow for ${e}, max is ${t}`;
  }
}, dm = class {
  constructor(e, t = 0) {
    h(this, "_tag", "DataOverflow");
    h(this, "message");
    h(this, "originalError");
    this.message = t === 0 ? `this.data is already full (value: ${e})` : `this.data will overflow with "${e}", remaining bytes: ${t}`;
  }
}, vD = class {
  constructor(e) {
    h(this, "_tag", "HexaString");
    h(this, "message");
    h(this, "originalError");
    this.message = `Invalid encoded hexa string or length is null: ${e}`;
  }
};
const W8 = 4294967295;
let Ds = class {
  constructor(e = W8) {
    h(this, "data", new Uint8Array());
    h(this, "errors", []);
    h(this, "build", () => this.data);
    h(this, "tryBuild", () => this.hasErrors() ? void 0 : this.data);
    h(this, "add8BitUIntToData", (e) => this.addNumberToData(e, 8n, !1, !1));
    h(this, "add16BitUIntToData", (e, t = !0) => this.addNumberToData(e, 16n, !1, t));
    h(this, "add32BitUIntToData", (e, t = !0) => this.addNumberToData(e, 32n, !1, t));
    h(this, "add64BitUIntToData", (e, t = !0) => this.addNumberToData(e, 64n, !1, t));
    h(this, "add128BitUIntToData", (e, t = !0) => this.addNumberToData(e, 128n, !1, t));
    h(this, "add256BitUIntToData", (e, t = !0) => this.addNumberToData(e, 256n, !1, t));
    h(this, "add16BitIntToData", (e, t = !0) => this.addNumberToData(e, 16n, !0, t));
    h(this, "add32BitIntToData", (e, t = !0) => this.addNumberToData(e, 32n, !0, t));
    h(this, "add64BitIntToData", (e, t = !0) => this.addNumberToData(e, 64n, !0, t));
    h(this, "add128BitIntToData", (e, t = !0) => this.addNumberToData(e, 128n, !0, t));
    h(this, "add256BitIntToData", (e, t = !0) => this.addNumberToData(e, 256n, !0, t));
    h(this, "addBufferToData", (e) => this.hasEnoughLengthRemaining(e) ? (this.data = Uint8Array.from([...this.data, ...e]), this) : (this.errors.push(new dm(e.toString())), this));
    h(this, "addHexaStringToData", (e) => {
      const t = _r(e);
      return t === null || t.length === 0 ? (this.errors.push(new vD(e)), this) : (this.addBufferToData(t), this);
    });
    h(this, "addAsciiStringToData", (e) => {
      const t = new TextEncoder().encode(e);
      return this.addBufferToData(t), this;
    });
    h(this, "encodeInLVFromHexa", (e) => {
      const t = _r(e);
      return t === null || t.length === 0 ? (this.errors.push(new vD(e)), this) : this.hasEnoughLengthRemaining(t, !0) ? (this.add8BitUIntToData(t.length), this.addBufferToData(t), this) : (this.errors.push(new dm(e)), this);
    });
    h(this, "encodeInLVFromBuffer", (e) => this.hasEnoughLengthRemaining(e, !0) ? (this.add8BitUIntToData(e.length), this.addBufferToData(e), this) : (this.errors.push(new dm(e.toString())), this));
    h(this, "encodeInLVFromAscii", (e) => this.hasEnoughLengthRemaining(e, !0) ? (this.add8BitUIntToData(e.length), this.addAsciiStringToData(e), this) : (this.errors.push(new dm(e)), this));
    h(this, "encodeInTLVFromAscii", (e, t) => (this.add8BitUIntToData(e), this.encodeInLVFromAscii(t)));
    h(this, "encodeInTLVFromHexa", (e, t) => (this.add8BitUIntToData(e), this.encodeInLVFromHexa(t)));
    h(this, "encodeInTLVFromBuffer", (e, t) => (this.add8BitUIntToData(e), this.encodeInLVFromBuffer(t)));
    h(this, "encodeInTLVFromUInt8", (e, t) => (this.add8BitUIntToData(e), this.add8BitUIntToData(1), this.add8BitUIntToData(t)));
    h(this, "encodeInTLVFromUInt16", (e, t, n = !0) => (this.add8BitUIntToData(e), this.add8BitUIntToData(2), this.add16BitUIntToData(t, n)));
    h(this, "encodeInTLVFromUInt32", (e, t, n = !0) => (this.add8BitUIntToData(e), this.add8BitUIntToData(4), this.add32BitUIntToData(t, n)));
    h(this, "encodeInTLVFromUInt64", (e, t, n = !0) => (this.add8BitUIntToData(e), this.add8BitUIntToData(8), this.add64BitUIntToData(t, n)));
    h(this, "getAvailablePayloadLength", () => this.maxPayloadSize - this.data.length);
    h(this, "getErrors", () => this.errors);
    h(this, "hasErrors", () => this.errors.length !== 0);
    h(this, "hasEnoughLengthRemaining", (e, t = !1) => this.data.length + e.length + (t ? 1 : 0) <= this.maxPayloadSize);
    this.maxPayloadSize = e;
  }
  addNumberToData(e, t, n, i) {
    let s = this.checkBoundsAndConvert(e, t, n);
    if (s === void 0) return this;
    const o = Number(t) / 8, a = new Uint8Array(o);
    if (i) for (let c = o - 1; c >= 0; c--) a[c] = Number(s & 0xffn), s >>= 8n;
    else for (let c = 0; c < o; c++) a[c] = Number(s & 0xffn), s >>= 8n;
    return this.addBufferToData(a);
  }
  checkBoundsAndConvert(e, t, n) {
    if (typeof e == "number") {
      if (!Number.isInteger(e) || e > Number.MAX_SAFE_INTEGER) {
        this.errors.push(new U0(e.toString()));
        return;
      }
      e = BigInt(e);
    }
    if (n) {
      const i = 1n << t - 1n;
      if (e >= i || e < -i) {
        this.errors.push(new U0(e.toString(), i - 1n));
        return;
      }
      if (e < 0n) {
        const s = (1n << t) - 1n;
        e = -e, e = (~e & s) + 1n;
      }
    } else {
      const i = 1n << t;
      if (e < 0 || e >= i) {
        this.errors.push(new U0(e.toString(), i - 1n));
        return;
      }
    }
    return e;
  }
};
const Is = 255;
let ot = class {
  constructor({ ins: e, cla: t, p1: n, p2: i }) {
    h(this, "_ins");
    h(this, "_cla");
    h(this, "_p1");
    h(this, "p2");
    h(this, "data", new Ds(Is));
    h(this, "build", () => new q8(this._cla, this._ins, this._p1, this.p2, this.data.build()));
    h(this, "add8BitUIntToData", (e) => (this.data.add8BitUIntToData(e), this));
    h(this, "add16BitUIntToData", (e) => (this.data.add16BitUIntToData(e), this));
    h(this, "add32BitUIntToData", (e) => (this.data.add32BitUIntToData(e), this));
    h(this, "addBufferToData", (e) => (this.data.addBufferToData(e), this));
    h(this, "addHexaStringToData", (e) => (this.data.addHexaStringToData(e), this));
    h(this, "addAsciiStringToData", (e) => (this.data.addAsciiStringToData(e), this));
    h(this, "encodeInLVFromHexa", (e) => (this.data.encodeInLVFromHexa(e), this));
    h(this, "encodeInLVFromBuffer", (e) => (this.data.encodeInLVFromBuffer(e), this));
    h(this, "encodeInLVFromAscii", (e) => (this.data.encodeInLVFromAscii(e), this));
    h(this, "getAvailablePayloadLength", () => this.data.getAvailablePayloadLength());
    h(this, "getErrors", () => this.data.getErrors());
    this._cla = t & 255, this._ins = e & 255, this._p1 = n & 255, this.p2 = i & 255;
  }
}, OB = class {
  constructor(e) {
    h(this, "index", 0);
    this.buffer = e;
  }
  testMinimalLength(e) {
    return e <= this.buffer.length - this.index;
  }
  extract8BitUInt() {
    if (!this.outOfRange(1)) return this.buffer[this.index++];
  }
  extract16BitUInt(e = !0) {
    const t = this.extractNumber(16n, !1, e);
    return t === void 0 ? void 0 : Number(t);
  }
  extract16BitInt(e = !0) {
    const t = this.extractNumber(16n, !0, e);
    return t === void 0 ? void 0 : Number(t);
  }
  extract32BitUInt(e = !0) {
    const t = this.extractNumber(32n, !1, e);
    return t === void 0 ? void 0 : Number(t);
  }
  extract32BitInt(e = !0) {
    const t = this.extractNumber(32n, !0, e);
    return t === void 0 ? void 0 : Number(t);
  }
  extract64BitUInt(e = !0) {
    return this.extractNumber(64n, !1, e);
  }
  extract64BitInt(e = !0) {
    return this.extractNumber(64n, !0, e);
  }
  extract128BitUInt(e = !0) {
    return this.extractNumber(128n, !1, e);
  }
  extract128BitInt(e = !0) {
    return this.extractNumber(128n, !0, e);
  }
  extract256BitUInt(e = !0) {
    return this.extractNumber(256n, !1, e);
  }
  extract256BitInt(e = !0) {
    return this.extractNumber(256n, !0, e);
  }
  extractFieldByLength(e) {
    if (this.outOfRange(e)) return;
    if (e === 0) return new Uint8Array();
    const t = this.buffer.slice(this.index, this.index + e);
    return this.index += e, t;
  }
  extractFieldLVEncoded() {
    const e = this.extract8BitUInt();
    if (e === void 0) return;
    if (e === 0) return new Uint8Array();
    const t = this.extractFieldByLength(e);
    return t === void 0 && this.index--, t;
  }
  extractFieldTLVEncoded() {
    if (this.outOfRange(2)) return;
    const e = this.index, t = this.extract8BitUInt(), n = this.extractFieldLVEncoded();
    if (t === void 0 || n === void 0) {
      this.index--;
      return;
    }
    const i = this.index;
    return { tag: t, value: n, tlv: this.buffer.slice(e, i) };
  }
  encodeToHexaString(e, t = !1) {
    if (e === void 0 || e.length === 0) return "";
    const n = It(e);
    return t ? n : n.slice(2);
  }
  encodeToString(e) {
    let t = "", n = 0;
    if (!e) return t;
    for (; n <= e.length; ) {
      const i = e[n];
      i && (t += String.fromCharCode(i)), n++;
    }
    return t;
  }
  getCurrentIndex() {
    return this.index;
  }
  resetIndex() {
    this.index = 0;
  }
  getUnparsedRemainingLength() {
    return this.buffer.length - this.index;
  }
  outOfRange(e) {
    return this.index + e > this.buffer.length;
  }
  extractNumber(e, t, n) {
    const i = Number(e) / 8;
    if (this.outOfRange(i)) return;
    let s = 0n;
    if (n) for (let o = 0; o < i; o++) s = s << 8n | BigInt(this.buffer[o + this.index]);
    else for (let o = i - 1; o >= 0; o--) s = s << 8n | BigInt(this.buffer[o + this.index]);
    if (t) {
      const o = 1n << e - 1n;
      s & o && (s -= o << 1n);
    }
    return this.index += i, s;
  }
}, kr = class {
  constructor(e) {
    h(this, "parser");
    h(this, "testMinimalLength", (e) => this.parser.testMinimalLength(e));
    h(this, "extract8BitUInt", () => this.parser.extract8BitUInt());
    h(this, "extract16BitUInt", () => this.parser.extract16BitUInt());
    h(this, "extract32BitUInt", () => this.parser.extract32BitUInt());
    h(this, "extractFieldByLength", (e) => this.parser.extractFieldByLength(e));
    h(this, "extractFieldLVEncoded", () => this.parser.extractFieldLVEncoded());
    h(this, "extractFieldTLVEncoded", () => this.parser.extractFieldTLVEncoded());
    h(this, "encodeToString", (e) => this.parser.encodeToString(e));
    h(this, "getUnparsedRemainingLength", () => this.parser.getUnparsedRemainingLength());
    this.parser = new OB(e.data);
  }
  encodeToHexaString(e, t = !1) {
    return t ? this.parser.encodeToHexaString(e, !0) : this.parser.encodeToHexaString(e, !1);
  }
}, ht = class {
  constructor(e) {
    h(this, "_tag", "InvalidStatusWordError");
    h(this, "originalError");
    this.originalError = new Error(e ?? "Invalid status word.");
  }
}, Z8 = class {
  constructor(e) {
    h(this, "_tag", "InvalidResponseFormatError");
    h(this, "originalError");
    this.originalError = new Error(e ?? "Invalid response format.");
  }
};
var J8 = ((r) => (r.Error = "ERROR", r.Success = "SUCCESS", r))(J8 || {});
function ye({ data: r, error: e }) {
  return e ? { status: "ERROR", error: e } : { status: "SUCCESS", data: r };
}
function We(r) {
  return r.status === "SUCCESS";
}
let Jr = class Fl {
  static isValidStatusCode(e) {
    return e.length === 2;
  }
  static isSuccessResponse({ statusCode: e }) {
    return Fl.isValidStatusCode(e) ? e[0] === 144 && e[1] === 0 : !1;
  }
  static isLockedDeviceResponse({ statusCode: e }) {
    return Fl.isValidStatusCode(e) ? e[0] === 85 && e[1] === 21 || e[0] === 105 && e[1] === 130 || e[0] === 83 && e[1] === 3 : !1;
  }
  static isRefusedByUser({ statusCode: e }) {
    return Fl.isValidStatusCode(e) ? e[0] === 85 && e[1] === 1 || e[0] === 105 && e[1] === 133 : !1;
  }
  static isAppAlreadyInstalled({ statusCode: e }) {
    return Fl.isValidStatusCode(e) ? e[0] === 106 && e[1] === 128 || e[0] === 106 && e[1] === 129 || e[0] === 106 && e[1] === 142 || e[0] === 106 && e[1] === 143 : !1;
  }
  static isOutOfMemory({ statusCode: e }) {
    return Fl.isValidStatusCode(e) ? e[0] === 106 && e[1] === 132 || e[0] === 106 && e[1] === 133 || e[0] === 81 && e[1] === 2 || e[0] === 81 && e[1] === 3 : !1;
  }
  static isApduThatTriggersDisconnection(e) {
    const t = /* @__PURE__ */ new Map();
    return t.set("openApp", new Uint8Array([224, 216, 0, 0])), t.set("closeApp", new Uint8Array([176, 167, 0, 0])), Array.from(t.values()).some((n) => {
      for (let i = 0; i < 4; i++) if (n[i] !== e[i]) return !1;
      return !0;
    });
  }
}, dl = class {
  constructor({ tag: e, errorCode: t, originalError: n, message: i }) {
    h(this, "_tag");
    h(this, "originalError");
    h(this, "errorCode");
    h(this, "message");
    this._tag = e, this.originalError = n, this.errorCode = t, this.message = i ?? "An error occured during device exchange.";
  }
}, JI = class {
  constructor(e) {
    h(this, "_tag", "UnknownDeviceExchangeError");
    h(this, "originalError");
    h(this, "message");
    this.originalError = e, this.message = "Unexpected device exchange error happened.";
  }
};
const hl = (r, e) => Object.keys(e).includes(r);
let X8 = class extends dl {
  constructor(e) {
    super({ tag: "GlobalCommandError", ...e });
  }
};
const bD = { 5515: { message: "Device is locked.", tag: "DeviceLockedError" }, 5501: { message: "Action refused on device.", tag: "ActionRefusedError" }, 5502: { message: "Pin is not set", tag: "PinNotSetError" }, 5223: { message: "Device internal error", tag: "DeviceInternalError" }, "6e00": { message: "CLA not supported", tag: "DeviceInternalError" }, "6d00": { message: "INS not supported", tag: "DeviceInternalError" } };
let ha = class {
  static handle(e) {
    const t = new kr(e).encodeToHexaString(e.statusCode);
    return hl(t, bD) ? new X8({ ...bD[t], errorCode: t }) : new JI({ message: "UnknownError", errorCode: t });
  }
}, $B = class {
  constructor() {
    h(this, "args");
    h(this, "triggersDisconnection", !0);
  }
  getApdu() {
    const e = { cla: 176, ins: 167, p1: 0, p2: 0 };
    return new ot(e).build();
  }
  parseResponse(e) {
    return Jr.isSuccessResponse(e) ? ye({ data: void 0 }) : ye({ error: ha.handle(e) });
  }
}, Oh = class {
  constructor() {
    h(this, "args");
  }
  getApdu() {
    const e = { cla: 176, ins: 1, p1: 0, p2: 0 };
    return new ot(e).build();
  }
  parseResponse(e) {
    if (!Jr.isSuccessResponse(e)) return ye({ error: ha.handle(e) });
    const t = new kr(e);
    if (t.extract8BitUInt() !== 1) return ye({ error: new Z8("getAppAndVersion: format not supported") });
    const n = t.encodeToString(t.extractFieldLVEncoded()), i = t.encodeToString(t.extractFieldLVEncoded());
    if (t.getUnparsedRemainingLength() === 0) return ye({ data: { name: n, version: i } });
    const s = t.extractFieldLVEncoded();
    return ye({ data: { name: n, version: i, flags: s } });
  }
};
var Y8 = ((r) => (r[r.BATTERY_PERCENTAGE = 0] = "BATTERY_PERCENTAGE", r[r.BATTERY_VOLTAGE = 1] = "BATTERY_VOLTAGE", r[r.BATTERY_TEMPERATURE = 2] = "BATTERY_TEMPERATURE", r[r.BATTERY_CURRENT = 3] = "BATTERY_CURRENT", r[r.BATTERY_FLAGS = 4] = "BATTERY_FLAGS", r))(Y8 || {}), Q8 = ((r) => (r[r.NONE = 0] = "NONE", r[r.USB = 1] = "USB", r[r.QI = 2] = "QI", r))(Q8 || {}), hm = { exports: {} }, F0, wD;
function xv() {
  if (wD) return F0;
  wD = 1;
  const r = "2.0.0", e = 256, t = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
  9007199254740991, n = 16, i = e - 6;
  return F0 = {
    MAX_LENGTH: e,
    MAX_SAFE_COMPONENT_LENGTH: n,
    MAX_SAFE_BUILD_LENGTH: i,
    MAX_SAFE_INTEGER: t,
    RELEASE_TYPES: [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ],
    SEMVER_SPEC_VERSION: r,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  }, F0;
}
var M0, _D;
function Av() {
  return _D || (_D = 1, M0 = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...e) => console.error("SEMVER", ...e) : () => {
  }), M0;
}
var SD;
function Vg() {
  return SD || (SD = 1, (function(r, e) {
    const {
      MAX_SAFE_COMPONENT_LENGTH: t,
      MAX_SAFE_BUILD_LENGTH: n,
      MAX_LENGTH: i
    } = xv(), s = Av();
    e = r.exports = {};
    const o = e.re = [], a = e.safeRe = [], c = e.src = [], u = e.safeSrc = [], l = e.t = {};
    let d = 0;
    const f = "[a-zA-Z0-9-]", p = [
      ["\\s", 1],
      ["\\d", i],
      [f, n]
    ], y = (v) => {
      for (const [_, w] of p)
        v = v.split(`${_}*`).join(`${_}{0,${w}}`).split(`${_}+`).join(`${_}{1,${w}}`);
      return v;
    }, g = (v, _, w) => {
      const E = y(_), I = d++;
      s(v, I, _), l[v] = I, c[I] = _, u[I] = E, o[I] = new RegExp(_, w ? "g" : void 0), a[I] = new RegExp(E, w ? "g" : void 0);
    };
    g("NUMERICIDENTIFIER", "0|[1-9]\\d*"), g("NUMERICIDENTIFIERLOOSE", "\\d+"), g("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${f}*`), g("MAINVERSION", `(${c[l.NUMERICIDENTIFIER]})\\.(${c[l.NUMERICIDENTIFIER]})\\.(${c[l.NUMERICIDENTIFIER]})`), g("MAINVERSIONLOOSE", `(${c[l.NUMERICIDENTIFIERLOOSE]})\\.(${c[l.NUMERICIDENTIFIERLOOSE]})\\.(${c[l.NUMERICIDENTIFIERLOOSE]})`), g("PRERELEASEIDENTIFIER", `(?:${c[l.NONNUMERICIDENTIFIER]}|${c[l.NUMERICIDENTIFIER]})`), g("PRERELEASEIDENTIFIERLOOSE", `(?:${c[l.NONNUMERICIDENTIFIER]}|${c[l.NUMERICIDENTIFIERLOOSE]})`), g("PRERELEASE", `(?:-(${c[l.PRERELEASEIDENTIFIER]}(?:\\.${c[l.PRERELEASEIDENTIFIER]})*))`), g("PRERELEASELOOSE", `(?:-?(${c[l.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${c[l.PRERELEASEIDENTIFIERLOOSE]})*))`), g("BUILDIDENTIFIER", `${f}+`), g("BUILD", `(?:\\+(${c[l.BUILDIDENTIFIER]}(?:\\.${c[l.BUILDIDENTIFIER]})*))`), g("FULLPLAIN", `v?${c[l.MAINVERSION]}${c[l.PRERELEASE]}?${c[l.BUILD]}?`), g("FULL", `^${c[l.FULLPLAIN]}$`), g("LOOSEPLAIN", `[v=\\s]*${c[l.MAINVERSIONLOOSE]}${c[l.PRERELEASELOOSE]}?${c[l.BUILD]}?`), g("LOOSE", `^${c[l.LOOSEPLAIN]}$`), g("GTLT", "((?:<|>)?=?)"), g("XRANGEIDENTIFIERLOOSE", `${c[l.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), g("XRANGEIDENTIFIER", `${c[l.NUMERICIDENTIFIER]}|x|X|\\*`), g("XRANGEPLAIN", `[v=\\s]*(${c[l.XRANGEIDENTIFIER]})(?:\\.(${c[l.XRANGEIDENTIFIER]})(?:\\.(${c[l.XRANGEIDENTIFIER]})(?:${c[l.PRERELEASE]})?${c[l.BUILD]}?)?)?`), g("XRANGEPLAINLOOSE", `[v=\\s]*(${c[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c[l.XRANGEIDENTIFIERLOOSE]})(?:${c[l.PRERELEASELOOSE]})?${c[l.BUILD]}?)?)?`), g("XRANGE", `^${c[l.GTLT]}\\s*${c[l.XRANGEPLAIN]}$`), g("XRANGELOOSE", `^${c[l.GTLT]}\\s*${c[l.XRANGEPLAINLOOSE]}$`), g("COERCEPLAIN", `(^|[^\\d])(\\d{1,${t}})(?:\\.(\\d{1,${t}}))?(?:\\.(\\d{1,${t}}))?`), g("COERCE", `${c[l.COERCEPLAIN]}(?:$|[^\\d])`), g("COERCEFULL", c[l.COERCEPLAIN] + `(?:${c[l.PRERELEASE]})?(?:${c[l.BUILD]})?(?:$|[^\\d])`), g("COERCERTL", c[l.COERCE], !0), g("COERCERTLFULL", c[l.COERCEFULL], !0), g("LONETILDE", "(?:~>?)"), g("TILDETRIM", `(\\s*)${c[l.LONETILDE]}\\s+`, !0), e.tildeTrimReplace = "$1~", g("TILDE", `^${c[l.LONETILDE]}${c[l.XRANGEPLAIN]}$`), g("TILDELOOSE", `^${c[l.LONETILDE]}${c[l.XRANGEPLAINLOOSE]}$`), g("LONECARET", "(?:\\^)"), g("CARETTRIM", `(\\s*)${c[l.LONECARET]}\\s+`, !0), e.caretTrimReplace = "$1^", g("CARET", `^${c[l.LONECARET]}${c[l.XRANGEPLAIN]}$`), g("CARETLOOSE", `^${c[l.LONECARET]}${c[l.XRANGEPLAINLOOSE]}$`), g("COMPARATORLOOSE", `^${c[l.GTLT]}\\s*(${c[l.LOOSEPLAIN]})$|^$`), g("COMPARATOR", `^${c[l.GTLT]}\\s*(${c[l.FULLPLAIN]})$|^$`), g("COMPARATORTRIM", `(\\s*)${c[l.GTLT]}\\s*(${c[l.LOOSEPLAIN]}|${c[l.XRANGEPLAIN]})`, !0), e.comparatorTrimReplace = "$1$2$3", g("HYPHENRANGE", `^\\s*(${c[l.XRANGEPLAIN]})\\s+-\\s+(${c[l.XRANGEPLAIN]})\\s*$`), g("HYPHENRANGELOOSE", `^\\s*(${c[l.XRANGEPLAINLOOSE]})\\s+-\\s+(${c[l.XRANGEPLAINLOOSE]})\\s*$`), g("STAR", "(<|>)?=?\\s*\\*"), g("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), g("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  })(hm, hm.exports)), hm.exports;
}
var V0, ED;
function XI() {
  if (ED) return V0;
  ED = 1;
  const r = Object.freeze({ loose: !0 }), e = Object.freeze({});
  return V0 = (n) => n ? typeof n != "object" ? r : n : e, V0;
}
var z0, xD;
function RB() {
  if (xD) return z0;
  xD = 1;
  const r = /^[0-9]+$/, e = (n, i) => {
    const s = r.test(n), o = r.test(i);
    return s && o && (n = +n, i = +i), n === i ? 0 : s && !o ? -1 : o && !s ? 1 : n < i ? -1 : 1;
  };
  return z0 = {
    compareIdentifiers: e,
    rcompareIdentifiers: (n, i) => e(i, n)
  }, z0;
}
var j0, AD;
function Nn() {
  if (AD) return j0;
  AD = 1;
  const r = Av(), { MAX_LENGTH: e, MAX_SAFE_INTEGER: t } = xv(), { safeRe: n, t: i } = Vg(), s = XI(), { compareIdentifiers: o } = RB();
  class a {
    constructor(u, l) {
      if (l = s(l), u instanceof a) {
        if (u.loose === !!l.loose && u.includePrerelease === !!l.includePrerelease)
          return u;
        u = u.version;
      } else if (typeof u != "string")
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof u}".`);
      if (u.length > e)
        throw new TypeError(
          `version is longer than ${e} characters`
        );
      r("SemVer", u, l), this.options = l, this.loose = !!l.loose, this.includePrerelease = !!l.includePrerelease;
      const d = u.trim().match(l.loose ? n[i.LOOSE] : n[i.FULL]);
      if (!d)
        throw new TypeError(`Invalid Version: ${u}`);
      if (this.raw = u, this.major = +d[1], this.minor = +d[2], this.patch = +d[3], this.major > t || this.major < 0)
        throw new TypeError("Invalid major version");
      if (this.minor > t || this.minor < 0)
        throw new TypeError("Invalid minor version");
      if (this.patch > t || this.patch < 0)
        throw new TypeError("Invalid patch version");
      d[4] ? this.prerelease = d[4].split(".").map((f) => {
        if (/^[0-9]+$/.test(f)) {
          const p = +f;
          if (p >= 0 && p < t)
            return p;
        }
        return f;
      }) : this.prerelease = [], this.build = d[5] ? d[5].split(".") : [], this.format();
    }
    format() {
      return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
    }
    toString() {
      return this.version;
    }
    compare(u) {
      if (r("SemVer.compare", this.version, this.options, u), !(u instanceof a)) {
        if (typeof u == "string" && u === this.version)
          return 0;
        u = new a(u, this.options);
      }
      return u.version === this.version ? 0 : this.compareMain(u) || this.comparePre(u);
    }
    compareMain(u) {
      return u instanceof a || (u = new a(u, this.options)), o(this.major, u.major) || o(this.minor, u.minor) || o(this.patch, u.patch);
    }
    comparePre(u) {
      if (u instanceof a || (u = new a(u, this.options)), this.prerelease.length && !u.prerelease.length)
        return -1;
      if (!this.prerelease.length && u.prerelease.length)
        return 1;
      if (!this.prerelease.length && !u.prerelease.length)
        return 0;
      let l = 0;
      do {
        const d = this.prerelease[l], f = u.prerelease[l];
        if (r("prerelease compare", l, d, f), d === void 0 && f === void 0)
          return 0;
        if (f === void 0)
          return 1;
        if (d === void 0)
          return -1;
        if (d === f)
          continue;
        return o(d, f);
      } while (++l);
    }
    compareBuild(u) {
      u instanceof a || (u = new a(u, this.options));
      let l = 0;
      do {
        const d = this.build[l], f = u.build[l];
        if (r("build compare", l, d, f), d === void 0 && f === void 0)
          return 0;
        if (f === void 0)
          return 1;
        if (d === void 0)
          return -1;
        if (d === f)
          continue;
        return o(d, f);
      } while (++l);
    }
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    inc(u, l, d) {
      if (u.startsWith("pre")) {
        if (!l && d === !1)
          throw new Error("invalid increment argument: identifier is empty");
        if (l) {
          const f = `-${l}`.match(this.options.loose ? n[i.PRERELEASELOOSE] : n[i.PRERELEASE]);
          if (!f || f[1] !== l)
            throw new Error(`invalid identifier: ${l}`);
        }
      }
      switch (u) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", l, d);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", l, d);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", l, d), this.inc("pre", l, d);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case "prerelease":
          this.prerelease.length === 0 && this.inc("patch", l, d), this.inc("pre", l, d);
          break;
        case "release":
          if (this.prerelease.length === 0)
            throw new Error(`version ${this.raw} is not a prerelease`);
          this.prerelease.length = 0;
          break;
        case "major":
          (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          this.prerelease.length === 0 && this.patch++, this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
        case "pre": {
          const f = Number(d) ? 1 : 0;
          if (this.prerelease.length === 0)
            this.prerelease = [f];
          else {
            let p = this.prerelease.length;
            for (; --p >= 0; )
              typeof this.prerelease[p] == "number" && (this.prerelease[p]++, p = -2);
            if (p === -1) {
              if (l === this.prerelease.join(".") && d === !1)
                throw new Error("invalid increment argument: identifier already exists");
              this.prerelease.push(f);
            }
          }
          if (l) {
            let p = [l, f];
            d === !1 && (p = [l]), o(this.prerelease[0], l) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = p) : this.prerelease = p;
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${u}`);
      }
      return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
    }
  }
  return j0 = a, j0;
}
var H0, ID;
function of() {
  if (ID) return H0;
  ID = 1;
  const r = Nn();
  return H0 = (t, n, i = !1) => {
    if (t instanceof r)
      return t;
    try {
      return new r(t, n);
    } catch (s) {
      if (!i)
        return null;
      throw s;
    }
  }, H0;
}
var G0, CD;
function e5() {
  if (CD) return G0;
  CD = 1;
  const r = of();
  return G0 = (t, n) => {
    const i = r(t, n);
    return i ? i.version : null;
  }, G0;
}
var K0, DD;
function t5() {
  if (DD) return K0;
  DD = 1;
  const r = of();
  return K0 = (t, n) => {
    const i = r(t.trim().replace(/^[=v]+/, ""), n);
    return i ? i.version : null;
  }, K0;
}
var q0, TD;
function r5() {
  if (TD) return q0;
  TD = 1;
  const r = Nn();
  return q0 = (t, n, i, s, o) => {
    typeof i == "string" && (o = s, s = i, i = void 0);
    try {
      return new r(
        t instanceof r ? t.version : t,
        i
      ).inc(n, s, o).version;
    } catch {
      return null;
    }
  }, q0;
}
var W0, kD;
function n5() {
  if (kD) return W0;
  kD = 1;
  const r = of();
  return W0 = (t, n) => {
    const i = r(t, null, !0), s = r(n, null, !0), o = i.compare(s);
    if (o === 0)
      return null;
    const a = o > 0, c = a ? i : s, u = a ? s : i, l = !!c.prerelease.length;
    if (!!u.prerelease.length && !l) {
      if (!u.patch && !u.minor)
        return "major";
      if (u.compareMain(c) === 0)
        return u.minor && !u.patch ? "minor" : "patch";
    }
    const f = l ? "pre" : "";
    return i.major !== s.major ? f + "major" : i.minor !== s.minor ? f + "minor" : i.patch !== s.patch ? f + "patch" : "prerelease";
  }, W0;
}
var Z0, OD;
function i5() {
  if (OD) return Z0;
  OD = 1;
  const r = Nn();
  return Z0 = (t, n) => new r(t, n).major, Z0;
}
var J0, $D;
function s5() {
  if ($D) return J0;
  $D = 1;
  const r = Nn();
  return J0 = (t, n) => new r(t, n).minor, J0;
}
var X0, RD;
function o5() {
  if (RD) return X0;
  RD = 1;
  const r = Nn();
  return X0 = (t, n) => new r(t, n).patch, X0;
}
var Y0, PD;
function a5() {
  if (PD) return Y0;
  PD = 1;
  const r = of();
  return Y0 = (t, n) => {
    const i = r(t, n);
    return i && i.prerelease.length ? i.prerelease : null;
  }, Y0;
}
var Q0, ND;
function Ps() {
  if (ND) return Q0;
  ND = 1;
  const r = Nn();
  return Q0 = (t, n, i) => new r(t, i).compare(new r(n, i)), Q0;
}
var eb, BD;
function c5() {
  if (BD) return eb;
  BD = 1;
  const r = Ps();
  return eb = (t, n, i) => r(n, t, i), eb;
}
var tb, LD;
function u5() {
  if (LD) return tb;
  LD = 1;
  const r = Ps();
  return tb = (t, n) => r(t, n, !0), tb;
}
var rb, UD;
function YI() {
  if (UD) return rb;
  UD = 1;
  const r = Nn();
  return rb = (t, n, i) => {
    const s = new r(t, i), o = new r(n, i);
    return s.compare(o) || s.compareBuild(o);
  }, rb;
}
var nb, FD;
function l5() {
  if (FD) return nb;
  FD = 1;
  const r = YI();
  return nb = (t, n) => t.sort((i, s) => r(i, s, n)), nb;
}
var ib, MD;
function d5() {
  if (MD) return ib;
  MD = 1;
  const r = YI();
  return ib = (t, n) => t.sort((i, s) => r(s, i, n)), ib;
}
var sb, VD;
function Iv() {
  if (VD) return sb;
  VD = 1;
  const r = Ps();
  return sb = (t, n, i) => r(t, n, i) > 0, sb;
}
var ob, zD;
function QI() {
  if (zD) return ob;
  zD = 1;
  const r = Ps();
  return ob = (t, n, i) => r(t, n, i) < 0, ob;
}
var ab, jD;
function PB() {
  if (jD) return ab;
  jD = 1;
  const r = Ps();
  return ab = (t, n, i) => r(t, n, i) === 0, ab;
}
var cb, HD;
function NB() {
  if (HD) return cb;
  HD = 1;
  const r = Ps();
  return cb = (t, n, i) => r(t, n, i) !== 0, cb;
}
var ub, GD;
function e1() {
  if (GD) return ub;
  GD = 1;
  const r = Ps();
  return ub = (t, n, i) => r(t, n, i) >= 0, ub;
}
var lb, KD;
function t1() {
  if (KD) return lb;
  KD = 1;
  const r = Ps();
  return lb = (t, n, i) => r(t, n, i) <= 0, lb;
}
var db, qD;
function BB() {
  if (qD) return db;
  qD = 1;
  const r = PB(), e = NB(), t = Iv(), n = e1(), i = QI(), s = t1();
  return db = (a, c, u, l) => {
    switch (c) {
      case "===":
        return typeof a == "object" && (a = a.version), typeof u == "object" && (u = u.version), a === u;
      case "!==":
        return typeof a == "object" && (a = a.version), typeof u == "object" && (u = u.version), a !== u;
      case "":
      case "=":
      case "==":
        return r(a, u, l);
      case "!=":
        return e(a, u, l);
      case ">":
        return t(a, u, l);
      case ">=":
        return n(a, u, l);
      case "<":
        return i(a, u, l);
      case "<=":
        return s(a, u, l);
      default:
        throw new TypeError(`Invalid operator: ${c}`);
    }
  }, db;
}
var hb, WD;
function h5() {
  if (WD) return hb;
  WD = 1;
  const r = Nn(), e = of(), { safeRe: t, t: n } = Vg();
  return hb = (s, o) => {
    if (s instanceof r)
      return s;
    if (typeof s == "number" && (s = String(s)), typeof s != "string")
      return null;
    o = o || {};
    let a = null;
    if (!o.rtl)
      a = s.match(o.includePrerelease ? t[n.COERCEFULL] : t[n.COERCE]);
    else {
      const p = o.includePrerelease ? t[n.COERCERTLFULL] : t[n.COERCERTL];
      let y;
      for (; (y = p.exec(s)) && (!a || a.index + a[0].length !== s.length); )
        (!a || y.index + y[0].length !== a.index + a[0].length) && (a = y), p.lastIndex = y.index + y[1].length + y[2].length;
      p.lastIndex = -1;
    }
    if (a === null)
      return null;
    const c = a[2], u = a[3] || "0", l = a[4] || "0", d = o.includePrerelease && a[5] ? `-${a[5]}` : "", f = o.includePrerelease && a[6] ? `+${a[6]}` : "";
    return e(`${c}.${u}.${l}${d}${f}`, o);
  }, hb;
}
var fb, ZD;
function f5() {
  if (ZD) return fb;
  ZD = 1;
  class r {
    constructor() {
      this.max = 1e3, this.map = /* @__PURE__ */ new Map();
    }
    get(t) {
      const n = this.map.get(t);
      if (n !== void 0)
        return this.map.delete(t), this.map.set(t, n), n;
    }
    delete(t) {
      return this.map.delete(t);
    }
    set(t, n) {
      if (!this.delete(t) && n !== void 0) {
        if (this.map.size >= this.max) {
          const s = this.map.keys().next().value;
          this.delete(s);
        }
        this.map.set(t, n);
      }
      return this;
    }
  }
  return fb = r, fb;
}
var pb, JD;
function Ns() {
  if (JD) return pb;
  JD = 1;
  const r = /\s+/g;
  class e {
    constructor(x, k) {
      if (k = i(k), x instanceof e)
        return x.loose === !!k.loose && x.includePrerelease === !!k.includePrerelease ? x : new e(x.raw, k);
      if (x instanceof s)
        return this.raw = x.value, this.set = [[x]], this.formatted = void 0, this;
      if (this.options = k, this.loose = !!k.loose, this.includePrerelease = !!k.includePrerelease, this.raw = x.trim().replace(r, " "), this.set = this.raw.split("||").map((B) => this.parseRange(B.trim())).filter((B) => B.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const B = this.set[0];
        if (this.set = this.set.filter((A) => !g(A[0])), this.set.length === 0)
          this.set = [B];
        else if (this.set.length > 1) {
          for (const A of this.set)
            if (A.length === 1 && v(A[0])) {
              this.set = [A];
              break;
            }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let x = 0; x < this.set.length; x++) {
          x > 0 && (this.formatted += "||");
          const k = this.set[x];
          for (let B = 0; B < k.length; B++)
            B > 0 && (this.formatted += " "), this.formatted += k[B].toString().trim();
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(x) {
      const B = ((this.options.includePrerelease && p) | (this.options.loose && y)) + ":" + x, A = n.get(B);
      if (A)
        return A;
      const K = this.options.loose, F = K ? c[u.HYPHENRANGELOOSE] : c[u.HYPHENRANGE];
      x = x.replace(F, q(this.options.includePrerelease)), o("hyphen replace", x), x = x.replace(c[u.COMPARATORTRIM], l), o("comparator trim", x), x = x.replace(c[u.TILDETRIM], d), o("tilde trim", x), x = x.replace(c[u.CARETTRIM], f), o("caret trim", x);
      let j = x.split(" ").map((he) => w(he, this.options)).join(" ").split(/\s+/).map((he) => Y(he, this.options));
      K && (j = j.filter((he) => (o("loose invalid filter", he, this.options), !!he.match(c[u.COMPARATORLOOSE])))), o("range list", j);
      const re = /* @__PURE__ */ new Map(), z = j.map((he) => new s(he, this.options));
      for (const he of z) {
        if (g(he))
          return [he];
        re.set(he.value, he);
      }
      re.size > 1 && re.has("") && re.delete("");
      const ce = [...re.values()];
      return n.set(B, ce), ce;
    }
    intersects(x, k) {
      if (!(x instanceof e))
        throw new TypeError("a Range is required");
      return this.set.some((B) => _(B, k) && x.set.some((A) => _(A, k) && B.every((K) => A.every((F) => K.intersects(F, k)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(x) {
      if (!x)
        return !1;
      if (typeof x == "string")
        try {
          x = new a(x, this.options);
        } catch {
          return !1;
        }
      for (let k = 0; k < this.set.length; k++)
        if (J(this.set[k], x, this.options))
          return !0;
      return !1;
    }
  }
  pb = e;
  const t = f5(), n = new t(), i = XI(), s = Cv(), o = Av(), a = Nn(), {
    safeRe: c,
    t: u,
    comparatorTrimReplace: l,
    tildeTrimReplace: d,
    caretTrimReplace: f
  } = Vg(), { FLAG_INCLUDE_PRERELEASE: p, FLAG_LOOSE: y } = xv(), g = (O) => O.value === "<0.0.0-0", v = (O) => O.value === "", _ = (O, x) => {
    let k = !0;
    const B = O.slice();
    let A = B.pop();
    for (; k && B.length; )
      k = B.every((K) => A.intersects(K, x)), A = B.pop();
    return k;
  }, w = (O, x) => (o("comp", O, x), O = T(O, x), o("caret", O), O = I(O, x), o("tildes", O), O = C(O, x), o("xrange", O), O = Z(O, x), o("stars", O), O), E = (O) => !O || O.toLowerCase() === "x" || O === "*", I = (O, x) => O.trim().split(/\s+/).map((k) => S(k, x)).join(" "), S = (O, x) => {
    const k = x.loose ? c[u.TILDELOOSE] : c[u.TILDE];
    return O.replace(k, (B, A, K, F, j) => {
      o("tilde", O, B, A, K, F, j);
      let re;
      return E(A) ? re = "" : E(K) ? re = `>=${A}.0.0 <${+A + 1}.0.0-0` : E(F) ? re = `>=${A}.${K}.0 <${A}.${+K + 1}.0-0` : j ? (o("replaceTilde pr", j), re = `>=${A}.${K}.${F}-${j} <${A}.${+K + 1}.0-0`) : re = `>=${A}.${K}.${F} <${A}.${+K + 1}.0-0`, o("tilde return", re), re;
    });
  }, T = (O, x) => O.trim().split(/\s+/).map((k) => b(k, x)).join(" "), b = (O, x) => {
    o("caret", O, x);
    const k = x.loose ? c[u.CARETLOOSE] : c[u.CARET], B = x.includePrerelease ? "-0" : "";
    return O.replace(k, (A, K, F, j, re) => {
      o("caret", O, A, K, F, j, re);
      let z;
      return E(K) ? z = "" : E(F) ? z = `>=${K}.0.0${B} <${+K + 1}.0.0-0` : E(j) ? K === "0" ? z = `>=${K}.${F}.0${B} <${K}.${+F + 1}.0-0` : z = `>=${K}.${F}.0${B} <${+K + 1}.0.0-0` : re ? (o("replaceCaret pr", re), K === "0" ? F === "0" ? z = `>=${K}.${F}.${j}-${re} <${K}.${F}.${+j + 1}-0` : z = `>=${K}.${F}.${j}-${re} <${K}.${+F + 1}.0-0` : z = `>=${K}.${F}.${j}-${re} <${+K + 1}.0.0-0`) : (o("no pr"), K === "0" ? F === "0" ? z = `>=${K}.${F}.${j}${B} <${K}.${F}.${+j + 1}-0` : z = `>=${K}.${F}.${j}${B} <${K}.${+F + 1}.0-0` : z = `>=${K}.${F}.${j} <${+K + 1}.0.0-0`), o("caret return", z), z;
    });
  }, C = (O, x) => (o("replaceXRanges", O, x), O.split(/\s+/).map((k) => P(k, x)).join(" ")), P = (O, x) => {
    O = O.trim();
    const k = x.loose ? c[u.XRANGELOOSE] : c[u.XRANGE];
    return O.replace(k, (B, A, K, F, j, re) => {
      o("xRange", O, B, A, K, F, j, re);
      const z = E(K), ce = z || E(F), he = ce || E(j), de = he;
      return A === "=" && de && (A = ""), re = x.includePrerelease ? "-0" : "", z ? A === ">" || A === "<" ? B = "<0.0.0-0" : B = "*" : A && de ? (ce && (F = 0), j = 0, A === ">" ? (A = ">=", ce ? (K = +K + 1, F = 0, j = 0) : (F = +F + 1, j = 0)) : A === "<=" && (A = "<", ce ? K = +K + 1 : F = +F + 1), A === "<" && (re = "-0"), B = `${A + K}.${F}.${j}${re}`) : ce ? B = `>=${K}.0.0${re} <${+K + 1}.0.0-0` : he && (B = `>=${K}.${F}.0${re} <${K}.${+F + 1}.0-0`), o("xRange return", B), B;
    });
  }, Z = (O, x) => (o("replaceStars", O, x), O.trim().replace(c[u.STAR], "")), Y = (O, x) => (o("replaceGTE0", O, x), O.trim().replace(c[x.includePrerelease ? u.GTE0PRE : u.GTE0], "")), q = (O) => (x, k, B, A, K, F, j, re, z, ce, he, de) => (E(B) ? k = "" : E(A) ? k = `>=${B}.0.0${O ? "-0" : ""}` : E(K) ? k = `>=${B}.${A}.0${O ? "-0" : ""}` : F ? k = `>=${k}` : k = `>=${k}${O ? "-0" : ""}`, E(z) ? re = "" : E(ce) ? re = `<${+z + 1}.0.0-0` : E(he) ? re = `<${z}.${+ce + 1}.0-0` : de ? re = `<=${z}.${ce}.${he}-${de}` : O ? re = `<${z}.${ce}.${+he + 1}-0` : re = `<=${re}`, `${k} ${re}`.trim()), J = (O, x, k) => {
    for (let B = 0; B < O.length; B++)
      if (!O[B].test(x))
        return !1;
    if (x.prerelease.length && !k.includePrerelease) {
      for (let B = 0; B < O.length; B++)
        if (o(O[B].semver), O[B].semver !== s.ANY && O[B].semver.prerelease.length > 0) {
          const A = O[B].semver;
          if (A.major === x.major && A.minor === x.minor && A.patch === x.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return pb;
}
var gb, XD;
function Cv() {
  if (XD) return gb;
  XD = 1;
  const r = Symbol("SemVer ANY");
  class e {
    static get ANY() {
      return r;
    }
    constructor(l, d) {
      if (d = t(d), l instanceof e) {
        if (l.loose === !!d.loose)
          return l;
        l = l.value;
      }
      l = l.trim().split(/\s+/).join(" "), o("comparator", l, d), this.options = d, this.loose = !!d.loose, this.parse(l), this.semver === r ? this.value = "" : this.value = this.operator + this.semver.version, o("comp", this);
    }
    parse(l) {
      const d = this.options.loose ? n[i.COMPARATORLOOSE] : n[i.COMPARATOR], f = l.match(d);
      if (!f)
        throw new TypeError(`Invalid comparator: ${l}`);
      this.operator = f[1] !== void 0 ? f[1] : "", this.operator === "=" && (this.operator = ""), f[2] ? this.semver = new a(f[2], this.options.loose) : this.semver = r;
    }
    toString() {
      return this.value;
    }
    test(l) {
      if (o("Comparator.test", l, this.options.loose), this.semver === r || l === r)
        return !0;
      if (typeof l == "string")
        try {
          l = new a(l, this.options);
        } catch {
          return !1;
        }
      return s(l, this.operator, this.semver, this.options);
    }
    intersects(l, d) {
      if (!(l instanceof e))
        throw new TypeError("a Comparator is required");
      return this.operator === "" ? this.value === "" ? !0 : new c(l.value, d).test(this.value) : l.operator === "" ? l.value === "" ? !0 : new c(this.value, d).test(l.semver) : (d = t(d), d.includePrerelease && (this.value === "<0.0.0-0" || l.value === "<0.0.0-0") || !d.includePrerelease && (this.value.startsWith("<0.0.0") || l.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && l.operator.startsWith(">") || this.operator.startsWith("<") && l.operator.startsWith("<") || this.semver.version === l.semver.version && this.operator.includes("=") && l.operator.includes("=") || s(this.semver, "<", l.semver, d) && this.operator.startsWith(">") && l.operator.startsWith("<") || s(this.semver, ">", l.semver, d) && this.operator.startsWith("<") && l.operator.startsWith(">")));
    }
  }
  gb = e;
  const t = XI(), { safeRe: n, t: i } = Vg(), s = BB(), o = Av(), a = Nn(), c = Ns();
  return gb;
}
var mb, YD;
function Dv() {
  if (YD) return mb;
  YD = 1;
  const r = Ns();
  return mb = (t, n, i) => {
    try {
      n = new r(n, i);
    } catch {
      return !1;
    }
    return n.test(t);
  }, mb;
}
var yb, QD;
function p5() {
  if (QD) return yb;
  QD = 1;
  const r = Ns();
  return yb = (t, n) => new r(t, n).set.map((i) => i.map((s) => s.value).join(" ").trim().split(" ")), yb;
}
var vb, eT;
function g5() {
  if (eT) return vb;
  eT = 1;
  const r = Nn(), e = Ns();
  return vb = (n, i, s) => {
    let o = null, a = null, c = null;
    try {
      c = new e(i, s);
    } catch {
      return null;
    }
    return n.forEach((u) => {
      c.test(u) && (!o || a.compare(u) === -1) && (o = u, a = new r(o, s));
    }), o;
  }, vb;
}
var bb, tT;
function m5() {
  if (tT) return bb;
  tT = 1;
  const r = Nn(), e = Ns();
  return bb = (n, i, s) => {
    let o = null, a = null, c = null;
    try {
      c = new e(i, s);
    } catch {
      return null;
    }
    return n.forEach((u) => {
      c.test(u) && (!o || a.compare(u) === 1) && (o = u, a = new r(o, s));
    }), o;
  }, bb;
}
var wb, rT;
function y5() {
  if (rT) return wb;
  rT = 1;
  const r = Nn(), e = Ns(), t = Iv();
  return wb = (i, s) => {
    i = new e(i, s);
    let o = new r("0.0.0");
    if (i.test(o) || (o = new r("0.0.0-0"), i.test(o)))
      return o;
    o = null;
    for (let a = 0; a < i.set.length; ++a) {
      const c = i.set[a];
      let u = null;
      c.forEach((l) => {
        const d = new r(l.semver.version);
        switch (l.operator) {
          case ">":
            d.prerelease.length === 0 ? d.patch++ : d.prerelease.push(0), d.raw = d.format();
          /* fallthrough */
          case "":
          case ">=":
            (!u || t(d, u)) && (u = d);
            break;
          case "<":
          case "<=":
            break;
          /* istanbul ignore next */
          default:
            throw new Error(`Unexpected operation: ${l.operator}`);
        }
      }), u && (!o || t(o, u)) && (o = u);
    }
    return o && i.test(o) ? o : null;
  }, wb;
}
var _b, nT;
function v5() {
  if (nT) return _b;
  nT = 1;
  const r = Ns();
  return _b = (t, n) => {
    try {
      return new r(t, n).range || "*";
    } catch {
      return null;
    }
  }, _b;
}
var Sb, iT;
function r1() {
  if (iT) return Sb;
  iT = 1;
  const r = Nn(), e = Cv(), { ANY: t } = e, n = Ns(), i = Dv(), s = Iv(), o = QI(), a = t1(), c = e1();
  return Sb = (l, d, f, p) => {
    l = new r(l, p), d = new n(d, p);
    let y, g, v, _, w;
    switch (f) {
      case ">":
        y = s, g = a, v = o, _ = ">", w = ">=";
        break;
      case "<":
        y = o, g = c, v = s, _ = "<", w = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (i(l, d, p))
      return !1;
    for (let E = 0; E < d.set.length; ++E) {
      const I = d.set[E];
      let S = null, T = null;
      if (I.forEach((b) => {
        b.semver === t && (b = new e(">=0.0.0")), S = S || b, T = T || b, y(b.semver, S.semver, p) ? S = b : v(b.semver, T.semver, p) && (T = b);
      }), S.operator === _ || S.operator === w || (!T.operator || T.operator === _) && g(l, T.semver))
        return !1;
      if (T.operator === w && v(l, T.semver))
        return !1;
    }
    return !0;
  }, Sb;
}
var Eb, sT;
function b5() {
  if (sT) return Eb;
  sT = 1;
  const r = r1();
  return Eb = (t, n, i) => r(t, n, ">", i), Eb;
}
var xb, oT;
function w5() {
  if (oT) return xb;
  oT = 1;
  const r = r1();
  return xb = (t, n, i) => r(t, n, "<", i), xb;
}
var Ab, aT;
function _5() {
  if (aT) return Ab;
  aT = 1;
  const r = Ns();
  return Ab = (t, n, i) => (t = new r(t, i), n = new r(n, i), t.intersects(n, i)), Ab;
}
var Ib, cT;
function S5() {
  if (cT) return Ib;
  cT = 1;
  const r = Dv(), e = Ps();
  return Ib = (t, n, i) => {
    const s = [];
    let o = null, a = null;
    const c = t.sort((f, p) => e(f, p, i));
    for (const f of c)
      r(f, n, i) ? (a = f, o || (o = f)) : (a && s.push([o, a]), a = null, o = null);
    o && s.push([o, null]);
    const u = [];
    for (const [f, p] of s)
      f === p ? u.push(f) : !p && f === c[0] ? u.push("*") : p ? f === c[0] ? u.push(`<=${p}`) : u.push(`${f} - ${p}`) : u.push(`>=${f}`);
    const l = u.join(" || "), d = typeof n.raw == "string" ? n.raw : String(n);
    return l.length < d.length ? l : n;
  }, Ib;
}
var Cb, uT;
function E5() {
  if (uT) return Cb;
  uT = 1;
  const r = Ns(), e = Cv(), { ANY: t } = e, n = Dv(), i = Ps(), s = (d, f, p = {}) => {
    if (d === f)
      return !0;
    d = new r(d, p), f = new r(f, p);
    let y = !1;
    e: for (const g of d.set) {
      for (const v of f.set) {
        const _ = c(g, v, p);
        if (y = y || _ !== null, _)
          continue e;
      }
      if (y)
        return !1;
    }
    return !0;
  }, o = [new e(">=0.0.0-0")], a = [new e(">=0.0.0")], c = (d, f, p) => {
    if (d === f)
      return !0;
    if (d.length === 1 && d[0].semver === t) {
      if (f.length === 1 && f[0].semver === t)
        return !0;
      p.includePrerelease ? d = o : d = a;
    }
    if (f.length === 1 && f[0].semver === t) {
      if (p.includePrerelease)
        return !0;
      f = a;
    }
    const y = /* @__PURE__ */ new Set();
    let g, v;
    for (const C of d)
      C.operator === ">" || C.operator === ">=" ? g = u(g, C, p) : C.operator === "<" || C.operator === "<=" ? v = l(v, C, p) : y.add(C.semver);
    if (y.size > 1)
      return null;
    let _;
    if (g && v) {
      if (_ = i(g.semver, v.semver, p), _ > 0)
        return null;
      if (_ === 0 && (g.operator !== ">=" || v.operator !== "<="))
        return null;
    }
    for (const C of y) {
      if (g && !n(C, String(g), p) || v && !n(C, String(v), p))
        return null;
      for (const P of f)
        if (!n(C, String(P), p))
          return !1;
      return !0;
    }
    let w, E, I, S, T = v && !p.includePrerelease && v.semver.prerelease.length ? v.semver : !1, b = g && !p.includePrerelease && g.semver.prerelease.length ? g.semver : !1;
    T && T.prerelease.length === 1 && v.operator === "<" && T.prerelease[0] === 0 && (T = !1);
    for (const C of f) {
      if (S = S || C.operator === ">" || C.operator === ">=", I = I || C.operator === "<" || C.operator === "<=", g) {
        if (b && C.semver.prerelease && C.semver.prerelease.length && C.semver.major === b.major && C.semver.minor === b.minor && C.semver.patch === b.patch && (b = !1), C.operator === ">" || C.operator === ">=") {
          if (w = u(g, C, p), w === C && w !== g)
            return !1;
        } else if (g.operator === ">=" && !n(g.semver, String(C), p))
          return !1;
      }
      if (v) {
        if (T && C.semver.prerelease && C.semver.prerelease.length && C.semver.major === T.major && C.semver.minor === T.minor && C.semver.patch === T.patch && (T = !1), C.operator === "<" || C.operator === "<=") {
          if (E = l(v, C, p), E === C && E !== v)
            return !1;
        } else if (v.operator === "<=" && !n(v.semver, String(C), p))
          return !1;
      }
      if (!C.operator && (v || g) && _ !== 0)
        return !1;
    }
    return !(g && I && !v && _ !== 0 || v && S && !g && _ !== 0 || b || T);
  }, u = (d, f, p) => {
    if (!d)
      return f;
    const y = i(d.semver, f.semver, p);
    return y > 0 ? d : y < 0 || f.operator === ">" && d.operator === ">=" ? f : d;
  }, l = (d, f, p) => {
    if (!d)
      return f;
    const y = i(d.semver, f.semver, p);
    return y < 0 ? d : y > 0 || f.operator === "<" && d.operator === "<=" ? f : d;
  };
  return Cb = s, Cb;
}
var Db, lT;
function x5() {
  if (lT) return Db;
  lT = 1;
  const r = Vg(), e = xv(), t = Nn(), n = RB(), i = of(), s = e5(), o = t5(), a = r5(), c = n5(), u = i5(), l = s5(), d = o5(), f = a5(), p = Ps(), y = c5(), g = u5(), v = YI(), _ = l5(), w = d5(), E = Iv(), I = QI(), S = PB(), T = NB(), b = e1(), C = t1(), P = BB(), Z = h5(), Y = Cv(), q = Ns(), J = Dv(), O = p5(), x = g5(), k = m5(), B = y5(), A = v5(), K = r1(), F = b5(), j = w5(), re = _5(), z = S5(), ce = E5();
  return Db = {
    parse: i,
    valid: s,
    clean: o,
    inc: a,
    diff: c,
    major: u,
    minor: l,
    patch: d,
    prerelease: f,
    compare: p,
    rcompare: y,
    compareLoose: g,
    compareBuild: v,
    sort: _,
    rsort: w,
    gt: E,
    lt: I,
    eq: S,
    neq: T,
    gte: b,
    lte: C,
    cmp: P,
    coerce: Z,
    Comparator: Y,
    Range: q,
    satisfies: J,
    toComparators: O,
    maxSatisfying: x,
    minSatisfying: k,
    minVersion: B,
    validRange: A,
    outside: K,
    gtr: F,
    ltr: j,
    intersects: re,
    simplifyRange: z,
    subset: ce,
    SemVer: t,
    re: r.re,
    src: r.src,
    tokens: r.t,
    SEMVER_SPEC_VERSION: e.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: e.RELEASE_TYPES,
    compareIdentifiers: n.compareIdentifiers,
    rcompareIdentifiers: n.rcompareIdentifiers
  }, Db;
}
var Et = x5();
const ky = /* @__PURE__ */ KI(Et);
var je = ((r) => (r.NANO_S = "nanoS", r.NANO_SP = "nanoSP", r.NANO_X = "nanoX", r.STAX = "stax", r.FLEX = "flex", r.APEX = "apexp", r))(je || {});
let LB = class {
  constructor({ id: e, model: t, name: n }) {
    h(this, "id");
    h(this, "model");
    h(this, "name");
    this.id = e, this.model = t, this.name = n;
  }
};
const dT = 11415;
let A5 = class {
  constructor(e) {
    if (this.seFlags = e, this.seFlags.length !== 4) throw new Error("Invalid secure element flags length");
  }
  generalDeviceState() {
    const e = this.seFlags[0] ?? 0;
    return { isPinValidated: this._checkNthBitInByte(e, 1), hasMcuSerialNumber: this._checkNthBitInByte(e, 2), hasValidCertificate: this._checkNthBitInByte(e, 3), isCustomAuthorityConnectionAllowed: this._checkNthBitInByte(e, 4), isSecureConnectionAllowed: this._checkNthBitInByte(e, 5), isOnboarded: this._checkNthBitInByte(e, 6), isMcuCodeSigned: this._checkNthBitInByte(e, 7), isInRecoveryMode: this._checkNthBitInByte(e, 8) };
  }
  endorsementInformation() {
    throw new Error("Not implemented");
  }
  wordsInformation() {
    throw new Error("Not implemented");
  }
  onboardingStatus() {
    throw new Error("Not implemented");
  }
  _checkNthBitInByte(e, t) {
    return (e >> 8 - t & 1) === 1;
  }
}, UB = class {
  constructor() {
    h(this, "args");
  }
  getApdu() {
    const e = { cla: 224, ins: 1, p1: 0, p2: 0 };
    return new ot(e).build();
  }
  parseResponse(e, t) {
    if (!Jr.isSuccessResponse(e)) return ye({ error: ha.handle(e) });
    const n = new kr(e), i = n.extract32BitUInt();
    if (i === void 0) return ye({ error: new ht("Missing target ID in OS version") });
    let s = n.encodeToString(n.extractFieldLVEncoded()), o = n.extractFieldLVEncoded() ?? new Uint8Array(0);
    const a = { ...new A5(o).generalDeviceState() };
    s || (s = "0.0.0", o = new Uint8Array());
    const c = (i & 4026531840) !== 805306368, u = s.includes("-osu");
    let l = "", d = "", f = "", p = "", y, g, v, _;
    if (c) {
      f = s, y = i;
      const w = n.extractFieldLVEncoded();
      w && (w.length >= 5 ? (l = n.encodeToString(w), g = parseInt(n.encodeToHexaString(n.extractFieldLVEncoded()), 16)) : g = parseInt(n.encodeToHexaString(w), 16));
    } else {
      if (l = s, g = i, d = n.encodeToString(n.extractFieldLVEncoded()), this.isBootloaderVersionSupported(l, t) && (f = n.encodeToString(n.extractFieldLVEncoded())), this.isHardwareVersionSupported(l, t) ? p = n.encodeToHexaString(n.extractFieldLVEncoded()) : p = "00", this.isLocalizationSupported(l, t)) {
        const w = n.extractFieldLVEncoded();
        w !== void 0 && (v = parseInt(n.encodeToHexaString(w), 16));
      }
      if (this.isRecoverSupported(l, t)) {
        const w = n.extractFieldLVEncoded();
        w !== void 0 && (_ = parseInt(n.encodeToHexaString(w), 16));
      }
    }
    return ye({ data: { isBootloader: c, isOsu: u, targetId: i, seTargetId: g, mcuTargetId: y, seVersion: l, seFlags: o, mcuSephVersion: d, mcuBootloaderVersion: f, hwVersion: p, langId: v, recoverState: _, secureElementFlags: a } });
  }
  isBootloaderVersionSupported(e, t) {
    const n = Et.coerce(e) ?? "";
    switch (t) {
      case je.NANO_S:
      case je.NANO_X:
        return Et.gte(n, "2.0.0");
      default:
        return !0;
    }
  }
  isHardwareVersionSupported(e, t) {
    const n = Et.coerce(e) ?? "";
    switch (t) {
      case je.NANO_X:
        return Et.gte(n, "2.0.0");
      default:
        return !1;
    }
  }
  isLocalizationSupported(e, t) {
    const n = Et.coerce(e) ?? "";
    switch (t) {
      case je.NANO_S:
        return !1;
      case je.NANO_SP:
        return Et.gte(n, "1.1.0");
      case je.NANO_X:
        return Et.gte(n, "2.1.0");
      default:
        return !0;
    }
  }
  isRecoverSupported(e, t) {
    const n = Et.coerce(e) ?? "";
    switch (t) {
      case je.NANO_S:
        return !1;
      case je.NANO_SP:
        return Et.gte(n, "1.1.2");
      case je.NANO_X:
        return Et.gte(n, "2.2.3");
      case je.STAX:
        return Et.gte(n, "1.4.0");
      case je.FLEX:
        return Et.gte(n, "1.0.1");
      default:
        return !0;
    }
  }
};
const hT = { 6624: { message: "Invalid state (List applications command must be sent)" } };
let I5 = class extends dl {
  constructor({ message: e, errorCode: t }) {
    super({ message: e, errorCode: t, tag: "ListAppsCommandError" });
  }
}, C5 = class {
  constructor(e = { isContinue: !1 }) {
    h(this, "args");
    this.args = e;
  }
  getApdu() {
    const e = { cla: 224, ins: this.args.isContinue ? 223 : 222, p1: 0, p2: 0 };
    return new ot(e).build();
  }
  parseResponse(e) {
    const t = [], n = new kr(e);
    if (!Jr.isSuccessResponse(e)) {
      const i = n.encodeToHexaString(e.statusCode);
      return hl(i, hT) ? ye({ error: new I5({ ...hT[i], errorCode: i }) }) : ye({ error: ha.handle(e) });
    }
    if (e.data.length <= 0) return ye({ data: [] });
    for (n.extract8BitUInt(); n.getUnparsedRemainingLength() > 0; ) {
      const i = n.extract8BitUInt(), s = n.extract16BitUInt();
      n.extract16BitUInt();
      const o = n.encodeToHexaString(n.extractFieldByLength(32)), a = n.encodeToHexaString(n.extractFieldByLength(32)), c = n.encodeToString(n.extractFieldLVEncoded());
      t.push({ appEntryLength: i, appSizeInBlocks: s, appCodeHash: o, appFullHash: a, appName: c });
    }
    return ye({ data: t });
  }
};
const fT = { "422f": { message: "Incorrect structure type" }, 4230: { message: "Incorrect certificate version" }, 4231: { message: "Incorrect certificate validity" }, 4232: { message: "Incorrect certificate validity index" }, 4233: { message: "Unknown signer key ID" }, 4234: { message: "Unknown signature algorithm" }, 4235: { message: "Unknown public key ID" }, 4236: { message: "Unknown public key usage" }, 4237: { message: "Incorrect elliptic curve ID" }, 4238: { message: "Incorrect signature algorithm associated to the public key" }, 4239: { message: "Unknown target device" }, "422d": { message: "Unknown certificate tag" }, 3301: { message: "Failed to hash data" }, "422e": { message: "expected_key_usage doesn't match certificate key usage" }, 5720: { message: "Failed to verify signature" }, 4118: { message: "trusted_name buffer is too small to contain the trusted name" }, ffff: { message: "Cryptography-related error" } };
let D5 = class extends dl {
  constructor({ message: e, errorCode: t }) {
    super({ tag: "ProvidePkiCertificateCommandError", message: e, errorCode: t });
  }
}, uS = class {
  constructor(e) {
    h(this, "args");
    h(this, "triggersDisconnection", !1);
    this.args = e;
  }
  getApdu() {
    const e = { cla: 176, ins: 6, p1: this.args.keyUsage, p2: 0 };
    return new ot(e).addBufferToData(this.args.certificate).build();
  }
  parseResponse(e) {
    if (Jr.isSuccessResponse(e)) return ye({ data: void 0 });
    const t = new kr(e).encodeToHexaString(e.statusCode);
    return hl(t, fT) ? ye({ error: new D5({ ...fT[t], errorCode: t }) }) : ye({ error: ha.handle(e) });
  }
};
const pT = { "670a": { message: "No app name provided" }, 6807: { message: "Unknown application name" } };
let T5 = class extends dl {
  constructor({ message: e, errorCode: t }) {
    super({ tag: "OpenAppCommandError", message: e, errorCode: t });
  }
}, k5 = class {
  constructor(e) {
    h(this, "args");
    h(this, "triggersDisconnection", !0);
    this.args = e;
  }
  getApdu() {
    const e = { cla: 224, ins: 216, p1: 0, p2: 0 };
    return new ot(e).addAsciiStringToData(this.args.appName).build();
  }
  parseResponse(e) {
    if (Jr.isSuccessResponse(e)) return ye({ data: void 0 });
    const t = new kr(e).encodeToHexaString(e.statusCode);
    return hl(t, pT) ? ye({ error: new T5({ ...pT[t], errorCode: t }) }) : ye({ error: ha.handle(e) });
  }
};
var na = ((r) => (r.LOCKED = "LOCKED", r.BUSY = "BUSY", r.CONNECTED = "CONNECTED", r.NOT_CONNECTED = "NOT CONNECTED", r))(na || {}), Oe = ((r) => (r.NotStarted = "not-started", r.Pending = "pending", r.Stopped = "stopped", r.Completed = "completed", r.Error = "error", r))(Oe || {}), $e = ((r) => (r.None = "none", r.UnlockDevice = "unlock-device", r.AllowSecureConnection = "allow-secure-connection", r.ConfirmOpenApp = "confirm-open-app", r.SignTransaction = "sign-transaction", r.SignTypedData = "sign-typed-data", r.AllowListApps = "allow-list-apps", r.VerifyAddress = "verify-address", r.SignPersonalMessage = "sign-personal-message", r.SignDelegationAuthorization = "sign-delegation-authorization", r.Web3ChecksOptIn = "web3-checks-opt-in", r.VerifySafeAddress = "verify-safe-address", r))($e || {});
const pe = {
  of(r) {
    return Le(r);
  },
  empty() {
    return ve;
  },
  zero() {
    return ve;
  },
  fromNullable(r) {
    return r == null ? ve : Le(r);
  },
  fromFalsy(r) {
    return r ? Le(r) : ve;
  },
  fromPredicate(r, e) {
    switch (arguments.length) {
      case 1:
        return (t) => pe.fromPredicate(r, t);
      default:
        return r(e) ? Le(e) : ve;
    }
  },
  mapMaybe(r, e) {
    switch (arguments.length) {
      case 1:
        return (t) => pe.mapMaybe(r, t);
      default:
        return pe.catMaybes(e.map(r));
    }
  },
  catMaybes(r) {
    let e = [];
    for (const t of r)
      t.isJust() && e.push(t.extract());
    return e;
  },
  encase(r) {
    try {
      return Le(r());
    } catch {
      return ve;
    }
  },
  isMaybe(r) {
    return r instanceof n1 || r instanceof i1;
  },
  sequence(r) {
    let e = [];
    for (const t of r)
      if (t.isJust())
        e.push(t.extract());
      else
        return ve;
    return Le(e);
  },
  "fantasy-land/of"(r) {
    return this.of(r);
  },
  "fantasy-land/empty"() {
    return this.empty();
  },
  "fantasy-land/zero"() {
    return this.zero();
  }
};
class n1 {
  constructor(e) {
    this.__value = e, this["fantasy-land/equals"] = this.equals, this["fantasy-land/map"] = this.map, this["fantasy-land/ap"] = this.ap, this["fantasy-land/alt"] = this.alt, this["fantasy-land/chain"] = this.chain, this["fantasy-land/reduce"] = this.reduce, this["fantasy-land/extend"] = this.extend, this["fantasy-land/filter"] = this.filter;
  }
  isJust() {
    return !0;
  }
  isNothing() {
    return !1;
  }
  inspect() {
    return `Just(${this.__value})`;
  }
  toString() {
    return this.inspect();
  }
  toJSON() {
    const e = this.__value;
    return e instanceof Date ? e.toJSON() : e;
  }
  equals(e) {
    return this.extract() === e.extract();
  }
  map(e) {
    return Le(e(this.__value));
  }
  ap(e) {
    return e.isJust() ? this.map(e.extract()) : ve;
  }
  alt(e) {
    return this;
  }
  altLazy(e) {
    return this;
  }
  chain(e) {
    return e(this.__value);
  }
  chainNullable(e) {
    return pe.fromNullable(e(this.__value));
  }
  join() {
    return this.__value;
  }
  reduce(e, t) {
    return e(t, this.__value);
  }
  extend(e) {
    return Le(e(this));
  }
  unsafeCoerce() {
    return this.__value;
  }
  caseOf(e) {
    return "_" in e ? e._() : e.Just(this.__value);
  }
  orDefault(e) {
    return this.__value;
  }
  orDefaultLazy(e) {
    return this.__value;
  }
  toList() {
    return [this.__value];
  }
  mapOrDefault(e, t) {
    return e(this.__value);
  }
  extract() {
    return this.__value;
  }
  extractNullable() {
    return this.__value;
  }
  toEither(e) {
    return te(this.__value);
  }
  ifJust(e) {
    return e(this.__value), this;
  }
  ifNothing(e) {
    return this;
  }
  filter(e) {
    return e(this.__value) ? Le(this.__value) : ve;
  }
}
n1.prototype.constructor = pe;
class i1 {
  constructor() {
    this["fantasy-land/equals"] = this.equals, this["fantasy-land/map"] = this.map, this["fantasy-land/ap"] = this.ap, this["fantasy-land/alt"] = this.alt, this["fantasy-land/chain"] = this.chain, this["fantasy-land/reduce"] = this.reduce, this["fantasy-land/extend"] = this.extend, this["fantasy-land/filter"] = this.filter;
  }
  isJust() {
    return !1;
  }
  isNothing() {
    return !0;
  }
  inspect() {
    return "Nothing";
  }
  toString() {
    return this.inspect();
  }
  toJSON() {
    return this.__value;
  }
  equals(e) {
    return this.extract() === e.extract();
  }
  map(e) {
    return ve;
  }
  ap(e) {
    return ve;
  }
  alt(e) {
    return e;
  }
  altLazy(e) {
    return e();
  }
  chain(e) {
    return ve;
  }
  chainNullable(e) {
    return ve;
  }
  join() {
    return ve;
  }
  reduce(e, t) {
    return t;
  }
  extend(e) {
    return ve;
  }
  unsafeCoerce() {
    throw new Error("Maybe#unsafeCoerce was ran on a Nothing");
  }
  caseOf(e) {
    return "_" in e ? e._() : e.Nothing();
  }
  orDefault(e) {
    return e;
  }
  orDefaultLazy(e) {
    return e();
  }
  toList() {
    return [];
  }
  mapOrDefault(e, t) {
    return t;
  }
  extract() {
  }
  extractNullable() {
    return null;
  }
  toEither(e) {
    return N(e);
  }
  ifJust(e) {
    return this;
  }
  ifNothing(e) {
    return e(), this;
  }
  filter(e) {
    return ve;
  }
}
i1.prototype.constructor = pe;
const Le = (r) => new n1(r), ve = new i1(), Pt = {
  of(r) {
    return te(r);
  },
  lefts(r) {
    let e = [];
    for (const t of r)
      t.isLeft() && e.push(t.extract());
    return e;
  },
  rights(r) {
    let e = [];
    for (const t of r)
      t.isRight() && e.push(t.extract());
    return e;
  },
  encase(r) {
    try {
      return te(r());
    } catch (e) {
      return N(e);
    }
  },
  sequence(r) {
    let e = [];
    for (const t of r) {
      if (t.isLeft())
        return t;
      e.push(t.extract());
    }
    return te(e);
  },
  isEither(r) {
    return r instanceof o1 || r instanceof s1;
  },
  "fantasy-land/of"(r) {
    return Pt.of(r);
  }
};
class s1 {
  constructor(e) {
    this.__value = e, this._ = "R", this["fantasy-land/bimap"] = this.bimap, this["fantasy-land/map"] = this.map, this["fantasy-land/ap"] = this.ap, this["fantasy-land/equals"] = this.equals, this["fantasy-land/chain"] = this.chain, this["fantasy-land/alt"] = this.alt, this["fantasy-land/reduce"] = this.reduce, this["fantasy-land/extend"] = this.extend;
  }
  isLeft() {
    return !1;
  }
  isRight() {
    return !0;
  }
  toJSON() {
    return this.__value;
  }
  inspect() {
    return `Right(${this.__value})`;
  }
  toString() {
    return this.inspect();
  }
  bimap(e, t) {
    return te(t(this.__value));
  }
  map(e) {
    return te(e(this.__value));
  }
  mapLeft(e) {
    return this;
  }
  ap(e) {
    return e.isRight() ? this.map(e.extract()) : e;
  }
  equals(e) {
    return e.isRight() ? this.__value === e.extract() : !1;
  }
  chain(e) {
    return e(this.__value);
  }
  chainLeft(e) {
    return this;
  }
  join() {
    return this.__value;
  }
  alt(e) {
    return this;
  }
  altLazy(e) {
    return this;
  }
  reduce(e, t) {
    return e(t, this.__value);
  }
  extend(e) {
    return te(e(this));
  }
  unsafeCoerce() {
    return this.__value;
  }
  caseOf(e) {
    return "_" in e ? e._() : e.Right(this.__value);
  }
  leftOrDefault(e) {
    return e;
  }
  orDefault(e) {
    return this.__value;
  }
  orDefaultLazy(e) {
    return this.__value;
  }
  leftOrDefaultLazy(e) {
    return e();
  }
  ifLeft(e) {
    return this;
  }
  ifRight(e) {
    return e(this.__value), this;
  }
  toMaybe() {
    return Le(this.__value);
  }
  leftToMaybe() {
    return ve;
  }
  extract() {
    return this.__value;
  }
  swap() {
    return N(this.__value);
  }
}
s1.prototype.constructor = Pt;
class o1 {
  constructor(e) {
    this.__value = e, this._ = "L", this["fantasy-land/bimap"] = this.bimap, this["fantasy-land/map"] = this.map, this["fantasy-land/ap"] = this.ap, this["fantasy-land/equals"] = this.equals, this["fantasy-land/chain"] = this.chain, this["fantasy-land/alt"] = this.alt, this["fantasy-land/reduce"] = this.reduce, this["fantasy-land/extend"] = this.extend;
  }
  isLeft() {
    return !0;
  }
  isRight() {
    return !1;
  }
  toJSON() {
    return this.__value;
  }
  inspect() {
    return `Left(${JSON.stringify(this.__value)})`;
  }
  toString() {
    return this.inspect();
  }
  bimap(e, t) {
    return N(e(this.__value));
  }
  map(e) {
    return this;
  }
  mapLeft(e) {
    return N(e(this.__value));
  }
  ap(e) {
    return e.isLeft() ? e : this;
  }
  equals(e) {
    return e.isLeft() ? e.extract() === this.__value : !1;
  }
  chain(e) {
    return this;
  }
  chainLeft(e) {
    return e(this.__value);
  }
  join() {
    return this;
  }
  alt(e) {
    return e;
  }
  altLazy(e) {
    return e();
  }
  reduce(e, t) {
    return t;
  }
  extend(e) {
    return this;
  }
  unsafeCoerce() {
    throw this.__value instanceof Error ? this.__value : new Error("Either#unsafeCoerce was ran on a Left");
  }
  caseOf(e) {
    return "_" in e ? e._() : e.Left(this.__value);
  }
  leftOrDefault(e) {
    return this.__value;
  }
  orDefault(e) {
    return e;
  }
  orDefaultLazy(e) {
    return e();
  }
  leftOrDefaultLazy(e) {
    return this.__value;
  }
  ifLeft(e) {
    return e(this.__value), this;
  }
  ifRight(e) {
    return this;
  }
  toMaybe() {
    return ve;
  }
  leftToMaybe() {
    return Le(this.__value);
  }
  extract() {
    return this.__value;
  }
  swap() {
    return te(this.__value);
  }
}
o1.prototype.constructor = Pt;
const N = (r) => new o1(r), te = (r) => new s1(r);
var FB;
const MB = {
  liftEither(r) {
    if (r.isRight())
      return Promise.resolve(r.extract());
    throw r.extract();
  },
  fromPromise(r) {
    return r.then(MB.liftEither);
  },
  throwE(r) {
    throw r;
  }
};
class VB {
  constructor(e) {
    this.runPromise = e, this[FB] = "EitherAsync", this["fantasy-land/chain"] = this.chain, this["fantasy-land/alt"] = this.alt, this.then = (t, n) => this.run().then(t, n);
  }
  leftOrDefault(e) {
    return this.run().then((t) => t.leftOrDefault(e));
  }
  orDefault(e) {
    return this.run().then((t) => t.orDefault(e));
  }
  join() {
    return me(async (e) => {
      const t = await this;
      if (t.isRight()) {
        const n = await t.extract();
        return e.liftEither(n);
      }
      return e.liftEither(t);
    });
  }
  ap(e) {
    return me(async (t) => {
      const n = await e;
      if (n.isRight()) {
        const i = await this.run();
        return i.isRight() ? n.extract()(i.extract()) : t.liftEither(i);
      }
      return t.liftEither(n);
    });
  }
  alt(e) {
    return me(async (t) => {
      const n = await this.run();
      if (n.isRight())
        return n.extract();
      {
        const i = await e;
        return t.liftEither(i);
      }
    });
  }
  extend(e) {
    return me(async (t) => {
      const n = await this.run();
      if (n.isRight()) {
        const i = me.liftEither(n);
        return t.liftEither(te(e(i)));
      }
      return t.liftEither(n);
    });
  }
  async run() {
    try {
      return te(await this.runPromise(MB));
    } catch (e) {
      return N(e);
    }
  }
  bimap(e, t) {
    return me(async (n) => {
      const i = await this.run();
      try {
        return await n.liftEither(i.bimap(e, t));
      } catch (s) {
        throw await s;
      }
    });
  }
  map(e) {
    return me((t) => this.runPromise(t).then(e));
  }
  mapLeft(e) {
    return me(async (t) => {
      try {
        return await this.runPromise(t);
      } catch (n) {
        throw await e(n);
      }
    });
  }
  chain(e) {
    return me(async (t) => {
      const n = await this.runPromise(t);
      return t.fromPromise(e(n));
    });
  }
  chainLeft(e) {
    return me(async (t) => {
      try {
        return await this.runPromise(t);
      } catch (n) {
        return t.fromPromise(e(n));
      }
    });
  }
  toMaybeAsync() {
    return Br(async ({ liftMaybe: e }) => {
      const t = await this.run();
      return e(t.toMaybe());
    });
  }
  swap() {
    return me(async (e) => {
      const t = await this.run();
      return t.isRight() && e.throwE(t.extract()), e.liftEither(te(t.extract()));
    });
  }
  ifLeft(e) {
    return me(async (t) => {
      const n = await this.run();
      return n.ifLeft(e), t.liftEither(n);
    });
  }
  ifRight(e) {
    return me(async (t) => {
      const n = await this.run();
      return n.ifRight(e), t.liftEither(n);
    });
  }
  void() {
    return this.map((e) => {
    });
  }
  caseOf(e) {
    return this.run().then((t) => t.caseOf(e));
  }
  finally(e) {
    return me(({ fromPromise: t }) => t(this.run().finally(e)));
  }
}
FB = Symbol.toStringTag;
const me = Object.assign((r) => new VB(r), {
  fromPromise: (r) => me(({ fromPromise: e }) => e(r())),
  liftEither: (r) => me(({ liftEither: e }) => e(r)),
  lefts: (r) => Promise.all(r.map((e) => e.run())).then(Pt.lefts),
  rights: (r) => Promise.all(r.map((e) => e.run())).then(Pt.rights),
  sequence: (r) => me(async (e) => {
    let t = [];
    for await (const n of r) {
      if (n.isLeft())
        return e.liftEither(n);
      t.push(n.extract());
    }
    return e.liftEither(te(t));
  }),
  all: (r) => me.fromPromise(async () => Promise.all(r).then(Pt.sequence))
});
VB.prototype.constructor = me;
var zB;
const jB = {
  liftMaybe(r) {
    if (r.isJust())
      return Promise.resolve(r.extract());
    throw ve;
  },
  fromPromise(r) {
    return r.then(jB.liftMaybe);
  }
};
class HB {
  constructor(e) {
    this.runPromise = e, this[zB] = "MaybeAsync", this["fantasy-land/chain"] = this.chain, this["fantasy-land/filter"] = this.filter, this["fantasy-land/alt"] = this.alt;
  }
  orDefault(e) {
    return this.run().then((t) => t.orDefault(e));
  }
  join() {
    return Br(async (e) => {
      const t = await this.run();
      if (t.isJust()) {
        const n = await t.extract();
        return e.liftMaybe(n);
      }
      return e.liftMaybe(ve);
    });
  }
  ap(e) {
    return Br(async (t) => {
      const n = await e;
      if (n.isJust()) {
        const i = await this.run();
        return i.isJust() ? n.extract()(i.extract()) : t.liftMaybe(ve);
      }
      return t.liftMaybe(ve);
    });
  }
  alt(e) {
    return Br(async (t) => {
      const n = await this.run();
      if (n.isJust())
        return n.extract();
      {
        const i = await e;
        return t.liftMaybe(i);
      }
    });
  }
  extend(e) {
    return Br(async (t) => {
      const n = await this.run();
      if (n.isJust()) {
        const i = Br.liftMaybe(n);
        return t.liftMaybe(Le(e(i)));
      }
      return t.liftMaybe(ve);
    });
  }
  filter(e) {
    return Br(async (t) => {
      const n = await this.run();
      return t.liftMaybe(n.filter(e));
    });
  }
  async run() {
    try {
      return Le(await this.runPromise(jB));
    } catch {
      return ve;
    }
  }
  map(e) {
    return Br((t) => this.runPromise(t).then(e));
  }
  chain(e) {
    return Br(async (t) => {
      const n = await this.runPromise(t);
      return t.fromPromise(e(n));
    });
  }
  toEitherAsync(e) {
    return me(async ({ liftEither: t }) => {
      const n = await this.run();
      return t(n.toEither(e));
    });
  }
  ifJust(e) {
    return Br(async (t) => {
      const n = await this.run();
      return n.ifJust(e), t.liftMaybe(n);
    });
  }
  ifNothing(e) {
    return Br(async (t) => {
      const n = await this.run();
      return n.ifNothing(e), t.liftMaybe(n);
    });
  }
  void() {
    return this.map((e) => {
    });
  }
  caseOf(e) {
    return this.run().then((t) => t.caseOf(e));
  }
  finally(e) {
    return Br(({ fromPromise: t }) => t(this.run().finally(e)));
  }
  then(e, t) {
    return this.run().then(e, t);
  }
}
zB = Symbol.toStringTag;
const Br = Object.assign((r) => new HB(r), {
  catMaybes: (r) => Promise.all(r).then(pe.catMaybes),
  fromPromise: (r) => Br(({ fromPromise: e }) => e(r())),
  liftMaybe: (r) => Br(({ liftMaybe: e }) => e(r))
});
HB.prototype.constructor = Br;
function O5() {
  if (typeof globalThis < "u")
    return globalThis;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
}
function $5() {
  const r = O5();
  if (r.__xstate__)
    return r.__xstate__;
}
const R5 = (r) => {
  if (typeof window > "u")
    return;
  const e = $5();
  e && e.register(r);
};
class gT {
  constructor(e) {
    this._process = e, this._active = !1, this._current = null, this._last = null;
  }
  start() {
    this._active = !0, this.flush();
  }
  clear() {
    this._current && (this._current.next = null, this._last = this._current);
  }
  enqueue(e) {
    const t = {
      value: e,
      next: null
    };
    if (this._current) {
      this._last.next = t, this._last = t;
      return;
    }
    this._current = t, this._last = t, this._active && this.flush();
  }
  flush() {
    for (; this._current; ) {
      const e = this._current;
      this._process(e.value), this._current = e.next;
    }
    this._last = null;
  }
}
const GB = ".", P5 = "", KB = "", N5 = "#", B5 = "*", qB = "xstate.init", L5 = "xstate.error", Lp = "xstate.stop";
function U5(r, e) {
  return {
    type: `xstate.after.${r}.${e}`
  };
}
function lS(r, e) {
  return {
    type: `xstate.done.state.${r}`,
    output: e
  };
}
function F5(r, e) {
  return {
    type: `xstate.done.actor.${r}`,
    output: e,
    actorId: r
  };
}
function WB(r, e) {
  return {
    type: `xstate.error.actor.${r}`,
    error: e,
    actorId: r
  };
}
function ZB(r) {
  return {
    type: qB,
    input: r
  };
}
function To(r) {
  setTimeout(() => {
    throw r;
  });
}
const M5 = typeof Symbol == "function" && Symbol.observable || "@@observable";
function JB(r, e) {
  const t = mT(r), n = mT(e);
  return typeof n == "string" ? typeof t == "string" ? n === t : !1 : typeof t == "string" ? t in n : Object.keys(t).every((i) => i in n ? JB(t[i], n[i]) : !1);
}
function a1(r) {
  if (YB(r))
    return r;
  const e = [];
  let t = "";
  for (let n = 0; n < r.length; n++) {
    switch (r.charCodeAt(n)) {
      // \
      case 92:
        t += r[n + 1], n++;
        continue;
      // .
      case 46:
        e.push(t), t = "";
        continue;
    }
    t += r[n];
  }
  return e.push(t), e;
}
function mT(r) {
  if (bV(r))
    return r.value;
  if (typeof r != "string")
    return r;
  const e = a1(r);
  return V5(e);
}
function V5(r) {
  if (r.length === 1)
    return r[0];
  const e = {};
  let t = e;
  for (let n = 0; n < r.length - 1; n++)
    if (n === r.length - 2)
      t[r[n]] = r[n + 1];
    else {
      const i = t;
      t = {}, i[r[n]] = t;
    }
  return e;
}
function yT(r, e) {
  const t = {}, n = Object.keys(r);
  for (let i = 0; i < n.length; i++) {
    const s = n[i];
    t[s] = e(r[s], s, r, i);
  }
  return t;
}
function XB(r) {
  return YB(r) ? r : [r];
}
function ec(r) {
  return r === void 0 ? [] : XB(r);
}
function dS(r, e, t, n) {
  return typeof r == "function" ? r({
    context: e,
    event: t,
    self: n
  }) : r;
}
function YB(r) {
  return Array.isArray(r);
}
function z5(r) {
  return r.type.startsWith("xstate.error.actor");
}
function Ml(r) {
  return XB(r).map((e) => typeof e > "u" || typeof e == "string" ? {
    target: e
  } : e);
}
function QB(r) {
  if (!(r === void 0 || r === P5))
    return ec(r);
}
function hS(r, e, t) {
  var s, o, a;
  const n = typeof r == "object", i = n ? r : void 0;
  return {
    next: (s = n ? r.next : r) == null ? void 0 : s.bind(i),
    error: (o = n ? r.error : e) == null ? void 0 : o.bind(i),
    complete: (a = n ? r.complete : t) == null ? void 0 : a.bind(i)
  };
}
function vT(r, e) {
  return `${e}.${r}`;
}
function c1(r, e) {
  const t = e.match(/^xstate\.invoke\.(\d+)\.(.*)/);
  if (!t)
    return r.implementations.actors[e];
  const [, n, i] = t, o = r.getStateNodeById(i).config.invoke;
  return (Array.isArray(o) ? o[n] : o).src;
}
function bT(r, e) {
  return `${r.sessionId}.${e}`;
}
let j5 = 0;
function H5(r, e) {
  const t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new WeakMap(), s = /* @__PURE__ */ new Set(), o = {}, {
    clock: a,
    logger: c
  } = e, u = {
    schedule: (f, p, y, g, v = Math.random().toString(36).slice(2)) => {
      const _ = {
        source: f,
        target: p,
        event: y,
        delay: g,
        id: v,
        startedAt: Date.now()
      }, w = bT(f, v);
      d._snapshot._scheduledEvents[w] = _;
      const E = a.setTimeout(() => {
        delete o[w], delete d._snapshot._scheduledEvents[w], d._relay(f, p, y);
      }, g);
      o[w] = E;
    },
    cancel: (f, p) => {
      const y = bT(f, p), g = o[y];
      delete o[y], delete d._snapshot._scheduledEvents[y], g !== void 0 && a.clearTimeout(g);
    },
    cancelAll: (f) => {
      for (const p in d._snapshot._scheduledEvents) {
        const y = d._snapshot._scheduledEvents[p];
        y.source === f && u.cancel(f, y.id);
      }
    }
  }, l = (f) => {
    if (!s.size)
      return;
    const p = {
      ...f,
      rootId: r.sessionId
    };
    s.forEach((y) => {
      var g;
      return (g = y.next) == null ? void 0 : g.call(y, p);
    });
  }, d = {
    _snapshot: {
      _scheduledEvents: ((e == null ? void 0 : e.snapshot) && e.snapshot.scheduler) ?? {}
    },
    _bookId: () => `x:${j5++}`,
    _register: (f, p) => (t.set(f, p), f),
    _unregister: (f) => {
      t.delete(f.sessionId);
      const p = i.get(f);
      p !== void 0 && (n.delete(p), i.delete(f));
    },
    get: (f) => n.get(f),
    _set: (f, p) => {
      const y = n.get(f);
      if (y && y !== p)
        throw new Error(`Actor with system ID '${f}' already exists.`);
      n.set(f, p), i.set(p, f);
    },
    inspect: (f) => {
      const p = hS(f);
      return s.add(p), {
        unsubscribe() {
          s.delete(p);
        }
      };
    },
    _sendInspectionEvent: l,
    _relay: (f, p, y) => {
      d._sendInspectionEvent({
        type: "@xstate.event",
        sourceRef: f,
        actorRef: p,
        event: y
      }), p._send(y);
    },
    scheduler: u,
    getSnapshot: () => ({
      _scheduledEvents: {
        ...d._snapshot._scheduledEvents
      }
    }),
    start: () => {
      const f = d._snapshot._scheduledEvents;
      d._snapshot._scheduledEvents = {};
      for (const p in f) {
        const {
          source: y,
          target: g,
          event: v,
          delay: _,
          id: w
        } = f[p];
        u.schedule(y, g, v, _, w);
      }
    },
    _clock: a,
    _logger: c
  };
  return d;
}
let Tb = !1;
const u1 = 1;
let Un = /* @__PURE__ */ (function(r) {
  return r[r.NotStarted = 0] = "NotStarted", r[r.Running = 1] = "Running", r[r.Stopped = 2] = "Stopped", r;
})({});
const G5 = {
  clock: {
    setTimeout: (r, e) => setTimeout(r, e),
    clearTimeout: (r) => clearTimeout(r)
  },
  logger: console.log.bind(console),
  devTools: !1
};
class K5 {
  /**
   * Creates a new actor instance for the given logic with the provided options,
   * if any.
   *
   * @param logic The logic to create an actor from
   * @param options Actor options
   */
  constructor(e, t) {
    this.logic = e, this._snapshot = void 0, this.clock = void 0, this.options = void 0, this.id = void 0, this.mailbox = new gT(this._process.bind(this)), this.observers = /* @__PURE__ */ new Set(), this.eventListeners = /* @__PURE__ */ new Map(), this.logger = void 0, this._processingStatus = Un.NotStarted, this._parent = void 0, this._syncSnapshot = void 0, this.ref = void 0, this._actorScope = void 0, this._systemId = void 0, this.sessionId = void 0, this.system = void 0, this._doneEvent = void 0, this.src = void 0, this._deferred = [];
    const n = {
      ...G5,
      ...t
    }, {
      clock: i,
      logger: s,
      parent: o,
      syncSnapshot: a,
      id: c,
      systemId: u,
      inspect: l
    } = n;
    this.system = o ? o.system : H5(this, {
      clock: i,
      logger: s
    }), l && !o && this.system.inspect(hS(l)), this.sessionId = this.system._bookId(), this.id = c ?? this.sessionId, this.logger = (t == null ? void 0 : t.logger) ?? this.system._logger, this.clock = (t == null ? void 0 : t.clock) ?? this.system._clock, this._parent = o, this._syncSnapshot = a, this.options = n, this.src = n.src ?? e, this.ref = this, this._actorScope = {
      self: this,
      id: this.id,
      sessionId: this.sessionId,
      logger: this.logger,
      defer: (d) => {
        this._deferred.push(d);
      },
      system: this.system,
      stopChild: (d) => {
        if (d._parent !== this)
          throw new Error(`Cannot stop child actor ${d.id} of ${this.id} because it is not a child`);
        d._stop();
      },
      emit: (d) => {
        const f = this.eventListeners.get(d.type), p = this.eventListeners.get("*");
        if (!f && !p)
          return;
        const y = [...f ? f.values() : [], ...p ? p.values() : []];
        for (const g of y)
          g(d);
      },
      actionExecutor: (d) => {
        const f = () => {
          if (this._actorScope.system._sendInspectionEvent({
            type: "@xstate.action",
            actorRef: this,
            action: {
              type: d.type,
              params: d.params
            }
          }), !d.exec)
            return;
          const p = Tb;
          try {
            Tb = !0, d.exec(d.info, d.params);
          } finally {
            Tb = p;
          }
        };
        this._processingStatus === Un.Running ? f() : this._deferred.push(f);
      }
    }, this.send = this.send.bind(this), this.system._sendInspectionEvent({
      type: "@xstate.actor",
      actorRef: this
    }), u && (this._systemId = u, this.system._set(u, this)), this._initState((t == null ? void 0 : t.snapshot) ?? (t == null ? void 0 : t.state)), u && this._snapshot.status !== "active" && this.system._unregister(this);
  }
  _initState(e) {
    var t;
    try {
      this._snapshot = e ? this.logic.restoreSnapshot ? this.logic.restoreSnapshot(e, this._actorScope) : e : this.logic.getInitialSnapshot(this._actorScope, (t = this.options) == null ? void 0 : t.input);
    } catch (n) {
      this._snapshot = {
        status: "error",
        output: void 0,
        error: n
      };
    }
  }
  update(e, t) {
    var i, s;
    this._snapshot = e;
    let n;
    for (; n = this._deferred.shift(); )
      try {
        n();
      } catch (o) {
        this._deferred.length = 0, this._snapshot = {
          ...e,
          status: "error",
          error: o
        };
      }
    switch (this._snapshot.status) {
      case "active":
        for (const o of this.observers)
          try {
            (i = o.next) == null || i.call(o, e);
          } catch (a) {
            To(a);
          }
        break;
      case "done":
        for (const o of this.observers)
          try {
            (s = o.next) == null || s.call(o, e);
          } catch (a) {
            To(a);
          }
        this._stopProcedure(), this._complete(), this._doneEvent = F5(this.id, this._snapshot.output), this._parent && this.system._relay(this, this._parent, this._doneEvent);
        break;
      case "error":
        this._error(this._snapshot.error);
        break;
    }
    this.system._sendInspectionEvent({
      type: "@xstate.snapshot",
      actorRef: this,
      event: t,
      snapshot: e
    });
  }
  /**
   * Subscribe an observer to an actors snapshot values.
   *
   * @remarks
   * The observer will receive the actors snapshot value when it is emitted.
   * The observer can be:
   *
   * - A plain function that receives the latest snapshot, or
   * - An observer object whose `.next(snapshot)` method receives the latest
   *   snapshot
   *
   * @example
   *
   * ```ts
   * // Observer as a plain function
   * const subscription = actor.subscribe((snapshot) => {
   *   console.log(snapshot);
   * });
   * ```
   *
   * @example
   *
   * ```ts
   * // Observer as an object
   * const subscription = actor.subscribe({
   *   next(snapshot) {
   *     console.log(snapshot);
   *   },
   *   error(err) {
   *     // ...
   *   },
   *   complete() {
   *     // ...
   *   }
   * });
   * ```
   *
   * The return value of `actor.subscribe(observer)` is a subscription object
   * that has an `.unsubscribe()` method. You can call
   * `subscription.unsubscribe()` to unsubscribe the observer:
   *
   * @example
   *
   * ```ts
   * const subscription = actor.subscribe((snapshot) => {
   *   // ...
   * });
   *
   * // Unsubscribe the observer
   * subscription.unsubscribe();
   * ```
   *
   * When the actor is stopped, all of its observers will automatically be
   * unsubscribed.
   *
   * @param observer - Either a plain function that receives the latest
   *   snapshot, or an observer object whose `.next(snapshot)` method receives
   *   the latest snapshot
   */
  subscribe(e, t, n) {
    var s;
    const i = hS(e, t, n);
    if (this._processingStatus !== Un.Stopped)
      this.observers.add(i);
    else
      switch (this._snapshot.status) {
        case "done":
          try {
            (s = i.complete) == null || s.call(i);
          } catch (o) {
            To(o);
          }
          break;
        case "error": {
          const o = this._snapshot.error;
          if (!i.error)
            To(o);
          else
            try {
              i.error(o);
            } catch (a) {
              To(a);
            }
          break;
        }
      }
    return {
      unsubscribe: () => {
        this.observers.delete(i);
      }
    };
  }
  on(e, t) {
    let n = this.eventListeners.get(e);
    n || (n = /* @__PURE__ */ new Set(), this.eventListeners.set(e, n));
    const i = t.bind(void 0);
    return n.add(i), {
      unsubscribe: () => {
        n.delete(i);
      }
    };
  }
  /** Starts the Actor from the initial state */
  start() {
    if (this._processingStatus === Un.Running)
      return this;
    this._syncSnapshot && this.subscribe({
      next: (n) => {
        n.status === "active" && this.system._relay(this, this._parent, {
          type: `xstate.snapshot.${this.id}`,
          snapshot: n
        });
      },
      error: () => {
      }
    }), this.system._register(this.sessionId, this), this._systemId && this.system._set(this._systemId, this), this._processingStatus = Un.Running;
    const e = ZB(this.options.input);
    switch (this.system._sendInspectionEvent({
      type: "@xstate.event",
      sourceRef: this._parent,
      actorRef: this,
      event: e
    }), this._snapshot.status) {
      case "done":
        return this.update(this._snapshot, e), this;
      case "error":
        return this._error(this._snapshot.error), this;
    }
    if (this._parent || this.system.start(), this.logic.start)
      try {
        this.logic.start(this._snapshot, this._actorScope);
      } catch (n) {
        return this._snapshot = {
          ...this._snapshot,
          status: "error",
          error: n
        }, this._error(n), this;
      }
    return this.update(this._snapshot, e), this.options.devTools && this.attachDevTools(), this.mailbox.start(), this;
  }
  _process(e) {
    let t, n;
    try {
      t = this.logic.transition(this._snapshot, e, this._actorScope);
    } catch (i) {
      n = {
        err: i
      };
    }
    if (n) {
      const {
        err: i
      } = n;
      this._snapshot = {
        ...this._snapshot,
        status: "error",
        error: i
      }, this._error(i);
      return;
    }
    this.update(t, e), e.type === Lp && (this._stopProcedure(), this._complete());
  }
  _stop() {
    return this._processingStatus === Un.Stopped ? this : (this.mailbox.clear(), this._processingStatus === Un.NotStarted ? (this._processingStatus = Un.Stopped, this) : (this.mailbox.enqueue({
      type: Lp
    }), this));
  }
  /** Stops the Actor and unsubscribe all listeners. */
  stop() {
    if (this._parent)
      throw new Error("A non-root actor cannot be stopped directly.");
    return this._stop();
  }
  _complete() {
    var e;
    for (const t of this.observers)
      try {
        (e = t.complete) == null || e.call(t);
      } catch (n) {
        To(n);
      }
    this.observers.clear();
  }
  _reportError(e) {
    if (!this.observers.size) {
      this._parent || To(e);
      return;
    }
    let t = !1;
    for (const n of this.observers) {
      const i = n.error;
      t || (t = !i);
      try {
        i == null || i(e);
      } catch (s) {
        To(s);
      }
    }
    this.observers.clear(), t && To(e);
  }
  _error(e) {
    this._stopProcedure(), this._reportError(e), this._parent && this.system._relay(this, this._parent, WB(this.id, e));
  }
  // TODO: atm children don't belong entirely to the actor so
  // in a way - it's not even super aware of them
  // so we can't stop them from here but we really should!
  // right now, they are being stopped within the machine's transition
  // but that could throw and leave us with "orphaned" active actors
  _stopProcedure() {
    return this._processingStatus !== Un.Running ? this : (this.system.scheduler.cancelAll(this), this.mailbox.clear(), this.mailbox = new gT(this._process.bind(this)), this._processingStatus = Un.Stopped, this.system._unregister(this), this);
  }
  /** @internal */
  _send(e) {
    this._processingStatus !== Un.Stopped && this.mailbox.enqueue(e);
  }
  /**
   * Sends an event to the running Actor to trigger a transition.
   *
   * @param event The event to send
   */
  send(e) {
    this.system._relay(void 0, this, e);
  }
  attachDevTools() {
    const {
      devTools: e
    } = this.options;
    e && (typeof e == "function" ? e : R5)(this);
  }
  toJSON() {
    return {
      xstate$$type: u1,
      id: this.id
    };
  }
  /**
   * Obtain the internal state of the actor, which can be persisted.
   *
   * @remarks
   * The internal state can be persisted from any actor, not only machines.
   *
   * Note that the persisted state is not the same as the snapshot from
   * {@link Actor.getSnapshot}. Persisted state represents the internal state of
   * the actor, while snapshots represent the actor's last emitted value.
   *
   * Can be restored with {@link ActorOptions.state}
   * @see https://stately.ai/docs/persistence
   */
  getPersistedSnapshot(e) {
    return this.logic.getPersistedSnapshot(this._snapshot, e);
  }
  [M5]() {
    return this;
  }
  /**
   * Read an actors snapshot synchronously.
   *
   * @remarks
   * The snapshot represent an actor's last emitted value.
   *
   * When an actor receives an event, its internal state may change. An actor
   * may emit a snapshot when a state transition occurs.
   *
   * Note that some actors, such as callback actors generated with
   * `fromCallback`, will not emit snapshots.
   * @see {@link Actor.subscribe} to subscribe to an actors snapshot values.
   * @see {@link Actor.getPersistedSnapshot} to persist the internal state of an actor (which is more than just a snapshot).
   */
  getSnapshot() {
    return this._snapshot;
  }
}
function Gu(r, ...[e]) {
  return new K5(r, e);
}
function q5(r, e, t, n, {
  sendId: i
}) {
  const s = typeof i == "function" ? i(t, n) : i;
  return [e, {
    sendId: s
  }, void 0];
}
function W5(r, e) {
  r.defer(() => {
    r.system.scheduler.cancel(r.self, e.sendId);
  });
}
function eL(r) {
  function e(t, n) {
  }
  return e.type = "xstate.cancel", e.sendId = r, e.resolve = q5, e.execute = W5, e;
}
function Z5(r, e, t, n, {
  id: i,
  systemId: s,
  src: o,
  input: a,
  syncSnapshot: c
}) {
  const u = typeof o == "string" ? c1(e.machine, o) : o, l = typeof i == "function" ? i(t) : i;
  let d, f;
  return u && (f = typeof a == "function" ? a({
    context: e.context,
    event: t.event,
    self: r.self
  }) : a, d = Gu(u, {
    id: l,
    src: o,
    parent: r.self,
    syncSnapshot: c,
    systemId: s,
    input: f
  })), [Ku(e, {
    children: {
      ...e.children,
      [l]: d
    }
  }), {
    id: i,
    systemId: s,
    actorRef: d,
    src: o,
    input: f
  }, void 0];
}
function J5(r, {
  actorRef: e
}) {
  e && r.defer(() => {
    e._processingStatus !== Un.Stopped && e.start();
  });
}
function tL(...[r, {
  id: e,
  systemId: t,
  input: n,
  syncSnapshot: i = !1
} = {}]) {
  function s(o, a) {
  }
  return s.type = "xstate.spawnChild", s.id = e, s.systemId = t, s.src = r, s.input = n, s.syncSnapshot = i, s.resolve = Z5, s.execute = J5, s;
}
function X5(r, e, t, n, {
  actorRef: i
}) {
  const s = typeof i == "function" ? i(t, n) : i, o = typeof s == "string" ? e.children[s] : s;
  let a = e.children;
  return o && (a = {
    ...a
  }, delete a[o.id]), [Ku(e, {
    children: a
  }), o, void 0];
}
function Y5(r, e) {
  if (e) {
    if (r.system._unregister(e), e._processingStatus !== Un.Running) {
      r.stopChild(e);
      return;
    }
    r.defer(() => {
      r.stopChild(e);
    });
  }
}
function l1(r) {
  function e(t, n) {
  }
  return e.type = "xstate.stopChild", e.actorRef = r, e.resolve = X5, e.execute = Y5, e;
}
function Q5(r, {
  context: e,
  event: t
}, {
  guards: n
}) {
  return n.every((i) => zg(i, e, t, r));
}
function rL(r) {
  function e(t, n) {
    return !1;
  }
  return e.check = Q5, e.guards = r, e;
}
function zg(r, e, t, n) {
  const {
    machine: i
  } = n, s = typeof r == "function", o = s ? r : i.implementations.guards[typeof r == "string" ? r : r.type];
  if (!s && !o)
    throw new Error(`Guard '${typeof r == "string" ? r : r.type}' is not implemented.'.`);
  if (typeof o != "function")
    return zg(o, e, t, n);
  const a = {
    context: e,
    event: t
  }, c = s || typeof r == "string" ? void 0 : "params" in r ? typeof r.params == "function" ? r.params({
    context: e,
    event: t
  }) : r.params : void 0;
  return "check" in o ? o.check(
    n,
    a,
    o
    // this holds all params
  ) : o(a, c);
}
const d1 = (r) => r.type === "atomic" || r.type === "final";
function $h(r) {
  return Object.values(r.states).filter((e) => e.type !== "history");
}
function jg(r, e) {
  const t = [];
  if (e === r)
    return t;
  let n = r.parent;
  for (; n && n !== e; )
    t.push(n), n = n.parent;
  return t;
}
function Oy(r) {
  const e = new Set(r), t = iL(e);
  for (const n of e)
    if (n.type === "compound" && (!t.get(n) || !t.get(n).length))
      wT(n).forEach((i) => e.add(i));
    else if (n.type === "parallel") {
      for (const i of $h(n))
        if (i.type !== "history" && !e.has(i)) {
          const s = wT(i);
          for (const o of s)
            e.add(o);
        }
    }
  for (const n of e) {
    let i = n.parent;
    for (; i; )
      e.add(i), i = i.parent;
  }
  return e;
}
function nL(r, e) {
  const t = e.get(r);
  if (!t)
    return {};
  if (r.type === "compound") {
    const i = t[0];
    if (i) {
      if (d1(i))
        return i.key;
    } else
      return {};
  }
  const n = {};
  for (const i of t)
    n[i.key] = nL(i, e);
  return n;
}
function iL(r) {
  const e = /* @__PURE__ */ new Map();
  for (const t of r)
    e.has(t) || e.set(t, []), t.parent && (e.has(t.parent) || e.set(t.parent, []), e.get(t.parent).push(t));
  return e;
}
function sL(r, e) {
  const t = Oy(e);
  return nL(r, iL(t));
}
function h1(r, e) {
  return e.type === "compound" ? $h(e).some((t) => t.type === "final" && r.has(t)) : e.type === "parallel" ? $h(e).every((t) => h1(r, t)) : e.type === "final";
}
const Tv = (r) => r[0] === N5;
function eV(r, e) {
  return r.transitions.get(e) || [...r.transitions.keys()].filter((n) => {
    if (n === B5)
      return !0;
    if (!n.endsWith(".*"))
      return !1;
    const i = n.split("."), s = e.split(".");
    for (let o = 0; o < i.length; o++) {
      const a = i[o], c = s[o];
      if (a === "*")
        return o === i.length - 1;
      if (a !== c)
        return !1;
    }
    return !0;
  }).sort((n, i) => i.length - n.length).flatMap((n) => r.transitions.get(n));
}
function tV(r) {
  const e = r.config.after;
  if (!e)
    return [];
  const t = (i) => {
    const s = U5(i, r.id), o = s.type;
    return r.entry.push(fL(s, {
      id: o,
      delay: i
    })), r.exit.push(eL(o)), o;
  };
  return Object.keys(e).flatMap((i) => {
    const s = e[i], o = typeof s == "string" ? {
      target: s
    } : s, a = Number.isNaN(+i) ? i : +i, c = t(a);
    return ec(o).map((u) => ({
      ...u,
      event: c,
      delay: a
    }));
  }).map((i) => {
    const {
      delay: s
    } = i;
    return {
      ...jc(r, i.event, i),
      delay: s
    };
  });
}
function jc(r, e, t) {
  const n = QB(t.target), i = t.reenter ?? !1, s = iV(r, n), o = {
    ...t,
    actions: ec(t.actions),
    guard: t.guard,
    target: s,
    source: r,
    reenter: i,
    eventType: e,
    toJSON: () => ({
      ...o,
      source: `#${r.id}`,
      target: s ? s.map((a) => `#${a.id}`) : void 0
    })
  };
  return o;
}
function rV(r) {
  const e = /* @__PURE__ */ new Map();
  if (r.config.on)
    for (const t of Object.keys(r.config.on)) {
      if (t === KB)
        throw new Error('Null events ("") cannot be specified as a transition key. Use `always: { ... }` instead.');
      const n = r.config.on[t];
      e.set(t, Ml(n).map((i) => jc(r, t, i)));
    }
  if (r.config.onDone) {
    const t = `xstate.done.state.${r.id}`;
    e.set(t, Ml(r.config.onDone).map((n) => jc(r, t, n)));
  }
  for (const t of r.invoke) {
    if (t.onDone) {
      const n = `xstate.done.actor.${t.id}`;
      e.set(n, Ml(t.onDone).map((i) => jc(r, n, i)));
    }
    if (t.onError) {
      const n = `xstate.error.actor.${t.id}`;
      e.set(n, Ml(t.onError).map((i) => jc(r, n, i)));
    }
    if (t.onSnapshot) {
      const n = `xstate.snapshot.${t.id}`;
      e.set(n, Ml(t.onSnapshot).map((i) => jc(r, n, i)));
    }
  }
  for (const t of r.after) {
    let n = e.get(t.eventType);
    n || (n = [], e.set(t.eventType, n)), n.push(t);
  }
  return e;
}
function nV(r, e) {
  const t = typeof e == "string" ? r.states[e] : e ? r.states[e.target] : void 0;
  if (!t && e)
    throw new Error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-base-to-string
      `Initial state node "${e}" not found on parent state node #${r.id}`
    );
  const n = {
    source: r,
    actions: !e || typeof e == "string" ? [] : ec(e.actions),
    eventType: null,
    reenter: !1,
    target: t ? [t] : [],
    toJSON: () => ({
      ...n,
      source: `#${r.id}`,
      target: t ? [`#${t.id}`] : []
    })
  };
  return n;
}
function iV(r, e) {
  if (e !== void 0)
    return e.map((t) => {
      if (typeof t != "string")
        return t;
      if (Tv(t))
        return r.machine.getStateNodeById(t);
      const n = t[0] === GB;
      if (n && !r.parent)
        return $y(r, t.slice(1));
      const i = n ? r.key + t : t;
      if (r.parent)
        try {
          return $y(r.parent, i);
        } catch (s) {
          throw new Error(`Invalid transition definition for state node '${r.id}':
${s.message}`);
        }
      else
        throw new Error(`Invalid target: "${t}" is not a valid target from the root node. Did you mean ".${t}"?`);
    });
}
function oL(r) {
  const e = QB(r.config.target);
  return e ? {
    target: e.map((t) => typeof t == "string" ? $y(r.parent, t) : t)
  } : r.parent.initial;
}
function Zc(r) {
  return r.type === "history";
}
function wT(r) {
  const e = aL(r);
  for (const t of e)
    for (const n of jg(t, r))
      e.add(n);
  return e;
}
function aL(r) {
  const e = /* @__PURE__ */ new Set();
  function t(n) {
    if (!e.has(n)) {
      if (e.add(n), n.type === "compound")
        t(n.initial.target[0]);
      else if (n.type === "parallel")
        for (const i of $h(n))
          t(i);
    }
  }
  return t(r), e;
}
function Rh(r, e) {
  if (Tv(e))
    return r.machine.getStateNodeById(e);
  if (!r.states)
    throw new Error(`Unable to retrieve child state '${e}' from '${r.id}'; no child states exist.`);
  const t = r.states[e];
  if (!t)
    throw new Error(`Child state '${e}' does not exist on '${r.id}'`);
  return t;
}
function $y(r, e) {
  if (typeof e == "string" && Tv(e))
    try {
      return r.machine.getStateNodeById(e);
    } catch {
    }
  const t = a1(e).slice();
  let n = r;
  for (; t.length; ) {
    const i = t.shift();
    if (!i.length)
      break;
    n = Rh(n, i);
  }
  return n;
}
function Ry(r, e) {
  if (typeof e == "string") {
    const i = r.states[e];
    if (!i)
      throw new Error(`State '${e}' does not exist on '${r.id}'`);
    return [r, i];
  }
  const t = Object.keys(e), n = t.map((i) => Rh(r, i)).filter(Boolean);
  return [r.machine.root, r].concat(n, t.reduce((i, s) => {
    const o = Rh(r, s);
    if (!o)
      return i;
    const a = Ry(o, e[s]);
    return i.concat(a);
  }, []));
}
function sV(r, e, t, n) {
  const s = Rh(r, e).next(t, n);
  return !s || !s.length ? r.next(t, n) : s;
}
function oV(r, e, t, n) {
  const i = Object.keys(e), s = Rh(r, i[0]), o = f1(s, e[i[0]], t, n);
  return !o || !o.length ? r.next(t, n) : o;
}
function aV(r, e, t, n) {
  const i = [];
  for (const s of Object.keys(e)) {
    const o = e[s];
    if (!o)
      continue;
    const a = Rh(r, s), c = f1(a, o, t, n);
    c && i.push(...c);
  }
  return i.length ? i : r.next(t, n);
}
function f1(r, e, t, n) {
  return typeof e == "string" ? sV(r, e, t, n) : Object.keys(e).length === 1 ? oV(r, e, t, n) : aV(r, e, t, n);
}
function cV(r) {
  return Object.keys(r.states).map((e) => r.states[e]).filter((e) => e.type === "history");
}
function pc(r, e) {
  let t = r;
  for (; t.parent && t.parent !== e; )
    t = t.parent;
  return t.parent === e;
}
function uV(r, e) {
  const t = new Set(r), n = new Set(e);
  for (const i of t)
    if (n.has(i))
      return !0;
  for (const i of n)
    if (t.has(i))
      return !0;
  return !1;
}
function cL(r, e, t) {
  const n = /* @__PURE__ */ new Set();
  for (const i of r) {
    let s = !1;
    const o = /* @__PURE__ */ new Set();
    for (const a of n)
      if (uV(fS([i], e, t), fS([a], e, t)))
        if (pc(i.source, a.source))
          o.add(a);
        else {
          s = !0;
          break;
        }
    if (!s) {
      for (const a of o)
        n.delete(a);
      n.add(i);
    }
  }
  return Array.from(n);
}
function lV(r) {
  const [e, ...t] = r;
  for (const n of jg(e, void 0))
    if (t.every((i) => pc(i, n)))
      return n;
}
function p1(r, e) {
  if (!r.target)
    return [];
  const t = /* @__PURE__ */ new Set();
  for (const n of r.target)
    if (Zc(n))
      if (e[n.id])
        for (const i of e[n.id])
          t.add(i);
      else
        for (const i of p1(oL(n), e))
          t.add(i);
    else
      t.add(n);
  return [...t];
}
function uL(r, e) {
  const t = p1(r, e);
  if (!t)
    return;
  if (!r.reenter && t.every((i) => i === r.source || pc(i, r.source)))
    return r.source;
  const n = lV(t.concat(r.source));
  if (n)
    return n;
  if (!r.reenter)
    return r.source.machine.root;
}
function fS(r, e, t) {
  var i;
  const n = /* @__PURE__ */ new Set();
  for (const s of r)
    if ((i = s.target) != null && i.length) {
      const o = uL(s, t);
      s.reenter && s.source === o && n.add(o);
      for (const a of e)
        pc(a, o) && n.add(a);
    }
  return [...n];
}
function dV(r, e) {
  if (r.length !== e.size)
    return !1;
  for (const t of r)
    if (!e.has(t))
      return !1;
  return !0;
}
function pS(r, e, t, n, i, s) {
  if (!r.length)
    return e;
  const o = new Set(e._nodes);
  let a = e.historyValue;
  const c = cL(r, o, a);
  let u = e;
  i || ([u, a] = gV(u, n, t, c, o, a, s, t.actionExecutor)), u = Ph(u, n, t, c.flatMap((d) => d.actions), s, void 0), u = fV(u, n, t, c, o, s, a, i);
  const l = [...o];
  u.status === "done" && (u = Ph(u, n, t, l.sort((d, f) => f.order - d.order).flatMap((d) => d.exit), s, void 0));
  try {
    return a === e.historyValue && dV(e._nodes, o) ? u : Ku(u, {
      _nodes: l,
      historyValue: a
    });
  } catch (d) {
    throw d;
  }
}
function hV(r, e, t, n, i) {
  if (n.output === void 0)
    return;
  const s = lS(i.id, i.output !== void 0 && i.parent ? dS(i.output, r.context, e, t.self) : void 0);
  return dS(n.output, r.context, s, t.self);
}
function fV(r, e, t, n, i, s, o, a) {
  let c = r;
  const u = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Set();
  pV(n, o, l, u), a && l.add(r.machine.root);
  const d = /* @__PURE__ */ new Set();
  for (const f of [...u].sort((p, y) => p.order - y.order)) {
    i.add(f);
    const p = [];
    p.push(...f.entry);
    for (const y of f.invoke)
      p.push(tL(y.src, {
        ...y,
        syncSnapshot: !!y.onSnapshot
      }));
    if (l.has(f)) {
      const y = f.initial.actions;
      p.push(...y);
    }
    if (c = Ph(c, e, t, p, s, f.invoke.map((y) => y.id)), f.type === "final") {
      const y = f.parent;
      let g = (y == null ? void 0 : y.type) === "parallel" ? y : y == null ? void 0 : y.parent, v = g || f;
      for ((y == null ? void 0 : y.type) === "compound" && s.push(lS(y.id, f.output !== void 0 ? dS(f.output, c.context, e, t.self) : void 0)); (g == null ? void 0 : g.type) === "parallel" && !d.has(g) && h1(i, g); )
        d.add(g), s.push(lS(g.id)), v = g, g = g.parent;
      if (g)
        continue;
      c = Ku(c, {
        status: "done",
        output: hV(c, e, t, c.machine.root, v)
      });
    }
  }
  return c;
}
function pV(r, e, t, n) {
  for (const i of r) {
    const s = uL(i, e);
    for (const a of i.target || [])
      !Zc(a) && // if the target is different than the source then it will *definitely* be entered
      (i.source !== a || // we know that the domain can't lie within the source
      // if it's different than the source then it's outside of it and it means that the target has to be entered as well
      i.source !== s || // reentering transitions always enter the target, even if it's the source itself
      i.reenter) && (n.add(a), t.add(a)), Zl(a, e, t, n);
    const o = p1(i, e);
    for (const a of o) {
      const c = jg(a, s);
      (s == null ? void 0 : s.type) === "parallel" && c.push(s), lL(n, e, t, c, !i.source.parent && i.reenter ? void 0 : s);
    }
  }
}
function Zl(r, e, t, n) {
  var i;
  if (Zc(r))
    if (e[r.id]) {
      const s = e[r.id];
      for (const o of s)
        n.add(o), Zl(o, e, t, n);
      for (const o of s)
        kb(o, r.parent, n, e, t);
    } else {
      const s = oL(r);
      for (const o of s.target)
        n.add(o), s === ((i = r.parent) == null ? void 0 : i.initial) && t.add(r.parent), Zl(o, e, t, n);
      for (const o of s.target)
        kb(o, r.parent, n, e, t);
    }
  else if (r.type === "compound") {
    const [s] = r.initial.target;
    Zc(s) || (n.add(s), t.add(s)), Zl(s, e, t, n), kb(s, r, n, e, t);
  } else if (r.type === "parallel")
    for (const s of $h(r).filter((o) => !Zc(o)))
      [...n].some((o) => pc(o, s)) || (Zc(s) || (n.add(s), t.add(s)), Zl(s, e, t, n));
}
function lL(r, e, t, n, i) {
  for (const s of n)
    if ((!i || pc(s, i)) && r.add(s), s.type === "parallel")
      for (const o of $h(s).filter((a) => !Zc(a)))
        [...r].some((a) => pc(a, o)) || (r.add(o), Zl(o, e, t, r));
}
function kb(r, e, t, n, i) {
  lL(t, n, i, jg(r, e));
}
function gV(r, e, t, n, i, s, o, a) {
  let c = r;
  const u = fS(n, i, s);
  u.sort((d, f) => f.order - d.order);
  let l;
  for (const d of u)
    for (const f of cV(d)) {
      let p;
      f.history === "deep" ? p = (y) => d1(y) && pc(y, d) : p = (y) => y.parent === d, l ?? (l = {
        ...s
      }), l[f.id] = Array.from(i).filter(p);
    }
  for (const d of u)
    c = Ph(c, e, t, [...d.exit, ...d.invoke.map((f) => l1(f.id))], o, void 0), i.delete(d);
  return [c, l || s];
}
function mV(r, e) {
  return r.implementations.actions[e];
}
function dL(r, e, t, n, i, s) {
  const {
    machine: o
  } = r;
  let a = r;
  for (const c of n) {
    const u = typeof c == "function", l = u ? c : (
      // the existing type of `.actions` assumes non-nullable `TExpressionAction`
      // it's fine to cast this here to get a common type and lack of errors in the rest of the code
      // our logic below makes sure that we call those 2 "variants" correctly
      mV(o, typeof c == "string" ? c : c.type)
    ), d = {
      context: a.context,
      event: e,
      self: t.self,
      system: t.system
    }, f = u || typeof c == "string" ? void 0 : "params" in c ? typeof c.params == "function" ? c.params({
      context: a.context,
      event: e
    }) : c.params : void 0;
    if (!l || !("resolve" in l)) {
      t.actionExecutor({
        type: typeof c == "string" ? c : typeof c == "object" ? c.type : c.name || "(anonymous)",
        info: d,
        params: f,
        exec: l
      });
      continue;
    }
    const p = l, [y, g, v] = p.resolve(
      t,
      a,
      d,
      f,
      l,
      // this holds all params
      i
    );
    a = y, "retryResolve" in p && (s == null || s.push([p, g])), "execute" in p && t.actionExecutor({
      type: p.type,
      info: d,
      params: g,
      exec: p.execute.bind(null, t, g)
    }), v && (a = dL(a, e, t, v, i, s));
  }
  return a;
}
function Ph(r, e, t, n, i, s) {
  const o = s ? [] : void 0, a = dL(r, e, t, n, {
    internalQueue: i,
    deferredActorIds: s
  }, o);
  return o == null || o.forEach(([c, u]) => {
    c.retryResolve(t, a, u);
  }), a;
}
function Ob(r, e, t, n) {
  let i = r;
  const s = [];
  function o(u, l, d) {
    t.system._sendInspectionEvent({
      type: "@xstate.microstep",
      actorRef: t.self,
      event: l,
      snapshot: u,
      _transitions: d
    }), s.push(u);
  }
  if (e.type === Lp)
    return i = Ku(_T(i, e, t), {
      status: "stopped"
    }), o(i, e, []), {
      snapshot: i,
      microstates: s
    };
  let a = e;
  if (a.type !== qB) {
    const u = a, l = z5(u), d = ST(u, i);
    if (l && !d.length)
      return i = Ku(r, {
        status: "error",
        error: u.error
      }), o(i, u, []), {
        snapshot: i,
        microstates: s
      };
    i = pS(
      d,
      r,
      t,
      a,
      !1,
      // isInitial
      n
    ), o(i, u, d);
  }
  let c = !0;
  for (; i.status === "active"; ) {
    let u = c ? yV(i, a) : [];
    const l = u.length ? i : void 0;
    if (!u.length) {
      if (!n.length)
        break;
      a = n.shift(), u = ST(a, i);
    }
    i = pS(u, i, t, a, !1, n), c = i !== l, o(i, a, u);
  }
  return i.status !== "active" && _T(i, a, t), {
    snapshot: i,
    microstates: s
  };
}
function _T(r, e, t) {
  return Ph(r, e, t, Object.values(r.children).map((n) => l1(n)), [], void 0);
}
function ST(r, e) {
  return e.machine.getTransitionData(e, r);
}
function yV(r, e) {
  const t = /* @__PURE__ */ new Set(), n = r._nodes.filter(d1);
  for (const i of n)
    e: for (const s of [i].concat(jg(i, void 0)))
      if (s.always) {
        for (const o of s.always)
          if (o.guard === void 0 || zg(o.guard, r.context, e, r)) {
            t.add(o);
            break e;
          }
      }
  return cL(Array.from(t), new Set(r._nodes), r.historyValue);
}
function vV(r, e) {
  const t = Oy(Ry(r, e));
  return sL(r, [...t]);
}
function bV(r) {
  return !!r && typeof r == "object" && "machine" in r && "value" in r;
}
const wV = function(e) {
  return JB(e, this.value);
}, _V = function(e) {
  return this.tags.has(e);
}, SV = function(e) {
  const t = this.machine.getTransitionData(this, e);
  return !!(t != null && t.length) && // Check that at least one transition is not forbidden
  t.some((n) => n.target !== void 0 || n.actions.length);
}, EV = function() {
  const {
    _nodes: e,
    tags: t,
    machine: n,
    getMeta: i,
    toJSON: s,
    can: o,
    hasTag: a,
    matches: c,
    ...u
  } = this;
  return {
    ...u,
    tags: Array.from(t)
  };
}, xV = function() {
  return this._nodes.reduce((e, t) => (t.meta !== void 0 && (e[t.id] = t.meta), e), {});
};
function ny(r, e) {
  return {
    status: r.status,
    output: r.output,
    error: r.error,
    machine: e,
    context: r.context,
    _nodes: r._nodes,
    value: sL(e.root, r._nodes),
    tags: new Set(r._nodes.flatMap((t) => t.tags)),
    children: r.children,
    historyValue: r.historyValue || {},
    matches: wV,
    hasTag: _V,
    can: SV,
    getMeta: xV,
    toJSON: EV
  };
}
function Ku(r, e = {}) {
  return ny({
    ...r,
    ...e
  }, r.machine);
}
function AV(r, e) {
  const {
    _nodes: t,
    tags: n,
    machine: i,
    children: s,
    context: o,
    can: a,
    hasTag: c,
    matches: u,
    getMeta: l,
    toJSON: d,
    ...f
  } = r, p = {};
  for (const g in s) {
    const v = s[g];
    p[g] = {
      snapshot: v.getPersistedSnapshot(e),
      src: v.src,
      systemId: v._systemId,
      syncSnapshot: v._syncSnapshot
    };
  }
  return {
    ...f,
    context: hL(o),
    children: p
  };
}
function hL(r) {
  let e;
  for (const t in r) {
    const n = r[t];
    if (n && typeof n == "object")
      if ("sessionId" in n && "send" in n && "ref" in n)
        e ?? (e = Array.isArray(r) ? r.slice() : {
          ...r
        }), e[t] = {
          xstate$$type: u1,
          id: n.id
        };
      else {
        const i = hL(n);
        i !== n && (e ?? (e = Array.isArray(r) ? r.slice() : {
          ...r
        }), e[t] = i);
      }
  }
  return e ?? r;
}
function IV(r, e, t, n, {
  event: i,
  id: s,
  delay: o
}, {
  internalQueue: a
}) {
  const c = e.machine.implementations.delays;
  if (typeof i == "string")
    throw new Error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      `Only event objects may be used with raise; use raise({ type: "${i}" }) instead`
    );
  const u = typeof i == "function" ? i(t, n) : i;
  let l;
  if (typeof o == "string") {
    const d = c && c[o];
    l = typeof d == "function" ? d(t, n) : d;
  } else
    l = typeof o == "function" ? o(t, n) : o;
  return typeof l != "number" && a.push(u), [e, {
    event: u,
    id: s,
    delay: l
  }, void 0];
}
function CV(r, e) {
  const {
    event: t,
    delay: n,
    id: i
  } = e;
  if (typeof n == "number") {
    r.defer(() => {
      const s = r.self;
      r.system.scheduler.schedule(s, s, t, n, i);
    });
    return;
  }
}
function fL(r, e) {
  function t(n, i) {
  }
  return t.type = "xstate.raise", t.event = r, t.id = e == null ? void 0 : e.id, t.delay = e == null ? void 0 : e.delay, t.resolve = IV, t.execute = CV, t;
}
const ET = "xstate.observable.next", xT = "xstate.observable.error", AT = "xstate.observable.complete";
function kv(r) {
  return {
    config: r,
    transition: (t, n) => {
      if (t.status !== "active")
        return t;
      switch (n.type) {
        case ET:
          return {
            ...t,
            context: n.data
          };
        case xT:
          return {
            ...t,
            status: "error",
            error: n.data,
            input: void 0,
            _subscription: void 0
          };
        case AT:
          return {
            ...t,
            status: "done",
            input: void 0,
            _subscription: void 0
          };
        case Lp:
          return t._subscription.unsubscribe(), {
            ...t,
            status: "stopped",
            input: void 0,
            _subscription: void 0
          };
        default:
          return t;
      }
    },
    getInitialSnapshot: (t, n) => ({
      status: "active",
      output: void 0,
      error: void 0,
      context: void 0,
      input: n,
      _subscription: void 0
    }),
    start: (t, {
      self: n,
      system: i,
      emit: s
    }) => {
      t.status !== "done" && (t._subscription = r({
        input: t.input,
        system: i,
        self: n,
        emit: s
      }).subscribe({
        next: (o) => {
          i._relay(n, n, {
            type: ET,
            data: o
          });
        },
        error: (o) => {
          i._relay(n, n, {
            type: xT,
            data: o
          });
        },
        complete: () => {
          i._relay(n, n, {
            type: AT
          });
        }
      }));
    },
    getPersistedSnapshot: ({
      _subscription: t,
      ...n
    }) => n,
    restoreSnapshot: (t) => ({
      ...t,
      _subscription: void 0
    })
  };
}
const IT = "xstate.promise.resolve", CT = "xstate.promise.reject", fm = /* @__PURE__ */ new WeakMap();
function tt(r) {
  return {
    config: r,
    transition: (t, n, i) => {
      var s;
      if (t.status !== "active")
        return t;
      switch (n.type) {
        case IT: {
          const o = n.data;
          return {
            ...t,
            status: "done",
            output: o,
            input: void 0
          };
        }
        case CT:
          return {
            ...t,
            status: "error",
            error: n.data,
            input: void 0
          };
        case Lp:
          return (s = fm.get(i.self)) == null || s.abort(), {
            ...t,
            status: "stopped",
            input: void 0
          };
        default:
          return t;
      }
    },
    start: (t, {
      self: n,
      system: i,
      emit: s
    }) => {
      if (t.status !== "active")
        return;
      const o = new AbortController();
      fm.set(n, o), Promise.resolve(r({
        input: t.input,
        system: i,
        self: n,
        signal: o.signal,
        emit: s
      })).then((c) => {
        n.getSnapshot().status === "active" && (fm.delete(n), i._relay(n, n, {
          type: IT,
          data: c
        }));
      }, (c) => {
        n.getSnapshot().status === "active" && (fm.delete(n), i._relay(n, n, {
          type: CT,
          data: c
        }));
      });
    },
    getInitialSnapshot: (t, n) => ({
      status: "active",
      output: void 0,
      error: void 0,
      input: n
    }),
    getPersistedSnapshot: (t) => t,
    restoreSnapshot: (t) => t
  };
}
function DV(r, {
  machine: e,
  context: t
}, n, i) {
  const s = (o, a) => {
    if (typeof o == "string") {
      const c = c1(e, o);
      if (!c)
        throw new Error(`Actor logic '${o}' not implemented in machine '${e.id}'`);
      const u = Gu(c, {
        id: a == null ? void 0 : a.id,
        parent: r.self,
        syncSnapshot: a == null ? void 0 : a.syncSnapshot,
        input: typeof (a == null ? void 0 : a.input) == "function" ? a.input({
          context: t,
          event: n,
          self: r.self
        }) : a == null ? void 0 : a.input,
        src: o,
        systemId: a == null ? void 0 : a.systemId
      });
      return i[u.id] = u, u;
    } else
      return Gu(o, {
        id: a == null ? void 0 : a.id,
        parent: r.self,
        syncSnapshot: a == null ? void 0 : a.syncSnapshot,
        input: a == null ? void 0 : a.input,
        src: o,
        systemId: a == null ? void 0 : a.systemId
      });
  };
  return (o, a) => {
    const c = s(o, a);
    return i[c.id] = c, r.defer(() => {
      c._processingStatus !== Un.Stopped && c.start();
    }), c;
  };
}
function TV(r, e, t, n, {
  assignment: i
}) {
  if (!e.context)
    throw new Error("Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.");
  const s = {}, o = {
    context: e.context,
    event: t.event,
    spawn: DV(r, e, t.event, s),
    self: r.self,
    system: r.system
  };
  let a = {};
  if (typeof i == "function")
    a = i(o, n);
  else
    for (const u of Object.keys(i)) {
      const l = i[u];
      a[u] = typeof l == "function" ? l(o, n) : l;
    }
  const c = Object.assign({}, e.context, a);
  return [Ku(e, {
    context: c,
    children: Object.keys(s).length ? {
      ...e.children,
      ...s
    } : e.children
  }), void 0, void 0];
}
function Q(r) {
  function e(t, n) {
  }
  return e.type = "xstate.assign", e.assignment = r, e.resolve = TV, e;
}
function kV(r, e, t, n, {
  event: i
}) {
  const s = typeof i == "function" ? i(t, n) : i;
  return [e, {
    event: s
  }, void 0];
}
function OV(r, {
  event: e
}) {
  r.defer(() => r.emit(e));
}
function pL(r) {
  function e(t, n) {
  }
  return e.type = "xstate.emit", e.event = r, e.resolve = kV, e.execute = OV, e;
}
let gS = /* @__PURE__ */ (function(r) {
  return r.Parent = "#_parent", r.Internal = "#_internal", r;
})({});
function $V(r, e, t, n, {
  to: i,
  event: s,
  id: o,
  delay: a
}, c) {
  var y;
  const u = e.machine.implementations.delays;
  if (typeof s == "string")
    throw new Error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      `Only event objects may be used with sendTo; use sendTo({ type: "${s}" }) instead`
    );
  const l = typeof s == "function" ? s(t, n) : s;
  let d;
  if (typeof a == "string") {
    const g = u && u[a];
    d = typeof g == "function" ? g(t, n) : g;
  } else
    d = typeof a == "function" ? a(t, n) : a;
  const f = typeof i == "function" ? i(t, n) : i;
  let p;
  if (typeof f == "string") {
    if (f === gS.Parent ? p = r.self._parent : f === gS.Internal ? p = r.self : f.startsWith("#_") ? p = e.children[f.slice(2)] : p = (y = c.deferredActorIds) != null && y.includes(f) ? f : e.children[f], !p)
      throw new Error(`Unable to send event to actor '${f}' from machine '${e.machine.id}'.`);
  } else
    p = f || r.self;
  return [e, {
    to: p,
    targetId: typeof f == "string" ? f : void 0,
    event: l,
    id: o,
    delay: d
  }, void 0];
}
function RV(r, e, t) {
  typeof t.to == "string" && (t.to = e.children[t.to]);
}
function PV(r, e) {
  r.defer(() => {
    const {
      to: t,
      event: n,
      delay: i,
      id: s
    } = e;
    if (typeof i == "number") {
      r.system.scheduler.schedule(r.self, t, n, i, s);
      return;
    }
    r.system._relay(
      r.self,
      // at this point, in a deferred task, it should already be mutated by retryResolveSendTo
      // if it initially started as a string
      t,
      n.type === L5 ? WB(r.self.id, n.data) : n
    );
  });
}
function gL(r, e, t) {
  function n(i, s) {
  }
  return n.type = "xstate.sendTo", n.to = r, n.event = e, n.id = t == null ? void 0 : t.id, n.delay = t == null ? void 0 : t.delay, n.resolve = $V, n.retryResolve = RV, n.execute = PV, n;
}
function NV(r, e) {
  return gL(gS.Parent, r, e);
}
function BV(r, e, t, n, {
  collect: i
}) {
  const s = [], o = function(c) {
    s.push(c);
  };
  return o.assign = (...a) => {
    s.push(Q(...a));
  }, o.cancel = (...a) => {
    s.push(eL(...a));
  }, o.raise = (...a) => {
    s.push(fL(...a));
  }, o.sendTo = (...a) => {
    s.push(gL(...a));
  }, o.sendParent = (...a) => {
    s.push(NV(...a));
  }, o.spawnChild = (...a) => {
    s.push(tL(...a));
  }, o.stopChild = (...a) => {
    s.push(l1(...a));
  }, o.emit = (...a) => {
    s.push(pL(...a));
  }, i({
    context: t.context,
    event: t.event,
    enqueue: o,
    check: (a) => zg(a, e.context, t.event, e),
    self: r.self,
    system: r.system
  }, n), [e, void 0, s];
}
function LV(r) {
  function e(t, n) {
  }
  return e.type = "xstate.enqueueActions", e.collect = r, e.resolve = BV, e;
}
const DT = /* @__PURE__ */ new WeakMap();
function Sl(r, e, t) {
  let n = DT.get(r);
  return n ? e in n || (n[e] = t()) : (n = {
    [e]: t()
  }, DT.set(r, n)), n[e];
}
const UV = {}, Df = (r) => typeof r == "string" ? {
  type: r
} : typeof r == "function" ? "resolve" in r ? {
  type: r.type
} : {
  type: r.name
} : r;
class g1 {
  constructor(e, t) {
    if (this.config = e, this.key = void 0, this.id = void 0, this.type = void 0, this.path = void 0, this.states = void 0, this.history = void 0, this.entry = void 0, this.exit = void 0, this.parent = void 0, this.machine = void 0, this.meta = void 0, this.output = void 0, this.order = -1, this.description = void 0, this.tags = [], this.transitions = void 0, this.always = void 0, this.parent = t._parent, this.key = t._key, this.machine = t._machine, this.path = this.parent ? this.parent.path.concat(this.key) : [], this.id = this.config.id || [this.machine.id, ...this.path].join(GB), this.type = this.config.type || (this.config.states && Object.keys(this.config.states).length ? "compound" : this.config.history ? "history" : "atomic"), this.description = this.config.description, this.order = this.machine.idMap.size, this.machine.idMap.set(this.id, this), this.states = this.config.states ? yT(this.config.states, (n, i) => new g1(n, {
      _parent: this,
      _key: i,
      _machine: this.machine
    })) : UV, this.type === "compound" && !this.config.initial)
      throw new Error(`No initial state specified for compound state node "#${this.id}". Try adding { initial: "${Object.keys(this.states)[0]}" } to the state config.`);
    this.history = this.config.history === !0 ? "shallow" : this.config.history || !1, this.entry = ec(this.config.entry).slice(), this.exit = ec(this.config.exit).slice(), this.meta = this.config.meta, this.output = this.type === "final" || !this.parent ? this.config.output : void 0, this.tags = ec(e.tags).slice();
  }
  /** @internal */
  _initialize() {
    this.transitions = rV(this), this.config.always && (this.always = Ml(this.config.always).map((e) => jc(this, KB, e))), Object.keys(this.states).forEach((e) => {
      this.states[e]._initialize();
    });
  }
  /** The well-structured state node definition. */
  get definition() {
    return {
      id: this.id,
      key: this.key,
      version: this.machine.version,
      type: this.type,
      initial: this.initial ? {
        target: this.initial.target,
        source: this,
        actions: this.initial.actions.map(Df),
        eventType: null,
        reenter: !1,
        toJSON: () => ({
          target: this.initial.target.map((e) => `#${e.id}`),
          source: `#${this.id}`,
          actions: this.initial.actions.map(Df),
          eventType: null
        })
      } : void 0,
      history: this.history,
      states: yT(this.states, (e) => e.definition),
      on: this.on,
      transitions: [...this.transitions.values()].flat().map((e) => ({
        ...e,
        actions: e.actions.map(Df)
      })),
      entry: this.entry.map(Df),
      exit: this.exit.map(Df),
      meta: this.meta,
      order: this.order || -1,
      output: this.output,
      invoke: this.invoke,
      description: this.description,
      tags: this.tags
    };
  }
  /** @internal */
  toJSON() {
    return this.definition;
  }
  /** The logic invoked as actors by this state node. */
  get invoke() {
    return Sl(this, "invoke", () => ec(this.config.invoke).map((e, t) => {
      const {
        src: n,
        systemId: i
      } = e, s = e.id ?? vT(this.id, t), o = typeof n == "string" ? n : `xstate.invoke.${vT(this.id, t)}`;
      return {
        ...e,
        src: o,
        id: s,
        systemId: i,
        toJSON() {
          const {
            onDone: a,
            onError: c,
            ...u
          } = e;
          return {
            ...u,
            type: "xstate.invoke",
            src: o,
            id: s
          };
        }
      };
    }));
  }
  /** The mapping of events to transitions. */
  get on() {
    return Sl(this, "on", () => [...this.transitions].flatMap(([t, n]) => n.map((i) => [t, i])).reduce((t, [n, i]) => (t[n] = t[n] || [], t[n].push(i), t), {}));
  }
  get after() {
    return Sl(this, "delayedTransitions", () => tV(this));
  }
  get initial() {
    return Sl(this, "initial", () => nV(this, this.config.initial));
  }
  /** @internal */
  next(e, t) {
    const n = t.type, i = [];
    let s;
    const o = Sl(this, `candidates-${n}`, () => eV(this, n));
    for (const a of o) {
      const {
        guard: c
      } = a, u = e.context;
      let l = !1;
      try {
        l = !c || zg(c, u, t, e);
      } catch (d) {
        const f = typeof c == "string" ? c : typeof c == "object" ? c.type : void 0;
        throw new Error(`Unable to evaluate guard ${f ? `'${f}' ` : ""}in transition for event '${n}' in state node '${this.id}':
${d.message}`);
      }
      if (l) {
        i.push(...a.actions), s = a;
        break;
      }
    }
    return s ? [s] : void 0;
  }
  /** All the event types accepted by this state node and its descendants. */
  get events() {
    return Sl(this, "events", () => {
      const {
        states: e
      } = this, t = new Set(this.ownEvents);
      if (e)
        for (const n of Object.keys(e)) {
          const i = e[n];
          if (i.states)
            for (const s of i.events)
              t.add(`${s}`);
        }
      return Array.from(t);
    });
  }
  /**
   * All the events that have transitions directly from this state node.
   *
   * Excludes any inert events.
   */
  get ownEvents() {
    const e = new Set([...this.transitions.keys()].filter((t) => this.transitions.get(t).some((n) => !(!n.target && !n.actions.length && !n.reenter))));
    return Array.from(e);
  }
}
const FV = "#";
class m1 {
  constructor(e, t) {
    this.config = e, this.version = void 0, this.schemas = void 0, this.implementations = void 0, this.__xstatenode = !0, this.idMap = /* @__PURE__ */ new Map(), this.root = void 0, this.id = void 0, this.states = void 0, this.events = void 0, this.id = e.id || "(machine)", this.implementations = {
      actors: (t == null ? void 0 : t.actors) ?? {},
      actions: (t == null ? void 0 : t.actions) ?? {},
      delays: (t == null ? void 0 : t.delays) ?? {},
      guards: (t == null ? void 0 : t.guards) ?? {}
    }, this.version = this.config.version, this.schemas = this.config.schemas, this.transition = this.transition.bind(this), this.getInitialSnapshot = this.getInitialSnapshot.bind(this), this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this), this.restoreSnapshot = this.restoreSnapshot.bind(this), this.start = this.start.bind(this), this.root = new g1(e, {
      _key: this.id,
      _machine: this
    }), this.root._initialize(), this.states = this.root.states, this.events = this.root.events;
  }
  /**
   * Clones this state machine with the provided implementations and merges the
   * `context` (if provided).
   *
   * @param implementations Options (`actions`, `guards`, `actors`, `delays`,
   *   `context`) to recursively merge with the existing options.
   * @returns A new `StateMachine` instance with the provided implementations.
   */
  provide(e) {
    const {
      actions: t,
      guards: n,
      actors: i,
      delays: s
    } = this.implementations;
    return new m1(this.config, {
      actions: {
        ...t,
        ...e.actions
      },
      guards: {
        ...n,
        ...e.guards
      },
      actors: {
        ...i,
        ...e.actors
      },
      delays: {
        ...s,
        ...e.delays
      }
    });
  }
  resolveState(e) {
    const t = vV(this.root, e.value), n = Oy(Ry(this.root, t));
    return ny({
      _nodes: [...n],
      context: e.context || {},
      children: {},
      status: h1(n, this.root) ? "done" : e.status || "active",
      output: e.output,
      error: e.error,
      historyValue: e.historyValue
    }, this);
  }
  /**
   * Determines the next snapshot given the current `snapshot` and received
   * `event`. Calculates a full macrostep from all microsteps.
   *
   * @param snapshot The current snapshot
   * @param event The received event
   */
  transition(e, t, n) {
    return Ob(e, t, n, []).snapshot;
  }
  /**
   * Determines the next state given the current `state` and `event`. Calculates
   * a microstep.
   *
   * @param state The current state
   * @param event The received event
   */
  microstep(e, t, n) {
    return Ob(e, t, n, []).microstates;
  }
  getTransitionData(e, t) {
    return f1(this.root, e.value, e, t) || [];
  }
  /**
   * The initial state _before_ evaluating any microsteps. This "pre-initial"
   * state is provided to initial actions executed in the initial state.
   */
  getPreInitialState(e, t, n) {
    const {
      context: i
    } = this.config, s = ny({
      context: typeof i != "function" && i ? i : {},
      _nodes: [this.root],
      children: {},
      status: "active"
    }, this);
    return typeof i == "function" ? Ph(s, t, e, [Q(({
      spawn: a,
      event: c,
      self: u
    }) => i({
      spawn: a,
      input: c.input,
      self: u
    }))], n, void 0) : s;
  }
  /**
   * Returns the initial `State` instance, with reference to `self` as an
   * `ActorRef`.
   */
  getInitialSnapshot(e, t) {
    const n = ZB(t), i = [], s = this.getPreInitialState(e, n, i), o = pS([{
      target: [...aL(this.root)],
      source: this.root,
      reenter: !0,
      actions: [],
      eventType: null,
      toJSON: null
      // TODO: fix
    }], s, e, n, !0, i), {
      snapshot: a
    } = Ob(o, n, e, i);
    return a;
  }
  start(e) {
    Object.values(e.children).forEach((t) => {
      t.getSnapshot().status === "active" && t.start();
    });
  }
  getStateNodeById(e) {
    const t = a1(e), n = t.slice(1), i = Tv(t[0]) ? t[0].slice(FV.length) : t[0], s = this.idMap.get(i);
    if (!s)
      throw new Error(`Child state node '#${i}' does not exist on machine '${this.id}'`);
    return $y(s, n);
  }
  get definition() {
    return this.root.definition;
  }
  toJSON() {
    return this.definition;
  }
  getPersistedSnapshot(e, t) {
    return AV(e, t);
  }
  restoreSnapshot(e, t) {
    const n = {}, i = e.children;
    Object.keys(i).forEach((c) => {
      const u = i[c], l = u.snapshot, d = u.src, f = typeof d == "string" ? c1(this, d) : d;
      if (!f)
        return;
      const p = Gu(f, {
        id: c,
        parent: t.self,
        syncSnapshot: u.syncSnapshot,
        snapshot: l,
        src: d,
        systemId: u.systemId
      });
      n[c] = p;
    });
    const s = ny({
      ...e,
      children: n,
      _nodes: Array.from(Oy(Ry(this.root, e.value)))
    }, this), o = /* @__PURE__ */ new Set();
    function a(c, u) {
      if (!o.has(c)) {
        o.add(c);
        for (const l in c) {
          const d = c[l];
          if (d && typeof d == "object") {
            if ("xstate$$type" in d && d.xstate$$type === u1) {
              c[l] = u[d.id];
              continue;
            }
            a(d, u);
          }
        }
      }
    }
    return a(s.context, n), s;
  }
}
function MV(r, e) {
  return new m1(r, e);
}
function Or({
  schemas: r,
  actors: e,
  actions: t,
  guards: n,
  delays: i
}) {
  return {
    createMachine: (s) => MV({
      ...s,
      schemas: r
    }, {
      actors: e,
      actions: t,
      guards: n,
      delays: i
    })
  };
}
let mL = class {
  constructor(e) {
    h(this, "_tag", "DeviceNotOnboardedError");
    h(this, "originalError");
    this.originalError = new Error(e ?? "Device not onboarded.");
  }
}, mS = class {
  constructor(e) {
    h(this, "_tag", "DeviceLockedError");
    h(this, "originalError");
    this.originalError = new Error(e ?? "Device locked.");
  }
}, yL = class {
  constructor(e) {
    h(this, "_tag", "UnsupportedFirmwareDAError");
    h(this, "originalError");
    this.originalError = new Error(e ?? "Unknown error.");
  }
}, TT = class {
  constructor(e) {
    h(this, "_tag", "RefusedByUserDAError");
    h(this, "originalError");
    this.originalError = new Error(e ?? "Unknown error.");
  }
}, VV = class {
  constructor(e) {
    h(this, "_tag", "AppAlreadyInstalledDAError");
    h(this, "originalError");
    this.originalError = new Error(e ?? "Unknown error.");
  }
}, vL = class {
  constructor(e) {
    h(this, "_tag", "OutOfMemoryDAError");
    h(this, "originalError");
    this.originalError = new Error(e ?? "Unknown error.");
  }
}, fo = class {
  constructor(e) {
    h(this, "_tag", "UnknownDAError");
    h(this, "originalError");
    this.originalError = new Error(e ?? "Unknown error.");
  }
};
const fl = 6e4;
var yS = function(r, e) {
  return yS = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, n) {
    t.__proto__ = n;
  } || function(t, n) {
    for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
  }, yS(r, e);
};
function xo(r, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  yS(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
function zV(r, e, t, n) {
  function i(s) {
    return s instanceof t ? s : new t(function(o) {
      o(s);
    });
  }
  return new (t || (t = Promise))(function(s, o) {
    function a(l) {
      try {
        u(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      try {
        u(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function u(l) {
      l.done ? s(l.value) : i(l.value).then(a, c);
    }
    u((n = n.apply(r, e || [])).next());
  });
}
function bL(r, e) {
  var t = { label: 0, sent: function() {
    if (s[0] & 1) throw s[1];
    return s[1];
  }, trys: [], ops: [] }, n, i, s, o = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
  return o.next = a(0), o.throw = a(1), o.return = a(2), typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(u) {
    return function(l) {
      return c([u, l]);
    };
  }
  function c(u) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, u[0] && (t = 0)), t; ) try {
      if (n = 1, i && (s = u[0] & 2 ? i.return : u[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, u[1])).done) return s;
      switch (i = 0, s && (u = [u[0] & 2, s.value]), u[0]) {
        case 0:
        case 1:
          s = u;
          break;
        case 4:
          return t.label++, { value: u[1], done: !1 };
        case 5:
          t.label++, i = u[1], u = [0];
          continue;
        case 7:
          u = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (u[0] === 6 || u[0] === 2)) {
            t = 0;
            continue;
          }
          if (u[0] === 3 && (!s || u[1] > s[0] && u[1] < s[3])) {
            t.label = u[1];
            break;
          }
          if (u[0] === 6 && t.label < s[1]) {
            t.label = s[1], s = u;
            break;
          }
          if (s && t.label < s[2]) {
            t.label = s[2], t.ops.push(u);
            break;
          }
          s[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      u = e.call(r, t);
    } catch (l) {
      u = [6, l], i = 0;
    } finally {
      n = s = 0;
    }
    if (u[0] & 5) throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function Nh(r) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && r[e], n = 0;
  if (t) return t.call(r);
  if (r && typeof r.length == "number") return {
    next: function() {
      return r && n >= r.length && (r = void 0), { value: r && r[n++], done: !r };
    }
  };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Up(r, e) {
  var t = typeof Symbol == "function" && r[Symbol.iterator];
  if (!t) return r;
  var n = t.call(r), i, s = [], o;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; ) s.push(i.value);
  } catch (a) {
    o = { error: a };
  } finally {
    try {
      i && !i.done && (t = n.return) && t.call(n);
    } finally {
      if (o) throw o.error;
    }
  }
  return s;
}
function Fp(r, e, t) {
  if (t || arguments.length === 2) for (var n = 0, i = e.length, s; n < i; n++)
    (s || !(n in e)) && (s || (s = Array.prototype.slice.call(e, 0, n)), s[n] = e[n]);
  return r.concat(s || Array.prototype.slice.call(e));
}
function ld(r) {
  return this instanceof ld ? (this.v = r, this) : new ld(r);
}
function jV(r, e, t) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var n = t.apply(r, e || []), i, s = [];
  return i = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), a("next"), a("throw"), a("return", o), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function o(p) {
    return function(y) {
      return Promise.resolve(y).then(p, d);
    };
  }
  function a(p, y) {
    n[p] && (i[p] = function(g) {
      return new Promise(function(v, _) {
        s.push([p, g, v, _]) > 1 || c(p, g);
      });
    }, y && (i[p] = y(i[p])));
  }
  function c(p, y) {
    try {
      u(n[p](y));
    } catch (g) {
      f(s[0][3], g);
    }
  }
  function u(p) {
    p.value instanceof ld ? Promise.resolve(p.value.v).then(l, d) : f(s[0][2], p);
  }
  function l(p) {
    c("next", p);
  }
  function d(p) {
    c("throw", p);
  }
  function f(p, y) {
    p(y), s.shift(), s.length && c(s[0][0], s[0][1]);
  }
}
function HV(r) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = r[Symbol.asyncIterator], t;
  return e ? e.call(r) : (r = typeof Nh == "function" ? Nh(r) : r[Symbol.iterator](), t = {}, n("next"), n("throw"), n("return"), t[Symbol.asyncIterator] = function() {
    return this;
  }, t);
  function n(s) {
    t[s] = r[s] && function(o) {
      return new Promise(function(a, c) {
        o = r[s](o), i(a, c, o.done, o.value);
      });
    };
  }
  function i(s, o, a, c) {
    Promise.resolve(c).then(function(u) {
      s({ value: u, done: a });
    }, o);
  }
}
function Sr(r) {
  return typeof r == "function";
}
function Ov(r) {
  var e = function(n) {
    Error.call(n), n.stack = new Error().stack;
  }, t = r(e);
  return t.prototype = Object.create(Error.prototype), t.prototype.constructor = t, t;
}
var $b = Ov(function(r) {
  return function(t) {
    r(this), this.message = t ? t.length + ` errors occurred during unsubscription:
` + t.map(function(n, i) {
      return i + 1 + ") " + n.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = t;
  };
});
function Py(r, e) {
  if (r) {
    var t = r.indexOf(e);
    0 <= t && r.splice(t, 1);
  }
}
var Hg = (function() {
  function r(e) {
    this.initialTeardown = e, this.closed = !1, this._parentage = null, this._finalizers = null;
  }
  return r.prototype.unsubscribe = function() {
    var e, t, n, i, s;
    if (!this.closed) {
      this.closed = !0;
      var o = this._parentage;
      if (o)
        if (this._parentage = null, Array.isArray(o))
          try {
            for (var a = Nh(o), c = a.next(); !c.done; c = a.next()) {
              var u = c.value;
              u.remove(this);
            }
          } catch (g) {
            e = { error: g };
          } finally {
            try {
              c && !c.done && (t = a.return) && t.call(a);
            } finally {
              if (e) throw e.error;
            }
          }
        else
          o.remove(this);
      var l = this.initialTeardown;
      if (Sr(l))
        try {
          l();
        } catch (g) {
          s = g instanceof $b ? g.errors : [g];
        }
      var d = this._finalizers;
      if (d) {
        this._finalizers = null;
        try {
          for (var f = Nh(d), p = f.next(); !p.done; p = f.next()) {
            var y = p.value;
            try {
              kT(y);
            } catch (g) {
              s = s ?? [], g instanceof $b ? s = Fp(Fp([], Up(s)), Up(g.errors)) : s.push(g);
            }
          }
        } catch (g) {
          n = { error: g };
        } finally {
          try {
            p && !p.done && (i = f.return) && i.call(f);
          } finally {
            if (n) throw n.error;
          }
        }
      }
      if (s)
        throw new $b(s);
    }
  }, r.prototype.add = function(e) {
    var t;
    if (e && e !== this)
      if (this.closed)
        kT(e);
      else {
        if (e instanceof r) {
          if (e.closed || e._hasParent(this))
            return;
          e._addParent(this);
        }
        (this._finalizers = (t = this._finalizers) !== null && t !== void 0 ? t : []).push(e);
      }
  }, r.prototype._hasParent = function(e) {
    var t = this._parentage;
    return t === e || Array.isArray(t) && t.includes(e);
  }, r.prototype._addParent = function(e) {
    var t = this._parentage;
    this._parentage = Array.isArray(t) ? (t.push(e), t) : t ? [t, e] : e;
  }, r.prototype._removeParent = function(e) {
    var t = this._parentage;
    t === e ? this._parentage = null : Array.isArray(t) && Py(t, e);
  }, r.prototype.remove = function(e) {
    var t = this._finalizers;
    t && Py(t, e), e instanceof r && e._removeParent(this);
  }, r.EMPTY = (function() {
    var e = new r();
    return e.closed = !0, e;
  })(), r;
})(), wL = Hg.EMPTY;
function _L(r) {
  return r instanceof Hg || r && "closed" in r && Sr(r.remove) && Sr(r.add) && Sr(r.unsubscribe);
}
function kT(r) {
  Sr(r) ? r() : r.unsubscribe();
}
var GV = {
  Promise: void 0
}, KV = {
  setTimeout: function(r, e) {
    for (var t = [], n = 2; n < arguments.length; n++)
      t[n - 2] = arguments[n];
    return setTimeout.apply(void 0, Fp([r, e], Up(t)));
  },
  clearTimeout: function(r) {
    return clearTimeout(r);
  },
  delegate: void 0
};
function SL(r) {
  KV.setTimeout(function() {
    throw r;
  });
}
function OT() {
}
function iy(r) {
  r();
}
var y1 = (function(r) {
  xo(e, r);
  function e(t) {
    var n = r.call(this) || this;
    return n.isStopped = !1, t ? (n.destination = t, _L(t) && t.add(n)) : n.destination = ZV, n;
  }
  return e.create = function(t, n, i) {
    return new Bh(t, n, i);
  }, e.prototype.next = function(t) {
    this.isStopped || this._next(t);
  }, e.prototype.error = function(t) {
    this.isStopped || (this.isStopped = !0, this._error(t));
  }, e.prototype.complete = function() {
    this.isStopped || (this.isStopped = !0, this._complete());
  }, e.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = !0, r.prototype.unsubscribe.call(this), this.destination = null);
  }, e.prototype._next = function(t) {
    this.destination.next(t);
  }, e.prototype._error = function(t) {
    try {
      this.destination.error(t);
    } finally {
      this.unsubscribe();
    }
  }, e.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }, e;
})(Hg), qV = (function() {
  function r(e) {
    this.partialObserver = e;
  }
  return r.prototype.next = function(e) {
    var t = this.partialObserver;
    if (t.next)
      try {
        t.next(e);
      } catch (n) {
        pm(n);
      }
  }, r.prototype.error = function(e) {
    var t = this.partialObserver;
    if (t.error)
      try {
        t.error(e);
      } catch (n) {
        pm(n);
      }
    else
      pm(e);
  }, r.prototype.complete = function() {
    var e = this.partialObserver;
    if (e.complete)
      try {
        e.complete();
      } catch (t) {
        pm(t);
      }
  }, r;
})(), Bh = (function(r) {
  xo(e, r);
  function e(t, n, i) {
    var s = r.call(this) || this, o;
    return Sr(t) || !t ? o = {
      next: t ?? void 0,
      error: n ?? void 0,
      complete: i ?? void 0
    } : o = t, s.destination = new qV(o), s;
  }
  return e;
})(y1);
function pm(r) {
  SL(r);
}
function WV(r) {
  throw r;
}
var ZV = {
  closed: !0,
  next: OT,
  error: WV,
  complete: OT
}, v1 = (function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
})();
function b1(r) {
  return r;
}
function JV(r) {
  return r.length === 0 ? b1 : r.length === 1 ? r[0] : function(t) {
    return r.reduce(function(n, i) {
      return i(n);
    }, t);
  };
}
var mn = (function() {
  function r(e) {
    e && (this._subscribe = e);
  }
  return r.prototype.lift = function(e) {
    var t = new r();
    return t.source = this, t.operator = e, t;
  }, r.prototype.subscribe = function(e, t, n) {
    var i = this, s = YV(e) ? e : new Bh(e, t, n);
    return iy(function() {
      var o = i, a = o.operator, c = o.source;
      s.add(a ? a.call(s, c) : c ? i._subscribe(s) : i._trySubscribe(s));
    }), s;
  }, r.prototype._trySubscribe = function(e) {
    try {
      return this._subscribe(e);
    } catch (t) {
      e.error(t);
    }
  }, r.prototype.forEach = function(e, t) {
    var n = this;
    return t = $T(t), new t(function(i, s) {
      var o = new Bh({
        next: function(a) {
          try {
            e(a);
          } catch (c) {
            s(c), o.unsubscribe();
          }
        },
        error: s,
        complete: i
      });
      n.subscribe(o);
    });
  }, r.prototype._subscribe = function(e) {
    var t;
    return (t = this.source) === null || t === void 0 ? void 0 : t.subscribe(e);
  }, r.prototype[v1] = function() {
    return this;
  }, r.prototype.pipe = function() {
    for (var e = [], t = 0; t < arguments.length; t++)
      e[t] = arguments[t];
    return JV(e)(this);
  }, r.prototype.toPromise = function(e) {
    var t = this;
    return e = $T(e), new e(function(n, i) {
      var s;
      t.subscribe(function(o) {
        return s = o;
      }, function(o) {
        return i(o);
      }, function() {
        return n(s);
      });
    });
  }, r.create = function(e) {
    return new r(e);
  }, r;
})();
function $T(r) {
  var e;
  return (e = r ?? GV.Promise) !== null && e !== void 0 ? e : Promise;
}
function XV(r) {
  return r && Sr(r.next) && Sr(r.error) && Sr(r.complete);
}
function YV(r) {
  return r && r instanceof y1 || XV(r) && _L(r);
}
function QV(r) {
  return Sr(r == null ? void 0 : r.lift);
}
function Ri(r) {
  return function(e) {
    if (QV(e))
      return e.lift(function(t) {
        try {
          return r(t, this);
        } catch (n) {
          this.error(n);
        }
      });
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function Zi(r, e, t, n, i) {
  return new ez(r, e, t, n, i);
}
var ez = (function(r) {
  xo(e, r);
  function e(t, n, i, s, o, a) {
    var c = r.call(this, t) || this;
    return c.onFinalize = o, c.shouldUnsubscribe = a, c._next = n ? function(u) {
      try {
        n(u);
      } catch (l) {
        t.error(l);
      }
    } : r.prototype._next, c._error = s ? function(u) {
      try {
        s(u);
      } catch (l) {
        t.error(l);
      } finally {
        this.unsubscribe();
      }
    } : r.prototype._error, c._complete = i ? function() {
      try {
        i();
      } catch (u) {
        t.error(u);
      } finally {
        this.unsubscribe();
      }
    } : r.prototype._complete, c;
  }
  return e.prototype.unsubscribe = function() {
    var t;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var n = this.closed;
      r.prototype.unsubscribe.call(this), !n && ((t = this.onFinalize) === null || t === void 0 || t.call(this));
    }
  }, e;
})(y1), tz = Ov(function(r) {
  return function() {
    r(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
  };
}), af = (function(r) {
  xo(e, r);
  function e() {
    var t = r.call(this) || this;
    return t.closed = !1, t.currentObservers = null, t.observers = [], t.isStopped = !1, t.hasError = !1, t.thrownError = null, t;
  }
  return e.prototype.lift = function(t) {
    var n = new RT(this, this);
    return n.operator = t, n;
  }, e.prototype._throwIfClosed = function() {
    if (this.closed)
      throw new tz();
  }, e.prototype.next = function(t) {
    var n = this;
    iy(function() {
      var i, s;
      if (n._throwIfClosed(), !n.isStopped) {
        n.currentObservers || (n.currentObservers = Array.from(n.observers));
        try {
          for (var o = Nh(n.currentObservers), a = o.next(); !a.done; a = o.next()) {
            var c = a.value;
            c.next(t);
          }
        } catch (u) {
          i = { error: u };
        } finally {
          try {
            a && !a.done && (s = o.return) && s.call(o);
          } finally {
            if (i) throw i.error;
          }
        }
      }
    });
  }, e.prototype.error = function(t) {
    var n = this;
    iy(function() {
      if (n._throwIfClosed(), !n.isStopped) {
        n.hasError = n.isStopped = !0, n.thrownError = t;
        for (var i = n.observers; i.length; )
          i.shift().error(t);
      }
    });
  }, e.prototype.complete = function() {
    var t = this;
    iy(function() {
      if (t._throwIfClosed(), !t.isStopped) {
        t.isStopped = !0;
        for (var n = t.observers; n.length; )
          n.shift().complete();
      }
    });
  }, e.prototype.unsubscribe = function() {
    this.isStopped = this.closed = !0, this.observers = this.currentObservers = null;
  }, Object.defineProperty(e.prototype, "observed", {
    get: function() {
      var t;
      return ((t = this.observers) === null || t === void 0 ? void 0 : t.length) > 0;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._trySubscribe = function(t) {
    return this._throwIfClosed(), r.prototype._trySubscribe.call(this, t);
  }, e.prototype._subscribe = function(t) {
    return this._throwIfClosed(), this._checkFinalizedStatuses(t), this._innerSubscribe(t);
  }, e.prototype._innerSubscribe = function(t) {
    var n = this, i = this, s = i.hasError, o = i.isStopped, a = i.observers;
    return s || o ? wL : (this.currentObservers = null, a.push(t), new Hg(function() {
      n.currentObservers = null, Py(a, t);
    }));
  }, e.prototype._checkFinalizedStatuses = function(t) {
    var n = this, i = n.hasError, s = n.thrownError, o = n.isStopped;
    i ? t.error(s) : o && t.complete();
  }, e.prototype.asObservable = function() {
    var t = new mn();
    return t.source = this, t;
  }, e.create = function(t, n) {
    return new RT(t, n);
  }, e;
})(mn), RT = (function(r) {
  xo(e, r);
  function e(t, n) {
    var i = r.call(this) || this;
    return i.destination = t, i.source = n, i;
  }
  return e.prototype.next = function(t) {
    var n, i;
    (i = (n = this.destination) === null || n === void 0 ? void 0 : n.next) === null || i === void 0 || i.call(n, t);
  }, e.prototype.error = function(t) {
    var n, i;
    (i = (n = this.destination) === null || n === void 0 ? void 0 : n.error) === null || i === void 0 || i.call(n, t);
  }, e.prototype.complete = function() {
    var t, n;
    (n = (t = this.destination) === null || t === void 0 ? void 0 : t.complete) === null || n === void 0 || n.call(t);
  }, e.prototype._subscribe = function(t) {
    var n, i;
    return (i = (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(t)) !== null && i !== void 0 ? i : wL;
  }, e;
})(af), fa = (function(r) {
  xo(e, r);
  function e(t) {
    var n = r.call(this) || this;
    return n._value = t, n;
  }
  return Object.defineProperty(e.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._subscribe = function(t) {
    var n = r.prototype._subscribe.call(this, t);
    return !n.closed && t.next(this._value), n;
  }, e.prototype.getValue = function() {
    var t = this, n = t.hasError, i = t.thrownError, s = t._value;
    if (n)
      throw i;
    return this._throwIfClosed(), s;
  }, e.prototype.next = function(t) {
    r.prototype.next.call(this, this._value = t);
  }, e;
})(af), w1 = {
  now: function() {
    return (w1.delegate || Date).now();
  },
  delegate: void 0
}, $v = (function(r) {
  xo(e, r);
  function e(t, n, i) {
    t === void 0 && (t = 1 / 0), n === void 0 && (n = 1 / 0), i === void 0 && (i = w1);
    var s = r.call(this) || this;
    return s._bufferSize = t, s._windowTime = n, s._timestampProvider = i, s._buffer = [], s._infiniteTimeWindow = !0, s._infiniteTimeWindow = n === 1 / 0, s._bufferSize = Math.max(1, t), s._windowTime = Math.max(1, n), s;
  }
  return e.prototype.next = function(t) {
    var n = this, i = n.isStopped, s = n._buffer, o = n._infiniteTimeWindow, a = n._timestampProvider, c = n._windowTime;
    i || (s.push(t), !o && s.push(a.now() + c)), this._trimBuffer(), r.prototype.next.call(this, t);
  }, e.prototype._subscribe = function(t) {
    this._throwIfClosed(), this._trimBuffer();
    for (var n = this._innerSubscribe(t), i = this, s = i._infiniteTimeWindow, o = i._buffer, a = o.slice(), c = 0; c < a.length && !t.closed; c += s ? 1 : 2)
      t.next(a[c]);
    return this._checkFinalizedStatuses(t), n;
  }, e.prototype._trimBuffer = function() {
    var t = this, n = t._bufferSize, i = t._timestampProvider, s = t._buffer, o = t._infiniteTimeWindow, a = (o ? 1 : 2) * n;
    if (n < 1 / 0 && a < s.length && s.splice(0, s.length - a), !o) {
      for (var c = i.now(), u = 0, l = 1; l < s.length && s[l] <= c; l += 2)
        u = l;
      u && s.splice(0, u + 1);
    }
  }, e;
})(af), rz = (function(r) {
  xo(e, r);
  function e(t, n) {
    return r.call(this) || this;
  }
  return e.prototype.schedule = function(t, n) {
    return this;
  }, e;
})(Hg), PT = {
  setInterval: function(r, e) {
    for (var t = [], n = 2; n < arguments.length; n++)
      t[n - 2] = arguments[n];
    return setInterval.apply(void 0, Fp([r, e], Up(t)));
  },
  clearInterval: function(r) {
    return clearInterval(r);
  },
  delegate: void 0
}, nz = (function(r) {
  xo(e, r);
  function e(t, n) {
    var i = r.call(this, t, n) || this;
    return i.scheduler = t, i.work = n, i.pending = !1, i;
  }
  return e.prototype.schedule = function(t, n) {
    var i;
    if (n === void 0 && (n = 0), this.closed)
      return this;
    this.state = t;
    var s = this.id, o = this.scheduler;
    return s != null && (this.id = this.recycleAsyncId(o, s, n)), this.pending = !0, this.delay = n, this.id = (i = this.id) !== null && i !== void 0 ? i : this.requestAsyncId(o, this.id, n), this;
  }, e.prototype.requestAsyncId = function(t, n, i) {
    return i === void 0 && (i = 0), PT.setInterval(t.flush.bind(t, this), i);
  }, e.prototype.recycleAsyncId = function(t, n, i) {
    if (i === void 0 && (i = 0), i != null && this.delay === i && this.pending === !1)
      return n;
    n != null && PT.clearInterval(n);
  }, e.prototype.execute = function(t, n) {
    if (this.closed)
      return new Error("executing a cancelled action");
    this.pending = !1;
    var i = this._execute(t, n);
    if (i)
      return i;
    this.pending === !1 && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
  }, e.prototype._execute = function(t, n) {
    var i = !1, s;
    try {
      this.work(t);
    } catch (o) {
      i = !0, s = o || new Error("Scheduled action threw falsy error");
    }
    if (i)
      return this.unsubscribe(), s;
  }, e.prototype.unsubscribe = function() {
    if (!this.closed) {
      var t = this, n = t.id, i = t.scheduler, s = i.actions;
      this.work = this.state = this.scheduler = null, this.pending = !1, Py(s, this), n != null && (this.id = this.recycleAsyncId(i, n, null)), this.delay = null, r.prototype.unsubscribe.call(this);
    }
  }, e;
})(rz), NT = (function() {
  function r(e, t) {
    t === void 0 && (t = r.now), this.schedulerActionCtor = e, this.now = t;
  }
  return r.prototype.schedule = function(e, t, n) {
    return t === void 0 && (t = 0), new this.schedulerActionCtor(this, e).schedule(n, t);
  }, r.now = w1.now, r;
})(), iz = (function(r) {
  xo(e, r);
  function e(t, n) {
    n === void 0 && (n = NT.now);
    var i = r.call(this, t, n) || this;
    return i.actions = [], i._active = !1, i;
  }
  return e.prototype.flush = function(t) {
    var n = this.actions;
    if (this._active) {
      n.push(t);
      return;
    }
    var i;
    this._active = !0;
    do
      if (i = t.execute(t.state, t.delay))
        break;
    while (t = n.shift());
    if (this._active = !1, i) {
      for (; t = n.shift(); )
        t.unsubscribe();
      throw i;
    }
  }, e;
})(NT), _1 = new iz(nz), sz = _1, Rv = new mn(function(r) {
  return r.complete();
});
function EL(r) {
  return r && Sr(r.schedule);
}
function xL(r) {
  return r[r.length - 1];
}
function Pv(r) {
  return EL(xL(r)) ? r.pop() : void 0;
}
function oz(r, e) {
  return typeof xL(r) == "number" ? r.pop() : e;
}
var AL = (function(r) {
  return r && typeof r.length == "number" && typeof r != "function";
});
function IL(r) {
  return Sr(r == null ? void 0 : r.then);
}
function CL(r) {
  return Sr(r[v1]);
}
function DL(r) {
  return Symbol.asyncIterator && Sr(r == null ? void 0 : r[Symbol.asyncIterator]);
}
function TL(r) {
  return new TypeError("You provided " + (r !== null && typeof r == "object" ? "an invalid object" : "'" + r + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function az() {
  return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
}
var kL = az();
function OL(r) {
  return Sr(r == null ? void 0 : r[kL]);
}
function $L(r) {
  return jV(this, arguments, function() {
    var t, n, i, s;
    return bL(this, function(o) {
      switch (o.label) {
        case 0:
          t = r.getReader(), o.label = 1;
        case 1:
          o.trys.push([1, , 9, 10]), o.label = 2;
        case 2:
          return [4, ld(t.read())];
        case 3:
          return n = o.sent(), i = n.value, s = n.done, s ? [4, ld(void 0)] : [3, 5];
        case 4:
          return [2, o.sent()];
        case 5:
          return [4, ld(i)];
        case 6:
          return [4, o.sent()];
        case 7:
          return o.sent(), [3, 2];
        case 8:
          return [3, 10];
        case 9:
          return t.releaseLock(), [7];
        case 10:
          return [2];
      }
    });
  });
}
function RL(r) {
  return Sr(r == null ? void 0 : r.getReader);
}
function Bs(r) {
  if (r instanceof mn)
    return r;
  if (r != null) {
    if (CL(r))
      return cz(r);
    if (AL(r))
      return uz(r);
    if (IL(r))
      return lz(r);
    if (DL(r))
      return PL(r);
    if (OL(r))
      return dz(r);
    if (RL(r))
      return hz(r);
  }
  throw TL(r);
}
function cz(r) {
  return new mn(function(e) {
    var t = r[v1]();
    if (Sr(t.subscribe))
      return t.subscribe(e);
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function uz(r) {
  return new mn(function(e) {
    for (var t = 0; t < r.length && !e.closed; t++)
      e.next(r[t]);
    e.complete();
  });
}
function lz(r) {
  return new mn(function(e) {
    r.then(function(t) {
      e.closed || (e.next(t), e.complete());
    }, function(t) {
      return e.error(t);
    }).then(null, SL);
  });
}
function dz(r) {
  return new mn(function(e) {
    var t, n;
    try {
      for (var i = Nh(r), s = i.next(); !s.done; s = i.next()) {
        var o = s.value;
        if (e.next(o), e.closed)
          return;
      }
    } catch (a) {
      t = { error: a };
    } finally {
      try {
        s && !s.done && (n = i.return) && n.call(i);
      } finally {
        if (t) throw t.error;
      }
    }
    e.complete();
  });
}
function PL(r) {
  return new mn(function(e) {
    fz(r, e).catch(function(t) {
      return e.error(t);
    });
  });
}
function hz(r) {
  return PL($L(r));
}
function fz(r, e) {
  var t, n, i, s;
  return zV(this, void 0, void 0, function() {
    var o, a;
    return bL(this, function(c) {
      switch (c.label) {
        case 0:
          c.trys.push([0, 5, 6, 11]), t = HV(r), c.label = 1;
        case 1:
          return [4, t.next()];
        case 2:
          if (n = c.sent(), !!n.done) return [3, 4];
          if (o = n.value, e.next(o), e.closed)
            return [2];
          c.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          return a = c.sent(), i = { error: a }, [3, 11];
        case 6:
          return c.trys.push([6, , 9, 10]), n && !n.done && (s = t.return) ? [4, s.call(t)] : [3, 8];
        case 7:
          c.sent(), c.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (i) throw i.error;
          return [7];
        case 10:
          return [7];
        case 11:
          return e.complete(), [2];
      }
    });
  });
}
function oc(r, e, t, n, i) {
  n === void 0 && (n = 0), i === void 0 && (i = !1);
  var s = e.schedule(function() {
    t(), i ? r.add(this.schedule(null, n)) : this.unsubscribe();
  }, n);
  if (r.add(s), !i)
    return s;
}
function NL(r, e) {
  return e === void 0 && (e = 0), Ri(function(t, n) {
    t.subscribe(Zi(n, function(i) {
      return oc(n, r, function() {
        return n.next(i);
      }, e);
    }, function() {
      return oc(n, r, function() {
        return n.complete();
      }, e);
    }, function(i) {
      return oc(n, r, function() {
        return n.error(i);
      }, e);
    }));
  });
}
function BL(r, e) {
  return e === void 0 && (e = 0), Ri(function(t, n) {
    n.add(r.schedule(function() {
      return t.subscribe(n);
    }, e));
  });
}
function pz(r, e) {
  return Bs(r).pipe(BL(e), NL(e));
}
function gz(r, e) {
  return Bs(r).pipe(BL(e), NL(e));
}
function mz(r, e) {
  return new mn(function(t) {
    var n = 0;
    return e.schedule(function() {
      n === r.length ? t.complete() : (t.next(r[n++]), t.closed || this.schedule());
    });
  });
}
function yz(r, e) {
  return new mn(function(t) {
    var n;
    return oc(t, e, function() {
      n = r[kL](), oc(t, e, function() {
        var i, s, o;
        try {
          i = n.next(), s = i.value, o = i.done;
        } catch (a) {
          t.error(a);
          return;
        }
        o ? t.complete() : t.next(s);
      }, 0, !0);
    }), function() {
      return Sr(n == null ? void 0 : n.return) && n.return();
    };
  });
}
function LL(r, e) {
  if (!r)
    throw new Error("Iterable cannot be null");
  return new mn(function(t) {
    oc(t, e, function() {
      var n = r[Symbol.asyncIterator]();
      oc(t, e, function() {
        n.next().then(function(i) {
          i.done ? t.complete() : t.next(i.value);
        });
      }, 0, !0);
    });
  });
}
function vz(r, e) {
  return LL($L(r), e);
}
function bz(r, e) {
  if (r != null) {
    if (CL(r))
      return pz(r, e);
    if (AL(r))
      return mz(r, e);
    if (IL(r))
      return gz(r, e);
    if (DL(r))
      return LL(r, e);
    if (OL(r))
      return yz(r, e);
    if (RL(r))
      return vz(r, e);
  }
  throw TL(r);
}
function rn(r, e) {
  return e ? bz(r, e) : Bs(r);
}
function Ji() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  var t = Pv(r);
  return rn(r, t);
}
var UL = Ov(function(r) {
  return function() {
    r(this), this.name = "EmptyError", this.message = "no elements in sequence";
  };
});
function S1(r, e) {
  return new Promise(function(t, n) {
    var i = !1, s;
    r.subscribe({
      next: function(o) {
        s = o, i = !0;
      },
      error: n,
      complete: function() {
        i ? t(s) : n(new UL());
      }
    });
  });
}
function wz(r, e) {
  return new Promise(function(t, n) {
    var i = new Bh({
      next: function(s) {
        t(s), i.unsubscribe();
      },
      error: n,
      complete: function() {
        n(new UL());
      }
    });
    r.subscribe(i);
  });
}
function FL(r) {
  return r instanceof Date && !isNaN(r);
}
var _z = Ov(function(r) {
  return function(t) {
    t === void 0 && (t = null), r(this), this.message = "Timeout has occurred", this.name = "TimeoutError", this.info = t;
  };
});
function ML(r, e) {
  var t = FL(r) ? { first: r } : typeof r == "number" ? { each: r } : r, n = t.first, i = t.each, s = t.with, o = s === void 0 ? Sz : s, a = t.scheduler, c = a === void 0 ? _1 : a, u = t.meta, l = u === void 0 ? null : u;
  if (n == null && i == null)
    throw new TypeError("No timeout provided.");
  return Ri(function(d, f) {
    var p, y, g = null, v = 0, _ = function(w) {
      y = oc(f, c, function() {
        try {
          p.unsubscribe(), Bs(o({
            meta: l,
            lastValue: g,
            seen: v
          })).subscribe(f);
        } catch (E) {
          f.error(E);
        }
      }, w);
    };
    p = d.subscribe(Zi(f, function(w) {
      y == null || y.unsubscribe(), v++, f.next(g = w), i > 0 && _(i);
    }, void 0, void 0, function() {
      y != null && y.closed || y == null || y.unsubscribe(), g = null;
    })), !v && _(n != null ? typeof n == "number" ? n : +n - c.now() : i);
  });
}
function Sz(r) {
  throw new _z(r);
}
function cr(r, e) {
  return Ri(function(t, n) {
    var i = 0;
    t.subscribe(Zi(n, function(s) {
      n.next(r.call(e, s, i++));
    }));
  });
}
function Ez(r, e, t, n, i, s, o, a) {
  var c = [], u = 0, l = 0, d = !1, f = function() {
    d && !c.length && !u && e.complete();
  }, p = function(g) {
    return u < n ? y(g) : c.push(g);
  }, y = function(g) {
    u++;
    var v = !1;
    Bs(t(g, l++)).subscribe(Zi(e, function(_) {
      e.next(_);
    }, function() {
      v = !0;
    }, void 0, function() {
      if (v)
        try {
          u--;
          for (var _ = function() {
            var w = c.shift();
            o || y(w);
          }; c.length && u < n; )
            _();
          f();
        } catch (w) {
          e.error(w);
        }
    }));
  };
  return r.subscribe(Zi(e, p, function() {
    d = !0, f();
  })), function() {
  };
}
function cf(r, e, t) {
  return t === void 0 && (t = 1 / 0), Sr(e) ? cf(function(n, i) {
    return cr(function(s, o) {
      return e(n, s, i, o);
    })(Bs(r(n, i)));
  }, t) : (typeof e == "number" && (t = e), Ri(function(n, i) {
    return Ez(n, i, r, t);
  }));
}
function VL(r) {
  return r === void 0 && (r = 1 / 0), cf(b1, r);
}
function xz() {
  return VL(1);
}
function BT() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  return xz()(rn(r, Pv(r)));
}
function E1(r, e, t) {
  r === void 0 && (r = 0), t === void 0 && (t = sz);
  var n = -1;
  return e != null && (EL(e) ? t = e : n = e), new mn(function(i) {
    var s = FL(r) ? +r - t.now() : r;
    s < 0 && (s = 0);
    var o = 0;
    return t.schedule(function() {
      i.closed || (i.next(o++), 0 <= n ? this.schedule(void 0, n) : i.complete());
    }, s);
  });
}
function zL(r, e) {
  return e === void 0 && (e = _1), E1(r, r, e);
}
function x1() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  var t = Pv(r), n = oz(r, 1 / 0), i = r;
  return i.length ? i.length === 1 ? Bs(i[0]) : VL(n)(rn(i, t)) : Rv;
}
function fn(r, e) {
  return Ri(function(t, n) {
    var i = 0;
    t.subscribe(Zi(n, function(s) {
      return r.call(e, s, i++) && n.next(s);
    }));
  });
}
function jL(r) {
  return Ri(function(e, t) {
    var n = null, i = !1, s;
    n = e.subscribe(Zi(t, void 0, void 0, function(o) {
      s = Bs(r(o, jL(r)(e))), n ? (n.unsubscribe(), n = null, s.subscribe(t)) : i = !0;
    })), i && (n.unsubscribe(), n = null, s.subscribe(t));
  });
}
function Az(r, e, t, n, i) {
  return function(s, o) {
    var a = t, c = e, u = 0;
    s.subscribe(Zi(o, function(l) {
      var d = u++;
      c = a ? r(c, l, d) : (a = !0, l), o.next(c);
    }, i));
  };
}
function HL(r) {
  return r <= 0 ? function() {
    return Rv;
  } : Ri(function(e, t) {
    var n = 0;
    e.subscribe(Zi(t, function(i) {
      ++n <= r && (t.next(i), r <= n && t.complete());
    }));
  });
}
function A1(r, e) {
  return Ri(Az(r, e, arguments.length >= 2, !0));
}
function GL(r) {
  r === void 0 && (r = {});
  var e = r.connector, t = e === void 0 ? function() {
    return new af();
  } : e, n = r.resetOnError, i = n === void 0 ? !0 : n, s = r.resetOnComplete, o = s === void 0 ? !0 : s, a = r.resetOnRefCountZero, c = a === void 0 ? !0 : a;
  return function(u) {
    var l, d, f, p = 0, y = !1, g = !1, v = function() {
      d == null || d.unsubscribe(), d = void 0;
    }, _ = function() {
      v(), l = f = void 0, y = g = !1;
    }, w = function() {
      var E = l;
      _(), E == null || E.unsubscribe();
    };
    return Ri(function(E, I) {
      p++, !g && !y && v();
      var S = f = f ?? t();
      I.add(function() {
        p--, p === 0 && !g && !y && (d = Rb(w, c));
      }), S.subscribe(I), !l && p > 0 && (l = new Bh({
        next: function(T) {
          return S.next(T);
        },
        error: function(T) {
          g = !0, v(), d = Rb(_, i, T), S.error(T);
        },
        complete: function() {
          y = !0, v(), d = Rb(_, o), S.complete();
        }
      }), Bs(E).subscribe(l));
    })(u);
  };
}
function Rb(r, e) {
  for (var t = [], n = 2; n < arguments.length; n++)
    t[n - 2] = arguments[n];
  if (e === !0) {
    r();
    return;
  }
  if (e !== !1) {
    var i = new Bh({
      next: function() {
        i.unsubscribe(), r();
      }
    });
    return Bs(e.apply(void 0, Fp([], Up(t)))).subscribe(i);
  }
}
function Iz() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  var t = Pv(r);
  return Ri(function(n, i) {
    (t ? BT(r, n, t) : BT(r, n)).subscribe(i);
  });
}
function Qr(r, e) {
  return Ri(function(t, n) {
    var i = null, s = 0, o = !1, a = function() {
      return o && !i && n.complete();
    };
    t.subscribe(Zi(n, function(c) {
      i == null || i.unsubscribe();
      var u = 0, l = s++;
      Bs(r(c, l)).subscribe(i = Zi(n, function(d) {
        return n.next(e ? e(c, d, l, u++) : d);
      }, function() {
        i = null, a();
      }));
    }, function() {
      o = !0, a();
    }));
  });
}
function po(r, e, t) {
  var n = Sr(r) || e || t ? { next: r, error: e, complete: t } : r;
  return n ? Ri(function(i, s) {
    var o;
    (o = n.subscribe) === null || o === void 0 || o.call(n);
    var a = !0;
    i.subscribe(Zi(s, function(c) {
      var u;
      (u = n.next) === null || u === void 0 || u.call(n, c), s.next(c);
    }, function() {
      var c;
      a = !1, (c = n.complete) === null || c === void 0 || c.call(n), s.complete();
    }, function(c) {
      var u;
      a = !1, (u = n.error) === null || u === void 0 || u.call(n, c), s.error(c);
    }, function() {
      var c, u;
      a && ((c = n.unsubscribe) === null || c === void 0 || c.call(n)), (u = n.finalize) === null || u === void 0 || u.call(n);
    }));
  }) : b1;
}
let Qi = class {
  constructor(e) {
    h(this, "input");
    h(this, "inspect", !1);
    this.input = e.input, this.inspect = !!e.inspect;
  }
  _execute(e) {
    const t = this.makeStateMachine(e);
    return this._subscribeToStateMachine(t);
  }
  _subscribeToStateMachine(e) {
    const t = Gu(e, { input: this.input }), n = new $v(), i = (a) => {
      const { context: c, status: u, output: l, error: d } = a;
      switch (u) {
        case "active":
          n.next({ status: Oe.Pending, intermediateValue: c.intermediateValue });
          break;
        case "done":
          l.caseOf({ Left: (f) => {
            n.next({ status: Oe.Error, error: f });
          }, Right: (f) => {
            n.next({ status: Oe.Completed, output: f });
          } }), n.complete();
          break;
        case "error":
          n.error(d), n.complete();
          break;
        case "stopped":
          n.next({ status: Oe.Stopped }), n.complete();
          break;
        default:
          this._exhaustiveMatchingGuard(u);
      }
    }, s = new mn((a) => {
      const c = n.subscribe(a);
      return () => {
        o.unsubscribe(), c.unsubscribe(), t.stop();
      };
    }), o = t.subscribe(i);
    return t.start(), { observable: s.pipe(GL()), cancel: () => {
      t.stop(), o.unsubscribe(), i(t.getSnapshot());
    } };
  }
  _exhaustiveMatchingGuard(e) {
    throw console.log("_exhaustiveMatchingGuard status", e), new Error(`Unhandled status: ${e}`);
  }
};
var wr = ((r) => (r[r.Connected = 0] = "Connected", r[r.ReadyWithoutSecureChannel = 1] = "ReadyWithoutSecureChannel", r[r.ReadyWithSecureChannel = 2] = "ReadyWithSecureChannel", r))(wr || {});
let KL = class extends Qi {
  makeStateMachine(e) {
    const { getAppAndVersion: t, getDeviceSessionState: n, setDeviceSessionState: i, waitForDeviceUnlock: s, isDeviceOnboarded: o } = this.extractDependencies(e), a = this.input.unlockTimeout ?? fl;
    return Or({ actors: { getAppAndVersion: tt(t), waitForDeviceUnlock: kv(s) }, guards: { isDeviceOnboarded: () => o(), isDeviceLocked: ({ context: c }) => c._internalState.locked, hasError: ({ context: c }) => c._internalState.error !== null }, actions: { assignErrorDeviceNotOnboarded: Q({ _internalState: (c) => ({ ...c.context._internalState, error: new mL() }) }), assignErrorDeviceLocked: Q({ _internalState: (c) => ({ ...c.context._internalState, error: new mS() }), intermediateValue: { requiredUserInteraction: $e.UnlockDevice } }), assignErrorFromEvent: Q({ _internalState: (c) => ({ ...c.context._internalState, error: c.event.error }) }), assignNoUserActionNeeded: Q({ intermediateValue: (c) => ({ ...c.context.intermediateValue, requiredUserInteraction: $e.None }) }), assignUserActionUnlockNeeded: Q({ intermediateValue: (c) => ({ ...c.context.intermediateValue, requiredUserInteraction: $e.UnlockDevice }) }) } }).createMachine({ id: "GetDeviceStatusDeviceAction", initial: "DeviceReady", context: (c) => {
      const u = n(), { sessionStateType: l } = u;
      return { input: { unlockTimeout: c.input.unlockTimeout }, intermediateValue: { requiredUserInteraction: $e.None }, _internalState: { onboarded: !1, locked: !1, currentApp: l === wr.ReadyWithoutSecureChannel ? u.currentApp.name : null, currentAppVersion: null, error: null } };
    }, states: { DeviceReady: { always: { target: "OnboardingCheck" } }, OnboardingCheck: { always: [{ guard: { type: "isDeviceOnboarded" }, target: "AppAndVersionCheck", actions: Q({ _internalState: (c) => ({ ...c.context._internalState, onboarded: !0 }) }) }, { target: "Error", actions: "assignErrorDeviceNotOnboarded" }] }, UserActionUnlockDevice: { entry: "assignUserActionUnlockNeeded", exit: "assignNoUserActionNeeded", invoke: { id: "UserActionUnlockDevice", src: "waitForDeviceUnlock", input: (c) => ({ unlockTimeout: a }), onDone: { target: "AppAndVersionCheck", actions: Q({ _internalState: (c) => ({ ...c.context._internalState, locked: !1 }) }) }, onError: { target: "Error", actions: "assignErrorDeviceLocked" } } }, AppAndVersionCheck: { invoke: { src: "getAppAndVersion", onDone: { target: "ApplicationAvailableResultCheck", actions: Q({ _internalState: (c) => {
      if (We(c.event.output)) {
        const u = n();
        return u.sessionStateType !== wr.Connected ? i({ ...u, currentApp: c.event.output.data }) : i({ deviceModelId: u.deviceModelId, sessionStateType: wr.ReadyWithoutSecureChannel, deviceStatus: na.CONNECTED, currentApp: c.event.output.data, installedApps: [], isSecureConnectionAllowed: !1 }), { ...c.context._internalState, locked: !1, currentApp: c.event.output.data.name, currentAppVersion: c.event.output.data.version };
      }
      if ("errorCode" in c.event.output.error) {
        if (c.event.output.error.errorCode === "5515") return { ...c.context._internalState, locked: !0 };
        if (c.event.output.error.errorCode === "6e00") return { ...c.context._internalState, locked: !1, currentApp: "BOLOS", currentAppVersion: "0.0.0" };
      }
      return { ...c.context._internalState, error: c.event.output.error };
    } }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, ApplicationAvailableResultCheck: { always: [{ guard: "hasError", target: "Error" }, { target: "UserActionUnlockDevice", guard: "isDeviceLocked" }, { target: "Success" }] }, Success: { type: "final" }, Error: { type: "final" } }, output: (c) => {
      const { context: u } = c, { error: l, currentApp: d, currentAppVersion: f } = u._internalState;
      return l ? N(l) : te({ currentApp: d, currentAppVersion: f });
    } });
  }
  extractDependencies(e) {
    return { getAppAndVersion: () => e.sendCommand(new Oh()), waitForDeviceUnlock: ({ input: t }) => zL(1e3).pipe(Qr(() => rn(e.sendCommand(new Oh()))), cf((n) => !We(n) && "errorCode" in n.error && n.error.errorCode === "5515" ? Rv : Ji(void 0)), HL(1), ML(t.unlockTimeout)), getDeviceSessionState: () => e.getDeviceSessionState(), setDeviceSessionState: (t) => e.setDeviceSessionState(t), isDeviceOnboarded: () => !0 };
  }
}, vn = class {
  constructor(e) {
    h(this, "_tag", "GeneralDmkError");
    h(this, "originalError");
    e instanceof Error ? this.originalError = e : e !== void 0 && (this.originalError = new Error(String(e)));
  }
}, Cz = class extends vn {
  constructor(t) {
    super(t);
    h(this, "_tag", "DeviceAlreadyDiscoveredError");
    this.err = t;
  }
}, Dz = class extends vn {
  constructor(t) {
    super(t);
    h(this, "_tag", "DeviceNotRecognizedError");
    this.err = t;
  }
}, sy = class extends vn {
  constructor(t) {
    super(t);
    h(this, "_tag", "NoAccessibleDeviceError");
    this.err = t;
  }
}, Gs = class extends vn {
  constructor(t) {
    super(t);
    h(this, "_tag", "ConnectionOpeningError");
  }
}, Jl = class extends vn {
  constructor(t) {
    super(t);
    h(this, "_tag", "UnknownDeviceError");
    this.err = t;
  }
}, I1 = class extends vn {
  constructor(t) {
    super(t);
    h(this, "_tag", "TransportNotSupportedError");
    this.err = t;
  }
}, qL = class extends vn {
  constructor(t) {
    super(t);
    h(this, "_tag", "SendApduTimeoutError");
    this.err = t;
  }
}, LT = class extends vn {
  constructor(t) {
    super(t);
    h(this, "_tag", "DeviceNotInitializedError");
    this.err = t;
  }
}, Tz = class extends vn {
  constructor(t) {
    super(t);
    h(this, "_tag", "TransportAlreadyExistsError");
    this.err = t;
  }
}, _s = class extends vn {
  constructor(t) {
    super(t);
    h(this, "_tag", "DeviceDisconnectedWhileSendingError");
    this.err = t;
  }
}, Pb = class extends vn {
  constructor(t) {
    super(t);
    h(this, "_tag", "AlreadySendingApduError");
    this.err = t;
  }
}, kz = class extends vn {
  constructor(t) {
    super(t);
    h(this, "_tag", "DeviceDisconnectedBeforeSendingApdu");
    this.err = t;
  }
}, Oz = class extends vn {
  constructor(t) {
    super(t);
    h(this, "_tag", "NoTransportProvidedError");
    this.err = t;
  }
};
const $z = ["BOLOS", "OLOS", "OLOS\0"], WL = (r) => $z.includes(r);
let uf = class extends Qi {
  makeStateMachine(e) {
    const { closeApp: t, openApp: n, getDeviceSessionState: i, isDeviceOnboarded: s, setDeviceSessionState: o } = this.extractDependencies(e), a = this.input.unlockTimeout ?? fl, c = new KL({ input: { unlockTimeout: a } }).makeStateMachine(e);
    return Or({ actors: { closeApp: tt(t), openApp: tt(n), getDeviceStatus: c }, guards: { isDeviceOnboarded: () => s(), isRequestedAppOpen: ({ context: u }) => u._internalState.currentlyRunningApp === null ? !1 : u._internalState.currentlyRunningApp === u.input.appName, isDashboardOpen: ({ context: u }) => {
      if (u._internalState.currentlyRunningApp === null) throw new Error("context.currentlyRunningApp === null");
      return WL(u._internalState.currentlyRunningApp);
    }, hasDisconnectedWhileSending: ({ context: u }) => u._internalState.error !== null && u._internalState.error instanceof _s, hasError: ({ context: u }) => u._internalState.error !== null }, actions: { assignErrorDeviceNotOnboarded: Q({ _internalState: (u) => ({ ...u.context._internalState, error: new mL() }) }), assignUserActionNeededOpenApp: Q({ intermediateValue: (u) => ({ ...u.context.intermediateValue, requiredUserInteraction: $e.ConfirmOpenApp }) }), assignNoUserActionNeeded: Q({ intermediateValue: (u) => ({ ...u.context.intermediateValue, requiredUserInteraction: $e.None }) }), assignErrorFromEvent: Q({ _internalState: (u) => ({ ...u.context._internalState, error: u.event.error }) }), assignNoError: Q({ _internalState: (u) => ({ ...u.context._internalState, error: null }) }) } }).createMachine({ id: "OpenAppDeviceAction", initial: "DeviceReady", context: ({ input: u }) => {
      const l = i(), { sessionStateType: d } = l;
      return { input: u, intermediateValue: { requiredUserInteraction: $e.None }, _internalState: { error: null, currentlyRunningApp: d === wr.ReadyWithoutSecureChannel ? l.currentApp.name : null } };
    }, states: { DeviceReady: { always: { target: "OnboardingCheck" } }, OnboardingCheck: { always: [{ target: "GetDeviceStatus", guard: { type: "isDeviceOnboarded" } }, { target: "Error", actions: "assignErrorDeviceNotOnboarded" }] }, GetDeviceStatus: { invoke: { id: "deviceStatus", src: "getDeviceStatus", input: (u) => ({ unlockTimeout: u.context.input.unlockTimeout }), onSnapshot: { actions: Q({ intermediateValue: (u) => u.event.snapshot.context.intermediateValue }) }, onDone: { target: "CheckDeviceStatus", actions: Q({ _internalState: (u) => u.event.output.caseOf({ Right: (l) => {
      const d = i();
      return d.sessionStateType !== wr.Connected && o({ ...d, currentApp: { name: l.currentApp, version: l.currentAppVersion } }), { ...u.context._internalState, currentlyRunningApp: l.currentApp };
    }, Left: (l) => ({ ...u.context._internalState, currentlyRunningApp: null, error: l }) }) }) }, onError: { target: "Error", actions: [Q({ _internalState: (u) => ({ ...u.context._internalState, currentlyRunningApp: null }) }), "assignErrorFromEvent"] } } }, CheckDeviceStatus: { always: [{ target: "ApplicationReady", guard: "isRequestedAppOpen", actions: "assignNoError" }, { target: "Error", guard: "hasError" }, { target: "DashboardCheck" }] }, DashboardCheck: { always: [{ target: "OpenApplication", guard: "isDashboardOpen" }, "CloseApplication"] }, OpenApplication: { entry: "assignUserActionNeededOpenApp", exit: "assignNoUserActionNeeded", invoke: { src: "openApp", input: ({ context: u }) => ({ appName: u.input.appName }), onDone: { target: "OpenApplicationResultCheck", actions: Q({ _internalState: (u) => We(u.event.output) ? { ...u.context._internalState, currentlyRunningApp: u.context.input.appName } : { ...u.context._internalState, error: u.event.output.error } }) }, onError: { target: "OpenApplicationResultCheck", actions: "assignErrorFromEvent" } } }, OpenApplicationResultCheck: { always: [{ target: "GetDeviceStatus", guard: "hasDisconnectedWhileSending" }, { target: "Error", guard: "hasError" }, { target: "GetDeviceStatus" }] }, CloseApplication: { invoke: { src: "closeApp", onDone: { target: "CloseApplicationResultCheck", actions: Q({ _internalState: (u) => We(u.event.output) ? { ...u.context._internalState, currentlyRunningApp: "BOLOS" } : { ...u.context._internalState, error: u.event.output.error } }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, CloseApplicationResultCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "OpenApplication" }] }, ApplicationReady: { always: "Success" }, Success: { type: "final", actions: "assignNoError" }, Error: { type: "final" } }, output: ({ context: u }) => u._internalState.error ? N(u._internalState.error) : te(void 0) });
  }
  extractDependencies(e) {
    return { closeApp: async () => e.sendCommand(new $B()), openApp: async (t) => e.sendCommand(new k5({ appName: t.input.appName })), getDeviceSessionState: () => e.getDeviceSessionState(), setDeviceSessionState: (t) => e.setDeviceSessionState(t), isDeviceOnboarded: () => !0 };
  }
}, UT = class extends Qi {
  makeStateMachine(e) {
    const { callTask: t } = this.extractDependencies(e);
    return Or({ actors: { callTask: tt(t), openAppStateMachine: new uf({ input: { appName: this.input.appName } }).makeStateMachine(e) }, guards: { skipOpenApp: () => this.input.skipOpenApp, noInternalError: ({ context: n }) => n._internalState.error === null }, actions: { assignErrorFromEvent: Q({ _internalState: (n) => ({ ...n.context._internalState, error: n.event.error }) }) } }).createMachine({ id: "CallTaskInAppDeviceAction", initial: "InitialState", context: ({ input: n }) => ({ input: n, intermediateValue: { requiredUserInteraction: $e.None }, _internalState: { taskResponse: null, error: null } }), states: { InitialState: { always: [{ target: "CallTask", guard: "skipOpenApp" }, "OpenAppDeviceAction"] }, OpenAppDeviceAction: { invoke: { id: "openAppStateMachine", input: { appName: this.input.appName }, src: "openAppStateMachine", onSnapshot: { actions: Q({ intermediateValue: (n) => n.event.snapshot.context.intermediateValue }) }, onDone: { actions: Q({ _internalState: (n) => n.event.output.caseOf({ Right: () => n.context._internalState, Left: (i) => ({ ...n.context._internalState, error: i }) }) }), target: "CheckOpenAppDeviceActionResult" } } }, CheckOpenAppDeviceActionResult: { always: [{ target: "CallTask", guard: "noInternalError" }, "Error"] }, CallTask: { entry: Q({ intermediateValue: { requiredUserInteraction: this.input.requiredUserInteraction } }), exit: Q({ intermediateValue: { requiredUserInteraction: $e.None } }), invoke: { id: "callTask", src: "callTask", input: (n) => n.context.input.task, onDone: { target: "CallTaskResultCheck", actions: [Q({ _internalState: ({ event: n, context: i }) => We(n.output) ? { ...i._internalState, taskResponse: n.output.data } : { ...i._internalState, error: n.output.error } })] }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, CallTaskResultCheck: { always: [{ target: "Success", guard: "noInternalError" }, "Error"] }, Success: { type: "final" }, Error: { type: "final" } }, output: ({ context: n }) => n._internalState.taskResponse ? te(n._internalState.taskResponse) : N(n._internalState.error || new fo("No error in final state")) });
  }
  extractDependencies(e) {
    return { callTask: (t) => t.input(e) };
  }
}, C1 = class extends Qi {
  makeStateMachine(e) {
    const { getDeviceSessionState: t, setDeviceSessionState: n, closeApp: i, getAppAndVersion: s } = this.extractDependencies(e), o = this.input.unlockTimeout ?? fl, a = new KL({ input: { unlockTimeout: o } }).makeStateMachine(e);
    return Or({ actors: { getAppAndVersion: tt(s), closeApp: tt(i), getDeviceStatus: a }, guards: { hasError: ({ context: c }) => c._internalState.error !== null, isDashboardOpen: ({ context: c }) => c._internalState.currentApp !== null && WL(c._internalState.currentApp) }, actions: { assignErrorFromEvent: Q({ _internalState: (c) => ({ ...c.context._internalState, error: c.event.error }) }) } }).createMachine({ id: "GoToDashboardDeviceAction", initial: "DeviceReady", context: (c) => {
      const u = t();
      return { input: { unlockTimeout: c.input.unlockTimeout }, intermediateValue: { requiredUserInteraction: $e.None }, _internalState: { currentApp: "currentApp" in u ? u.currentApp.name : null, error: null } };
    }, states: { DeviceReady: { always: { target: "GetDeviceStatus" } }, GetDeviceStatus: { invoke: { id: "deviceStatus", src: "getDeviceStatus", input: (c) => ({ unlockTimeout: c.context.input.unlockTimeout }), onSnapshot: { actions: Q({ intermediateValue: (c) => c.event.snapshot.context.intermediateValue }) }, onDone: { target: "CheckDeviceStatus", actions: Q({ _internalState: (c) => c.event.output.caseOf({ Right: (u) => ({ ...c.context._internalState, currentApp: u.currentApp }), Left: (u) => ({ ...c.context._internalState, error: u }) }) }) } } }, CheckDeviceStatus: { always: [{ target: "Error", guard: "hasError" }, { target: "DashboardCheck" }] }, DashboardCheck: { always: [{ target: "Success", guard: "isDashboardOpen" }, { target: "Error", guard: "hasError" }, { target: "Error", guard: (c) => c.context._internalState.currentApp === null, actions: Q({ _internalState: (c) => ({ ...c.context._internalState, error: new fo("currentApp === null") }) }) }, { target: "CloseApp" }] }, CloseApp: { invoke: { src: "closeApp", onDone: { target: "CloseAppCheck", actions: Q({ _internalState: (c) => We(c.event.output) ? c.context._internalState : { ...c.context._internalState, error: c.event.output.error } }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, CloseAppCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "GetAppAndVersion", reenter: !0 }] }, GetAppAndVersion: { invoke: { src: "getAppAndVersion", onDone: { target: "DashboardCheck", actions: Q({ _internalState: (c) => {
      if (We(c.event.output)) {
        const u = t();
        return u.sessionStateType !== wr.Connected && n({ ...u, currentApp: c.event.output.data }), { ...c.context._internalState, currentApp: c.event.output.data.name };
      }
      return { ...c.context._internalState, error: c.event.output.error };
    } }) } } }, Success: { type: "final" }, Error: { type: "final" } }, output: (c) => c.context._internalState.error ? N(c.context._internalState.error) : te(void 0) });
  }
  extractDependencies(e) {
    return { closeApp: async () => e.sendCommand(new $B()), getAppAndVersion: async () => e.sendCommand(new Oh()), getDeviceSessionState: () => e.getDeviceSessionState(), setDeviceSessionState: (t) => e.setDeviceSessionState(t) };
  }
}, Rz = class extends Qi {
  makeStateMachine(e) {
    const { listApps: t } = this.extractDependencies(e), n = this.input.unlockTimeout ?? fl, i = new C1({ input: { unlockTimeout: n } }).makeStateMachine(e);
    return Or({ actors: { listApps: tt(t), goToDashboard: i }, guards: { hasError: ({ context: s }) => s._internalState.error !== null, hasMoreApps: (s) => s.context._internalState.shouldContinue }, actions: { assignAllowListApps: Q({ intermediateValue: (s) => ({ requiredUserInteraction: $e.AllowListApps }) }), assignErrorFromEvent: Q({ _internalState: (s) => ({ ...s.context._internalState, error: s.event.error }) }) } }).createMachine({ id: "ListAppsDeviceAction", initial: "DeviceReady", context: (s) => ({ input: { unlockTimeout: s.input.unlockTimeout }, intermediateValue: { requiredUserInteraction: $e.None }, _internalState: { error: null, apps: [], shouldContinue: !1 } }), states: { DeviceReady: { always: { target: "GoToDashboard" } }, GoToDashboard: { invoke: { id: "dashboard", src: "goToDashboard", input: (s) => ({ unlockTimeout: s.context.input.unlockTimeout }), onSnapshot: { actions: Q({ intermediateValue: (s) => s.event.snapshot.context.intermediateValue }) }, onDone: { target: "GoToDashboardCheck", actions: Q({ _internalState: (s) => s.event.output.caseOf({ Right: () => s.context._internalState, Left: (o) => ({ ...s.context._internalState, error: o }) }) }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, GoToDashboardCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "ListApps" }] }, ListApps: { entry: "assignAllowListApps", invoke: { src: "listApps", input: (s) => !1, onDone: { target: "Continue", actions: Q({ _internalState: (s) => We(s.event.output) ? { ...s.context._internalState, apps: s.context._internalState.apps.concat(s.event.output.data), shouldContinue: s.event.output.data.length >= 2 } : { ...s.context._internalState, error: s.event.output.error }, intermediateValue: (s) => ({ ...s.context.intermediateValue, requiredUserInteraction: $e.None }) }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, ListAppsCheck: { always: [{ target: "Error", guard: "hasError" }, "ListAppsContinue"] }, ListAppsContinue: { invoke: { src: "listApps", input: (s) => !0, onDone: { target: "Continue", actions: Q({ _internalState: (s) => We(s.event.output) ? { ...s.context._internalState, apps: s.context._internalState.apps.concat(s.event.output.data), shouldContinue: s.event.output.data.length >= 2 } : { ...s.context._internalState, error: s.event.output.error } }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, Continue: { always: [{ target: "ListAppsContinue", guard: "hasMoreApps" }, { target: "Success" }] }, Success: { type: "final" }, Error: { type: "final" } }, output: (s) => s.context._internalState.error ? N(s.context._internalState.error) : te(s.context._internalState.apps) });
  }
  extractDependencies(e) {
    return { listApps: async ({ input: t }) => {
      const n = new C5({ isContinue: t });
      return e.sendCommand(n);
    } };
  }
};
const FT = { "662d": { message: "Invalid LIST_ARG, first command must be sent with P1_LIST_LANGUAGE_PACKS_FIRST." } };
let Pz = class extends dl {
  constructor({ message: e, errorCode: t }) {
    super({ message: e, errorCode: t, tag: "ListLanguagePackCommandError" });
  }
}, Nz = class {
  constructor(e) {
    this.args = e;
  }
  getApdu() {
    const e = { cla: 224, ins: 52, p1: this.args.firstChunk ? 0 : 1, p2: 0 };
    return new ot(e).build();
  }
  parseResponse(e) {
    const t = new kr(e);
    if (!Jr.isSuccessResponse(e)) {
      const a = t.encodeToHexaString(e.statusCode);
      return hl(a, FT) ? ye({ error: new Pz({ ...FT[a], errorCode: a }) }) : ye({ error: ha.handle(e) });
    }
    if (t.extract8BitUInt() === void 0) return ye({ data: void 0 });
    t.extract8BitUInt();
    const n = t.extractFieldLVEncoded();
    if (n === void 0) return ye({ error: new ht("Failed to get language pack id") });
    const i = t.extractFieldLVEncoded();
    if (i === void 0) return ye({ error: new ht("Failed to get language pack size") });
    const s = parseInt(It(n), 16), o = parseInt(It(i), 16);
    return ye({ data: { id: s, size: o } });
  }
};
const Bz = "0000000000000000000000000000000000000000000000000000000000000000";
let Lz = class {
  constructor(e, t) {
    this.api = e, this.args = t;
  }
  async run() {
    const e = this.args.installedApps.filter((d) => this.isApplication(d)), t = this.api.getManagerApiService(), n = e.map((d) => d.hash), i = await t.getAppsByHash(n).chain((d) => t.getAppList(this.args.firmwareVersion.metadata).map((f) => ({ applications: d, catalog: f })));
    if (i.isLeft()) return ye({ error: new ht("Cannot get the application catalog") });
    const { applications: s, catalog: o } = i.unsafeCoerce(), a = s.reduce((d, f, p) => {
      if (f !== null) return [...d, f];
      const y = e[p], g = o.find((v) => v.versionName === y.name);
      return g ? [...d, g] : d;
    }, []), c = s.filter((d) => d !== null).reduce((d, f) => {
      const p = o.find((y) => y.versionName === f.versionName);
      return p && Et.gt(p.version, f.version) ? [...d, p] : d;
    }, []);
    let u = [];
    for (let d = 0; ; d++) {
      const f = await this.api.sendCommand(new Nz({ firstChunk: d === 0 }));
      if (!We(f) || f.data === void 0) break;
      u = [...u, f.data];
    }
    const l = await t.getLanguagePackages(this.args.deviceVersion, this.args.firmware);
    return l.isRight() ? ye({ data: { applications: a, applicationsUpdates: c, installedLanguages: u, catalog: { applications: o, languagePackages: l.extract() } } }) : ye({ error: new ht("Cannot get the languages catalog") });
  }
  isApplication(e) {
    return e.hashCode !== Bz;
  }
};
const MT = { "662e": { message: "Invalid state, no background image loaded." }, "662f": { message: "Invalid state, device is in recovery mode." } };
let Uz = class extends dl {
  constructor({ message: e, errorCode: t }) {
    super({ message: e, errorCode: t, tag: "GetCustomImageSizeCommandError" });
  }
}, Fz = class {
  getApdu() {
    const e = { cla: 224, ins: 100, p1: 0, p2: 0 };
    return new ot(e).build();
  }
  parseResponse(e) {
    const t = new kr(e);
    if (!Jr.isSuccessResponse(e)) {
      const i = t.encodeToHexaString(e.statusCode);
      return hl(i, MT) ? ye({ error: new Uz({ ...MT[i], errorCode: i }) }) : ye({ error: ha.handle(e) });
    }
    const n = t.extract32BitUInt();
    return ye(n === void 0 ? { error: new ht("Didn't receive any size") } : { data: n });
  }
}, Mz = class {
  constructor(e) {
    this.api = e;
  }
  async run() {
    const e = await this.api.sendCommand(new UB());
    if (!We(e)) return e;
    const t = { mcu: e.data.mcuSephVersion, bootloader: e.data.mcuBootloaderVersion, os: e.data.seVersion, metadata: e.data }, n = this.api.getManagerApiService(), i = await n.getDeviceVersion(e.data).chain((d) => n.getFirmwareVersion(e.data, d).map((f) => ({ deviceVersion: d, currentFirmware: f })));
    if (i.isLeft()) return ye({ error: new ht("Cannot fetch current firmware metadata") });
    const { deviceVersion: s, currentFirmware: o } = i.unsafeCoerce(), a = (await n.getLatestFirmwareVersion(o, s).chain((d) => n.getNextFirmwareVersion(d).chain((f) => n.getMcuList().map((p) => p.find((y) => y.name === t.mcu)).map((p) => p === void 0 || !f.mcuVersions.includes(p.id)).map((p) => ({ osuFirmware: d, finalFirmware: f, mcuUpdateRequired: p }))))).caseOf({ Right: (d) => d, Left: (d) => {
    } }), c = { currentFirmware: o, availableUpdate: a };
    let u = {};
    const l = await this.api.sendCommand(new Fz());
    return We(l) && (u = { size: l.data }), ye({ data: { deviceVersion: s, firmware: o, firmwareVersion: t, firmwareUpdateContext: c, customImage: u } });
  }
};
function Vz(r) {
  return Array.isArray(r) && r.every((e) => typeof e == "object" && e !== null && "flags" in e && "hash" in e && "hash_code_data" in e && "name" in e && typeof e.flags == "number" && typeof e.hash == "string" && typeof e.hash_code_data == "string" && typeof e.name == "string");
}
var Vl = null;
typeof WebSocket < "u" ? Vl = WebSocket : typeof MozWebSocket < "u" ? Vl = MozWebSocket : typeof global < "u" ? Vl = global.WebSocket || global.MozWebSocket : typeof window < "u" ? Vl = window.WebSocket || window.MozWebSocket : typeof self < "u" && (Vl = self.WebSocket || self.MozWebSocket);
const D1 = Vl;
var zz = ((r) => (r.GenuineCheck = "GenuineCheck", r.ListInstalledApps = "ListInstalledApps", r.UpdateMcu = "UpdateMcu", r.UpdateFirmware = "UpdateFirmware", r.InstallApp = "InstallApp", r.UninstallApp = "UninstallApp", r))(zz || {}), Ia = ((r) => (r.EXCHANGE = "exchange", r.BULK = "bulk", r.ERROR = "error", r.WARNING = "warning", r.SUCCESS = "success", r))(Ia || {}), vS = ((r) => (r.SUCCESS = "success", r.ERROR = "error", r))(vS || {}), lr = ((r) => (r.Opened = "opened", r.Closed = "closed", r.PermissionRequested = "permission-requested", r.PermissionGranted = "permission-granted", r.PreExchange = "pre-exchange", r.Exchange = "exchange", r.Progress = "progress", r.Warning = "warning", r.Error = "error", r.Result = "result", r))(lr || {});
function jz(r) {
  return r[0] === 224 && r[1] === 81;
}
var Zf = ((r) => (r[r.AppAlreadyInstalled = 0] = "AppAlreadyInstalled", r[r.DeviceLocked = 1] = "DeviceLocked", r[r.OutOfMemory = 2] = "OutOfMemory", r[r.RefusedByUser = 3] = "RefusedByUser", r[r.Unknown = 4] = "Unknown", r))(Zf || {});
let Hz = class {
  constructor(e) {
    h(this, "_tag", "WebSocketConnectionError");
    h(this, "originalError");
    this.error = e, this.originalError = e;
  }
}, cn = class {
  constructor(e, t = 4) {
    h(this, "_tag", "SecureChannelError");
    h(this, "originalError");
    this.error = e, this.errorType = t, this.originalError = e;
  }
  mapDAErrors() {
    switch (this.errorType) {
      case 1:
        return new mS();
      case 3:
        return new TT();
      default:
        return this;
    }
  }
  mapInstallDAErrors() {
    switch (this.errorType) {
      case 1:
        return new mS();
      case 3:
        return new TT();
      case 0:
        return new VV();
      case 2:
        return new vL();
      default:
        return this;
    }
  }
}, ZL = class {
  constructor(e, t) {
    h(this, "_connection");
    if (this._api = e, this._args = t, this._args.connection.isRight()) this._connection = this._args.connection.extract();
    else throw new cn(`Invalid WebSocket connection: ${String(this._args.connection.extract())}`);
  }
  run() {
    const e = this._api.disableRefresher("connectToSecureChannel");
    return new mn((t) => {
      let n = !1, i = !1, s = !1;
      const o = (a) => {
        t.next({ type: lr.Error, error: a }), t.complete(), i = !0;
      };
      return this._connection.onopen = () => {
        t.next({ type: lr.Opened });
      }, this._connection.onerror = (a) => {
        i || (t.next({ type: lr.Error, error: new cn({ url: this._connection.url, errorMessage: a.message }) }), t.complete());
      }, this._connection.onclose = () => {
        i || (s ? t.next({ type: lr.Closed }) : t.next({ type: lr.Error, error: new cn({ url: this._connection.url, errorMessage: "Connection closed unexpectedly" }) }), t.complete());
      }, this._connection.onmessage = async (a) => {
        if (n) return;
        let c;
        try {
          const u = JSON.parse(String(a.data));
          if (this.isInMessageType(u)) c = u;
          else throw new Error("Data does not match InMessageType");
        } catch {
          o(new cn({ url: this._connection.url, errorMessage: `Invalid message received: ${String(a.data)}` }));
          return;
        }
        switch (c.query) {
          case Ia.EXCHANGE: {
            const { nonce: u, data: l } = c;
            if (typeof l != "string") {
              o(new cn(`${Ia.EXCHANGE} data type should be an APDU`));
              return;
            }
            const d = _r(l);
            if (d === null || d.length < 5) {
              o(new cn(`Received invalid APDU data: ${l}`));
              return;
            }
            t.next({ type: lr.PreExchange, payload: { nonce: u, apdu: d } });
            let f = !1;
            jz(d) && !this.isSecureConnectionAllowed() && (f = !0, t.next({ type: lr.PermissionRequested }));
            const p = await this._api.sendApdu(d);
            if (n) return;
            p.caseOf({ Left: (y) => {
              o(new cn(y));
            }, Right: (y) => {
              let g;
              const v = this.mapDeviceError(y);
              v === null ? (g = vS.SUCCESS, t.next({ type: lr.Exchange, payload: { nonce: u, apdu: d, data: y.data, status: y.statusCode } }), f && t.next({ type: lr.PermissionGranted })) : (g = vS.ERROR, o(v));
              const _ = { nonce: u, response: g, data: It(y.data, !1) };
              this._connection.send(JSON.stringify(_));
            } });
            break;
          }
          case Ia.BULK: {
            if (i = !0, this._connection.close(), !Array.isArray(c.data) || c.data.length === 0 || !c.data.every((u) => typeof u == "string")) {
              o(new cn("Invalid bulk data received"));
              return;
            }
            for (let u = 0, l = c.data.length; u < l; u++) {
              const d = _r(c.data[u]);
              if (d === null || d.length < 5) {
                o(new cn(`Received invalid APDU bulk data: ${c.data[u]}`));
                return;
              }
              const f = await this._api.sendApdu(d);
              if (n) return;
              if (f.isLeft()) {
                o(new cn(f.extract()));
                return;
              } else if (f.isRight()) {
                const p = this.mapDeviceError(f.extract());
                if (p === null) t.next({ type: lr.Progress, payload: { progress: +Number((u + 1) / l).toFixed(2), index: u, total: l } });
                else {
                  o(p);
                  return;
                }
              }
            }
            s = !0, t.complete();
            break;
          }
          case Ia.SUCCESS: {
            if (i) break;
            const u = c.result ?? c.data;
            u && t.next({ type: lr.Result, payload: u ?? "" }), s = !0, t.complete();
            break;
          }
          case Ia.WARNING: {
            if (i) break;
            t.next({ type: lr.Warning, payload: { message: String(c.data) } });
            break;
          }
          case Ia.ERROR: {
            if (i) break;
            o(new cn({ url: this._connection.url, errorMessage: String(c.data) }));
          }
        }
      }, () => {
        e(), n = !0, this._connection.readyState === D1.OPEN && this._connection.close();
      };
    });
  }
  isSecureConnectionAllowed() {
    const e = this._api.getDeviceSessionState();
    return "isSecureConnectionAllowed" in e && e.isSecureConnectionAllowed;
  }
  isInMessageType(e) {
    if (typeof e != "object" || !e) return !1;
    const t = e;
    return typeof t.uuid == "string" && typeof t.session == "string" && typeof t.query == "string" && Object.values(Ia).includes(t.query) && typeof t.nonce == "number";
  }
  mapDeviceError(e) {
    return Jr.isSuccessResponse(e) ? null : Jr.isLockedDeviceResponse(e) ? new cn({ url: this._connection.url, errorMessage: "Device is locked" }, Zf.DeviceLocked) : Jr.isRefusedByUser(e) ? new cn({ url: this._connection.url, errorMessage: "User refused on the device" }, Zf.RefusedByUser) : Jr.isAppAlreadyInstalled(e) ? new cn({ url: this._connection.url, errorMessage: "App already installed" }, Zf.AppAlreadyInstalled) : Jr.isOutOfMemory(e) ? new cn({ url: this._connection.url, errorMessage: "Out of memory" }, Zf.OutOfMemory) : new cn({ url: this._connection.url, errorMessage: `Invalid status code: ${It(e.statusCode)}` });
  }
}, JL = class extends Qi {
  makeStateMachine(e) {
    const { getDeviceMetadata: t, getFirmwareMetadata: n, getApplicationsMetadata: i, listAppsSecureChannel: s } = this.extractDependencies(e), o = this.input.unlockTimeout ?? fl, a = new C1({ input: { unlockTimeout: o } }).makeStateMachine(e), c = new Rz({ input: { unlockTimeout: o } }).makeStateMachine(e);
    return Or({ actors: { goToDashboard: a, getDeviceMetadata: tt(t), getFirmwareMetadata: tt(n), getApplicationsMetadata: tt(i), listApps: c, listAppsSecureChannel: kv(s) }, guards: { hasError: ({ context: u }) => u._internalState.error !== null, hasMetadata: ({ context: u }) => u._internalState.firmwareVersion !== null && u._internalState.firmwareUpdateContext !== null && u._internalState.customImage !== null && u._internalState.applications !== null && u._internalState.applicationsUpdates !== null && u._internalState.installedLanguages !== null && u._internalState.catalog !== null, forceUpdate: ({ context: u }) => !!u.input.forceUpdate, useSecureChannel: ({ context: u }) => !!u.input.useSecureChannel }, actions: { assignErrorFromEvent: Q({ _internalState: (u) => ({ ...u.context._internalState, error: u.event.error }) }) } }).createMachine({ id: "GetDeviceMetadataDeviceAction", initial: "DeviceReady", context: (u) => ({ input: { useSecureChannel: u.input.useSecureChannel, forceUpdate: u.input.forceUpdate, unlockTimeout: u.input.unlockTimeout }, intermediateValue: { requiredUserInteraction: $e.None }, _internalState: { error: null, deviceVersion: null, firmware: null, firmwareVersion: null, firmwareUpdateContext: null, customImage: null, installedApps: null, applications: null, applicationsUpdates: null, installedLanguages: null, catalog: null } }), states: { DeviceReady: { always: [{ target: "GoToDashboard", guard: "forceUpdate" }, { target: "GetDeviceMetadataFromContext" }] }, GetDeviceMetadataFromContext: { invoke: { src: "getDeviceMetadata", onDone: { target: "GetDeviceMetadataFromContextResultCheck", actions: Q({ _internalState: (u) => u.event.output === null ? u.context._internalState : { ...u.context._internalState, firmwareVersion: u.event.output.firmwareVersion, firmwareUpdateContext: u.event.output.firmwareUpdateContext, customImage: u.event.output.customImage, applications: u.event.output.applications, applicationsUpdates: u.event.output.applicationsUpdates, installedLanguages: u.event.output.installedLanguages, catalog: u.event.output.catalog } }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, GetDeviceMetadataFromContextResultCheck: { always: [{ target: "Success", guard: "hasMetadata" }, { target: "GoToDashboard" }] }, GoToDashboard: { exit: Q({ intermediateValue: { requiredUserInteraction: $e.None } }), invoke: { id: "dashboard", src: "goToDashboard", input: (u) => ({ unlockTimeout: u.context.input.unlockTimeout }), onSnapshot: { actions: Q({ intermediateValue: (u) => u.event.snapshot.context.intermediateValue }) }, onDone: { target: "GoToDashboardCheck", actions: Q({ _internalState: (u) => u.event.output.caseOf({ Right: () => u.context._internalState, Left: (l) => ({ ...u.context._internalState, error: l }) }) }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, GoToDashboardCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "GetFirmwareMetadata" }] }, GetFirmwareMetadata: { invoke: { src: "getFirmwareMetadata", onDone: { target: "GetFirmwareMetadataResultCheck", actions: Q({ _internalState: (u) => {
      if (We(u.event.output)) {
        const l = e.getDeviceSessionState();
        return l.sessionStateType !== wr.Connected && e.setDeviceSessionState({ ...l, firmwareVersion: u.event.output.data.firmwareVersion, firmwareUpdateContext: u.event.output.data.firmwareUpdateContext, customImage: u.event.output.data.customImage }), { ...u.context._internalState, deviceVersion: u.event.output.data.deviceVersion, firmware: u.event.output.data.firmware, firmwareVersion: u.event.output.data.firmwareVersion, firmwareUpdateContext: u.event.output.data.firmwareUpdateContext, customImage: u.event.output.data.customImage };
      }
      return { ...u.context._internalState, error: u.event.output.error };
    } }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, GetFirmwareMetadataResultCheck: { always: [{ guard: "hasError", target: "Error" }, { guard: "useSecureChannel", target: "ListAppsSecureChannel" }, { target: "ListApps" }] }, ListAppsSecureChannel: { exit: Q({ intermediateValue: { requiredUserInteraction: $e.None } }), invoke: { id: "listAppsSecureChannel", src: "listAppsSecureChannel", input: (u) => ({ firmware: u.context._internalState.firmware, firmwareVersion: u.context._internalState.firmwareVersion }), onSnapshot: { actions: Q({ intermediateValue: (u) => {
      var l;
      switch ((l = u.event.snapshot.context) == null ? void 0 : l.type) {
        case lr.PermissionRequested:
          return { requiredUserInteraction: $e.AllowSecureConnection };
        case lr.PermissionGranted: {
          const d = e.getDeviceSessionState();
          return d.sessionStateType !== wr.Connected && e.setDeviceSessionState({ ...d, isSecureConnectionAllowed: !0 }), { requiredUserInteraction: $e.None };
        }
        default:
          return { ...u.context.intermediateValue };
      }
    }, _internalState: (u) => {
      var l, d;
      if (((l = u.event.snapshot.context) == null ? void 0 : l.type) === lr.Error) return { ...u.context._internalState, error: u.event.snapshot.context.error.mapDAErrors() };
      if (((d = u.event.snapshot.context) == null ? void 0 : d.type) === lr.Result) {
        if (Vz(u.event.snapshot.context.payload)) return { ...u.context._internalState, installedApps: u.event.snapshot.context.payload.map((f) => ({ name: f.name, hash: f.hash, hashCode: f.hash_code_data })) };
        throw new Error(`Invalid result ${JSON.stringify(u.event.snapshot.context.payload)}`);
      }
      return { ...u.context._internalState };
    } }) }, onDone: { target: "ListAppsCheck" }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, ListApps: { exit: Q({ intermediateValue: { requiredUserInteraction: $e.None } }), invoke: { id: "listApps", src: "listApps", input: (u) => ({ unlockTimeout: u.context.input.unlockTimeout }), onSnapshot: { actions: Q({ intermediateValue: (u) => u.event.snapshot.context.intermediateValue }) }, onDone: { target: "ListAppsCheck", actions: Q({ _internalState: (u) => u.event.output.isLeft() ? { ...u.context._internalState, error: u.event.output.extract() } : { ...u.context._internalState, installedApps: u.event.output.unsafeCoerce().map((l) => ({ name: l.appName, hash: l.appFullHash, hashCode: l.appCodeHash })) } }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, ListAppsCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "GetApplicationsMetadata" }] }, GetApplicationsMetadata: { invoke: { src: "getApplicationsMetadata", input: (u) => ({ deviceVersion: u.context._internalState.deviceVersion, firmware: u.context._internalState.firmware, firmwareVersion: u.context._internalState.firmwareVersion, installedApps: u.context._internalState.installedApps }), onDone: { target: "GetApplicationsMetadataResultCheck", actions: Q({ _internalState: (u) => {
      if (We(u.event.output)) {
        const l = e.getDeviceSessionState();
        return l.sessionStateType !== wr.Connected && e.setDeviceSessionState({ ...l, installedApps: u.event.output.data.applications, appsUpdates: u.event.output.data.applicationsUpdates, installedLanguages: u.event.output.data.installedLanguages, catalog: u.event.output.data.catalog }), { ...u.context._internalState, applications: u.event.output.data.applications, applicationsUpdates: u.event.output.data.applicationsUpdates, installedLanguages: u.event.output.data.installedLanguages, catalog: u.event.output.data.catalog };
      }
      return { ...u.context._internalState, error: u.event.output.error };
    } }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, GetApplicationsMetadataResultCheck: { always: [{ guard: "hasError", target: "Error" }, { target: "Success" }] }, Success: { type: "final" }, Error: { type: "final" } }, output: (u) => {
      const { context: l } = u, { error: d, firmwareVersion: f, firmwareUpdateContext: p, customImage: y, applications: g, applicationsUpdates: v, installedLanguages: _, catalog: w } = l._internalState;
      return d ? N(d) : te({ firmwareVersion: f, firmwareUpdateContext: p, customImage: y, applications: g, applicationsUpdates: v, installedLanguages: _, catalog: w });
    } });
  }
  extractDependencies(e) {
    return { getDeviceMetadata: async () => {
      var n;
      const t = e.getDeviceSessionState();
      return t.sessionStateType === wr.Connected || ((n = t.firmwareVersion) == null ? void 0 : n.metadata) === void 0 || t.firmwareUpdateContext === void 0 || t.customImage === void 0 || t.installedApps === void 0 || t.installedApps.length === 0 || t.appsUpdates === void 0 || t.installedLanguages === void 0 || t.catalog === void 0 ? null : { firmwareVersion: t.firmwareVersion, firmwareUpdateContext: t.firmwareUpdateContext, customImage: t.customImage, applications: t.installedApps, applicationsUpdates: t.appsUpdates, installedLanguages: t.installedLanguages, catalog: t.catalog };
    }, getFirmwareMetadata: async () => new Mz(e).run(), getApplicationsMetadata: async (t) => new Lz(e, { deviceVersion: t.input.deviceVersion, firmware: t.input.firmware, firmwareVersion: t.input.firmwareVersion, installedApps: t.input.installedApps }).run(), listAppsSecureChannel: (t) => {
      const { firmware: n, firmwareVersion: i } = t.input, s = e.getSecureChannelService().listInstalledApps(i.metadata, n);
      return new ZL(e, { connection: s }).run();
    } };
  }
}, Gz = class {
  constructor(e, t) {
    h(this, "deviceModelId");
    this.api = e, this.args = t;
    const n = e.getDeviceModel();
    this.deviceModelId = n.id;
  }
  run() {
    const e = this.api.getDeviceSessionState();
    if (e.sessionStateType === wr.Connected) return { error: new fo("Invalid device state") };
    if (e.catalog === void 0) return { error: new fo("Device apps metadata not fetched") };
    let t = [], n = [], i = [];
    for (const s of this.args.applications) {
      const o = e.catalog.applications.find((c) => c.versionName === s.name), a = e.installedApps.find((c) => c.versionName === s.name);
      if (a !== void 0 && this.validateConstraint(a, o, s.constraints)) {
        n = [...n, s.name];
        continue;
      }
      if (o !== void 0 && this.validateConstraint(o, void 0, s.constraints)) t = [...t, o];
      else if (this.args.allowMissingApplication) i = [...i, s.name];
      else return o !== void 0 ? { error: new yL(`Application ${s.name} not found in the catalog`) } : { error: new fo(`Application ${s.name} not found in the catalog`) };
    }
    return t = [...t.reduce((s, o) => {
      const a = o.parentName;
      if (a) {
        const c = e.catalog.applications.find((l) => l.versionName === a), u = e.installedApps.find((l) => l.versionName === a);
        if (c && !u) return [...s, c];
      }
      return s;
    }, []), ...t], { installPlan: t.filter((s, o) => t.findIndex((a) => a.versionName === s.versionName) === o), missingApplications: i, alreadyInstalled: n };
  }
  validateConstraint(e, t, n) {
    if (n === void 0) return !0;
    for (const i of n) if (!(i.exemptModels !== void 0 && i.exemptModels.includes(this.deviceModelId)) && !(i.applicableModels !== void 0 && !i.applicableModels.includes(this.deviceModelId))) return i.minVersion === "latest" ? !t || Et.gte(e.version, t.version) : Et.gte(e.version, i.minVersion);
    return !0;
  }
}, Kz = class {
  constructor(e, t) {
    h(this, "blockSize");
    h(this, "memoryBlocks");
    this.api = e, this.args = t;
    const n = e.getDeviceModel();
    this.blockSize = n.blockSize, this.memoryBlocks = Math.floor(n.memorySize / this.blockSize);
  }
  run() {
    const e = this.api.getDeviceSessionState();
    if (e.sessionStateType === wr.Connected) return { error: new fo("Invalid device state") };
    if (e.firmwareUpdateContext === void 0 || e.customImage === void 0 || e.installedLanguages === void 0) return { error: new fo("Device metadata not fetched") };
    const t = this.bytesToBlocks(e.firmwareUpdateContext.currentFirmware.bytes || 0), n = this.bytesToBlocks(e.customImage.size || 0), i = e.installedApps.reduce((c, u) => c + this.bytesToBlocks(u.bytes || 0), 0), s = e.installedLanguages.reduce((c, u) => c + this.bytesToBlocks(u.size), 0), o = t + n + i + s, a = this.memoryBlocks - o;
    return { outOfMemory: this.args.installPlan.reduce((c, u) => c + this.bytesToBlocks(u.bytes || 0), 0) > a };
  }
  bytesToBlocks(e) {
    return Math.ceil(e / this.blockSize);
  }
}, qz = class extends Qi {
  makeStateMachine(e) {
    const { buildInstallPlan: t, predictOutOfMemory: n, installApp: i } = this.extractDependencies(e), s = this.input.unlockTimeout ?? fl, o = new JL({ input: { unlockTimeout: s, useSecureChannel: !0, forceUpdate: !1 } }).makeStateMachine(e), a = new C1({ input: { unlockTimeout: s } }).makeStateMachine(e);
    return Or({ actors: { updateMetadata: o, buildInstallPlan: tt(t), predictOutOfMemory: tt(n), goToDashboard: a, installApp: kv(i) }, guards: { hasError: ({ context: c }) => c._internalState.error !== null, hasInstallPlan: (c) => c.context.intermediateValue.installPlan !== null, hasMoreApps: (c) => c.context._internalState.currentIndex < c.context.intermediateValue.installPlan.installPlan.length }, actions: { assignErrorFromEvent: Q({ _internalState: (c) => ({ ...c.context._internalState, error: c.event.error }) }), nextAppIndex: Q({ _internalState: (c) => ({ ...c.context._internalState, currentIndex: c.context._internalState.currentIndex + 1 }) }), cleanupDeviceState: () => {
      const c = e.getDeviceSessionState();
      c.sessionStateType !== wr.Connected && e.setDeviceSessionState({ ...c, installedApps: [], appsUpdates: void 0 });
    } } }).createMachine({ id: "InstallOrUpdateAppsDeviceAction", initial: "DeviceReady", context: (c) => ({ input: { applications: c.input.applications, allowMissingApplication: c.input.allowMissingApplication, unlockTimeout: c.input.unlockTimeout }, intermediateValue: { requiredUserInteraction: $e.None, installPlan: null }, _internalState: { error: null, osVersion: null, currentIndex: 0 } }), states: { DeviceReady: { always: [{ target: "UpdateDeviceMetadata" }] }, UpdateDeviceMetadata: { exit: Q({ intermediateValue: (c) => ({ ...c.context.intermediateValue, requiredUserInteraction: $e.None }) }), invoke: { id: "updateMetadata", src: "updateMetadata", input: (c) => ({ unlockTimeout: c.context.input.unlockTimeout, useSecureChannel: !0, forceUpdate: !1 }), onSnapshot: { actions: Q({ intermediateValue: (c) => ({ ...c.context.intermediateValue, requiredUserInteraction: c.event.snapshot.context.intermediateValue.requiredUserInteraction }) }) }, onDone: { target: "UpdateDeviceMetadataCheck", actions: Q({ _internalState: (c) => c.event.output.caseOf({ Right: (u) => ({ ...c.context._internalState, osVersion: u.firmwareVersion.metadata }), Left: (u) => ({ ...c.context._internalState, error: u }) }) }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, UpdateDeviceMetadataCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "Success", guard: "hasInstallPlan" }, { target: "BuildInstallPlan" }] }, BuildInstallPlan: { invoke: { src: "buildInstallPlan", input: (c) => ({ applications: c.context.input.applications, allowMissingApplication: c.context.input.allowMissingApplication }), onDone: { target: "BuildInstallPlanCheck", actions: Q({ _internalState: (c) => "error" in c.event.output ? { ...c.context._internalState, error: c.event.output.error } : c.context._internalState, intermediateValue: (c) => "error" in c.event.output ? c.context.intermediateValue : { ...c.context.intermediateValue, installPlan: { installPlan: c.event.output.installPlan, alreadyInstalled: c.event.output.alreadyInstalled, missingApplications: c.event.output.missingApplications, currentIndex: 0, currentProgress: 0 } } }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, BuildInstallPlanCheck: { always: [{ guard: "hasError", target: "Error" }, { target: "PredictOutOfMemory", guard: "hasMoreApps" }, { target: "Success" }] }, PredictOutOfMemory: { invoke: { src: "predictOutOfMemory", input: (c) => ({ installPlan: c.context.intermediateValue.installPlan.installPlan }), onDone: { target: "PredictOutOfMemoryCheck", actions: Q({ _internalState: (c) => "error" in c.event.output ? { ...c.context._internalState, error: c.event.output.error } : c.event.output.outOfMemory ? { ...c.context._internalState, error: new vL("Not enough memory for those applications") } : c.context._internalState }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, PredictOutOfMemoryCheck: { always: [{ guard: "hasError", target: "Error" }, { target: "GoToDashboard" }] }, GoToDashboard: { invoke: { id: "goToDashboard", src: "goToDashboard", input: (c) => ({ unlockTimeout: c.context.input.unlockTimeout }), onSnapshot: { actions: Q({ intermediateValue: (c) => ({ ...c.context.intermediateValue, requiredUserInteraction: c.event.snapshot.context.intermediateValue.requiredUserInteraction }) }) }, onDone: { target: "GoToDashboardCheck", actions: Q({ _internalState: (c) => c.event.output.caseOf({ Right: () => c.context._internalState, Left: (u) => ({ ...c.context._internalState, error: u }) }) }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, GoToDashboardCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "InstallApp", actions: "cleanupDeviceState" }] }, InstallApp: { exit: Q({ intermediateValue: (c) => ({ ...c.context.intermediateValue, requiredUserInteraction: $e.None }) }), invoke: { id: "installApp", src: "installApp", input: (c) => ({ osVersion: c.context._internalState.osVersion, application: c.context.intermediateValue.installPlan.installPlan[c.context._internalState.currentIndex] }), onSnapshot: { actions: Q({ intermediateValue: (c) => {
      var u;
      switch ((u = c.event.snapshot.context) == null ? void 0 : u.type) {
        case lr.PermissionRequested:
          return { ...c.context.intermediateValue, requiredUserInteraction: $e.AllowSecureConnection };
        case lr.PermissionGranted: {
          const l = e.getDeviceSessionState();
          return l.sessionStateType !== wr.Connected && e.setDeviceSessionState({ ...l, isSecureConnectionAllowed: !0 }), { ...c.context.intermediateValue, requiredUserInteraction: $e.None };
        }
        case lr.Progress:
          return { ...c.context.intermediateValue, installPlan: { ...c.context.intermediateValue.installPlan, currentIndex: c.context._internalState.currentIndex, currentProgress: c.event.snapshot.context.payload.progress } };
        default:
          return c.context.intermediateValue;
      }
    }, _internalState: (c) => {
      var u;
      return ((u = c.event.snapshot.context) == null ? void 0 : u.type) === lr.Error ? { ...c.context._internalState, error: c.event.snapshot.context.error.mapInstallDAErrors() } : c.context._internalState;
    } }) }, onDone: { target: "InstallAppCheck", actions: "nextAppIndex" }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, InstallAppCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "InstallApp", guard: "hasMoreApps" }, { target: "UpdateDeviceMetadata" }] }, Success: { type: "final" }, Error: { type: "final" } }, output: (c) => {
      const { context: u } = c, { error: l } = u._internalState, { installPlan: d } = u.intermediateValue;
      return l ? N(l) : te({ successfullyInstalled: d.installPlan, alreadyInstalled: d.alreadyInstalled, missingApplications: d.missingApplications });
    } });
  }
  extractDependencies(e) {
    return { buildInstallPlan: async (t) => new Gz(e, { applications: t.input.applications, allowMissingApplication: t.input.allowMissingApplication }).run(), predictOutOfMemory: async (t) => new Kz(e, { installPlan: t.input.installPlan }).run(), installApp: (t) => {
      const { osVersion: n, application: i } = t.input, s = e.getSecureChannelService().installApp(n, i);
      return new ZL(e, { connection: s }).run();
    } };
  }
}, T1 = class extends Qi {
  makeStateMachine(e) {
    const t = this.input.unlockTimeout ?? fl, n = new JL({ input: { unlockTimeout: t, useSecureChannel: !0, forceUpdate: !1 } }).makeStateMachine(e), i = new qz({ input: { unlockTimeout: t, applications: [...this.input.dependencies, this.input.application], allowMissingApplication: !1 } }).makeStateMachine(e), s = new uf({ input: { unlockTimeout: t, appName: this.input.application.name } }).makeStateMachine(e);
    return Or({ actors: { getMetadata: n, installApps: i, openApp: s }, guards: { hasError: ({ context: o }) => o._internalState.error !== null }, actions: { assignErrorFromEvent: Q({ _internalState: (o) => ({ ...o.context._internalState, error: o.event.error }) }) } }).createMachine({ id: "OpenAppWithDependenciesDeviceAction", initial: "DeviceReady", context: (o) => ({ input: { application: o.input.application, dependencies: o.input.dependencies, requireLatestFirmware: o.input.requireLatestFirmware, unlockTimeout: o.input.unlockTimeout }, intermediateValue: { requiredUserInteraction: $e.None, installPlan: null }, _internalState: { error: null, deviceMetadata: null, installResult: null } }), states: { DeviceReady: { always: [{ target: "GetDeviceMetadata" }] }, GetDeviceMetadata: { exit: Q({ intermediateValue: (o) => ({ ...o.context.intermediateValue, requiredUserInteraction: $e.None }) }), invoke: { id: "getMetadata", src: "getMetadata", input: (o) => ({ unlockTimeout: o.context.input.unlockTimeout, useSecureChannel: !0, forceUpdate: !1 }), onSnapshot: { actions: Q({ intermediateValue: (o) => ({ ...o.context.intermediateValue, requiredUserInteraction: o.event.snapshot.context.intermediateValue.requiredUserInteraction }) }) }, onDone: { target: "GetDeviceMetadataCheck", actions: Q({ _internalState: (o) => o.event.output.caseOf({ Right: (a) => o.context.input.requireLatestFirmware && a.firmwareUpdateContext.availableUpdate !== void 0 ? { ...o.context._internalState, error: new yL("Firmware is not the latest version") } : { ...o.context._internalState, deviceMetadata: a }, Left: (a) => ({ ...o.context._internalState, error: a }) }) }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, GetDeviceMetadataCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "InstallDependencies" }] }, InstallDependencies: { exit: Q({ intermediateValue: (o) => ({ ...o.context.intermediateValue, requiredUserInteraction: $e.None }) }), invoke: { src: "installApps", input: (o) => ({ unlockTimeout: o.context.input.unlockTimeout, applications: [...o.context.input.dependencies, o.context.input.application], allowMissingApplication: !1 }), onSnapshot: { actions: Q({ intermediateValue: (o) => ({ ...o.context.intermediateValue, requiredUserInteraction: o.event.snapshot.context.intermediateValue.requiredUserInteraction, installPlan: o.event.snapshot.context.intermediateValue.installPlan }) }) }, onDone: { target: "InstallDependenciesCheck", actions: Q({ _internalState: (o) => o.event.output.caseOf({ Right: (a) => ({ ...o.context._internalState, installResult: a }), Left: (a) => ({ ...o.context._internalState, error: a }) }) }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, InstallDependenciesCheck: { always: [{ guard: "hasError", target: "Error" }, { target: "OpenApp" }] }, OpenApp: { exit: Q({ intermediateValue: (o) => ({ ...o.context.intermediateValue, requiredUserInteraction: $e.None }) }), invoke: { src: "openApp", input: (o) => ({ unlockTimeout: o.context.input.unlockTimeout, appName: o.context.input.application.name }), onSnapshot: { actions: Q({ intermediateValue: (o) => ({ ...o.context.intermediateValue, requiredUserInteraction: o.event.snapshot.context.intermediateValue.requiredUserInteraction, installPlan: null }) }) }, onDone: { target: "OpenAppCheck", actions: Q({ _internalState: (o) => o.event.output.caseOf({ Right: () => o.context._internalState, Left: (a) => ({ ...o.context._internalState, error: a }) }) }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, OpenAppCheck: { always: [{ guard: "hasError", target: "Error" }, { target: "Success" }] }, Success: { type: "final" }, Error: { type: "final" } }, output: (o) => {
      const { context: a } = o, { error: c, deviceMetadata: u, installResult: l } = a._internalState;
      return c ? N(c) : te({ deviceMetadata: u, installResult: l });
    } });
  }
}, Wz = class extends Qi {
  makeStateMachine(e) {
    const { sendCommand: t } = this.extractDependencies(e);
    return Or({ actors: { sendCommand: tt(t), openAppStateMachine: new uf({ input: { appName: this.input.appName } }).makeStateMachine(e) }, guards: { skipOpenApp: () => this.input.skipOpenApp, noInternalError: ({ context: n }) => n._internalState.error === null }, actions: { assignErrorFromEvent: Q({ _internalState: (n) => ({ ...n.context._internalState, error: n.event.error }) }) } }).createMachine({ id: "SendCommandInAppDeviceAction", initial: "InitialState", context: ({ input: n }) => ({ input: n, intermediateValue: { requiredUserInteraction: $e.None }, _internalState: { commandResponse: null, error: null } }), states: { InitialState: { always: [{ target: "SendCommand", guard: "skipOpenApp" }, "OpenAppDeviceAction"] }, OpenAppDeviceAction: { invoke: { id: "openAppStateMachine", input: { appName: this.input.appName }, src: "openAppStateMachine", onSnapshot: { actions: Q({ intermediateValue: (n) => n.event.snapshot.context.intermediateValue }) }, onDone: { actions: Q({ _internalState: (n) => n.event.output.caseOf({ Right: () => n.context._internalState, Left: (i) => ({ ...n.context._internalState, error: i }) }) }), target: "CheckOpenAppDeviceActionResult" } } }, CheckOpenAppDeviceActionResult: { always: [{ target: "SendCommand", guard: "noInternalError" }, "Error"] }, SendCommand: { entry: Q({ intermediateValue: { requiredUserInteraction: this.input.requiredUserInteraction } }), exit: Q({ intermediateValue: { requiredUserInteraction: $e.None } }), invoke: { id: "sendCommand", src: "sendCommand", input: ({ context: n }) => n.input.command, onDone: { target: "SendCommandResultCheck", actions: [Q({ _internalState: ({ event: n, context: i }) => We(n.output) ? { ...i._internalState, commandResponse: n.output.data } : { ...i._internalState, error: n.output.error } })] }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, SendCommandResultCheck: { always: [{ target: "Success", guard: "noInternalError" }, "Error"] }, Success: { type: "final" }, Error: { type: "final" } }, output: ({ context: n }) => n._internalState.commandResponse ? te(n._internalState.commandResponse) : N(n._internalState.error || new fo("No error in final state")) });
  }
  extractDependencies(e) {
    return { sendCommand: (t) => e.sendCommand(t.input) };
  }
};
function Tr(r) {
  return (typeof r == "object" && r !== null || typeof r == "function") && typeof r.then == "function";
}
function Jn(r) {
  switch (typeof r) {
    case "string":
    case "symbol":
      return r.toString();
    case "function":
      return r.name;
    default:
      throw new Error(`Unexpected ${typeof r} service id type`);
  }
}
const Nb = Symbol.for("@inversifyjs/common/islazyServiceIdentifier");
var YN, cg, QN;
let k1 = (YN = Nb, QN = class {
  constructor(e) {
    h(this, YN);
    L(this, cg);
    D(this, cg, e), this[Nb] = !0;
  }
  static is(e) {
    return typeof e == "object" && e !== null && e[Nb] === !0;
  }
  unwrap() {
    return m(this, cg).call(this);
  }
}, cg = new WeakMap(), QN);
function qu(r, e) {
  return Reflect.getOwnMetadata(e, r);
}
function O1(r, e, t) {
  Reflect.defineMetadata(e, t, r);
}
function Du(r, e, t, n) {
  const i = n(qu(r, e) ?? t());
  Reflect.defineMetadata(e, i, r);
}
const Bb = "@inversifyjs/container/bindingId";
function Ca() {
  const r = qu(Object, Bb) ?? 0;
  return r === Number.MAX_SAFE_INTEGER ? O1(Object, Bb, Number.MIN_SAFE_INTEGER) : Du(Object, Bb, (() => r), ((e) => e + 1)), r;
}
const Cs = { Request: "Request", Singleton: "Singleton", Transient: "Transient" }, dr = { ConstantValue: "ConstantValue", DynamicValue: "DynamicValue", Factory: "Factory", Instance: "Instance", Provider: "Provider", ResolvedValue: "ResolvedValue", ServiceRedirection: "ServiceRedirection" };
function* XL(...r) {
  for (const e of r) yield* e;
}
var qs, mi, Id, $i, YL, QL, bS, eU, tU, Cd;
let $1 = (Cd = class {
  constructor(e) {
    L(this, $i);
    L(this, qs);
    L(this, mi);
    L(this, Id);
    D(this, qs, /* @__PURE__ */ new Map()), D(this, mi, {});
    for (const t of Reflect.ownKeys(e)) m(this, mi)[t] = /* @__PURE__ */ new Map();
    D(this, Id, e);
  }
  add(e, t) {
    R(this, $i, YL).call(this, e).push(t);
    for (const n of Reflect.ownKeys(t)) R(this, $i, QL).call(this, n, t[n]).push(e);
  }
  clone() {
    const e = Reflect.ownKeys(m(this, Id)), t = new Cd(m(this, Id));
    R(this, $i, bS).call(this, m(this, qs), m(t, qs));
    for (const n of e) R(this, $i, bS).call(this, m(this, mi)[n], m(t, mi)[n]);
    return t;
  }
  get(e, t) {
    return m(this, mi)[e].get(t);
  }
  getAllKeys(e) {
    return m(this, mi)[e].keys();
  }
  removeByRelation(e, t) {
    const n = this.get(e, t);
    if (n === void 0) return;
    const i = new Set(n);
    for (const s of i) {
      const o = m(this, qs).get(s);
      if (o === void 0) throw new Error("Expecting model relation, none found");
      for (const a of o) a[e] === t && R(this, $i, eU).call(this, s, a);
      m(this, qs).delete(s);
    }
  }
}, qs = new WeakMap(), mi = new WeakMap(), Id = new WeakMap(), $i = new WeakSet(), YL = function(e) {
  let t = m(this, qs).get(e);
  return t === void 0 && (t = [], m(this, qs).set(e, t)), t;
}, QL = function(e, t) {
  let n = m(this, mi)[e].get(t);
  return n === void 0 && (n = [], m(this, mi)[e].set(t, n)), n;
}, bS = function(e, t) {
  for (const [n, i] of e) t.set(n, [...i]);
}, eU = function(e, t) {
  for (const n of Reflect.ownKeys(t)) R(this, $i, tU).call(this, e, n, t[n]);
}, tU = function(e, t, n) {
  const i = m(this, mi)[t].get(n);
  if (i !== void 0) {
    const s = i.indexOf(e);
    s !== -1 && i.splice(s, 1), i.length === 0 && m(this, mi)[t].delete(n);
  }
}, Cd);
var xp, Bi, Ap;
(function(r) {
  r.moduleId = "moduleId", r.serviceId = "serviceId";
})(xp || (xp = {}));
var Ho, Dd, Fu;
let VT = (Fu = class {
  constructor(e, t) {
    L(this, Ho);
    L(this, Dd);
    D(this, Ho, t ?? new $1({ moduleId: { isOptional: !0 }, serviceId: { isOptional: !1 } })), D(this, Dd, e);
  }
  static build(e) {
    return new Fu(e);
  }
  add(e, t) {
    m(this, Ho).add(e, t);
  }
  clone() {
    return new Fu(m(this, Dd), m(this, Ho).clone());
  }
  get(e) {
    var s;
    const t = [], n = m(this, Ho).get(xp.serviceId, e);
    n !== void 0 && t.push(n);
    const i = (s = m(this, Dd)) == null ? void 0 : s.get(e);
    if (i !== void 0 && t.push(i), t.length !== 0) return XL(...t);
  }
  removeAllByModuleId(e) {
    m(this, Ho).removeByRelation(xp.moduleId, e);
  }
  removeAllByServiceId(e) {
    m(this, Ho).removeByRelation(xp.serviceId, e);
  }
}, Ho = new WeakMap(), Dd = new WeakMap(), Fu);
(function(r) {
  r.id = "id", r.moduleId = "moduleId", r.serviceId = "serviceId";
})(Bi || (Bi = {}));
var yi, Ua, Mu;
let zT = (Mu = class {
  constructor(e, t) {
    L(this, yi);
    L(this, Ua);
    D(this, yi, t ?? new $1({ id: { isOptional: !1 }, moduleId: { isOptional: !0 }, serviceId: { isOptional: !1 } })), D(this, Ua, e);
  }
  static build(e) {
    return new Mu(e);
  }
  clone() {
    return new Mu(m(this, Ua), m(this, yi).clone());
  }
  get(e) {
    var t;
    return this.getNonParentBindings(e) ?? ((t = m(this, Ua)) == null ? void 0 : t.get(e));
  }
  getById(e) {
    var t;
    return m(this, yi).get(Bi.id, e) ?? ((t = m(this, Ua)) == null ? void 0 : t.getById(e));
  }
  getByModuleId(e) {
    var t;
    return m(this, yi).get(Bi.moduleId, e) ?? ((t = m(this, Ua)) == null ? void 0 : t.getByModuleId(e));
  }
  getNonParentBindings(e) {
    return m(this, yi).get(Bi.serviceId, e);
  }
  getNonParentBoundServices() {
    return m(this, yi).getAllKeys(Bi.serviceId);
  }
  removeById(e) {
    m(this, yi).removeByRelation(Bi.id, e);
  }
  removeAllByModuleId(e) {
    m(this, yi).removeByRelation(Bi.moduleId, e);
  }
  removeAllByServiceId(e) {
    m(this, yi).removeByRelation(Bi.serviceId, e);
  }
  set(e) {
    const t = { [Bi.id]: e.id, [Bi.serviceId]: e.serviceIdentifier };
    e.moduleId !== void 0 && (t[Bi.moduleId] = e.moduleId), m(this, yi).add(e, t);
  }
}, yi = new WeakMap(), Ua = new WeakMap(), Mu);
(function(r) {
  r.moduleId = "moduleId", r.serviceId = "serviceId";
})(Ap || (Ap = {}));
var Go, Td, Vu;
let jT = (Vu = class {
  constructor(e, t) {
    L(this, Go);
    L(this, Td);
    D(this, Go, t ?? new $1({ moduleId: { isOptional: !0 }, serviceId: { isOptional: !1 } })), D(this, Td, e);
  }
  static build(e) {
    return new Vu(e);
  }
  add(e, t) {
    m(this, Go).add(e, t);
  }
  clone() {
    return new Vu(m(this, Td), m(this, Go).clone());
  }
  get(e) {
    var s;
    const t = [], n = m(this, Go).get(Ap.serviceId, e);
    n !== void 0 && t.push(n);
    const i = (s = m(this, Td)) == null ? void 0 : s.get(e);
    if (i !== void 0 && t.push(i), t.length !== 0) return XL(...t);
  }
  removeAllByModuleId(e) {
    m(this, Go).removeByRelation(Ap.moduleId, e);
  }
  removeAllByServiceId(e) {
    m(this, Go).removeByRelation(Ap.serviceId, e);
  }
}, Go = new WeakMap(), Td = new WeakMap(), Vu);
const Ip = "@inversifyjs/core/classMetadataReflectKey";
function Cp() {
  return { constructorArguments: [], lifecycle: { postConstructMethodName: void 0, preDestroyMethodName: void 0 }, properties: /* @__PURE__ */ new Map(), scope: void 0 };
}
const rU = "@inversifyjs/core/pendingClassMetadataCountReflectKey", Lb = Symbol.for("@inversifyjs/core/InversifyCoreError");
var eB, tB;
let fr = class nU extends (tB = Error, eB = Lb, tB) {
  constructor(t, n, i) {
    super(n, i);
    h(this, eB);
    h(this, "kind");
    this[Lb] = !0, this.kind = t;
  }
  static is(t) {
    return typeof t == "object" && t !== null && t[Lb] === !0;
  }
  static isErrorOfKind(t, n) {
    return nU.is(t) && t.kind === n;
  }
};
var nr, Lh, gc;
function Ny(r) {
  const e = qu(r, Ip) ?? Cp();
  if (!(function(t) {
    const n = qu(t, rU);
    return n !== void 0 && n !== 0;
  })(r)) return (function(t, n) {
    const i = [];
    if (n.length < t.length) throw new fr(nr.missingInjectionDecorator, `Found unexpected missing metadata on type "${t.name}". "${t.name}" constructor requires at least ${t.length.toString()} arguments, found ${n.length.toString()} instead.
Are you using @inject, @multiInject or @unmanaged decorators in every non optional constructor argument?

If you're using typescript and want to rely on auto injection, set "emitDecoratorMetadata" compiler option to true`);
    for (let s = 0; s < n.length; ++s) n[s] === void 0 && i.push(s);
    if (i.length > 0) throw new fr(nr.missingInjectionDecorator, `Found unexpected missing metadata on type "${t.name}" at constructor indexes "${i.join('", "')}".

Are you using @inject, @multiInject or @unmanaged decorators at those indexes?

If you're using typescript and want to rely on auto injection, set "emitDecoratorMetadata" compiler option to true`);
  })(r, e.constructorArguments), e;
  (function(t, n) {
    const i = [];
    for (let s = 0; s < n.constructorArguments.length; ++s) {
      const o = n.constructorArguments[s];
      o !== void 0 && o.kind !== Lh.unknown || i.push(`  - Missing or incomplete metadata for type "${t.name}" at constructor argument with index ${s.toString()}.
Every constructor parameter must be decorated either with @inject, @multiInject or @unmanaged decorator.`);
    }
    for (const [s, o] of n.properties) o.kind === Lh.unknown && i.push(`  - Missing or incomplete metadata for type "${t.name}" at property "${s.toString()}".
This property must be decorated either with @inject or @multiInject decorator.`);
    throw i.length === 0 ? new fr(nr.unknown, `Unexpected class metadata for type "${t.name}" with uncompletion traces.
This might be caused by one of the following reasons:

1. A third party library is targeting inversify reflection metadata.
2. A bug is causing the issue. Consider submiting an issue to fix it.`) : new fr(nr.missingInjectionDecorator, `Invalid class metadata at type ${t.name}:

${i.join(`

`)}`);
  })(r, e);
}
function Zz() {
  return 0;
}
function Jz(r) {
  return (e) => {
    e !== void 0 && e.kind === Lh.unknown && Du(r, rU, Zz, ((t) => t - 1));
  };
}
function Xz(r, e) {
  return (...t) => (n) => {
    if (n === void 0) return r(...t);
    if (n.kind === gc.unmanaged) throw new fr(nr.injectionDecoratorConflict, "Unexpected injection found. Multiple @inject, @multiInject or @unmanaged decorators found");
    return e(n, ...t);
  };
}
function Yz(r) {
  if (r.kind !== Lh.unknown && r.isFromTypescriptParamType !== !0) throw new fr(nr.injectionDecoratorConflict, "Unexpected injection found. Multiple @inject, @multiInject or @unmanaged decorators found");
}
(function(r) {
  r[r.injectionDecoratorConflict = 0] = "injectionDecoratorConflict", r[r.missingInjectionDecorator = 1] = "missingInjectionDecorator", r[r.planning = 2] = "planning", r[r.resolution = 3] = "resolution", r[r.unknown = 4] = "unknown";
})(nr || (nr = {})), (function(r) {
  r[r.unknown = 32] = "unknown";
})(Lh || (Lh = {})), (function(r) {
  r[r.multipleInjection = 0] = "multipleInjection", r[r.singleInjection = 1] = "singleInjection", r[r.unmanaged = 2] = "unmanaged";
})(gc || (gc = {}));
const Qz = Xz((function(r, e) {
  return { kind: r, name: void 0, optional: !1, tags: /* @__PURE__ */ new Map(), value: e };
}), (function(r, e, t) {
  return Yz(r), { ...r, kind: e, value: t };
}));
function HT(r, e) {
  return (t) => {
    const n = t.properties.get(e);
    return t.properties.set(e, r(n)), t;
  };
}
var Ta;
function ej(r, e, t, n) {
  if (fr.isErrorOfKind(n, nr.injectionDecoratorConflict)) {
    const i = (function(s, o, a) {
      if (a === void 0) {
        if (o === void 0) throw new fr(nr.unknown, "Unexpected undefined property and index values");
        return { kind: Ta.property, property: o, targetClass: s.constructor };
      }
      return typeof a == "number" ? { index: a, kind: Ta.parameter, targetClass: s } : { kind: Ta.method, method: o, targetClass: s };
    })(r, e, t);
    throw new fr(nr.injectionDecoratorConflict, `Unexpected injection error.

Cause:

${n.message}

Details

${(function(s) {
      switch (s.kind) {
        case Ta.method:
          return `[class: "${s.targetClass.name}", method: "${s.method.toString()}"]`;
        case Ta.parameter:
          return `[class: "${s.targetClass.name}", index: "${s.index.toString()}"]`;
        case Ta.property:
          return `[class: "${s.targetClass.name}", property: "${s.property.toString()}"]`;
      }
    })(i)}`, { cause: n });
  }
  throw n;
}
function tj(r, e) {
  return (t, n, i) => {
    try {
      i === void 0 ? (function(s, o) {
        const a = Ub(s, o);
        return (c, u) => {
          Du(c.constructor, Ip, Cp, HT(a(c), u));
        };
      })(r, e)(t, n) : typeof i == "number" ? (function(s, o) {
        const a = Ub(s, o);
        return (c, u, l) => {
          if (!/* @__PURE__ */ (function(d, f) {
            return typeof d == "function" && f === void 0;
          })(c, u)) throw new fr(nr.injectionDecoratorConflict, `Found an @inject decorator in a non constructor parameter.
Found @inject decorator at method "${(u == null ? void 0 : u.toString()) ?? ""}" at class "${c.constructor.name}"`);
          Du(c, Ip, Cp, /* @__PURE__ */ (function(d, f) {
            return (p) => {
              const y = p.constructorArguments[f];
              return p.constructorArguments[f] = d(y), p;
            };
          })(a(c), l));
        };
      })(r, e)(t, n, i) : (function(s, o) {
        const a = Ub(s, o);
        return (c, u, l) => {
          if (!(function(d) {
            return d.set !== void 0;
          })(l)) throw new fr(nr.injectionDecoratorConflict, `Found an @inject decorator in a non setter property method.
Found @inject decorator at method "${u.toString()}" at class "${c.constructor.name}"`);
          Du(c.constructor, Ip, Cp, HT(a(c), u));
        };
      })(r, e)(t, n, i);
    } catch (s) {
      ej(t, n, i, s);
    }
  };
}
function Ub(r, e) {
  return (t) => {
    const n = e(t);
    return (i) => (n(i), r(i));
  };
}
function X(r) {
  return tj(Qz(gc.singleInjection, r), Jz);
}
(function(r) {
  r[r.method = 0] = "method", r[r.parameter = 1] = "parameter", r[r.property = 2] = "property";
})(Ta || (Ta = {}));
const GT = "@inversifyjs/core/classIsInjectableFlagReflectKey", rj = [Array, BigInt, Boolean, Function, Number, Object, String];
function nj(r) {
  const e = qu(r, "design:paramtypes");
  e !== void 0 && Du(r, Ip, Cp, /* @__PURE__ */ (function(t) {
    return (n) => (t.forEach(((i, s) => {
      var o;
      n.constructorArguments[s] !== void 0 || (o = i, rj.includes(o)) || (n.constructorArguments[s] = (function(a) {
        return { isFromTypescriptParamType: !0, kind: gc.singleInjection, name: void 0, optional: !1, tags: /* @__PURE__ */ new Map(), value: a };
      })(i));
    })), n);
  })(e));
}
function le(r) {
  return (e) => {
    (function(t) {
      if (qu(t, GT) !== void 0) throw new fr(nr.injectionDecoratorConflict, `Cannot apply @injectable decorator multiple times at class "${t.name}"`);
      O1(t, GT, !0);
    })(e), nj(e);
  };
}
var dd;
(function(r) {
  r[r.multipleInjection = 0] = "multipleInjection", r[r.singleInjection = 1] = "singleInjection";
})(dd || (dd = {}));
var Ko;
const sD = class sD {
  constructor(e) {
    L(this, Ko);
    D(this, Ko, e);
  }
  get name() {
    return m(this, Ko).elem.name;
  }
  get serviceIdentifier() {
    return m(this, Ko).elem.serviceIdentifier;
  }
  get tags() {
    return m(this, Ko).elem.tags;
  }
  getAncestor() {
    if (m(this, Ko).previous !== void 0) return new sD(m(this, Ko).previous);
  }
};
Ko = new WeakMap();
let Uh = sD, ij = class iU {
  constructor(e) {
    h(this, "last");
    this.last = e;
  }
  concat(e) {
    return new iU({ elem: e, previous: this.last });
  }
  [Symbol.iterator]() {
    let e = this.last;
    return { next: () => {
      if (e === void 0) return { done: !0, value: void 0 };
      const t = e.elem;
      return e = e.previous, { done: !1, value: t };
    } };
  }
};
function Nv(r, e, t) {
  const n = (t == null ? void 0 : t.customServiceIdentifier) ?? e.serviceIdentifier, i = [...r.getBindings(n) ?? []].filter(((s) => s.isSatisfiedBy(e)));
  if (i.length === 0 && r.autobindOptions !== void 0 && typeof n == "function") {
    const s = (function(o, a) {
      const c = Ny(a), u = c.scope ?? o.scope;
      return { cache: { isRight: !1, value: void 0 }, id: Ca(), implementationType: a, isSatisfiedBy: () => !0, moduleId: void 0, onActivation: void 0, onDeactivation: void 0, scope: u, serviceIdentifier: a, type: dr.Instance };
    })(r.autobindOptions, n);
    r.setBinding(s), i.push(s);
  }
  return i;
}
function Wu(r) {
  return r.redirections !== void 0;
}
function sU(r, e, t, n) {
  var o;
  let i, s;
  Wu(t) ? (i = t.binding.targetServiceIdentifier, s = t.binding.serviceIdentifier) : (i = t.serviceIdentifier, s = (o = t.parent) == null ? void 0 : o.binding.serviceIdentifier), Array.isArray(r) ? (function(a, c, u, l, d) {
    if (a.length !== 0) {
      const f = `Ambiguous bindings found for service: "${Jn(u)}".

Registered bindings:

${a.map(((p) => (function(y) {
        switch (y.type) {
          case dr.Instance:
            return `[ type: "${y.type}", serviceIdentifier: "${Jn(y.serviceIdentifier)}", scope: "${y.scope}", implementationType: "${y.implementationType.name}" ]`;
          case dr.ServiceRedirection:
            return `[ type: "${y.type}", serviceIdentifier: "${Jn(y.serviceIdentifier)}", redirection: "${Jn(y.targetServiceIdentifier)}" ]`;
          default:
            return `[ type: "${y.type}", serviceIdentifier: "${Jn(y.serviceIdentifier)}", scope: "${y.scope}" ]`;
        }
      })(p.binding))).join(`
`)}

Trying to resolve bindings for "${oU(u, l)}".

${aU(d)}`;
      throw new fr(nr.planning, f);
    }
    c || KT(u, l, d);
  })(r, e, i, s, n) : (function(a, c, u, l, d) {
    a !== void 0 || c || KT(u, l, d);
  })(r, e, i, s, n);
}
function KT(r, e, t) {
  const n = `No bindings found for service: "${Jn(r)}".

Trying to resolve bindings for "${oU(r, e)}".

${aU(t)}`;
  throw new fr(nr.planning, n);
}
function oU(r, e) {
  return e === void 0 ? `${Jn(r)} (Root service)` : Jn(e);
}
function aU(r) {
  var t;
  const e = r.tags.size === 0 ? "" : `
- tags:
  - ${[...r.tags.keys()].map(((n) => n.toString())).join(`
  - `)}`;
  return `Binding constraints:
- service identifier: ${Jn(r.serviceIdentifier)}
- name: ${((t = r.name) == null ? void 0 : t.toString()) ?? "-"}${e}`;
}
function cU(r, e, t) {
  if (r.redirections.length !== 1) sU(r.redirections, e, r, t);
  else {
    const [n] = r.redirections;
    Wu(n) && cU(n, e, t);
  }
}
function R1(r, e, t) {
  if (Array.isArray(r.bindings) && r.bindings.length === 1) {
    const [n] = r.bindings;
    Wu(n) && cU(n, e, t);
  } else sU(r.bindings, e, r, t);
}
function sj(r, e) {
  if ((function(t) {
    return t instanceof Error && (t instanceof RangeError && /stack space|call stack|too much recursion/i.test(t.message) || t.name === "InternalError" && /too much recursion/.test(t.message));
  })(e)) {
    const t = (function(n) {
      const i = [...n];
      return i.length === 0 ? "(No dependency trace)" : i.map(Jn).join(" -> ");
    })((function(n) {
      const i = /* @__PURE__ */ new Set();
      for (const s of n.servicesBranch) {
        if (i.has(s)) return [...i, s];
        i.add(s);
      }
      return [...i];
    })(r));
    throw new fr(nr.planning, `Circular dependency found: ${t}`, { cause: e });
  }
  throw e;
}
function oj(r) {
  try {
    const e = /* @__PURE__ */ new Map();
    r.rootConstraints.tag !== void 0 && e.set(r.rootConstraints.tag.key, r.rootConstraints.tag.value);
    const t = new ij({ elem: { name: r.rootConstraints.name, serviceIdentifier: r.rootConstraints.serviceIdentifier, tags: e }, previous: void 0 }), n = new Uh(t.last), i = Nv(r, n), s = [], o = { bindings: s, parent: void 0, serviceIdentifier: r.rootConstraints.serviceIdentifier };
    if (s.push(...Bv(r, t, i, o)), !r.rootConstraints.isMultiple) {
      R1(o, r.rootConstraints.isOptional ?? !1, n);
      const [a] = s;
      o.bindings = a;
    }
    return { tree: { root: o } };
  } catch (e) {
    sj(r, e);
  }
}
function aj(r, e, t, n) {
  const i = { binding: e, classMetadata: r.getClassMetadata(e.implementationType), constructorParams: [], parent: n, propertyParams: /* @__PURE__ */ new Map() };
  return uU({ autobindOptions: r.autobindOptions, getBindings: r.getBindings, getClassMetadata: r.getClassMetadata, node: i, servicesBranch: r.servicesBranch, setBinding: r.setBinding }, t);
}
function qT(r, e, t) {
  if (t.kind === gc.unmanaged) return;
  const n = k1.is(t.value) ? t.value.unwrap() : t.value, i = e.concat({ name: t.name, serviceIdentifier: n, tags: t.tags }), s = new Uh(i.last), o = Nv(r, s), a = [], c = { bindings: a, parent: r.node, serviceIdentifier: n };
  if (a.push(...Bv(r, i, o, c)), t.kind === gc.singleInjection) {
    R1(c, t.optional, s);
    const [u] = a;
    c.bindings = u;
  }
  return c;
}
function cj(r, e, t) {
  const n = k1.is(t.value) ? t.value.unwrap() : t.value, i = e.concat({ name: t.name, serviceIdentifier: n, tags: t.tags }), s = new Uh(i.last), o = Nv(r, s), a = [], c = { bindings: a, parent: r.node, serviceIdentifier: n };
  if (a.push(...Bv(r, i, o, c)), t.kind === dd.singleInjection) {
    R1(c, t.optional, s);
    const [u] = a;
    c.bindings = u;
  }
  return c;
}
function uj(r, e, t, n) {
  const i = { binding: e, params: [], parent: n };
  return uU({ autobindOptions: r.autobindOptions, getBindings: r.getBindings, getClassMetadata: r.getClassMetadata, node: i, servicesBranch: r.servicesBranch, setBinding: r.setBinding }, t);
}
function Bv(r, e, t, n) {
  const i = Wu(n) ? n.binding.targetServiceIdentifier : n.serviceIdentifier;
  r.servicesBranch.push(i);
  const s = [];
  for (const o of t) switch (o.type) {
    case dr.Instance:
      s.push(aj(r, o, e, n));
      break;
    case dr.ResolvedValue:
      s.push(uj(r, o, e, n));
      break;
    case dr.ServiceRedirection: {
      const a = lj(r, e, o, n);
      s.push(a);
      break;
    }
    default:
      s.push({ binding: o, parent: n });
  }
  return r.servicesBranch.pop(), s;
}
function lj(r, e, t, n) {
  const i = { binding: t, parent: n, redirections: [] }, s = Nv(r, new Uh(e.last), { customServiceIdentifier: t.targetServiceIdentifier });
  return i.redirections.push(...Bv(r, e, s, i)), i;
}
function uU(r, e) {
  return r.node.binding.type === dr.Instance ? (function(t, n, i) {
    const s = n.classMetadata;
    for (const [o, a] of s.constructorArguments.entries()) n.constructorParams[o] = qT(t, i, a);
    for (const [o, a] of s.properties) {
      const c = qT(t, i, a);
      c !== void 0 && n.propertyParams.set(o, c);
    }
    return t.node;
  })(r, r.node, e) : (function(t, n, i) {
    const s = n.binding.metadata;
    for (const [o, a] of s.arguments.entries()) n.params[o] = cj(t, i, a);
    return t.node;
  })(r, r.node, e);
}
var Hc;
(function(r) {
  r[r.singleMandatory = 0] = "singleMandatory", r[r.singleOptional = 1] = "singleOptional", r[r.multipleMandatory = 2] = "multipleMandatory", r[r.multipleOptional = 3] = "multipleOptional", r[r.length = 4] = "length";
})(Hc || (Hc = {}));
var ou, au, cu, uu, kd, Lt, Jf, Lc, Po, lU, dU, rB;
let dj = (rB = class {
  constructor() {
    L(this, Lt);
    L(this, ou);
    L(this, au);
    L(this, cu);
    L(this, uu);
    L(this, kd);
    D(this, ou, R(this, Lt, Jf).call(this)), D(this, au, R(this, Lt, Jf).call(this)), D(this, uu, R(this, Lt, Jf).call(this)), D(this, cu, R(this, Lt, Jf).call(this)), D(this, kd, []);
  }
  clearCache() {
    for (const e of R(this, Lt, lU).call(this)) e.clear();
    for (const e of m(this, kd)) e.clearCache();
  }
  get(e) {
    var t, n, i, s, o, a;
    return e.name === void 0 ? e.tag === void 0 ? R(this, Lt, Po).call(this, m(this, ou), e).get(e.serviceIdentifier) : (n = (t = R(this, Lt, Po).call(this, m(this, cu), e).get(e.serviceIdentifier)) == null ? void 0 : t.get(e.tag.key)) == null ? void 0 : n.get(e.tag.value) : e.tag === void 0 ? (i = R(this, Lt, Po).call(this, m(this, au), e).get(e.serviceIdentifier)) == null ? void 0 : i.get(e.name) : (a = (o = (s = R(this, Lt, Po).call(this, m(this, uu), e).get(e.serviceIdentifier)) == null ? void 0 : s.get(e.name)) == null ? void 0 : o.get(e.tag.key)) == null ? void 0 : a.get(e.tag.value);
  }
  set(e, t) {
    e.name === void 0 ? e.tag === void 0 ? R(this, Lt, Po).call(this, m(this, ou), e).set(e.serviceIdentifier, t) : R(this, Lt, Lc).call(this, R(this, Lt, Lc).call(this, R(this, Lt, Po).call(this, m(this, cu), e), e.serviceIdentifier), e.tag.key).set(e.tag.value, t) : e.tag === void 0 ? R(this, Lt, Lc).call(this, R(this, Lt, Po).call(this, m(this, au), e), e.serviceIdentifier).set(e.name, t) : R(this, Lt, Lc).call(this, R(this, Lt, Lc).call(this, R(this, Lt, Lc).call(this, R(this, Lt, Po).call(this, m(this, uu), e), e.serviceIdentifier), e.name), e.tag.key).set(e.tag.value, t);
  }
  subscribe(e) {
    m(this, kd).push(e);
  }
}, ou = new WeakMap(), au = new WeakMap(), cu = new WeakMap(), uu = new WeakMap(), kd = new WeakMap(), Lt = new WeakSet(), Jf = function() {
  const e = new Array(Hc.length);
  for (let t = 0; t < e.length; ++t) e[t] = /* @__PURE__ */ new Map();
  return e;
}, Lc = function(e, t) {
  let n = e.get(t);
  return n === void 0 && (n = /* @__PURE__ */ new Map(), e.set(t, n)), n;
}, Po = function(e, t) {
  return e[R(this, Lt, dU).call(this, t)];
}, lU = function() {
  return [...m(this, ou), ...m(this, au), ...m(this, uu), ...m(this, cu)];
}, dU = function(e) {
  return e.isMultiple ? e.optional === !0 ? Hc.multipleOptional : Hc.multipleMandatory : e.optional === !0 ? Hc.singleOptional : Hc.singleMandatory;
}, rB);
function hU(r, e) {
  return Tr(e) ? (r.cache = { isRight: !0, value: e }, e.then(((t) => WT(r, t)))) : WT(r, e);
}
function WT(r, e) {
  return r.cache = { isRight: !0, value: e }, e;
}
function hj(r, e, t) {
  const n = r.getActivations(e);
  return n === void 0 ? t : Tr(t) ? ZT(r, t, n[Symbol.iterator]()) : (function(i, s, o) {
    let a = s, c = o.next();
    for (; c.done !== !0; ) {
      const u = c.value(i.context, a);
      if (Tr(u)) return ZT(i, u, o);
      a = u, c = o.next();
    }
    return a;
  })(r, t, n[Symbol.iterator]());
}
async function ZT(r, e, t) {
  let n = await e, i = t.next();
  for (; i.done !== !0; ) n = await i.value(r.context, n), i = t.next();
  return n;
}
function oy(r, e, t) {
  let n = t;
  if (e.onActivation !== void 0) {
    const i = e.onActivation;
    n = Tr(n) ? n.then(((s) => i(r.context, s))) : i(r.context, n);
  }
  return hj(r, e.serviceIdentifier, n);
}
function P1(r) {
  return (e, t) => t.cache.isRight ? t.cache.value : hU(t, oy(e, t, r(e, t)));
}
const fj = P1((function(r, e) {
  return e.value;
}));
function pj(r) {
  return r;
}
function N1(r, e) {
  return (t, n) => {
    const i = r(n);
    switch (i.scope) {
      case Cs.Singleton:
        return i.cache.isRight ? i.cache.value : hU(i, oy(t, i, e(t, n)));
      case Cs.Request: {
        if (t.requestScopeCache.has(i.id)) return t.requestScopeCache.get(i.id);
        const s = oy(t, i, e(t, n));
        return t.requestScopeCache.set(i.id, s), s;
      }
      case Cs.Transient:
        return oy(t, i, e(t, n));
    }
  };
}
const gj = ((r) => N1(pj, r))((function(r, e) {
  return e.value(r.context);
})), mj = P1((function(r, e) {
  return e.factory(r.context);
}));
function JT(r, e, t) {
  const n = (function(i, s, o) {
    if (o !== void 0) {
      if (!(o in i)) throw new fr(nr.resolution, `Expecting a "${o.toString()}" property when resolving "${s.implementationType.name}" class @postConstruct decorated method, none found.`);
      if (typeof i[o] != "function") throw new fr(nr.resolution, `Expecting a "${o.toString()}" method when resolving "${s.implementationType.name}" class @postConstruct decorated method, a non function property was found instead.`);
      {
        let a;
        try {
          a = i[o]();
        } catch (c) {
          throw new fr(nr.resolution, `Unexpected error found when calling "${o.toString()}" @postConstruct decorated method on class "${s.implementationType.name}"`, { cause: c });
        }
        if (Tr(a)) return (async function(c, u, l) {
          try {
            await l;
          } catch (d) {
            throw new fr(nr.resolution, `Unexpected error found when calling "${u.toString()}" @postConstruct decorated method on class "${c.implementationType.name}"`, { cause: d });
          }
        })(s, o, a);
      }
    }
  })(r, e, t);
  return Tr(n) ? n.then((() => r)) : r;
}
function XT(r) {
  return (e, t, n) => {
    const i = new n.binding.implementationType(...e), s = r(t, i, n);
    return Tr(s) ? s.then((() => JT(i, n.binding, n.classMetadata.lifecycle.postConstructMethodName))) : JT(i, n.binding, n.classMetadata.lifecycle.postConstructMethodName);
  };
}
const yj = P1((function(r, e) {
  return e.provider(r.context);
}));
function vj(r) {
  return r.binding;
}
function bj(r) {
  return r.binding;
}
const YT = /* @__PURE__ */ (function(r) {
  return (e, t, n) => {
    const i = [];
    for (const [s, o] of n.propertyParams) {
      const a = n.classMetadata.properties.get(s);
      if (a === void 0) throw new fr(nr.resolution, `Expecting metadata at property "${s.toString()}", none found`);
      a.kind !== gc.unmanaged && o.bindings !== void 0 && (t[s] = r(e, o), Tr(t[s]) && i.push((async () => {
        t[s] = await t[s];
      })()));
    }
    if (i.length > 0) return Promise.all(i).then((() => {
    }));
  };
})(Lv), QT = /* @__PURE__ */ (function(r) {
  return function e(t, n) {
    const i = [];
    for (const s of n.redirections) Wu(s) ? i.push(...e(t, s)) : i.push(r(t, s));
    return i;
  };
})(wS), wj = /* @__PURE__ */ (function(r, e, t) {
  return (n, i) => {
    const s = r(n, i);
    return Tr(s) ? e(s, n, i) : t(s, n, i);
  };
})(/* @__PURE__ */ (function(r) {
  return (e, t) => {
    const n = [];
    for (const i of t.constructorParams) i === void 0 ? n.push(void 0) : n.push(r(e, i));
    return n.some(Tr) ? Promise.all(n) : n;
  };
})(Lv), /* @__PURE__ */ (function(r) {
  return async (e, t, n) => {
    const i = await e;
    return r(i, t, n);
  };
})(XT(YT)), XT(YT)), _j = /* @__PURE__ */ (function(r) {
  return (e, t) => {
    const n = r(e, t);
    return Tr(n) ? n.then(((i) => t.binding.factory(...i))) : t.binding.factory(...n);
  };
})(/* @__PURE__ */ (function(r) {
  return (e, t) => {
    const n = [];
    for (const i of t.params) n.push(r(e, i));
    return n.some(Tr) ? Promise.all(n) : n;
  };
})(Lv)), Sj = ((r) => N1(vj, r))(wj), Ej = ((r) => N1(bj, r))(_j);
function xj(r) {
  return Lv(r, r.planResult.tree.root);
}
function wS(r, e) {
  switch (e.binding.type) {
    case dr.ConstantValue:
      return fj(r, e.binding);
    case dr.DynamicValue:
      return gj(r, e.binding);
    case dr.Factory:
      return mj(r, e.binding);
    case dr.Instance:
      return Sj(r, e);
    case dr.Provider:
      return yj(r, e.binding);
    case dr.ResolvedValue:
      return Ej(r, e);
  }
}
function Lv(r, e) {
  if (e.bindings !== void 0) return Array.isArray(e.bindings) ? (function(t, n) {
    const i = [];
    for (const s of n) Wu(s) ? i.push(...QT(t, s)) : i.push(wS(t, s));
    return i.some(Tr) ? Promise.all(i) : i;
  })(r, e.bindings) : (function(t, n) {
    if (Wu(n)) {
      const i = QT(t, n);
      if (i.length === 1) return i[0];
      throw new fr(nr.resolution, "Unexpected multiple resolved values on single injection");
    }
    return wS(t, n);
  })(r, e.bindings);
}
function Aj(r) {
  return r.scope !== void 0;
}
function ek(r, e) {
  if (r.lifecycle.preDestroyMethodName !== void 0 && typeof e[r.lifecycle.preDestroyMethodName] == "function") return e[r.lifecycle.preDestroyMethodName]();
}
function tk(r, e, t) {
  const n = r.getDeactivations(e);
  if (n !== void 0) return Tr(t) ? rk(t, n[Symbol.iterator]()) : (function(i, s) {
    let o = s.next();
    for (; o.done !== !0; ) {
      const a = o.value(i);
      if (Tr(a)) return rk(i, s);
      o = s.next();
    }
  })(t, n[Symbol.iterator]());
}
async function rk(r, e) {
  const t = await r;
  let n = e.next();
  for (; n.done !== !0; ) await n.value(t), n = e.next();
}
function Ij(r, e) {
  const t = (function(n, i) {
    if (i.type === dr.Instance) {
      const s = n.getClassMetadata(i.implementationType), o = i.cache.value;
      return Tr(o) ? o.then(((a) => ek(s, a))) : ek(s, o);
    }
  })(r, e);
  return t === void 0 ? nk(r, e) : t.then((() => nk(r, e)));
}
function nk(r, e) {
  const t = e.cache;
  return Tr(t.value) ? t.value.then(((n) => ik(r, e, n))) : ik(r, e, t.value);
}
function ik(r, e, t) {
  let n;
  return e.onDeactivation !== void 0 && (n = (0, e.onDeactivation)(t)), n === void 0 ? tk(r, e.serviceIdentifier, t) : n.then((() => tk(r, e.serviceIdentifier, t)));
}
function B1(r, e) {
  if (e === void 0) return;
  const t = (function(i) {
    const s = [];
    for (const o of i) Aj(o) && o.scope === Cs.Singleton && o.cache.isRight && s.push(o);
    return s;
  })(e), n = [];
  for (const i of t) {
    const s = Ij(r, i);
    s !== void 0 && n.push(s);
  }
  return n.length > 0 ? Promise.all(n).then((() => {
  })) : void 0;
}
function Cj(r, e) {
  const t = r.getBindingsFromModule(e);
  return B1(r, t);
}
function sk(r, e) {
  const t = r.getBindings(e);
  return B1(r, t);
}
const Fb = "@inversifyjs/container/bindingId";
var ug, lg, nB;
let mt = (nB = class {
  constructor(e) {
    L(this, ug);
    L(this, lg);
    D(this, ug, (function() {
      const t = qu(Object, Fb) ?? 0;
      return t === Number.MAX_SAFE_INTEGER ? O1(Object, Fb, Number.MIN_SAFE_INTEGER) : Du(Object, Fb, (() => t), ((n) => n + 1)), t;
    })()), D(this, lg, e);
  }
  get id() {
    return m(this, ug);
  }
  load(e) {
    return m(this, lg).call(this, e);
  }
}, ug = new WeakMap(), lg = new WeakMap(), nB);
const fU = Symbol.for("@inversifyjs/container/bindingIdentifier");
function ok(r) {
  return typeof r == "object" && r !== null && r[fU] === !0;
}
var iS;
let kc = (iS = class {
}, h(iS, "always", (e) => !0), iS);
function L1(r) {
  return { [fU]: !0, id: r.id };
}
function Xf(r) {
  return (e) => {
    for (let t = e.getAncestor(); t !== void 0; t = t.getAncestor()) if (r(t)) return !0;
    return !1;
  };
}
function Tf(r) {
  return (e) => e.name === r;
}
function gm(r) {
  return (e) => e.serviceIdentifier === r;
}
function kf(r, e) {
  return (t) => t.tags.has(r) && t.tags.get(r) === e;
}
function Dj(r) {
  return r.name === void 0 && r.tags.size === 0;
}
function mm(r) {
  const e = Xf(r);
  return (t) => !e(t);
}
function ym(r) {
  return (e) => {
    const t = e.getAncestor();
    return t === void 0 || !r(t);
  };
}
function vm(r) {
  return (e) => {
    const t = e.getAncestor();
    return t !== void 0 && r(t);
  };
}
var us, iB;
let Tj = (iB = class {
  constructor(e) {
    L(this, us);
    D(this, us, e);
  }
  getIdentifier() {
    return L1(m(this, us));
  }
  inRequestScope() {
    return m(this, us).scope = Cs.Request, new Tu(m(this, us));
  }
  inSingletonScope() {
    return m(this, us).scope = Cs.Singleton, new Tu(m(this, us));
  }
  inTransientScope() {
    return m(this, us).scope = Cs.Transient, new Tu(m(this, us));
  }
}, us = new WeakMap(), iB);
var ls, ds, lu, bi, bv, pU, sB;
let ak = (sB = class {
  constructor(e, t, n, i) {
    L(this, bv);
    L(this, ls);
    L(this, ds);
    L(this, lu);
    L(this, bi);
    D(this, ls, e), D(this, ds, t), D(this, lu, n), D(this, bi, i);
  }
  to(e) {
    const t = Ny(e), n = { cache: { isRight: !1, value: void 0 }, id: Ca(), implementationType: e, isSatisfiedBy: kc.always, moduleId: m(this, ds), onActivation: void 0, onDeactivation: void 0, scope: t.scope ?? m(this, lu), serviceIdentifier: m(this, bi), type: dr.Instance };
    return m(this, ls).call(this, n), new Mb(n);
  }
  toSelf() {
    if (typeof m(this, bi) != "function") throw new Error('"toSelf" function can only be applied when a newable function is used as service identifier');
    return this.to(m(this, bi));
  }
  toConstantValue(e) {
    const t = { cache: { isRight: !1, value: void 0 }, id: Ca(), isSatisfiedBy: kc.always, moduleId: m(this, ds), onActivation: void 0, onDeactivation: void 0, scope: Cs.Singleton, serviceIdentifier: m(this, bi), type: dr.ConstantValue, value: e };
    return m(this, ls).call(this, t), new Tu(t);
  }
  toDynamicValue(e) {
    const t = { cache: { isRight: !1, value: void 0 }, id: Ca(), isSatisfiedBy: kc.always, moduleId: m(this, ds), onActivation: void 0, onDeactivation: void 0, scope: m(this, lu), serviceIdentifier: m(this, bi), type: dr.DynamicValue, value: e };
    return m(this, ls).call(this, t), new Mb(t);
  }
  toResolvedValue(e, t) {
    const n = { cache: { isRight: !1, value: void 0 }, factory: e, id: Ca(), isSatisfiedBy: kc.always, metadata: R(this, bv, pU).call(this, t), moduleId: m(this, ds), onActivation: void 0, onDeactivation: void 0, scope: m(this, lu), serviceIdentifier: m(this, bi), type: dr.ResolvedValue };
    return m(this, ls).call(this, n), new Mb(n);
  }
  toFactory(e) {
    const t = { cache: { isRight: !1, value: void 0 }, factory: e, id: Ca(), isSatisfiedBy: kc.always, moduleId: m(this, ds), onActivation: void 0, onDeactivation: void 0, scope: Cs.Singleton, serviceIdentifier: m(this, bi), type: dr.Factory };
    return m(this, ls).call(this, t), new Tu(t);
  }
  toProvider(e) {
    const t = { cache: { isRight: !1, value: void 0 }, id: Ca(), isSatisfiedBy: kc.always, moduleId: m(this, ds), onActivation: void 0, onDeactivation: void 0, provider: e, scope: Cs.Singleton, serviceIdentifier: m(this, bi), type: dr.Provider };
    return m(this, ls).call(this, t), new Tu(t);
  }
  toService(e) {
    const t = { id: Ca(), isSatisfiedBy: kc.always, moduleId: m(this, ds), serviceIdentifier: m(this, bi), targetServiceIdentifier: e, type: dr.ServiceRedirection };
    m(this, ls).call(this, t);
  }
}, ls = new WeakMap(), ds = new WeakMap(), lu = new WeakMap(), bi = new WeakMap(), bv = new WeakSet(), pU = function(e) {
  return { arguments: (e ?? []).map(((t) => (function(n) {
    return typeof n == "object" && !k1.is(n);
  })(t) ? { kind: t.isMultiple === !0 ? dd.multipleInjection : dd.singleInjection, name: t.name, optional: t.optional ?? !1, tags: new Map((t.tags ?? []).map(((n) => [n.key, n.value]))), value: t.serviceIdentifier } : { kind: dd.singleInjection, name: void 0, optional: !1, tags: /* @__PURE__ */ new Map(), value: t })) };
}, sB);
var qo, oB;
let gU = (oB = class {
  constructor(e) {
    L(this, qo);
    D(this, qo, e);
  }
  getIdentifier() {
    return L1(m(this, qo));
  }
  onActivation(e) {
    return m(this, qo).onActivation = e, new _S(m(this, qo));
  }
  onDeactivation(e) {
    return m(this, qo).onDeactivation = e, new _S(m(this, qo));
  }
}, qo = new WeakMap(), oB);
var du, aB;
let _S = (aB = class {
  constructor(e) {
    L(this, du);
    D(this, du, e);
  }
  getIdentifier() {
    return L1(m(this, du));
  }
  when(e) {
    return m(this, du).isSatisfiedBy = e, new gU(m(this, du));
  }
  whenAnyAncestor(e) {
    return this.when(Xf(e));
  }
  whenAnyAncestorIs(e) {
    return this.when(Xf(gm(e)));
  }
  whenAnyAncestorNamed(e) {
    return this.when((function(t) {
      return Xf(Tf(t));
    })(e));
  }
  whenAnyAncestorTagged(e, t) {
    return this.when((function(n, i) {
      return Xf(kf(n, i));
    })(e, t));
  }
  whenDefault() {
    return this.when(Dj);
  }
  whenNamed(e) {
    return this.when(Tf(e));
  }
  whenNoParent(e) {
    return this.when(ym(e));
  }
  whenNoParentIs(e) {
    return this.when(ym(gm(e)));
  }
  whenNoParentNamed(e) {
    return this.when((function(t) {
      return ym(Tf(t));
    })(e));
  }
  whenNoParentTagged(e, t) {
    return this.when((function(n, i) {
      return ym(kf(n, i));
    })(e, t));
  }
  whenParent(e) {
    return this.when(vm(e));
  }
  whenParentIs(e) {
    return this.when(vm(gm(e)));
  }
  whenParentNamed(e) {
    return this.when((function(t) {
      return vm(Tf(t));
    })(e));
  }
  whenParentTagged(e, t) {
    return this.when((function(n, i) {
      return vm(kf(n, i));
    })(e, t));
  }
  whenTagged(e, t) {
    return this.when(kf(e, t));
  }
  whenNoAncestor(e) {
    return this.when(mm(e));
  }
  whenNoAncestorIs(e) {
    return this.when(mm(gm(e)));
  }
  whenNoAncestorNamed(e) {
    return this.when((function(t) {
      return mm(Tf(t));
    })(e));
  }
  whenNoAncestorTagged(e, t) {
    return this.when((function(n, i) {
      return mm(kf(n, i));
    })(e, t));
  }
}, du = new WeakMap(), aB);
var Od, cB;
let Tu = (cB = class extends _S {
  constructor(t) {
    super(t);
    L(this, Od);
    D(this, Od, new gU(t));
  }
  onActivation(t) {
    return m(this, Od).onActivation(t);
  }
  onDeactivation(t) {
    return m(this, Od).onDeactivation(t);
  }
}, Od = new WeakMap(), cB);
var hu, uB;
let Mb = (uB = class extends Tu {
  constructor(t) {
    super(t);
    L(this, hu);
    D(this, hu, new Tj(t));
  }
  inRequestScope() {
    return m(this, hu).inRequestScope();
  }
  inSingletonScope() {
    return m(this, hu).inSingletonScope();
  }
  inTransientScope() {
    return m(this, hu).inTransientScope();
  }
}, hu = new WeakMap(), uB);
const Vb = Symbol.for("@inversifyjs/container/InversifyContainerError");
var lB, dB;
let El = class mU extends (dB = Error, lB = Vb, dB) {
  constructor(t, n, i) {
    super(n, i);
    h(this, lB);
    h(this, "kind");
    this[Vb] = !0, this.kind = t;
  }
  static is(t) {
    return typeof t == "object" && t !== null && t[Vb] === !0;
  }
  static isErrorOfKind(t, n) {
    return mU.is(t) && t.kind === n;
  }
};
var ka;
(function(r) {
  r[r.invalidOperation = 0] = "invalidOperation";
})(ka || (ka = {}));
const kj = Cs.Transient;
var Sn, Xt, Fa, Fn, $d, Rd, Ma, Mn, Pd, Nd, Bd, Pe, yU, vU, bU, wU, Yf, SS, Qf, _U, ES, xS, AS, SU, ep, EU, IS, xU, CS, DS, AU, TS, hB;
let Uv = (hB = class {
  constructor(e) {
    L(this, Pe);
    L(this, Sn);
    L(this, Xt);
    L(this, Fa);
    L(this, Fn);
    L(this, $d);
    L(this, Rd);
    L(this, Ma);
    L(this, Mn);
    L(this, Pd);
    L(this, Nd);
    L(this, Bd);
    D(this, Fa, R(this, Pe, vU).call(this)), D(this, $d, (t) => m(this, Sn).get(t)), D(this, Mn, new dj()), D(this, Pd, R(this, Pe, SS).call(this)), (e == null ? void 0 : e.parent) === void 0 ? (D(this, Sn, VT.build(void 0)), D(this, Xt, zT.build(void 0)), D(this, Fn, jT.build(void 0))) : (D(this, Sn, VT.build(m(e.parent, Sn))), D(this, Xt, zT.build(m(e.parent, Xt))), D(this, Fn, jT.build(m(e.parent, Fn))), m(e.parent, Mn).subscribe(m(this, Mn))), D(this, Rd, m(this, Xt).get.bind(m(this, Xt))), D(this, Nd, R(this, Pe, ep).bind(this)), D(this, Ma, { autobind: (e == null ? void 0 : e.autobind) ?? !1, defaultScope: (e == null ? void 0 : e.defaultScope) ?? kj }), D(this, Bd, []);
  }
  bind(e) {
    return new ak(((t) => {
      R(this, Pe, ep).call(this, t);
    }), void 0, m(this, Ma).defaultScope, e);
  }
  get(e, t) {
    const n = R(this, Pe, Yf).call(this, !1, e, t), i = R(this, Pe, Qf).call(this, n);
    if (Tr(i)) throw new El(ka.invalidOperation, `Unexpected asyncronous service when resolving service "${Jn(e)}"`);
    return i;
  }
  getAll(e, t) {
    const n = R(this, Pe, Yf).call(this, !0, e, t), i = R(this, Pe, Qf).call(this, n);
    if (Tr(i)) throw new El(ka.invalidOperation, `Unexpected asyncronous service when resolving service "${Jn(e)}"`);
    return i;
  }
  async getAllAsync(e, t) {
    const n = R(this, Pe, Yf).call(this, !0, e, t);
    return R(this, Pe, Qf).call(this, n);
  }
  async getAsync(e, t) {
    const n = R(this, Pe, Yf).call(this, !1, e, t);
    return R(this, Pe, Qf).call(this, n);
  }
  isBound(e, t) {
    const n = m(this, Xt).get(e);
    return R(this, Pe, ES).call(this, e, n, t);
  }
  isCurrentBound(e, t) {
    const n = m(this, Xt).getNonParentBindings(e);
    return R(this, Pe, ES).call(this, e, n, t);
  }
  async load(...e) {
    await Promise.all(R(this, Pe, xS).call(this, ...e));
  }
  loadSync(...e) {
    const t = R(this, Pe, xS).call(this, ...e);
    for (const n of t) if (n !== void 0) throw new El(ka.invalidOperation, "Unexpected asyncronous module load. Consider using Container.load() instead.");
  }
  onActivation(e, t) {
    m(this, Sn).add(t, { serviceId: e });
  }
  onDeactivation(e, t) {
    m(this, Fn).add(t, { serviceId: e });
  }
  restore() {
    const e = m(this, Bd).pop();
    if (e === void 0) throw new El(ka.invalidOperation, "No snapshot available to restore");
    D(this, Sn, e.activationService), D(this, Xt, e.bindingService), D(this, Fn, e.deactivationService), R(this, Pe, SU).call(this);
  }
  async rebind(e) {
    return await this.unbind(e), this.bind(e);
  }
  rebindSync(e) {
    return this.unbindSync(e), this.bind(e);
  }
  snapshot() {
    m(this, Bd).push({ activationService: m(this, Sn).clone(), bindingService: m(this, Xt).clone(), deactivationService: m(this, Fn).clone() });
  }
  async unbind(e) {
    await R(this, Pe, IS).call(this, e);
  }
  async unbindAll() {
    const e = [...m(this, Xt).getNonParentBoundServices()];
    await Promise.all(e.map((async (t) => sk(m(this, Fa), t))));
    for (const t of e) m(this, Sn).removeAllByServiceId(t), m(this, Xt).removeAllByServiceId(t), m(this, Fn).removeAllByServiceId(t);
    m(this, Mn).clearCache();
  }
  unbindSync(e) {
    R(this, Pe, IS).call(this, e) !== void 0 && R(this, Pe, EU).call(this, e);
  }
  async unload(...e) {
    await Promise.all(R(this, Pe, AS).call(this, ...e)), R(this, Pe, DS).call(this, e);
  }
  unloadSync(...e) {
    const t = R(this, Pe, AS).call(this, ...e);
    for (const n of t) if (n !== void 0) throw new El(ka.invalidOperation, "Unexpected asyncronous module unload. Consider using Container.unload() instead.");
    R(this, Pe, DS).call(this, e);
  }
}, Sn = new WeakMap(), Xt = new WeakMap(), Fa = new WeakMap(), Fn = new WeakMap(), $d = new WeakMap(), Rd = new WeakMap(), Ma = new WeakMap(), Mn = new WeakMap(), Pd = new WeakMap(), Nd = new WeakMap(), Bd = new WeakMap(), Pe = new WeakSet(), yU = function(e) {
  return { bind: (t) => new ak(((n) => {
    R(this, Pe, ep).call(this, n);
  }), e, m(this, Ma).defaultScope, t), isBound: this.isBound.bind(this), onActivation: (t, n) => {
    m(this, Sn).add(n, { moduleId: e, serviceId: t });
  }, onDeactivation: (t, n) => {
    m(this, Fn).add(n, { moduleId: e, serviceId: t });
  }, rebind: this.rebind.bind(this), rebindSync: this.rebindSync.bind(this), unbind: this.unbind.bind(this), unbindSync: this.unbindSync.bind(this) };
}, vU = function() {
  return { getBindings: (e) => m(this, Xt).get(e), getBindingsFromModule: (e) => m(this, Xt).getByModuleId(e), getClassMetadata: Ny, getDeactivations: (e) => m(this, Fn).get(e) };
}, bU = function(e, t, n) {
  return { isMultiple: e, name: n == null ? void 0 : n.name, optional: n == null ? void 0 : n.optional, serviceIdentifier: t, tag: n == null ? void 0 : n.tag };
}, wU = function(e, t, n) {
  const i = { autobindOptions: (n == null ? void 0 : n.autobind) ?? m(this, Ma).autobind ? { scope: m(this, Ma).defaultScope } : void 0, getBindings: m(this, Rd), getClassMetadata: Ny, rootConstraints: { isMultiple: t, serviceIdentifier: e }, servicesBranch: [], setBinding: m(this, Nd) };
  return R(this, Pe, _U).call(this, i, n), i;
}, Yf = function(e, t, n) {
  const i = R(this, Pe, bU).call(this, e, t, n), s = m(this, Mn).get(i);
  if (s !== void 0) return s;
  const o = oj(R(this, Pe, wU).call(this, t, e, n));
  return m(this, Mn).set(i, o), o;
}, SS = function() {
  return { get: this.get.bind(this), getAll: this.getAll.bind(this), getAllAsync: this.getAllAsync.bind(this), getAsync: this.getAsync.bind(this) };
}, Qf = function(e) {
  return xj({ context: m(this, Pd), getActivations: m(this, $d), planResult: e, requestScopeCache: /* @__PURE__ */ new Map() });
}, _U = function(e, t) {
  t !== void 0 && (t.name !== void 0 && (e.rootConstraints.name = t.name), t.optional === !0 && (e.rootConstraints.isOptional = !0), t.tag !== void 0 && (e.rootConstraints.tag = { key: t.tag.key, value: t.tag.value }));
}, ES = function(e, t, n) {
  if (t === void 0) return !1;
  const i = { getAncestor: () => {
  }, name: n == null ? void 0 : n.name, serviceIdentifier: e, tags: /* @__PURE__ */ new Map() };
  (n == null ? void 0 : n.tag) !== void 0 && i.tags.set(n.tag.key, n.tag.value);
  for (const s of t) if (s.isSatisfiedBy(i)) return !0;
  return !1;
}, xS = function(...e) {
  return e.map(((t) => t.load(R(this, Pe, yU).call(this, t.id))));
}, AS = function(...e) {
  return e.map(((t) => Cj(m(this, Fa), t.id)));
}, SU = function() {
  m(this, Mn).clearCache(), D(this, $d, (e) => m(this, Sn).get(e)), D(this, Rd, m(this, Xt).get.bind(m(this, Xt))), D(this, Pd, R(this, Pe, SS).call(this)), D(this, Nd, R(this, Pe, ep).bind(this));
}, ep = function(e) {
  m(this, Xt).set(e), m(this, Mn).clearCache();
}, EU = function(e) {
  var i;
  let t;
  if (ok(e)) {
    const s = m(this, Xt).getById(e.id), o = (i = (n = s, (function(a) {
      if (a === void 0) return;
      const c = a.next();
      return c.done !== !0 ? c.value : void 0;
    })(n == null ? void 0 : n[Symbol.iterator]()))) == null ? void 0 : i.serviceIdentifier;
    t = o === void 0 ? "Unexpected asyncronous deactivation when unbinding binding identifier. Consider using Container.unbind() instead." : `Unexpected asyncronous deactivation when unbinding "${Jn(o)}" binding. Consider using Container.unbind() instead.`;
  } else t = `Unexpected asyncronous deactivation when unbinding "${Jn(e)}" service. Consider using Container.unbind() instead.`;
  var n;
  throw new El(ka.invalidOperation, t);
}, IS = function(e) {
  return ok(e) ? R(this, Pe, xU).call(this, e) : R(this, Pe, AU).call(this, e);
}, xU = function(e) {
  const t = m(this, Xt).getById(e.id), n = B1(m(this, Fa), t);
  if (n !== void 0) return n.then((() => {
    R(this, Pe, CS).call(this, e);
  }));
  R(this, Pe, CS).call(this, e);
}, CS = function(e) {
  m(this, Xt).removeById(e.id), m(this, Mn).clearCache();
}, DS = function(e) {
  for (const t of e) m(this, Sn).removeAllByModuleId(t.id), m(this, Xt).removeAllByModuleId(t.id), m(this, Fn).removeAllByModuleId(t.id);
  m(this, Mn).clearCache();
}, AU = function(e) {
  const t = sk(m(this, Fa), e);
  if (t !== void 0) return t.then((() => {
    R(this, Pe, TS).call(this, e);
  }));
  R(this, Pe, TS).call(this, e);
}, TS = function(e) {
  m(this, Sn).removeAllByServiceId(e), m(this, Xt).removeAllByServiceId(e), m(this, Fn).removeAllByServiceId(e), m(this, Mn).clearCache();
}, hB), Oj = class {
  constructor(e, t, n, i, s) {
    this.deviceModel = e, this.serviceUuid = t, this.writeUuid = n, this.writeCmdUuid = i, this.notifyUuid = s;
  }
}, xl = class {
  constructor(e) {
    h(this, "id");
    h(this, "productName");
    h(this, "usbProductId");
    h(this, "bootloaderUsbProductId");
    h(this, "usbOnly");
    h(this, "memorySize");
    h(this, "blockSize");
    h(this, "masks");
    h(this, "bluetoothSpec");
    this.id = e.id, this.productName = e.productName, this.usbProductId = e.usbProductId, this.bootloaderUsbProductId = e.bootloaderUsbProductId, this.usbOnly = e.usbOnly, this.memorySize = e.memorySize, this.blockSize = e.blockSize, this.masks = e.masks, this.bluetoothSpec = e.bluetoothSpec;
  }
  getBlockSize(e) {
    switch (this.id) {
      case je.NANO_S:
        return ky.lt(ky.coerce(e) ?? "", "2.0.0") ? 4 * 1024 : 2 * 1024;
      case je.NANO_X:
        return 4 * 1024;
      case je.NANO_SP:
      case je.STAX:
      case je.FLEX:
      case je.APEX:
        return 32;
    }
  }
};
var $j = Object.defineProperty, Rj = (r, e, t) => e in r ? $j(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Pj = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Nj = (r, e, t) => Rj(r, e + "", t);
let tc = class {
  getAllDeviceModels() {
    return Object.values(tc.deviceModelByIds);
  }
  getDeviceModel(e) {
    return tc.deviceModelByIds[e.id];
  }
  filterDeviceModels(e) {
    return this.getAllDeviceModels().filter((t) => Object.entries(e).every(([n, i]) => t[n] === i));
  }
  getBluetoothServicesInfos() {
    return Object.values(tc.deviceModelByIds).reduce((e, t) => {
      const { bluetoothSpec: n } = t;
      return n ? { ...e, ...n.reduce((i, s) => ({ ...i, [s.serviceUuid]: new Oj(t, s.serviceUuid, s.writeUuid, s.writeCmdUuid, s.notifyUuid) }), {}) } : e;
    }, {});
  }
  getBluetoothServices() {
    return Object.values(tc.deviceModelByIds).map((e) => (e.bluetoothSpec || []).map((t) => t.serviceUuid)).flat().filter((e) => !!e);
  }
};
Nj(tc, "deviceModelByIds", { [je.NANO_S]: new xl({ id: je.NANO_S, productName: "Ledger Nano S", usbProductId: 16, bootloaderUsbProductId: 1, usbOnly: !0, memorySize: 320 * 1024, blockSize: 4 * 1024, masks: [823132160] }), [je.NANO_SP]: new xl({ id: je.NANO_SP, productName: "Ledger Nano S Plus", usbProductId: 80, bootloaderUsbProductId: 5, usbOnly: !0, memorySize: 1533 * 1024, blockSize: 32, masks: [856686592] }), [je.NANO_X]: new xl({ id: je.NANO_X, productName: "Ledger Nano X", usbProductId: 64, bootloaderUsbProductId: 4, usbOnly: !1, memorySize: 2 * 1024 * 1024, blockSize: 4 * 1024, masks: [855638016], bluetoothSpec: [{ serviceUuid: "13d63400-2c97-0004-0000-4c6564676572", notifyUuid: "13d63400-2c97-0004-0001-4c6564676572", writeUuid: "13d63400-2c97-0004-0002-4c6564676572", writeCmdUuid: "13d63400-2c97-0004-0003-4c6564676572" }] }), [je.STAX]: new xl({ id: je.STAX, productName: "Ledger Stax", usbProductId: 96, bootloaderUsbProductId: 6, usbOnly: !1, memorySize: 1533 * 1024, blockSize: 32, masks: [857735168], bluetoothSpec: [{ serviceUuid: "13d63400-2c97-6004-0000-4c6564676572", notifyUuid: "13d63400-2c97-6004-0001-4c6564676572", writeUuid: "13d63400-2c97-6004-0002-4c6564676572", writeCmdUuid: "13d63400-2c97-6004-0003-4c6564676572" }] }), [je.FLEX]: new xl({ id: je.FLEX, productName: "Ledger Flex", usbProductId: 112, bootloaderUsbProductId: 7, usbOnly: !1, memorySize: 1533 * 1024, blockSize: 32, masks: [858783744], bluetoothSpec: [{ serviceUuid: "13d63400-2c97-3004-0000-4c6564676572", notifyUuid: "13d63400-2c97-3004-0001-4c6564676572", writeUuid: "13d63400-2c97-3004-0002-4c6564676572", writeCmdUuid: "13d63400-2c97-3004-0003-4c6564676572" }] }), [je.APEX]: new xl({ id: je.APEX, productName: "Ledger Apex", usbProductId: 128, bootloaderUsbProductId: 8, usbOnly: !1, memorySize: 1533 * 1024, blockSize: 32, masks: [859832320], bluetoothSpec: [{ serviceUuid: "13d63400-2c97-8004-0000-4c6564676572", notifyUuid: "13d63400-2c97-8004-0001-4c6564676572", writeUuid: "13d63400-2c97-8004-0002-4c6564676572", writeCmdUuid: "13d63400-2c97-8004-0003-4c6564676572" }] }) }), tc = Pj([le()], tc);
let Bj = class {
  constructor({ statusCode: e, data: t }) {
    h(this, "statusCode");
    h(this, "data");
    this.statusCode = e, this.data = t;
  }
};
const Lj = 5, Uc = 1, kS = 2, Xl = 2, OS = 2, Hr = [];
for (let r = 0; r < 256; ++r)
  Hr.push((r + 256).toString(16).slice(1));
function Uj(r, e = 0) {
  return (Hr[r[e + 0]] + Hr[r[e + 1]] + Hr[r[e + 2]] + Hr[r[e + 3]] + "-" + Hr[r[e + 4]] + Hr[r[e + 5]] + "-" + Hr[r[e + 6]] + Hr[r[e + 7]] + "-" + Hr[r[e + 8]] + Hr[r[e + 9]] + "-" + Hr[r[e + 10]] + Hr[r[e + 11]] + Hr[r[e + 12]] + Hr[r[e + 13]] + Hr[r[e + 14]] + Hr[r[e + 15]]).toLowerCase();
}
let zb;
const Fj = new Uint8Array(16);
function Mj() {
  if (!zb) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    zb = crypto.getRandomValues.bind(crypto);
  }
  return zb(Fj);
}
const Vj = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), ck = { randomUUID: Vj };
function pa(r, e, t) {
  if (ck.randomUUID && !r)
    return ck.randomUUID();
  r = r || {};
  const n = r.random || (r.rng || Mj)();
  return n[6] = n[6] & 15 | 64, n[8] = n[8] & 63 | 128, Uj(n);
}
const ac = { getLastBytesFrom(r, e) {
  return r.slice(-e);
}, getFirstBytesFrom(r, e) {
  return r.slice(0, e);
}, bytesToNumber(r) {
  return r.reduce((e, t, n) => e + t * Math.pow(256, r.length - 1 - n), 0);
}, numberToByteArray(r, e) {
  return new Uint8Array(e).map((t, n) => r >> 8 * (e - 1 - n) & 255);
} }, uk = 2, jb = 800;
let lk = class {
  constructor() {
    h(this, "_tag", "FramerOverflowError");
    h(this, "originalError");
    this.originalError = new Error("Frame header length is greater than frame size");
  }
}, zj = class {
  constructor() {
    h(this, "_tag", "FramerApduError");
    h(this, "originalError");
    this.originalError = new Error("Frame offset is greater than apdu length");
  }
}, dk = class {
  constructor(e) {
    h(this, "_tag", "ReceiverApduError");
    h(this, "originalError");
    this.originalError = new Error(e ?? "Unable to parse apdu");
  }
}, hk = class {
  constructor(e) {
    h(this, "_tag", "DeviceSessionNotFound");
    h(this, "originalError");
    this.originalError = e ?? new Error("Device session not found");
  }
}, IU = class {
  constructor({ header: e, data: t }) {
    h(this, "_header");
    h(this, "_data");
    this._header = e, this._data = t;
  }
  toString() {
    return JSON.stringify({ header: this._header.toString(), data: It(this._data) }, null, 2);
  }
  getRawData() {
    const e = this._header.getRawData(), t = new Uint8Array(e.length + this._data.length);
    return t.set(e, 0), t.set(this._data, e.length), t;
  }
  getHeader() {
    return this._header;
  }
  getData() {
    return this._data;
  }
}, CU = class {
  constructor({ uuid: e, dataSize: t, index: n, headTag: i, length: s, channel: o }) {
    h(this, "_uuid");
    h(this, "_channel");
    h(this, "_headTag");
    h(this, "_index");
    h(this, "_length");
    h(this, "_dataLength");
    this._uuid = e, this._dataLength = t, this._index = n, this._headTag = i, this._length = s, this._channel = o;
  }
  getDataLength() {
    return this._dataLength.map((e) => ac.bytesToNumber(e));
  }
  setDataSize(e) {
    return this._dataLength = e, this;
  }
  getLength() {
    return this._length;
  }
  toString() {
    var e, t;
    return JSON.stringify({ uuid: this._uuid.toString(), dataSize: (e = this._dataLength.extract()) == null ? void 0 : e.toString(), index: this._index.toString(), headTag: this._headTag.toString(), length: this._length.toString(), channel: (t = this._channel.extract()) == null ? void 0 : t.toString() });
  }
  getRawData() {
    return new Uint8Array([...this._channel.caseOf({ Just: (e) => [...e], Nothing: () => [] }), ...this._headTag, ...this._index, ...this._dataLength.caseOf({ Just: (e) => [...e], Nothing: () => [] })]);
  }
};
const Er = { LoggerPublisherServiceFactory: Symbol.for("LoggerPublisherServiceFactory") };
var jj = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Hj = (r, e) => (t, n) => e(t, n, r);
let $S = class {
  constructor({ channel: e = pe.zero() }, t) {
    h(this, "_channel");
    h(this, "_logger");
    h(this, "_pendingFrames");
    this._channel = e, this._logger = t("ApduReceiverService"), this._pendingFrames = [];
  }
  handleFrame(e) {
    return this.getFrameFromBytes(e).map((t) => {
      if (this._pendingFrames.push(t), !this._pendingFrames[0]) return ve;
      const n = this._pendingFrames[0].getHeader().getDataLength();
      return this.getCompleteFrame(n);
    });
  }
  getCompleteFrame(e) {
    return e.chain((t) => {
      if (!this.isComplete(t)) return this._logger.debug("frame is not complete, waiting for more"), ve;
      const n = ac.getFirstBytesFrom(this.concatFrames(this._pendingFrames), t), i = ac.getFirstBytesFrom(n, n.length - uk), s = ac.getLastBytesFrom(n, uk);
      return this._pendingFrames = [], Le(new Bj({ data: i, statusCode: s }));
    });
  }
  getFrameFromBytes(e) {
    const t = this._channel.caseOf({ Just: () => kS, Nothing: () => 0 }), n = e.slice(t, t + Uc), i = e.slice(t + Uc, t + Uc + Xl), s = i.reduce((f, p) => f + p, 0) === 0;
    if (!s && this._pendingFrames.length === 0) return N(new dk());
    const o = t + Uc + Xl, a = s ? OS : 0;
    if (e.length < t + Uc + Xl + a) return N(new dk("Unable to parse header from apdu"));
    const c = s ? Le(e.slice(o, o + a)) : ve, u = o + a, l = e.slice(u), d = new IU({ header: new CU({ uuid: pa(), channel: this._channel, dataSize: c, headTag: n, index: i, length: t + Uc + Xl + a }), data: l });
    return te(d);
  }
  isComplete(e) {
    return this._pendingFrames.reduce((t, n) => t + n.getData().length, 0) >= e;
  }
  concatFrames(e) {
    return e.reduce((t, n) => Uint8Array.from([...t, ...n.getData()]), new Uint8Array(0));
  }
};
$S = jj([le(), Hj(1, X(Er.LoggerPublisherServiceFactory))], $S);
var Gj = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Kj = (r, e) => (t, n) => e(t, n, r);
let RS = class {
  constructor({ frameSize: e, channel: t = pe.zero(), padding: n = !1 }, i) {
    h(this, "_frameSize");
    h(this, "_channel");
    h(this, "_padding");
    h(this, "_logger");
    this._frameSize = e, this._channel = t, this._padding = n, this._logger = i("DefaultApduSenderService");
  }
  getFrames(e) {
    const t = [];
    let n = 0, i = this.getFrameAtIndex(e, n);
    for (; i.isRight(); ) t.push(i.extract()), n += 1, i = this.getFrameAtIndex(e, n).mapLeft((s) => (s instanceof lk || this._logger.error("Error while parsing frame", { data: { error: s } }), s));
    return t;
  }
  getFrameAtIndex(e, t) {
    const n = this.getFrameHeaderFrom(t, e.length), i = t === 0 ? 0 : t * this._frameSize - this.getHeaderSizeSumFrom(t);
    if (i >= e.length) return N(new lk());
    if (n.getLength() > this._frameSize) return N(new zj());
    const s = this._frameSize - n.getLength(), o = e.slice(i, i + this._frameSize - n.getLength()), a = this._padding ? new Uint8Array(s).fill(0) : new Uint8Array(o.length < s ? o.length : s);
    a.set(o, 0);
    const c = new IU({ header: n, data: a });
    return te(c);
  }
  getFrameHeaderFrom(e, t) {
    const n = new CU({ uuid: pa(), channel: this._channel.map((i) => ac.getLastBytesFrom(i, kS)), headTag: new Uint8Array([Lj]), index: ac.numberToByteArray(e, Xl), length: this.getFrameHeaderSizeFromIndex(e), dataSize: pe.zero() });
    return e === 0 && n.setDataSize(pe.of(ac.numberToByteArray(t, OS))), n;
  }
  getHeaderSizeSumFrom(e) {
    let t = this.getFrameHeaderSizeFromIndex(0), n = 1;
    for (; n < e; ) t += this.getFrameHeaderSizeFromIndex(n), n += 1;
    return t;
  }
  getFrameHeaderSizeFromIndex(e) {
    return this._channel.caseOf({ Just: () => kS, Nothing: () => 0 }) + Xl + Uc + (e === 0 ? OS : 0);
  }
};
RS = Gj([le(), Kj(1, X(Er.LoggerPublisherServiceFactory))], RS);
const PS = { SendCommandUseCase: Symbol.for("SendCommandUseCase") }, ro = { LocalConfigDataSource: Symbol.for("LocalConfigDataSource"), RemoteConfigDataSource: Symbol.for("RemoteConfigDataSource"), ConfigService: Symbol.for("ConfigService"), GetDmkVersionUseCase: Symbol.for("GetDmkVersionUseCase") }, Vt = { ApduSenderServiceFactory: Symbol.for("ApduSenderServiceFactory"), ApduReceiverServiceFactory: Symbol.for("ApduReceiverServiceFactory"), DeviceSessionService: Symbol.for("DeviceSessionService"), GetDeviceSessionStateUseCase: Symbol.for("GetDeviceSessionStateUseCase"), DisableDeviceSessionRefresherUseCase: Symbol.for("DisableDeviceSessionRefresherUseCase"), CloseSessionsUseCase: Symbol.for("CloseSessionsUseCase") }, Yt = { StartDiscoveringUseCase: Symbol.for("StartDiscoveringUseCase"), StopDiscoveringUseCase: Symbol.for("StopDiscoveringUseCase"), ConnectUseCase: Symbol.for("ConnectUseCase"), DisconnectUseCase: Symbol.for("DisconnectUseCase"), GetConnectedDeviceUseCase: Symbol.for("GetConnectedDeviceUseCase"), ListenToAvailableDevicesUseCase: Symbol.for("ListenToAvailableDevicesUseCase"), ListenToConnectedDeviceUseCase: Symbol.for("ListenToConnectedDeviceUseCase"), ListConnectedDevicesUseCase: Symbol.for("ListConnectedDevicesUseCase") }, xi = { ManagerApiService: Symbol.for("ManagerApiService"), ManagerApiDataSource: Symbol.for("ManagerApiDataSource"), DmkConfig: Symbol.for("ManagerApiDmkConfig"), SetProviderUseCase: Symbol.for("SetProviderUseCase") }, NS = { SendApduUseCase: Symbol.for("SendApduUseCase") }, Ki = { DmkConfig: Symbol.for("TransportDmkConfig"), TransportService: Symbol.for("TransportService"), TransportsInput: Symbol.for("TransportsInput") };
var qj = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, fk = (r, e) => (t, n) => e(t, n, r);
let BS = class {
  constructor(e, t) {
    h(this, "_sessionService");
    h(this, "_logger");
    this._sessionService = e, this._logger = t("SendCommandUseCase");
  }
  async execute({ sessionId: e, command: t, abortTimeout: n }) {
    return this._sessionService.getDeviceSessionById(e).caseOf({ Right: async (i) => await i.sendCommand(t, n), Left: (i) => {
      throw this._logger.error("Error getting session", { data: { error: i } }), i;
    } });
  }
};
BS = qj([le(), fk(0, X(Vt.DeviceSessionService)), fk(1, X(Er.LoggerPublisherServiceFactory))], BS);
var Wj = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
};
let Ur = class {
  constructor() {
    h(this, "execute", vi.fn(() => "stub"));
  }
};
Ur = Wj([le()], Ur);
const Zj = ({ stub: r = !1 } = {}) => new mt(({ bind: e, rebindSync: t }) => {
  e(PS.SendCommandUseCase).to(BS), r && t(PS.SendCommandUseCase).to(Ur);
});
var Jj = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, pk = (r, e) => (t, n) => e(t, n, r);
let LS = class {
  constructor(e, t) {
    h(this, "_sessionService");
    h(this, "_logger");
    this._sessionService = e, this._logger = t("ExecuteDeviceActionUseCase");
  }
  execute({ sessionId: e, deviceAction: t }) {
    return this._sessionService.getDeviceSessionById(e).caseOf({ Right: (n) => n.executeDeviceAction(t), Left: (n) => {
      throw this._logger.error("Error getting session", { data: { error: n } }), n;
    } });
  }
};
LS = Jj([le(), pk(0, X(Vt.DeviceSessionService)), pk(1, X(Er.LoggerPublisherServiceFactory))], LS);
const US = { ExecuteDeviceActionUseCase: Symbol.for("ExecuteDeviceActionUseCase") }, Xj = ({ stub: r = !1 } = {}) => new mt(({ bind: e, rebindSync: t }) => {
  e(US.ExecuteDeviceActionUseCase).to(LS), r && t(US.ExecuteDeviceActionUseCase).to(Ur);
});
function Yj(r) {
  return typeof r == "object" && r !== null && "version" in r && "name" in r && typeof r.version == "string" && typeof r.name == "string";
}
let gk = class {
  constructor(e) {
    h(this, "_tag", "ApiCallError");
    h(this, "originalError");
    this.err = e, this.originalError = e;
  }
}, Qj = class {
  constructor(e) {
    h(this, "_tag", "ParseResponseError");
    h(this, "originalError");
    this.err = e, this.originalError = e;
  }
}, DU = class {
  constructor(e) {
    h(this, "_tag", "JSONParseError");
    h(this, "originalError");
    this.err = e, this.originalError = e;
  }
}, eH = class {
  constructor(e) {
    h(this, "_tag", "ReadFileError");
    h(this, "originalError");
    this.err = e, this.originalError = e;
  }
};
const tH = "@ledgerhq/device-management-kit", rH = "0.9.2", mk = {
  name: tH,
  version: rH
};
var nH = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
};
const iH = { name: mk.name, version: mk.version }, sH = () => JSON.stringify(iH);
let FS = class {
  getConfig() {
    return Pt.encase(() => sH()).mapLeft((e) => new eH(e)).chain((e) => Pt.encase(() => {
      const t = JSON.parse(e);
      if (Yj(t)) return t;
      throw new Error("Invalid config file");
    }).mapLeft((t) => new DU(t)));
  }
};
FS = nH([le()], FS);
var oH = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
};
let MS = class {
  getConfig() {
    return Pt.of({ name: "DeviceSDK", version: "0.0.0-stub.1" });
  }
};
MS = oH([le()], MS);
var aH = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
};
let VS = class {
  async getConfig() {
    const e = await this._callApi();
    if (e.isLeft()) return N(new gk(e.extract()));
    if (!e.extract().ok) return N(new gk(new Error("response not ok")));
    const t = await e.extract().json();
    return t.isLeft() ? N(new DU()) : t.chain((n) => this._parseResponse(n)).map((n) => n);
  }
  _parseResponse(e) {
    const { name: t, version: n } = e;
    return !t || !n ? N(new Qj()) : Pt.of({ name: t, version: n });
  }
  _callApi() {
    return new Promise((e) => {
      e(Pt.of({ ok: !0, json: async () => new Promise((t) => {
        t(Pt.of({ name: "DeviceSDK", version: "0.0.0-fake.1", yolo: "yolo" }));
      }) }));
    });
  }
};
VS = aH([le()], VS);
var cH = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
};
let zS = class {
  async getConfig() {
    return new Promise((e) => e(Pt.of({ name: "DeviceSDK", version: "0.0.0-fake.2" })));
  }
};
zS = cH([le()], zS);
var uH = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Hb = (r, e) => (t, n) => e(t, n, r);
let jS = class {
  constructor(e, t, n) {
    h(this, "_local");
    h(this, "_remote");
    h(this, "_logger");
    this._local = e, this._remote = t, this._logger = n("config");
  }
  async getDmkConfig() {
    const e = this._local.getConfig().ifLeft((t) => {
      this._logger.error("Local config not available", { data: { error: t } });
    });
    if (e.isRight()) {
      const t = e.extract();
      return this._logger.info("Local config available", { data: { config: t } }), t;
    }
    return this._remote.getConfig().then((t) => t.mapLeft((n) => (this._logger.error("Local config available", { data: { error: n } }), { name: "DeadDmk", version: "0.0.0-dead.1" })).extract());
  }
};
jS = uH([le(), Hb(0, X(ro.LocalConfigDataSource)), Hb(1, X(ro.RemoteConfigDataSource)), Hb(2, X(Er.LoggerPublisherServiceFactory))], jS);
var lH = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, dH = (r, e) => (t, n) => e(t, n, r);
let HS = class {
  constructor(e) {
    h(this, "_configService");
    this._configService = e;
  }
  async getDmkVersion() {
    return (await this._configService.getDmkConfig()).version;
  }
};
HS = lH([le(), dH(0, X(ro.ConfigService))], HS);
const hH = ({ stub: r }) => new mt(({ bind: e, rebindSync: t }) => {
  e(ro.LocalConfigDataSource).to(FS), e(ro.RemoteConfigDataSource).to(VS), e(ro.GetDmkVersionUseCase).to(HS), e(ro.ConfigService).to(jS), r && (t(ro.LocalConfigDataSource).to(MS), t(ro.RemoteConfigDataSource).to(zS));
}), TU = { DeviceModelDataSource: Symbol.for("DeviceModelDataSource") }, fH = ({ stub: r }) => new mt(({ bind: e }) => {
  e(TU.DeviceModelDataSource).to(tc);
});
var pH = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, yk = (r, e) => (t, n) => e(t, n, r);
let GS = class {
  constructor(e, t) {
    h(this, "_logger");
    this._sessionService = e, this._logger = t("DisableDeviceSessionRefresherUseCase");
  }
  execute({ sessionId: e, blockerId: t }) {
    return this._sessionService.getDeviceSessionById(e).caseOf({ Left: (n) => {
      throw this._logger.error("Error getting device session", { data: { error: n } }), n;
    }, Right: (n) => n.disableRefresher(t) });
  }
};
GS = pH([le(), yk(0, X(Vt.DeviceSessionService)), yk(1, X(Er.LoggerPublisherServiceFactory))], GS);
var gH = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, mH = (r, e) => (t, n) => e(t, n, r);
let KS = class {
  constructor(e) {
    h(this, "_sessions");
    h(this, "_logger");
    h(this, "_sessionsSubject");
    this._sessions = [], this._sessionsSubject = new $v(), this._logger = e("DeviceSessionService");
  }
  get sessionsObs() {
    return this._sessionsSubject.asObservable();
  }
  addDeviceSession(e) {
    return this._sessions.find((t) => t.id === e.id) ? (this._logger.warn("DeviceSession already exists", { data: { deviceSession: e } }), this) : (this._sessions.push(e), this._sessionsSubject.next(e), this._logger.info("DeviceSession added", { data: { sessionId: e.id } }), this);
  }
  removeDeviceSession(e) {
    const t = this._sessions.find((n) => n.id === e);
    return t ? (t.close(), this._sessions = this._sessions.filter((n) => n.id !== e), this._logger.info("DeviceSession removed", { data: { sessionId: e } }), this) : (this._logger.warn("DeviceSession not found", { data: { sessionId: e } }), this);
  }
  getDeviceSessionById(e) {
    return pe.fromNullable(this._sessions.find((t) => t.id === e)).toEither(new hk());
  }
  getDeviceSessionByDeviceId(e) {
    return pe.fromNullable(this._sessions.find((t) => t.connectedDevice.id === e)).toEither(new hk());
  }
  getDeviceSessions() {
    return this._sessions;
  }
};
KS = gH([le(), mH(0, X(Er.LoggerPublisherServiceFactory))], KS);
var yH = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, vk = (r, e) => (t, n) => e(t, n, r);
let qS = class {
  constructor(e, t) {
    h(this, "_sessionService");
    h(this, "_transportService");
    this._sessionService = e, this._transportService = t;
  }
  execute() {
    const e = this._sessionService.getDeviceSessions();
    for (const t of e) this._transportService.closeConnection(t.connectedDevice), this._sessionService.removeDeviceSession(t.id);
  }
};
qS = yH([le(), vk(0, X(Vt.DeviceSessionService)), vk(1, X(Ki.TransportService))], qS);
var vH = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, bk = (r, e) => (t, n) => e(t, n, r);
let WS = class {
  constructor(e, t) {
    h(this, "_sessionService");
    h(this, "_logger");
    this._sessionService = e, this._logger = t("GetDeviceSessionStateUseCase");
  }
  execute({ sessionId: e }) {
    return this._sessionService.getDeviceSessionById(e).caseOf({ Left: (t) => {
      throw this._logger.error("Error getting session device", { data: { error: t } }), t;
    }, Right: (t) => t.state });
  }
};
WS = vH([le(), bk(0, X(Vt.DeviceSessionService)), bk(1, X(Er.LoggerPublisherServiceFactory))], WS);
const bH = ({ stub: r } = { stub: !1 }) => new mt(({ bind: e, rebindSync: t }) => {
  e(Vt.ApduSenderServiceFactory).toFactory((n) => {
    const i = n.get(Er.LoggerPublisherServiceFactory);
    return (s) => new RS(s, i);
  }), e(Vt.ApduReceiverServiceFactory).toFactory((n) => {
    const i = n.get(Er.LoggerPublisherServiceFactory);
    return (s = {}) => new $S(s, i);
  }), e(Vt.DeviceSessionService).to(KS).inSingletonScope(), e(Vt.GetDeviceSessionStateUseCase).to(WS), e(Vt.CloseSessionsUseCase).to(qS), e(Vt.DisableDeviceSessionRefresherUseCase).to(GS), r && (t(Vt.GetDeviceSessionStateUseCase).to(Ur), t(Vt.DisableDeviceSessionRefresherUseCase).to(Ur));
}), ZS = 1e3, Gb = 1e3, wH = { isRefresherDisabled: !1, pollingInterval: 1e3 };
let _H = class {
  constructor() {
    h(this, "_queue", []);
    h(this, "_locked", !1);
  }
  async lock() {
    return new Promise((e) => {
      const t = () => {
        if (this._locked = !1, this._queue.length > 0) {
          const n = this._queue.shift();
          this._locked = !0, n();
        }
      };
      this._locked ? this._queue.push(() => e(t)) : (this._locked = !0, e(t));
    });
  }
}, SH = class {
  constructor(e, t) {
    h(this, "_refresherBlockers", /* @__PURE__ */ new Set());
    h(this, "_logger");
    this._refresher = t, this._logger = e("refresher-service");
  }
  disableRefresher(e) {
    const t = `${e}-${pa()}`;
    this.addRefresherBlocker(t), this._logger.debug("Refresher disabled", { data: { blockerId: t, blockers: Array.from(this._refresherBlockers) } });
    let n = !1;
    return () => {
      n || (n = !0, this.removeRefresherBlocker(t), this._logger.debug("Refresher re-enabled", { data: { blockerId: t, blockers: Array.from(this._refresherBlockers) } }));
    };
  }
  addRefresherBlocker(e) {
    const t = this._refresherBlockers.size;
    this._refresherBlockers.add(e), t === 0 && this._refresher.stop();
  }
  removeRefresherBlocker(e) {
    const t = this._refresherBlockers.size;
    this._refresherBlockers.delete(e), t > 0 && this._refresherBlockers.size === 0 && this._refresher.start();
  }
};
var Xn = ((r) => (r.NEW_STATE = "NEW_STATE", r.REFRESH_NEEDED = "REFRESH_NEEDED", r.COMMAND_SUCCEEDED = "COMMAND_SUCCEEDED", r.DEVICE_STATE_UPDATE_BUSY = "DEVICE_STATE_UPDATE_BUSY", r.DEVICE_STATE_UPDATE_LOCKED = "DEVICE_STATE_UPDATE_LOCKED", r.DEVICE_STATE_UPDATE_CONNECTED = "DEVICE_STATE_UPDATE_CONNECTED", r))(Xn || {});
let EH = class {
  constructor() {
    h(this, "_eventEmitter", new af());
  }
  listen() {
    return this._eventEmitter.asObservable();
  }
  dispatch(e) {
    this._eventEmitter.next(e);
  }
}, xH = class {
  constructor(e, t, n, i) {
    h(this, "_sendCommandFunction");
    h(this, "_subscription");
    h(this, "_logger");
    h(this, "mapEventAction", async (e) => {
      switch (e.eventName) {
        case Xn.REFRESH_NEEDED:
          return await this.ping();
        default:
          return null;
      }
    });
    this.connectedDevice = t, this._sessionEventDispatcher = n, this._sendCommandFunction = i, this._logger = e("device-pinger"), this._subscription = this._sessionEventDispatcher.listen().subscribe(async (s) => await this.mapEventAction(s));
  }
  async ping() {
    try {
      return await this.mapDevicePingAction(this.connectedDevice.deviceModel.id);
    } catch (e) {
      throw this._logger.error("Error while pinging device", { data: { error: e } }), e;
    }
  }
  async mapDevicePingAction(e) {
    switch (e) {
      case je.NANO_S: {
        const t = async () => {
          const s = await this._sendCommandFunction(new Oh(), jb);
          return this._sendCommandFunction(new UB(), jb), s;
        }, n = new Promise((s) => {
          setTimeout(() => s(null), ZS * 2 + 100);
        }), i = await Promise.race([t(), n]);
        return i ? this._sessionEventDispatcher.dispatch({ eventName: Xn.COMMAND_SUCCEEDED, eventData: i }) : this._sessionEventDispatcher.dispatch({ eventName: Xn.DEVICE_STATE_UPDATE_LOCKED }), i;
      }
      default: {
        const t = await this._sendCommandFunction(new Oh(), jb);
        return this._sessionEventDispatcher.dispatch({ eventName: Xn.COMMAND_SUCCEEDED, eventData: t }), t;
      }
    }
  }
  unsubscribe() {
    this._subscription.unsubscribe();
  }
}, AH = class {
  constructor(e, t, n, i) {
    h(this, "_refresherSubscription");
    h(this, "_refresherOptions");
    h(this, "_logger");
    h(this, "_connectedDeviceID");
    h(this, "getValidPollingInterval", (e, t) => {
      const { pollingInterval: n } = e;
      switch (this._connectedDeviceID) {
        case je.NANO_S: {
          const i = ZS * 2;
          return n !== void 0 && n < i ? (t.warn(`Polling interval of ${n} is too low, setting to minimum as ${i}`), i) : n ?? i;
        }
        default:
          return n !== void 0 && n < Gb ? (t.warn(`Polling interval of ${n} is too low, setting to minimum as ${Gb}`), Gb) : n ?? ZS;
      }
    });
    this._sessionEventDispatcher = n, this._refresherOptions = t, this._logger = e("device-session-refresher"), this._connectedDeviceID = i.deviceModel.id;
  }
  startRefresher() {
    if (this._refresherOptions.isRefresherDisabled) return;
    const e = this.getValidPollingInterval(this._refresherOptions, this._logger) * 2;
    this._refresherSubscription = E1(0, e).subscribe(() => {
      this._sessionEventDispatcher.dispatch({ eventName: Xn.REFRESH_NEEDED });
    });
  }
  stopRefresher() {
    this._refresherSubscription && (this._refresherSubscription.unsubscribe(), this._refresherSubscription = void 0, this._logger.info("Refresher stopped."));
  }
  restartRefresher() {
    this.stopRefresher(), this.startRefresher(), this._logger.info("Refresher restarted.");
  }
  destroy() {
    this.stopRefresher();
  }
}, IH = class {
  constructor(e, t, n, i, s) {
    h(this, "_subscription");
    h(this, "_logger");
    h(this, "mapEventAction", (e) => {
      switch (e.eventName) {
        case Xn.COMMAND_SUCCEEDED:
          return this._updateDeviceState(e.eventData);
        case Xn.DEVICE_STATE_UPDATE_BUSY:
          return this.setDeviceSessionState({ ...this._deviceState.getValue(), deviceStatus: na.BUSY });
        case Xn.DEVICE_STATE_UPDATE_LOCKED:
          return this.setDeviceSessionState({ ...this._deviceState.getValue(), deviceStatus: na.LOCKED });
        case Xn.DEVICE_STATE_UPDATE_CONNECTED:
          return this.setDeviceSessionState({ ...this._deviceState.getValue(), deviceStatus: na.CONNECTED });
        default:
          return null;
      }
    });
    this._sessionEventDispatcher = t, this._connectedDevice = n, this._deviceState = i, this.setDeviceSessionState = s, this._subscription = this._sessionEventDispatcher.listen().subscribe((o) => this.mapEventAction(o)), this._logger = e("device-session-state-handler");
  }
  _updateDeviceState(e) {
    const t = this._parseDeviceStatus(e);
    if (t) {
      const { sessionStateType: n, deviceStatus: i, currentApp: s } = t, o = this._deviceState.getValue();
      o.sessionStateType === wr.Connected ? this.setDeviceSessionState({ sessionStateType: n, deviceStatus: i, deviceModelId: this._connectedDevice.deviceModel.id, currentApp: s, installedApps: [], isSecureConnectionAllowed: !1 }) : this.setDeviceSessionState({ ...o, sessionStateType: n, deviceStatus: i, deviceModelId: this._connectedDevice.deviceModel.id, currentApp: s });
    }
  }
  _parseDeviceStatus(e) {
    return We(e) ? { sessionStateType: wr.ReadyWithoutSecureChannel, deviceStatus: na.CONNECTED, currentApp: { name: e.data.name, version: e.data.version } } : (this._logger.debug("Error while parsing APDU response", { data: { parsedResponse: e } }), null);
  }
  unsubscribe() {
    this._subscription.unsubscribe();
  }
}, CH = class {
  constructor({ connectedDevice: e, id: t = pa() }, n, i, s, o) {
    h(this, "_id");
    h(this, "_connectedDevice");
    h(this, "_deviceState");
    h(this, "_managerApiService");
    h(this, "_secureChannelService");
    h(this, "_logger");
    h(this, "_refresherOptions");
    h(this, "_pinger");
    h(this, "_deviceSessionRefresher");
    h(this, "_refresherService");
    h(this, "_commandMutex", new _H());
    h(this, "_sessionEventDispatcher", new EH());
    this._id = t, this._connectedDevice = e, this._logger = n("device-session"), this._managerApiService = i, this._secureChannelService = s, this._refresherOptions = { ...wH, ...o }, this._deviceState = new fa({ sessionStateType: wr.Connected, deviceStatus: na.CONNECTED, deviceModelId: this._connectedDevice.deviceModel.id }), this._pinger = new xH(n, e, this._sessionEventDispatcher, (a, c) => this.sendCommand(a, c)), this._deviceSessionRefresher = new AH(n, this._refresherOptions, this._sessionEventDispatcher, this._connectedDevice), new IH(n, this._sessionEventDispatcher, this._connectedDevice, this._deviceState, (a) => this.setDeviceSessionState(a)), this._refresherService = new SH(n, { start: () => this._deviceSessionRefresher.restartRefresher(), stop: () => this._deviceSessionRefresher.stopRefresher() });
  }
  async initialiseSession() {
    try {
      await this._pinger.ping();
    } catch (e) {
      throw this._logger.error("Error while initialising session", { data: { error: e } }), e;
    } finally {
      this._refresherOptions.isRefresherDisabled || this._deviceSessionRefresher.startRefresher();
    }
  }
  get id() {
    return this._id;
  }
  get connectedDevice() {
    return this._connectedDevice;
  }
  get state() {
    return this._deviceState.asObservable();
  }
  getDeviceSessionState() {
    return this._deviceState.getValue();
  }
  setDeviceSessionState(e) {
    this._deviceState.next(e);
  }
  async sendApdu(e, t = { isPolling: !1, triggersDisconnection: !1, abortTimeout: void 0 }) {
    const n = await this._commandMutex.lock();
    try {
      this._sessionEventDispatcher.dispatch({ eventName: Xn.DEVICE_STATE_UPDATE_BUSY }), this._logger.debug(`[exchange] => ${It(e, !1)}`);
      const i = await this._connectedDevice.sendApdu(e, t.triggersDisconnection, t.abortTimeout);
      return i.ifRight((s) => {
        this._logger.debug(`[exchange] <= ${It(s.data, !1)}${It(s.statusCode, !1)}`), Jr.isLockedDeviceResponse(s) ? this._sessionEventDispatcher.dispatch({ eventName: Xn.DEVICE_STATE_UPDATE_LOCKED }) : this._sessionEventDispatcher.dispatch({ eventName: Xn.DEVICE_STATE_UPDATE_CONNECTED });
      }).ifLeft(() => {
        this._sessionEventDispatcher.dispatch({ eventName: Xn.DEVICE_STATE_UPDATE_CONNECTED });
      }), i;
    } finally {
      n();
    }
  }
  async sendCommand(e, t) {
    const n = e.getApdu();
    return (await this.sendApdu(n.getRawApdu(), { isPolling: !1, triggersDisconnection: e.triggersDisconnection ?? !1, abortTimeout: t })).caseOf({ Left: (i) => {
      throw i;
    }, Right: (i) => e.parseResponse(i, this._connectedDevice.deviceModel.id) });
  }
  executeDeviceAction(e) {
    const { observable: t, cancel: n } = e._execute({ sendApdu: async (i) => this.sendApdu(i), sendCommand: async (i, s) => this.sendCommand(i, s), getDeviceModel: () => this._connectedDevice.deviceModel, getDeviceSessionState: () => this._deviceState.getValue(), getDeviceSessionStateObservable: () => this.state, setDeviceSessionState: (i) => (this.setDeviceSessionState(i), this._deviceState.getValue()), disableRefresher: (i) => this._refresherService.disableRefresher(i), getManagerApiService: () => this._managerApiService, getSecureChannelService: () => this._secureChannelService });
    return { observable: t, cancel: n };
  }
  close() {
    this._updateDeviceStatus(na.NOT_CONNECTED), this._deviceState.complete(), this._deviceSessionRefresher.stopRefresher();
  }
  disableRefresher(e) {
    return this._refresherService.disableRefresher(e);
  }
  _updateDeviceStatus(e) {
    const t = this._deviceState.getValue();
    this._deviceState.next({ ...t, deviceStatus: e });
  }
};
const hd = { SecureChannelService: Symbol.for("SecureChannelService"), SecureChannelDataSource: Symbol.for("SecureChannelDataSource"), DmkConfig: Symbol.for("SecureChannelDmkConfig") };
var DH = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Of = (r, e) => (t, n) => e(t, n, r);
let JS = class {
  constructor(e, t, n, i, s) {
    h(this, "_transportService");
    h(this, "_sessionService");
    h(this, "_loggerFactory");
    h(this, "_managerApi");
    h(this, "_secureChannel");
    h(this, "_logger");
    this._sessionService = t, this._transportService = e, this._loggerFactory = n, this._logger = n("ConnectUseCase"), this._managerApi = i, this._secureChannel = s;
  }
  handleDeviceDisconnect(e) {
    this._sessionService.getDeviceSessionByDeviceId(e).map((t) => {
      this._sessionService.removeDeviceSession(t.id);
    });
  }
  async execute({ device: e, sessionRefresherOptions: t }) {
    const n = this._transportService.getTransport(e.transport);
    return me.liftEither(n.toEither(new I1(new Error("Unknown transport")))).chain(async (i) => i.connect({ deviceId: e.id, onDisconnect: (s) => this.handleDeviceDisconnect(s) })).ifLeft((i) => {
      this._logger.error("Error connecting to device", { data: { deviceId: e.id, error: i } });
    }).map(async (i) => {
      const s = new CH({ connectedDevice: i }, this._loggerFactory, this._managerApi, this._secureChannel, t);
      return this._sessionService.addDeviceSession(s), await s.initialiseSession(), s.id;
    }).caseOf({ Left: (i) => {
      throw i;
    }, Right: (i) => i });
  }
};
JS = DH([le(), Of(0, X(Ki.TransportService)), Of(1, X(Vt.DeviceSessionService)), Of(2, X(Er.LoggerPublisherServiceFactory)), Of(3, X(xi.ManagerApiService)), Of(4, X(hd.SecureChannelService))], JS);
var TH = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Kb = (r, e) => (t, n) => e(t, n, r);
let XS = class {
  constructor(e, t, n) {
    h(this, "_transportService");
    h(this, "_sessionService");
    h(this, "_logger");
    this._sessionService = t, this._transportService = e, this._logger = n("DisconnectUseCase");
  }
  async execute({ sessionId: e }) {
    return me(async ({ liftEither: t }) => {
      const n = await t(this._sessionService.getDeviceSessionById(e).ifLeft((o) => {
        this._logger.error("Device session not found", { data: { sessionId: e, error: o } });
      })), i = n.connectedDevice.transport, s = await t(this._transportService.getTransport(i).toEither(new I1(new Error("Unknown transport"))));
      n.close(), this._sessionService.removeDeviceSession(e), await s.disconnect({ connectedDevice: n.connectedDevice });
    }).caseOf({ Left: (t) => {
      throw this._logger.error("Error disconnecting from device", { data: { error: t } }), t;
    }, Right: () => {
    } });
  }
};
XS = TH([le(), Kb(0, X(Ki.TransportService)), Kb(1, X(Vt.DeviceSessionService)), Kb(2, X(Er.LoggerPublisherServiceFactory))], XS);
let U1 = class {
  constructor({ transportConnectedDevice: { id: e, deviceModel: { id: t, productName: n }, type: i }, sessionId: s }) {
    h(this, "id");
    h(this, "sessionId");
    h(this, "modelId");
    h(this, "name");
    h(this, "type");
    this.id = e, this.sessionId = s, this.modelId = t, this.name = n, this.type = i;
  }
};
var kH = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, wk = (r, e) => (t, n) => e(t, n, r);
let YS = class {
  constructor(e, t) {
    h(this, "_sessionService");
    h(this, "_logger");
    this._sessionService = e, this._logger = t("GetConnectedDeviceUseCase");
  }
  execute({ sessionId: e }) {
    return this._sessionService.getDeviceSessionById(e).caseOf({ Right: (t) => new U1({ sessionId: t.id, transportConnectedDevice: t.connectedDevice }), Left: (t) => {
      throw this._logger.error("Error getting session", { data: { error: t } }), t;
    } });
  }
};
YS = kH([le(), wk(0, X(Vt.DeviceSessionService)), wk(1, X(Er.LoggerPublisherServiceFactory))], YS);
var OH = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, _k = (r, e) => (t, n) => e(t, n, r);
let QS = class {
  constructor(e, t) {
    h(this, "_sessionService");
    h(this, "_logger");
    this._sessionService = e, this._logger = t("ListConnectedDeviceUseCase");
  }
  execute() {
    return this._logger.info("Listing connected devices"), this._sessionService.getDeviceSessions().map((e) => new U1({ transportConnectedDevice: e.connectedDevice, sessionId: e.id }));
  }
};
QS = OH([le(), _k(0, X(Vt.DeviceSessionService)), _k(1, X(Er.LoggerPublisherServiceFactory))], QS);
var $H = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Sk = (r, e) => (t, n) => e(t, n, r);
let eE = class {
  constructor(e, t) {
    h(this, "_transports");
    h(this, "_transportService");
    h(this, "_logger");
    this._transports = e.getAllTransports(), this._transportService = e, this._logger = t("ListenToAvailableDevicesUseCase");
  }
  mapTransportDiscoveredDeviceToDiscoveredDevice(e) {
    const t = new LB({ id: e.id, model: e.deviceModel.id, name: e.deviceModel.productName });
    return { id: e.id, deviceModel: t, transport: e.transport, name: e.name || t.name, rssi: e.rssi };
  }
  execute({ transport: e } = {}) {
    if (this._logger.info("Listening to available devices"), this._transports.length === 0) return this._logger.warn("No transports available"), rn([[]]);
    if (!e) {
      this._logger.info("Discovering all available transports");
      const t = this._transports.map((n, i) => n.listenToAvailableDevices().pipe(cr((s) => ({ index: i, arr: s }))));
      return x1(...t).pipe(A1((n, { index: i, arr: s }) => (n[i] = s, n), {}), cr((n) => Object.values(n).flat().map(this.mapTransportDiscoveredDeviceToDiscoveredDevice)));
    }
    return this._logger.info(`Discovering devices on transport ${e}`), this._transportService.getTransport(e).caseOf({ Nothing: () => (this._logger.error(`Transport ${e} not found`), Ji([])), Just: (t) => t.listenToAvailableDevices().pipe(cr((n) => n.map(this.mapTransportDiscoveredDeviceToDiscoveredDevice))) });
  }
};
eE = $H([le(), Sk(0, X(Ki.TransportService)), Sk(1, X(Er.LoggerPublisherServiceFactory))], eE);
var RH = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Ek = (r, e) => (t, n) => e(t, n, r);
let tE = class {
  constructor(e, t) {
    h(this, "_logger");
    this._sessionService = e, this._logger = t("ListenToConnectedDeviceUseCase");
  }
  execute() {
    return this._logger.info("Observe connected devices"), this._sessionService.sessionsObs.pipe(cr((e) => new U1({ transportConnectedDevice: e.connectedDevice, sessionId: e.id })));
  }
};
tE = RH([le(), Ek(0, X(Vt.DeviceSessionService)), Ek(1, X(Er.LoggerPublisherServiceFactory))], tE);
var PH = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, NH = (r, e) => (t, n) => e(t, n, r);
let rE = class {
  constructor(e) {
    this._transportService = e;
  }
  mapDiscoveredDevice(e) {
    const t = new LB({ id: e.id, model: e.deviceModel.id, name: e.deviceModel.productName });
    return { id: e.id, deviceModel: t, transport: e.transport, name: e.name || t.name, rssi: e.rssi };
  }
  execute({ transport: e } = {}) {
    if (!e) {
      const t = this._transportService.getAllTransports();
      return Ji(...t).pipe(cf((n) => n.startDiscovering().pipe(cr((i) => this.mapDiscoveredDevice(i)))));
    }
    return this._transportService.getTransport(e).caseOf({ Just: (t) => t.startDiscovering().pipe(cr((n) => this.mapDiscoveredDevice(n))), Nothing: () => {
      throw new I1(new Error("Unknown transport"));
    } });
  }
};
rE = PH([le(), NH(0, X(Ki.TransportService))], rE);
var BH = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, xk = (r, e) => (t, n) => e(t, n, r);
let nE = class {
  constructor(e, t) {
    h(this, "_logger");
    this.transportService = e, this._logger = t("StopDiscoveringUseCase");
  }
  async execute() {
    this._logger.debug("Stopping discovering devices");
    for (const e of this.transportService.getAllTransports()) await e.stopDiscovering();
  }
};
nE = BH([le(), xk(0, X(Ki.TransportService)), xk(1, X(Er.LoggerPublisherServiceFactory))], nE);
const LH = ({ stub: r = !1 }) => new mt(({ bind: e, rebindSync: t }) => {
  e(Yt.ConnectUseCase).to(JS), e(Yt.DisconnectUseCase).to(XS), e(Yt.StartDiscoveringUseCase).to(rE), e(Yt.StopDiscoveringUseCase).to(nE), e(Yt.GetConnectedDeviceUseCase).to(YS), e(Yt.ListenToAvailableDevicesUseCase).to(eE), e(Yt.ListenToConnectedDeviceUseCase).to(tE), e(Yt.ListConnectedDevicesUseCase).to(QS), r && (t(Yt.ConnectUseCase).to(Ur), t(Yt.DisconnectUseCase).to(Ur), t(Yt.StartDiscoveringUseCase).to(Ur), t(Yt.StopDiscoveringUseCase).to(Ur), t(Yt.GetConnectedDeviceUseCase).to(Ur), t(Yt.ListenToAvailableDevicesUseCase).to(Ur), t(Yt.ListenToConnectedDeviceUseCase).to(Ur), t(Yt.ListConnectedDevicesUseCase).to(Ur));
});
var Wr = ((r) => (r[r.Fatal = 0] = "Fatal", r[r.Error = 1] = "Error", r[r.Warning = 2] = "Warning", r[r.Info = 3] = "Info", r[r.Debug = 4] = "Debug", r))(Wr || {}), UH = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
};
let iE = class {
  constructor(e, t) {
    h(this, "subscribers");
    h(this, "tag");
    this.subscribers = e, this.tag = t;
  }
  _log(e, t, n) {
    this.subscribers.forEach((i) => {
      const s = { timestamp: Date.now(), tag: this.tag, ...n };
      i.log(e, t, s);
    });
  }
  info(e, t) {
    this._log(Wr.Info, e, t);
  }
  warn(e, t) {
    this._log(Wr.Warning, e, t);
  }
  debug(e, t) {
    this._log(Wr.Debug, e, t);
  }
  error(e, t) {
    this._log(Wr.Error, e, t);
  }
};
iE = UH([le()], iE);
const FH = ({ subscribers: r } = { subscribers: [] }) => new mt(({ bind: e }) => {
  e(Er.LoggerPublisherServiceFactory).toFactory((t) => (n) => new iE(r, n));
});
function kU(r, e) {
  return function() {
    return r.apply(e, arguments);
  };
}
const { toString: MH } = Object.prototype, { getPrototypeOf: F1 } = Object, Fv = /* @__PURE__ */ ((r) => (e) => {
  const t = MH.call(e);
  return r[t] || (r[t] = t.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Ls = (r) => (r = r.toLowerCase(), (e) => Fv(e) === r), Mv = (r) => (e) => typeof e === r, { isArray: lf } = Array, Mp = Mv("undefined");
function VH(r) {
  return r !== null && !Mp(r) && r.constructor !== null && !Mp(r.constructor) && Di(r.constructor.isBuffer) && r.constructor.isBuffer(r);
}
const OU = Ls("ArrayBuffer");
function zH(r) {
  let e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(r) : e = r && r.buffer && OU(r.buffer), e;
}
const jH = Mv("string"), Di = Mv("function"), $U = Mv("number"), Vv = (r) => r !== null && typeof r == "object", HH = (r) => r === !0 || r === !1, ay = (r) => {
  if (Fv(r) !== "object")
    return !1;
  const e = F1(r);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in r) && !(Symbol.iterator in r);
}, GH = Ls("Date"), KH = Ls("File"), qH = Ls("Blob"), WH = Ls("FileList"), ZH = (r) => Vv(r) && Di(r.pipe), JH = (r) => {
  let e;
  return r && (typeof FormData == "function" && r instanceof FormData || Di(r.append) && ((e = Fv(r)) === "formdata" || // detect form-data instance
  e === "object" && Di(r.toString) && r.toString() === "[object FormData]"));
}, XH = Ls("URLSearchParams"), [YH, QH, e7, t7] = ["ReadableStream", "Request", "Response", "Headers"].map(Ls), r7 = (r) => r.trim ? r.trim() : r.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Gg(r, e, { allOwnKeys: t = !1 } = {}) {
  if (r === null || typeof r > "u")
    return;
  let n, i;
  if (typeof r != "object" && (r = [r]), lf(r))
    for (n = 0, i = r.length; n < i; n++)
      e.call(null, r[n], n, r);
  else {
    const s = t ? Object.getOwnPropertyNames(r) : Object.keys(r), o = s.length;
    let a;
    for (n = 0; n < o; n++)
      a = s[n], e.call(null, r[a], a, r);
  }
}
function RU(r, e) {
  e = e.toLowerCase();
  const t = Object.keys(r);
  let n = t.length, i;
  for (; n-- > 0; )
    if (i = t[n], e === i.toLowerCase())
      return i;
  return null;
}
const Jc = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, PU = (r) => !Mp(r) && r !== Jc;
function sE() {
  const { caseless: r } = PU(this) && this || {}, e = {}, t = (n, i) => {
    const s = r && RU(e, i) || i;
    ay(e[s]) && ay(n) ? e[s] = sE(e[s], n) : ay(n) ? e[s] = sE({}, n) : lf(n) ? e[s] = n.slice() : e[s] = n;
  };
  for (let n = 0, i = arguments.length; n < i; n++)
    arguments[n] && Gg(arguments[n], t);
  return e;
}
const n7 = (r, e, t, { allOwnKeys: n } = {}) => (Gg(e, (i, s) => {
  t && Di(i) ? r[s] = kU(i, t) : r[s] = i;
}, { allOwnKeys: n }), r), i7 = (r) => (r.charCodeAt(0) === 65279 && (r = r.slice(1)), r), s7 = (r, e, t, n) => {
  r.prototype = Object.create(e.prototype, n), r.prototype.constructor = r, Object.defineProperty(r, "super", {
    value: e.prototype
  }), t && Object.assign(r.prototype, t);
}, o7 = (r, e, t, n) => {
  let i, s, o;
  const a = {};
  if (e = e || {}, r == null) return e;
  do {
    for (i = Object.getOwnPropertyNames(r), s = i.length; s-- > 0; )
      o = i[s], (!n || n(o, r, e)) && !a[o] && (e[o] = r[o], a[o] = !0);
    r = t !== !1 && F1(r);
  } while (r && (!t || t(r, e)) && r !== Object.prototype);
  return e;
}, a7 = (r, e, t) => {
  r = String(r), (t === void 0 || t > r.length) && (t = r.length), t -= e.length;
  const n = r.indexOf(e, t);
  return n !== -1 && n === t;
}, c7 = (r) => {
  if (!r) return null;
  if (lf(r)) return r;
  let e = r.length;
  if (!$U(e)) return null;
  const t = new Array(e);
  for (; e-- > 0; )
    t[e] = r[e];
  return t;
}, u7 = /* @__PURE__ */ ((r) => (e) => r && e instanceof r)(typeof Uint8Array < "u" && F1(Uint8Array)), l7 = (r, e) => {
  const n = (r && r[Symbol.iterator]).call(r);
  let i;
  for (; (i = n.next()) && !i.done; ) {
    const s = i.value;
    e.call(r, s[0], s[1]);
  }
}, d7 = (r, e) => {
  let t;
  const n = [];
  for (; (t = r.exec(e)) !== null; )
    n.push(t);
  return n;
}, h7 = Ls("HTMLFormElement"), f7 = (r) => r.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(t, n, i) {
    return n.toUpperCase() + i;
  }
), Ak = (({ hasOwnProperty: r }) => (e, t) => r.call(e, t))(Object.prototype), p7 = Ls("RegExp"), NU = (r, e) => {
  const t = Object.getOwnPropertyDescriptors(r), n = {};
  Gg(t, (i, s) => {
    let o;
    (o = e(i, s, r)) !== !1 && (n[s] = o || i);
  }), Object.defineProperties(r, n);
}, g7 = (r) => {
  NU(r, (e, t) => {
    if (Di(r) && ["arguments", "caller", "callee"].indexOf(t) !== -1)
      return !1;
    const n = r[t];
    if (Di(n)) {
      if (e.enumerable = !1, "writable" in e) {
        e.writable = !1;
        return;
      }
      e.set || (e.set = () => {
        throw Error("Can not rewrite read-only method '" + t + "'");
      });
    }
  });
}, m7 = (r, e) => {
  const t = {}, n = (i) => {
    i.forEach((s) => {
      t[s] = !0;
    });
  };
  return lf(r) ? n(r) : n(String(r).split(e)), t;
}, y7 = () => {
}, v7 = (r, e) => r != null && Number.isFinite(r = +r) ? r : e;
function b7(r) {
  return !!(r && Di(r.append) && r[Symbol.toStringTag] === "FormData" && r[Symbol.iterator]);
}
const w7 = (r) => {
  const e = new Array(10), t = (n, i) => {
    if (Vv(n)) {
      if (e.indexOf(n) >= 0)
        return;
      if (!("toJSON" in n)) {
        e[i] = n;
        const s = lf(n) ? [] : {};
        return Gg(n, (o, a) => {
          const c = t(o, i + 1);
          !Mp(c) && (s[a] = c);
        }), e[i] = void 0, s;
      }
    }
    return n;
  };
  return t(r, 0);
}, _7 = Ls("AsyncFunction"), S7 = (r) => r && (Vv(r) || Di(r)) && Di(r.then) && Di(r.catch), BU = ((r, e) => r ? setImmediate : e ? ((t, n) => (Jc.addEventListener("message", ({ source: i, data: s }) => {
  i === Jc && s === t && n.length && n.shift()();
}, !1), (i) => {
  n.push(i), Jc.postMessage(t, "*");
}))(`axios@${Math.random()}`, []) : (t) => setTimeout(t))(
  typeof setImmediate == "function",
  Di(Jc.postMessage)
), E7 = typeof queueMicrotask < "u" ? queueMicrotask.bind(Jc) : typeof process < "u" && process.nextTick || BU, ie = {
  isArray: lf,
  isArrayBuffer: OU,
  isBuffer: VH,
  isFormData: JH,
  isArrayBufferView: zH,
  isString: jH,
  isNumber: $U,
  isBoolean: HH,
  isObject: Vv,
  isPlainObject: ay,
  isReadableStream: YH,
  isRequest: QH,
  isResponse: e7,
  isHeaders: t7,
  isUndefined: Mp,
  isDate: GH,
  isFile: KH,
  isBlob: qH,
  isRegExp: p7,
  isFunction: Di,
  isStream: ZH,
  isURLSearchParams: XH,
  isTypedArray: u7,
  isFileList: WH,
  forEach: Gg,
  merge: sE,
  extend: n7,
  trim: r7,
  stripBOM: i7,
  inherits: s7,
  toFlatObject: o7,
  kindOf: Fv,
  kindOfTest: Ls,
  endsWith: a7,
  toArray: c7,
  forEachEntry: l7,
  matchAll: d7,
  isHTMLForm: h7,
  hasOwnProperty: Ak,
  hasOwnProp: Ak,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: NU,
  freezeMethods: g7,
  toObjectSet: m7,
  toCamelCase: f7,
  noop: y7,
  toFiniteNumber: v7,
  findKey: RU,
  global: Jc,
  isContextDefined: PU,
  isSpecCompliantForm: b7,
  toJSONObject: w7,
  isAsyncFn: _7,
  isThenable: S7,
  setImmediate: BU,
  asap: E7
};
function Ye(r, e, t, n, i) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = r, this.name = "AxiosError", e && (this.code = e), t && (this.config = t), n && (this.request = n), i && (this.response = i, this.status = i.status ? i.status : null);
}
ie.inherits(Ye, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: ie.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const LU = Ye.prototype, UU = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((r) => {
  UU[r] = { value: r };
});
Object.defineProperties(Ye, UU);
Object.defineProperty(LU, "isAxiosError", { value: !0 });
Ye.from = (r, e, t, n, i, s) => {
  const o = Object.create(LU);
  return ie.toFlatObject(r, o, function(c) {
    return c !== Error.prototype;
  }, (a) => a !== "isAxiosError"), Ye.call(o, r.message, e, t, n, i), o.cause = r, o.name = r.name, s && Object.assign(o, s), o;
};
const x7 = null;
function oE(r) {
  return ie.isPlainObject(r) || ie.isArray(r);
}
function FU(r) {
  return ie.endsWith(r, "[]") ? r.slice(0, -2) : r;
}
function Ik(r, e, t) {
  return r ? r.concat(e).map(function(i, s) {
    return i = FU(i), !t && s ? "[" + i + "]" : i;
  }).join(t ? "." : "") : e;
}
function A7(r) {
  return ie.isArray(r) && !r.some(oE);
}
const I7 = ie.toFlatObject(ie, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function zv(r, e, t) {
  if (!ie.isObject(r))
    throw new TypeError("target must be an object");
  e = e || new FormData(), t = ie.toFlatObject(t, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(g, v) {
    return !ie.isUndefined(v[g]);
  });
  const n = t.metaTokens, i = t.visitor || l, s = t.dots, o = t.indexes, c = (t.Blob || typeof Blob < "u" && Blob) && ie.isSpecCompliantForm(e);
  if (!ie.isFunction(i))
    throw new TypeError("visitor must be a function");
  function u(y) {
    if (y === null) return "";
    if (ie.isDate(y))
      return y.toISOString();
    if (!c && ie.isBlob(y))
      throw new Ye("Blob is not supported. Use a Buffer instead.");
    return ie.isArrayBuffer(y) || ie.isTypedArray(y) ? c && typeof Blob == "function" ? new Blob([y]) : Buffer.from(y) : y;
  }
  function l(y, g, v) {
    let _ = y;
    if (y && !v && typeof y == "object") {
      if (ie.endsWith(g, "{}"))
        g = n ? g : g.slice(0, -2), y = JSON.stringify(y);
      else if (ie.isArray(y) && A7(y) || (ie.isFileList(y) || ie.endsWith(g, "[]")) && (_ = ie.toArray(y)))
        return g = FU(g), _.forEach(function(E, I) {
          !(ie.isUndefined(E) || E === null) && e.append(
            // eslint-disable-next-line no-nested-ternary
            o === !0 ? Ik([g], I, s) : o === null ? g : g + "[]",
            u(E)
          );
        }), !1;
    }
    return oE(y) ? !0 : (e.append(Ik(v, g, s), u(y)), !1);
  }
  const d = [], f = Object.assign(I7, {
    defaultVisitor: l,
    convertValue: u,
    isVisitable: oE
  });
  function p(y, g) {
    if (!ie.isUndefined(y)) {
      if (d.indexOf(y) !== -1)
        throw Error("Circular reference detected in " + g.join("."));
      d.push(y), ie.forEach(y, function(_, w) {
        (!(ie.isUndefined(_) || _ === null) && i.call(
          e,
          _,
          ie.isString(w) ? w.trim() : w,
          g,
          f
        )) === !0 && p(_, g ? g.concat(w) : [w]);
      }), d.pop();
    }
  }
  if (!ie.isObject(r))
    throw new TypeError("data must be an object");
  return p(r), e;
}
function Ck(r) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(r).replace(/[!'()~]|%20|%00/g, function(n) {
    return e[n];
  });
}
function M1(r, e) {
  this._pairs = [], r && zv(r, this, e);
}
const MU = M1.prototype;
MU.append = function(e, t) {
  this._pairs.push([e, t]);
};
MU.toString = function(e) {
  const t = e ? function(n) {
    return e.call(this, n, Ck);
  } : Ck;
  return this._pairs.map(function(i) {
    return t(i[0]) + "=" + t(i[1]);
  }, "").join("&");
};
function C7(r) {
  return encodeURIComponent(r).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function VU(r, e, t) {
  if (!e)
    return r;
  const n = t && t.encode || C7;
  ie.isFunction(t) && (t = {
    serialize: t
  });
  const i = t && t.serialize;
  let s;
  if (i ? s = i(e, t) : s = ie.isURLSearchParams(e) ? e.toString() : new M1(e, t).toString(n), s) {
    const o = r.indexOf("#");
    o !== -1 && (r = r.slice(0, o)), r += (r.indexOf("?") === -1 ? "?" : "&") + s;
  }
  return r;
}
class Dk {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(e, t, n) {
    return this.handlers.push({
      fulfilled: e,
      rejected: t,
      synchronous: n ? n.synchronous : !1,
      runWhen: n ? n.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(e) {
    ie.forEach(this.handlers, function(n) {
      n !== null && e(n);
    });
  }
}
const zU = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, D7 = typeof URLSearchParams < "u" ? URLSearchParams : M1, T7 = typeof FormData < "u" ? FormData : null, k7 = typeof Blob < "u" ? Blob : null, O7 = {
  isBrowser: !0,
  classes: {
    URLSearchParams: D7,
    FormData: T7,
    Blob: k7
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, V1 = typeof window < "u" && typeof document < "u", aE = typeof navigator == "object" && navigator || void 0, $7 = V1 && (!aE || ["ReactNative", "NativeScript", "NS"].indexOf(aE.product) < 0), R7 = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", P7 = V1 && window.location.href || "http://localhost", N7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: V1,
  hasStandardBrowserEnv: $7,
  hasStandardBrowserWebWorkerEnv: R7,
  navigator: aE,
  origin: P7
}, Symbol.toStringTag, { value: "Module" })), pn = {
  ...N7,
  ...O7
};
function B7(r, e) {
  return zv(r, new pn.classes.URLSearchParams(), Object.assign({
    visitor: function(t, n, i, s) {
      return pn.isNode && ie.isBuffer(t) ? (this.append(n, t.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments);
    }
  }, e));
}
function L7(r) {
  return ie.matchAll(/\w+|\[(\w*)]/g, r).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
}
function U7(r) {
  const e = {}, t = Object.keys(r);
  let n;
  const i = t.length;
  let s;
  for (n = 0; n < i; n++)
    s = t[n], e[s] = r[s];
  return e;
}
function jU(r) {
  function e(t, n, i, s) {
    let o = t[s++];
    if (o === "__proto__") return !0;
    const a = Number.isFinite(+o), c = s >= t.length;
    return o = !o && ie.isArray(i) ? i.length : o, c ? (ie.hasOwnProp(i, o) ? i[o] = [i[o], n] : i[o] = n, !a) : ((!i[o] || !ie.isObject(i[o])) && (i[o] = []), e(t, n, i[o], s) && ie.isArray(i[o]) && (i[o] = U7(i[o])), !a);
  }
  if (ie.isFormData(r) && ie.isFunction(r.entries)) {
    const t = {};
    return ie.forEachEntry(r, (n, i) => {
      e(L7(n), i, t, 0);
    }), t;
  }
  return null;
}
function F7(r, e, t) {
  if (ie.isString(r))
    try {
      return (e || JSON.parse)(r), ie.trim(r);
    } catch (n) {
      if (n.name !== "SyntaxError")
        throw n;
    }
  return (t || JSON.stringify)(r);
}
const Kg = {
  transitional: zU,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, t) {
    const n = t.getContentType() || "", i = n.indexOf("application/json") > -1, s = ie.isObject(e);
    if (s && ie.isHTMLForm(e) && (e = new FormData(e)), ie.isFormData(e))
      return i ? JSON.stringify(jU(e)) : e;
    if (ie.isArrayBuffer(e) || ie.isBuffer(e) || ie.isStream(e) || ie.isFile(e) || ie.isBlob(e) || ie.isReadableStream(e))
      return e;
    if (ie.isArrayBufferView(e))
      return e.buffer;
    if (ie.isURLSearchParams(e))
      return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let a;
    if (s) {
      if (n.indexOf("application/x-www-form-urlencoded") > -1)
        return B7(e, this.formSerializer).toString();
      if ((a = ie.isFileList(e)) || n.indexOf("multipart/form-data") > -1) {
        const c = this.env && this.env.FormData;
        return zv(
          a ? { "files[]": e } : e,
          c && new c(),
          this.formSerializer
        );
      }
    }
    return s || i ? (t.setContentType("application/json", !1), F7(e)) : e;
  }],
  transformResponse: [function(e) {
    const t = this.transitional || Kg.transitional, n = t && t.forcedJSONParsing, i = this.responseType === "json";
    if (ie.isResponse(e) || ie.isReadableStream(e))
      return e;
    if (e && ie.isString(e) && (n && !this.responseType || i)) {
      const o = !(t && t.silentJSONParsing) && i;
      try {
        return JSON.parse(e);
      } catch (a) {
        if (o)
          throw a.name === "SyntaxError" ? Ye.from(a, Ye.ERR_BAD_RESPONSE, this, null, this.response) : a;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: pn.classes.FormData,
    Blob: pn.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
ie.forEach(["delete", "get", "head", "post", "put", "patch"], (r) => {
  Kg.headers[r] = {};
});
const M7 = ie.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), V7 = (r) => {
  const e = {};
  let t, n, i;
  return r && r.split(`
`).forEach(function(o) {
    i = o.indexOf(":"), t = o.substring(0, i).trim().toLowerCase(), n = o.substring(i + 1).trim(), !(!t || e[t] && M7[t]) && (t === "set-cookie" ? e[t] ? e[t].push(n) : e[t] = [n] : e[t] = e[t] ? e[t] + ", " + n : n);
  }), e;
}, Tk = Symbol("internals");
function $f(r) {
  return r && String(r).trim().toLowerCase();
}
function cy(r) {
  return r === !1 || r == null ? r : ie.isArray(r) ? r.map(cy) : String(r);
}
function z7(r) {
  const e = /* @__PURE__ */ Object.create(null), t = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let n;
  for (; n = t.exec(r); )
    e[n[1]] = n[2];
  return e;
}
const j7 = (r) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(r.trim());
function qb(r, e, t, n, i) {
  if (ie.isFunction(n))
    return n.call(this, e, t);
  if (i && (e = t), !!ie.isString(e)) {
    if (ie.isString(n))
      return e.indexOf(n) !== -1;
    if (ie.isRegExp(n))
      return n.test(e);
  }
}
function H7(r) {
  return r.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, t, n) => t.toUpperCase() + n);
}
function G7(r, e) {
  const t = ie.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((n) => {
    Object.defineProperty(r, n + t, {
      value: function(i, s, o) {
        return this[n].call(this, e, i, s, o);
      },
      configurable: !0
    });
  });
}
let ni = class {
  constructor(e) {
    e && this.set(e);
  }
  set(e, t, n) {
    const i = this;
    function s(a, c, u) {
      const l = $f(c);
      if (!l)
        throw new Error("header name must be a non-empty string");
      const d = ie.findKey(i, l);
      (!d || i[d] === void 0 || u === !0 || u === void 0 && i[d] !== !1) && (i[d || c] = cy(a));
    }
    const o = (a, c) => ie.forEach(a, (u, l) => s(u, l, c));
    if (ie.isPlainObject(e) || e instanceof this.constructor)
      o(e, t);
    else if (ie.isString(e) && (e = e.trim()) && !j7(e))
      o(V7(e), t);
    else if (ie.isHeaders(e))
      for (const [a, c] of e.entries())
        s(c, a, n);
    else
      e != null && s(t, e, n);
    return this;
  }
  get(e, t) {
    if (e = $f(e), e) {
      const n = ie.findKey(this, e);
      if (n) {
        const i = this[n];
        if (!t)
          return i;
        if (t === !0)
          return z7(i);
        if (ie.isFunction(t))
          return t.call(this, i, n);
        if (ie.isRegExp(t))
          return t.exec(i);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, t) {
    if (e = $f(e), e) {
      const n = ie.findKey(this, e);
      return !!(n && this[n] !== void 0 && (!t || qb(this, this[n], n, t)));
    }
    return !1;
  }
  delete(e, t) {
    const n = this;
    let i = !1;
    function s(o) {
      if (o = $f(o), o) {
        const a = ie.findKey(n, o);
        a && (!t || qb(n, n[a], a, t)) && (delete n[a], i = !0);
      }
    }
    return ie.isArray(e) ? e.forEach(s) : s(e), i;
  }
  clear(e) {
    const t = Object.keys(this);
    let n = t.length, i = !1;
    for (; n--; ) {
      const s = t[n];
      (!e || qb(this, this[s], s, e, !0)) && (delete this[s], i = !0);
    }
    return i;
  }
  normalize(e) {
    const t = this, n = {};
    return ie.forEach(this, (i, s) => {
      const o = ie.findKey(n, s);
      if (o) {
        t[o] = cy(i), delete t[s];
        return;
      }
      const a = e ? H7(s) : String(s).trim();
      a !== s && delete t[s], t[a] = cy(i), n[a] = !0;
    }), this;
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const t = /* @__PURE__ */ Object.create(null);
    return ie.forEach(this, (n, i) => {
      n != null && n !== !1 && (t[i] = e && ie.isArray(n) ? n.join(", ") : n);
    }), t;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, t]) => e + ": " + t).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...t) {
    const n = new this(e);
    return t.forEach((i) => n.set(i)), n;
  }
  static accessor(e) {
    const n = (this[Tk] = this[Tk] = {
      accessors: {}
    }).accessors, i = this.prototype;
    function s(o) {
      const a = $f(o);
      n[a] || (G7(i, o), n[a] = !0);
    }
    return ie.isArray(e) ? e.forEach(s) : s(e), this;
  }
};
ni.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
ie.reduceDescriptors(ni.prototype, ({ value: r }, e) => {
  let t = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => r,
    set(n) {
      this[t] = n;
    }
  };
});
ie.freezeMethods(ni);
function Wb(r, e) {
  const t = this || Kg, n = e || t, i = ni.from(n.headers);
  let s = n.data;
  return ie.forEach(r, function(a) {
    s = a.call(t, s, i.normalize(), e ? e.status : void 0);
  }), i.normalize(), s;
}
function HU(r) {
  return !!(r && r.__CANCEL__);
}
function df(r, e, t) {
  Ye.call(this, r ?? "canceled", Ye.ERR_CANCELED, e, t), this.name = "CanceledError";
}
ie.inherits(df, Ye, {
  __CANCEL__: !0
});
function GU(r, e, t) {
  const n = t.config.validateStatus;
  !t.status || !n || n(t.status) ? r(t) : e(new Ye(
    "Request failed with status code " + t.status,
    [Ye.ERR_BAD_REQUEST, Ye.ERR_BAD_RESPONSE][Math.floor(t.status / 100) - 4],
    t.config,
    t.request,
    t
  ));
}
function K7(r) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(r);
  return e && e[1] || "";
}
function q7(r, e) {
  r = r || 10;
  const t = new Array(r), n = new Array(r);
  let i = 0, s = 0, o;
  return e = e !== void 0 ? e : 1e3, function(c) {
    const u = Date.now(), l = n[s];
    o || (o = u), t[i] = c, n[i] = u;
    let d = s, f = 0;
    for (; d !== i; )
      f += t[d++], d = d % r;
    if (i = (i + 1) % r, i === s && (s = (s + 1) % r), u - o < e)
      return;
    const p = l && u - l;
    return p ? Math.round(f * 1e3 / p) : void 0;
  };
}
function W7(r, e) {
  let t = 0, n = 1e3 / e, i, s;
  const o = (u, l = Date.now()) => {
    t = l, i = null, s && (clearTimeout(s), s = null), r.apply(null, u);
  };
  return [(...u) => {
    const l = Date.now(), d = l - t;
    d >= n ? o(u, l) : (i = u, s || (s = setTimeout(() => {
      s = null, o(i);
    }, n - d)));
  }, () => i && o(i)];
}
const By = (r, e, t = 3) => {
  let n = 0;
  const i = q7(50, 250);
  return W7((s) => {
    const o = s.loaded, a = s.lengthComputable ? s.total : void 0, c = o - n, u = i(c), l = o <= a;
    n = o;
    const d = {
      loaded: o,
      total: a,
      progress: a ? o / a : void 0,
      bytes: c,
      rate: u || void 0,
      estimated: u && a && l ? (a - o) / u : void 0,
      event: s,
      lengthComputable: a != null,
      [e ? "download" : "upload"]: !0
    };
    r(d);
  }, t);
}, kk = (r, e) => {
  const t = r != null;
  return [(n) => e[0]({
    lengthComputable: t,
    total: r,
    loaded: n
  }), e[1]];
}, Ok = (r) => (...e) => ie.asap(() => r(...e)), Z7 = pn.hasStandardBrowserEnv ? /* @__PURE__ */ ((r, e) => (t) => (t = new URL(t, pn.origin), r.protocol === t.protocol && r.host === t.host && (e || r.port === t.port)))(
  new URL(pn.origin),
  pn.navigator && /(msie|trident)/i.test(pn.navigator.userAgent)
) : () => !0, J7 = pn.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(r, e, t, n, i, s) {
      const o = [r + "=" + encodeURIComponent(e)];
      ie.isNumber(t) && o.push("expires=" + new Date(t).toGMTString()), ie.isString(n) && o.push("path=" + n), ie.isString(i) && o.push("domain=" + i), s === !0 && o.push("secure"), document.cookie = o.join("; ");
    },
    read(r) {
      const e = document.cookie.match(new RegExp("(^|;\\s*)(" + r + ")=([^;]*)"));
      return e ? decodeURIComponent(e[3]) : null;
    },
    remove(r) {
      this.write(r, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function X7(r) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(r);
}
function Y7(r, e) {
  return e ? r.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : r;
}
function KU(r, e, t) {
  let n = !X7(e);
  return r && n || t == !1 ? Y7(r, e) : e;
}
const $k = (r) => r instanceof ni ? { ...r } : r;
function Zu(r, e) {
  e = e || {};
  const t = {};
  function n(u, l, d, f) {
    return ie.isPlainObject(u) && ie.isPlainObject(l) ? ie.merge.call({ caseless: f }, u, l) : ie.isPlainObject(l) ? ie.merge({}, l) : ie.isArray(l) ? l.slice() : l;
  }
  function i(u, l, d, f) {
    if (ie.isUndefined(l)) {
      if (!ie.isUndefined(u))
        return n(void 0, u, d, f);
    } else return n(u, l, d, f);
  }
  function s(u, l) {
    if (!ie.isUndefined(l))
      return n(void 0, l);
  }
  function o(u, l) {
    if (ie.isUndefined(l)) {
      if (!ie.isUndefined(u))
        return n(void 0, u);
    } else return n(void 0, l);
  }
  function a(u, l, d) {
    if (d in e)
      return n(u, l);
    if (d in r)
      return n(void 0, u);
  }
  const c = {
    url: s,
    method: s,
    data: s,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    withXSRFToken: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: a,
    headers: (u, l, d) => i($k(u), $k(l), d, !0)
  };
  return ie.forEach(Object.keys(Object.assign({}, r, e)), function(l) {
    const d = c[l] || i, f = d(r[l], e[l], l);
    ie.isUndefined(f) && d !== a || (t[l] = f);
  }), t;
}
const qU = (r) => {
  const e = Zu({}, r);
  let { data: t, withXSRFToken: n, xsrfHeaderName: i, xsrfCookieName: s, headers: o, auth: a } = e;
  e.headers = o = ni.from(o), e.url = VU(KU(e.baseURL, e.url), r.params, r.paramsSerializer), a && o.set(
    "Authorization",
    "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : ""))
  );
  let c;
  if (ie.isFormData(t)) {
    if (pn.hasStandardBrowserEnv || pn.hasStandardBrowserWebWorkerEnv)
      o.setContentType(void 0);
    else if ((c = o.getContentType()) !== !1) {
      const [u, ...l] = c ? c.split(";").map((d) => d.trim()).filter(Boolean) : [];
      o.setContentType([u || "multipart/form-data", ...l].join("; "));
    }
  }
  if (pn.hasStandardBrowserEnv && (n && ie.isFunction(n) && (n = n(e)), n || n !== !1 && Z7(e.url))) {
    const u = i && s && J7.read(s);
    u && o.set(i, u);
  }
  return e;
}, Q7 = typeof XMLHttpRequest < "u", e9 = Q7 && function(r) {
  return new Promise(function(t, n) {
    const i = qU(r);
    let s = i.data;
    const o = ni.from(i.headers).normalize();
    let { responseType: a, onUploadProgress: c, onDownloadProgress: u } = i, l, d, f, p, y;
    function g() {
      p && p(), y && y(), i.cancelToken && i.cancelToken.unsubscribe(l), i.signal && i.signal.removeEventListener("abort", l);
    }
    let v = new XMLHttpRequest();
    v.open(i.method.toUpperCase(), i.url, !0), v.timeout = i.timeout;
    function _() {
      if (!v)
        return;
      const E = ni.from(
        "getAllResponseHeaders" in v && v.getAllResponseHeaders()
      ), S = {
        data: !a || a === "text" || a === "json" ? v.responseText : v.response,
        status: v.status,
        statusText: v.statusText,
        headers: E,
        config: r,
        request: v
      };
      GU(function(b) {
        t(b), g();
      }, function(b) {
        n(b), g();
      }, S), v = null;
    }
    "onloadend" in v ? v.onloadend = _ : v.onreadystatechange = function() {
      !v || v.readyState !== 4 || v.status === 0 && !(v.responseURL && v.responseURL.indexOf("file:") === 0) || setTimeout(_);
    }, v.onabort = function() {
      v && (n(new Ye("Request aborted", Ye.ECONNABORTED, r, v)), v = null);
    }, v.onerror = function() {
      n(new Ye("Network Error", Ye.ERR_NETWORK, r, v)), v = null;
    }, v.ontimeout = function() {
      let I = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded";
      const S = i.transitional || zU;
      i.timeoutErrorMessage && (I = i.timeoutErrorMessage), n(new Ye(
        I,
        S.clarifyTimeoutError ? Ye.ETIMEDOUT : Ye.ECONNABORTED,
        r,
        v
      )), v = null;
    }, s === void 0 && o.setContentType(null), "setRequestHeader" in v && ie.forEach(o.toJSON(), function(I, S) {
      v.setRequestHeader(S, I);
    }), ie.isUndefined(i.withCredentials) || (v.withCredentials = !!i.withCredentials), a && a !== "json" && (v.responseType = i.responseType), u && ([f, y] = By(u, !0), v.addEventListener("progress", f)), c && v.upload && ([d, p] = By(c), v.upload.addEventListener("progress", d), v.upload.addEventListener("loadend", p)), (i.cancelToken || i.signal) && (l = (E) => {
      v && (n(!E || E.type ? new df(null, r, v) : E), v.abort(), v = null);
    }, i.cancelToken && i.cancelToken.subscribe(l), i.signal && (i.signal.aborted ? l() : i.signal.addEventListener("abort", l)));
    const w = K7(i.url);
    if (w && pn.protocols.indexOf(w) === -1) {
      n(new Ye("Unsupported protocol " + w + ":", Ye.ERR_BAD_REQUEST, r));
      return;
    }
    v.send(s || null);
  });
}, t9 = (r, e) => {
  const { length: t } = r = r ? r.filter(Boolean) : [];
  if (e || t) {
    let n = new AbortController(), i;
    const s = function(u) {
      if (!i) {
        i = !0, a();
        const l = u instanceof Error ? u : this.reason;
        n.abort(l instanceof Ye ? l : new df(l instanceof Error ? l.message : l));
      }
    };
    let o = e && setTimeout(() => {
      o = null, s(new Ye(`timeout ${e} of ms exceeded`, Ye.ETIMEDOUT));
    }, e);
    const a = () => {
      r && (o && clearTimeout(o), o = null, r.forEach((u) => {
        u.unsubscribe ? u.unsubscribe(s) : u.removeEventListener("abort", s);
      }), r = null);
    };
    r.forEach((u) => u.addEventListener("abort", s));
    const { signal: c } = n;
    return c.unsubscribe = () => ie.asap(a), c;
  }
}, r9 = function* (r, e) {
  let t = r.byteLength;
  if (t < e) {
    yield r;
    return;
  }
  let n = 0, i;
  for (; n < t; )
    i = n + e, yield r.slice(n, i), n = i;
}, n9 = async function* (r, e) {
  for await (const t of i9(r))
    yield* r9(t, e);
}, i9 = async function* (r) {
  if (r[Symbol.asyncIterator]) {
    yield* r;
    return;
  }
  const e = r.getReader();
  try {
    for (; ; ) {
      const { done: t, value: n } = await e.read();
      if (t)
        break;
      yield n;
    }
  } finally {
    await e.cancel();
  }
}, Rk = (r, e, t, n) => {
  const i = n9(r, e);
  let s = 0, o, a = (c) => {
    o || (o = !0, n && n(c));
  };
  return new ReadableStream({
    async pull(c) {
      try {
        const { done: u, value: l } = await i.next();
        if (u) {
          a(), c.close();
          return;
        }
        let d = l.byteLength;
        if (t) {
          let f = s += d;
          t(f);
        }
        c.enqueue(new Uint8Array(l));
      } catch (u) {
        throw a(u), u;
      }
    },
    cancel(c) {
      return a(c), i.return();
    }
  }, {
    highWaterMark: 2
  });
}, jv = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", WU = jv && typeof ReadableStream == "function", s9 = jv && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((r) => (e) => r.encode(e))(new TextEncoder()) : async (r) => new Uint8Array(await new Response(r).arrayBuffer())), ZU = (r, ...e) => {
  try {
    return !!r(...e);
  } catch {
    return !1;
  }
}, o9 = WU && ZU(() => {
  let r = !1;
  const e = new Request(pn.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return r = !0, "half";
    }
  }).headers.has("Content-Type");
  return r && !e;
}), Pk = 64 * 1024, cE = WU && ZU(() => ie.isReadableStream(new Response("").body)), Ly = {
  stream: cE && ((r) => r.body)
};
jv && ((r) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e) => {
    !Ly[e] && (Ly[e] = ie.isFunction(r[e]) ? (t) => t[e]() : (t, n) => {
      throw new Ye(`Response type '${e}' is not supported`, Ye.ERR_NOT_SUPPORT, n);
    });
  });
})(new Response());
const a9 = async (r) => {
  if (r == null)
    return 0;
  if (ie.isBlob(r))
    return r.size;
  if (ie.isSpecCompliantForm(r))
    return (await new Request(pn.origin, {
      method: "POST",
      body: r
    }).arrayBuffer()).byteLength;
  if (ie.isArrayBufferView(r) || ie.isArrayBuffer(r))
    return r.byteLength;
  if (ie.isURLSearchParams(r) && (r = r + ""), ie.isString(r))
    return (await s9(r)).byteLength;
}, c9 = async (r, e) => {
  const t = ie.toFiniteNumber(r.getContentLength());
  return t ?? a9(e);
}, u9 = jv && (async (r) => {
  let {
    url: e,
    method: t,
    data: n,
    signal: i,
    cancelToken: s,
    timeout: o,
    onDownloadProgress: a,
    onUploadProgress: c,
    responseType: u,
    headers: l,
    withCredentials: d = "same-origin",
    fetchOptions: f
  } = qU(r);
  u = u ? (u + "").toLowerCase() : "text";
  let p = t9([i, s && s.toAbortSignal()], o), y;
  const g = p && p.unsubscribe && (() => {
    p.unsubscribe();
  });
  let v;
  try {
    if (c && o9 && t !== "get" && t !== "head" && (v = await c9(l, n)) !== 0) {
      let S = new Request(e, {
        method: "POST",
        body: n,
        duplex: "half"
      }), T;
      if (ie.isFormData(n) && (T = S.headers.get("content-type")) && l.setContentType(T), S.body) {
        const [b, C] = kk(
          v,
          By(Ok(c))
        );
        n = Rk(S.body, Pk, b, C);
      }
    }
    ie.isString(d) || (d = d ? "include" : "omit");
    const _ = "credentials" in Request.prototype;
    y = new Request(e, {
      ...f,
      signal: p,
      method: t.toUpperCase(),
      headers: l.normalize().toJSON(),
      body: n,
      duplex: "half",
      credentials: _ ? d : void 0
    });
    let w = await fetch(y);
    const E = cE && (u === "stream" || u === "response");
    if (cE && (a || E && g)) {
      const S = {};
      ["status", "statusText", "headers"].forEach((P) => {
        S[P] = w[P];
      });
      const T = ie.toFiniteNumber(w.headers.get("content-length")), [b, C] = a && kk(
        T,
        By(Ok(a), !0)
      ) || [];
      w = new Response(
        Rk(w.body, Pk, b, () => {
          C && C(), g && g();
        }),
        S
      );
    }
    u = u || "text";
    let I = await Ly[ie.findKey(Ly, u) || "text"](w, r);
    return !E && g && g(), await new Promise((S, T) => {
      GU(S, T, {
        data: I,
        headers: ni.from(w.headers),
        status: w.status,
        statusText: w.statusText,
        config: r,
        request: y
      });
    });
  } catch (_) {
    throw g && g(), _ && _.name === "TypeError" && /fetch/i.test(_.message) ? Object.assign(
      new Ye("Network Error", Ye.ERR_NETWORK, r, y),
      {
        cause: _.cause || _
      }
    ) : Ye.from(_, _ && _.code, r, y);
  }
}), uE = {
  http: x7,
  xhr: e9,
  fetch: u9
};
ie.forEach(uE, (r, e) => {
  if (r) {
    try {
      Object.defineProperty(r, "name", { value: e });
    } catch {
    }
    Object.defineProperty(r, "adapterName", { value: e });
  }
});
const Nk = (r) => `- ${r}`, l9 = (r) => ie.isFunction(r) || r === null || r === !1, JU = {
  getAdapter: (r) => {
    r = ie.isArray(r) ? r : [r];
    const { length: e } = r;
    let t, n;
    const i = {};
    for (let s = 0; s < e; s++) {
      t = r[s];
      let o;
      if (n = t, !l9(t) && (n = uE[(o = String(t)).toLowerCase()], n === void 0))
        throw new Ye(`Unknown adapter '${o}'`);
      if (n)
        break;
      i[o || "#" + s] = n;
    }
    if (!n) {
      const s = Object.entries(i).map(
        ([a, c]) => `adapter ${a} ` + (c === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let o = e ? s.length > 1 ? `since :
` + s.map(Nk).join(`
`) : " " + Nk(s[0]) : "as no adapter specified";
      throw new Ye(
        "There is no suitable adapter to dispatch the request " + o,
        "ERR_NOT_SUPPORT"
      );
    }
    return n;
  },
  adapters: uE
};
function Zb(r) {
  if (r.cancelToken && r.cancelToken.throwIfRequested(), r.signal && r.signal.aborted)
    throw new df(null, r);
}
function Bk(r) {
  return Zb(r), r.headers = ni.from(r.headers), r.data = Wb.call(
    r,
    r.transformRequest
  ), ["post", "put", "patch"].indexOf(r.method) !== -1 && r.headers.setContentType("application/x-www-form-urlencoded", !1), JU.getAdapter(r.adapter || Kg.adapter)(r).then(function(n) {
    return Zb(r), n.data = Wb.call(
      r,
      r.transformResponse,
      n
    ), n.headers = ni.from(n.headers), n;
  }, function(n) {
    return HU(n) || (Zb(r), n && n.response && (n.response.data = Wb.call(
      r,
      r.transformResponse,
      n.response
    ), n.response.headers = ni.from(n.response.headers))), Promise.reject(n);
  });
}
const XU = "1.8.2", Hv = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((r, e) => {
  Hv[r] = function(n) {
    return typeof n === r || "a" + (e < 1 ? "n " : " ") + r;
  };
});
const Lk = {};
Hv.transitional = function(e, t, n) {
  function i(s, o) {
    return "[Axios v" + XU + "] Transitional option '" + s + "'" + o + (n ? ". " + n : "");
  }
  return (s, o, a) => {
    if (e === !1)
      throw new Ye(
        i(o, " has been removed" + (t ? " in " + t : "")),
        Ye.ERR_DEPRECATED
      );
    return t && !Lk[o] && (Lk[o] = !0, console.warn(
      i(
        o,
        " has been deprecated since v" + t + " and will be removed in the near future"
      )
    )), e ? e(s, o, a) : !0;
  };
};
Hv.spelling = function(e) {
  return (t, n) => (console.warn(`${n} is likely a misspelling of ${e}`), !0);
};
function d9(r, e, t) {
  if (typeof r != "object")
    throw new Ye("options must be an object", Ye.ERR_BAD_OPTION_VALUE);
  const n = Object.keys(r);
  let i = n.length;
  for (; i-- > 0; ) {
    const s = n[i], o = e[s];
    if (o) {
      const a = r[s], c = a === void 0 || o(a, s, r);
      if (c !== !0)
        throw new Ye("option " + s + " must be " + c, Ye.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (t !== !0)
      throw new Ye("Unknown option " + s, Ye.ERR_BAD_OPTION);
  }
}
const uy = {
  assertOptions: d9,
  validators: Hv
}, Fs = uy.validators;
let ku = class {
  constructor(e) {
    this.defaults = e, this.interceptors = {
      request: new Dk(),
      response: new Dk()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(e, t) {
    try {
      return await this._request(e, t);
    } catch (n) {
      if (n instanceof Error) {
        let i = {};
        Error.captureStackTrace ? Error.captureStackTrace(i) : i = new Error();
        const s = i.stack ? i.stack.replace(/^.+\n/, "") : "";
        try {
          n.stack ? s && !String(n.stack).endsWith(s.replace(/^.+\n.+\n/, "")) && (n.stack += `
` + s) : n.stack = s;
        } catch {
        }
      }
      throw n;
    }
  }
  _request(e, t) {
    typeof e == "string" ? (t = t || {}, t.url = e) : t = e || {}, t = Zu(this.defaults, t);
    const { transitional: n, paramsSerializer: i, headers: s } = t;
    n !== void 0 && uy.assertOptions(n, {
      silentJSONParsing: Fs.transitional(Fs.boolean),
      forcedJSONParsing: Fs.transitional(Fs.boolean),
      clarifyTimeoutError: Fs.transitional(Fs.boolean)
    }, !1), i != null && (ie.isFunction(i) ? t.paramsSerializer = {
      serialize: i
    } : uy.assertOptions(i, {
      encode: Fs.function,
      serialize: Fs.function
    }, !0)), t.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? t.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : t.allowAbsoluteUrls = !0), uy.assertOptions(t, {
      baseUrl: Fs.spelling("baseURL"),
      withXsrfToken: Fs.spelling("withXSRFToken")
    }, !0), t.method = (t.method || this.defaults.method || "get").toLowerCase();
    let o = s && ie.merge(
      s.common,
      s[t.method]
    );
    s && ie.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (y) => {
        delete s[y];
      }
    ), t.headers = ni.concat(o, s);
    const a = [];
    let c = !0;
    this.interceptors.request.forEach(function(g) {
      typeof g.runWhen == "function" && g.runWhen(t) === !1 || (c = c && g.synchronous, a.unshift(g.fulfilled, g.rejected));
    });
    const u = [];
    this.interceptors.response.forEach(function(g) {
      u.push(g.fulfilled, g.rejected);
    });
    let l, d = 0, f;
    if (!c) {
      const y = [Bk.bind(this), void 0];
      for (y.unshift.apply(y, a), y.push.apply(y, u), f = y.length, l = Promise.resolve(t); d < f; )
        l = l.then(y[d++], y[d++]);
      return l;
    }
    f = a.length;
    let p = t;
    for (d = 0; d < f; ) {
      const y = a[d++], g = a[d++];
      try {
        p = y(p);
      } catch (v) {
        g.call(this, v);
        break;
      }
    }
    try {
      l = Bk.call(this, p);
    } catch (y) {
      return Promise.reject(y);
    }
    for (d = 0, f = u.length; d < f; )
      l = l.then(u[d++], u[d++]);
    return l;
  }
  getUri(e) {
    e = Zu(this.defaults, e);
    const t = KU(e.baseURL, e.url, e.allowAbsoluteUrls);
    return VU(t, e.params, e.paramsSerializer);
  }
};
ie.forEach(["delete", "get", "head", "options"], function(e) {
  ku.prototype[e] = function(t, n) {
    return this.request(Zu(n || {}, {
      method: e,
      url: t,
      data: (n || {}).data
    }));
  };
});
ie.forEach(["post", "put", "patch"], function(e) {
  function t(n) {
    return function(s, o, a) {
      return this.request(Zu(a || {}, {
        method: e,
        headers: n ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: s,
        data: o
      }));
    };
  }
  ku.prototype[e] = t(), ku.prototype[e + "Form"] = t(!0);
});
let h9 = class YU {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let t;
    this.promise = new Promise(function(s) {
      t = s;
    });
    const n = this;
    this.promise.then((i) => {
      if (!n._listeners) return;
      let s = n._listeners.length;
      for (; s-- > 0; )
        n._listeners[s](i);
      n._listeners = null;
    }), this.promise.then = (i) => {
      let s;
      const o = new Promise((a) => {
        n.subscribe(a), s = a;
      }).then(i);
      return o.cancel = function() {
        n.unsubscribe(s);
      }, o;
    }, e(function(s, o, a) {
      n.reason || (n.reason = new df(s, o, a), t(n.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : this._listeners = [e];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(e) {
    if (!this._listeners)
      return;
    const t = this._listeners.indexOf(e);
    t !== -1 && this._listeners.splice(t, 1);
  }
  toAbortSignal() {
    const e = new AbortController(), t = (n) => {
      e.abort(n);
    };
    return this.subscribe(t), e.signal.unsubscribe = () => this.unsubscribe(t), e.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let e;
    return {
      token: new YU(function(i) {
        e = i;
      }),
      cancel: e
    };
  }
};
function f9(r) {
  return function(t) {
    return r.apply(null, t);
  };
}
function p9(r) {
  return ie.isObject(r) && r.isAxiosError === !0;
}
const lE = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(lE).forEach(([r, e]) => {
  lE[e] = r;
});
function QU(r) {
  const e = new ku(r), t = kU(ku.prototype.request, e);
  return ie.extend(t, ku.prototype, e, { allOwnKeys: !0 }), ie.extend(t, e, null, { allOwnKeys: !0 }), t.create = function(i) {
    return QU(Zu(r, i));
  }, t;
}
const He = QU(Kg);
He.Axios = ku;
He.CanceledError = df;
He.CancelToken = h9;
He.isCancel = HU;
He.VERSION = XU;
He.toFormData = zv;
He.AxiosError = Ye;
He.Cancel = He.CanceledError;
He.all = function(e) {
  return Promise.all(e);
};
He.spread = f9;
He.isAxiosError = p9;
He.mergeConfig = Zu;
He.AxiosHeaders = ni;
He.formToJSON = (r) => jU(ie.isHTMLForm(r) ? new FormData(r) : r);
He.getAdapter = JU.getAdapter;
He.HttpStatusCode = lE;
He.default = He;
const {
  Axios: Lye,
  AxiosError: Uye,
  CanceledError: Fye,
  isCancel: Mye,
  CancelToken: Vye,
  VERSION: zye,
  all: jye,
  Cancel: Hye,
  isAxiosError: Gye,
  spread: Kye,
  toFormData: qye,
  AxiosHeaders: Wye,
  HttpStatusCode: Zye,
  formToJSON: Jye,
  getAdapter: Xye,
  mergeConfig: Yye
} = He;
var tp = ((r) => (r.currency = "currency", r.plugin = "plugin", r.tool = "tool", r.swap = "swap", r))(tp || {});
const eF = "https://manager.api.live.ledger.com/api", tF = "http://localhost:8080", z1 = 1, j1 = "0";
let ns = class {
  constructor(e) {
    h(this, "_tag", "FetchError");
    h(this, "originalError");
    this.error = e, this.originalError = e;
  }
};
var rp = ((r) => (r.currency = "currency", r.plugin = "plugin", r.tool = "tool", r.swap = "swap", r))(rp || {}), g9 = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, m9 = (r, e) => (t, n) => e(t, n, r);
let dE = class {
  constructor({ managerApiUrl: e, provider: t, firmwareDistributionSalt: n }) {
    h(this, "_managerApiBaseUrl");
    h(this, "_provider", z1);
    h(this, "_firmwareDistributionSalt", j1);
    this._managerApiBaseUrl = e, this._provider = t, this._firmwareDistributionSalt = n;
  }
  setProvider(e) {
    this._provider === e || e < 1 || (this._provider = e);
  }
  getProvider() {
    return this._provider;
  }
  getAppList(e) {
    const { targetId: t, firmwareVersionName: n } = e;
    return me(() => He.get(`${this._managerApiBaseUrl}/v2/apps/by-target`, { params: { target_id: t, provider: this._provider, firmware_version_name: n } })).map((i) => i.data).chain((i) => this.mapApplicationDtoToApplication(i)).mapLeft((i) => new ns(i));
  }
  getMcuList() {
    return me(() => He.get(`${this._managerApiBaseUrl}/mcu_versions`, {})).map((e) => e.data).chain((e) => this.mapMcuDtoToMcu(e)).mapLeft((e) => new ns(e));
  }
  getDeviceVersion(e) {
    const { targetId: t } = e;
    return me(() => He.get(`${this._managerApiBaseUrl}/get_device_version`, { params: { target_id: t, provider: this._provider } })).map((n) => n.data).chain((n) => this.mapDeviceVersionDto(n)).mapLeft((n) => new ns(n));
  }
  getFirmwareVersion(e) {
    const { deviceId: t, version: n } = e;
    return me(() => He.get(`${this._managerApiBaseUrl}/get_firmware_version`, { params: { device_version: t, version_name: n, provider: this._provider } })).map((i) => i.data).chain((i) => this.mapFinalFirmwareDto(i)).mapLeft((i) => new ns(i));
  }
  getFirmwareVersionById(e) {
    return me(() => He.get(`${this._managerApiBaseUrl}/firmware_final_versions/${e}`, {})).map((t) => t.data).chain((t) => this.mapFinalFirmwareDto(t)).mapLeft((t) => new ns(t));
  }
  getOsuFirmwareVersion(e) {
    const { deviceId: t, version: n } = e;
    return me(() => He.get(`${this._managerApiBaseUrl}/get_osu_version`, { params: { device_version: t, version_name: n, provider: this._provider } })).map((i) => i.data).chain((i) => this.mapOsuFirmwareDto(i)).mapLeft((i) => new ns(i));
  }
  getLatestFirmwareVersion(e) {
    const t = "34.27.0", { currentFinalFirmwareId: n, deviceId: i } = e;
    return me(() => He.get(`${this._managerApiBaseUrl}/get_latest_firmware`, { params: { current_se_firmware_final_version: n, device_version: i, provider: this._provider, salt: this._firmwareDistributionSalt, livecommonversion: t } })).map((s) => s.data).chain((s) => this.mapLatestFirmwareDto(s)).mapLeft((s) => new ns(s));
  }
  getAppsByHash(e) {
    const { hashes: t } = e;
    return me(() => He.post(`${this._managerApiBaseUrl}/v2/apps/hash`, t)).map((n) => n.data).chain((n) => this.mapNullableApplicationDtoToApplication(n)).mapLeft((n) => new ns(n));
  }
  getLanguagePackages(e) {
    const { deviceId: t, currentFinalFirmwareId: n } = e;
    return me(() => He.get(`${this._managerApiBaseUrl}/language-packages`, { params: { device_version: t, current_se_firmware_final_version: n } })).map((i) => i.data).chain((i) => this.mapLanguagesDtoToLanguages(i)).mapLeft((i) => new ns(i));
  }
  mapAppTypeDtoToAppType(e) {
    if (e === null) return null;
    switch (e) {
      case rp.currency:
        return tp.currency;
      case rp.plugin:
        return tp.plugin;
      case rp.tool:
        return tp.tool;
      case rp.swap:
        return tp.swap;
    }
  }
  mapApplicationDtoToApplication(e) {
    return me(() => Promise.resolve(e.map((t) => this.mapApplicationDto(t))));
  }
  mapNullableApplicationDtoToApplication(e) {
    return me(() => Promise.resolve(e.map((t) => t === null ? null : this.mapApplicationDto(t))));
  }
  mapApplicationDto(e) {
    if (typeof e != "object" || typeof e.versionId != "number" || typeof e.versionName != "string" || e.versionDisplayName !== null && typeof e.versionDisplayName != "string" || typeof e.version != "string" || e.currencyId !== null && typeof e.currencyId != "string" || e.description !== null && typeof e.description != "string" || e.applicationType !== null && typeof e.applicationType != "string" || typeof e.dateModified != "string" || e.icon !== null && typeof e.icon != "string" || e.authorName !== null && typeof e.authorName != "string" || e.supportURL !== null && typeof e.supportURL != "string" || e.contactURL !== null && typeof e.contactURL != "string" || e.sourceURL !== null && typeof e.sourceURL != "string" || e.compatibleWallets !== null && typeof e.compatibleWallets != "string" || typeof e.hash != "string" || typeof e.perso != "string" || typeof e.firmware != "string" || typeof e.firmwareKey != "string" || typeof e.delete != "string" || typeof e.deleteKey != "string" || e.bytes !== null && typeof e.bytes != "number" || e.warning !== null && typeof e.warning != "string" || typeof e.isDevTools != "boolean" || e.category !== null && typeof e.category != "number" || e.parent !== null && typeof e.parent != "number" || e.parentName !== null && typeof e.parentName != "string") throw new Error(`Incomplete application: ${JSON.stringify(e)}`);
    const { applicationType: t, hash: n, perso: i, firmware: s, firmwareKey: o, delete: a, deleteKey: c, ...u } = e;
    return { ...u, hash: n, perso: i, firmware: s, firmwareKey: o, delete: a, deleteKey: c, applicationType: this.mapAppTypeDtoToAppType(t) };
  }
  mapMcuDtoToMcu(e) {
    return me(() => Promise.resolve(e.map((t) => {
      if (typeof t != "object" || typeof t.id != "number" || typeof t.name != "string") throw new Error(`Incomplete MCU version: ${JSON.stringify(t)}`);
      return { id: t.id, name: t.name };
    })));
  }
  mapDeviceVersionDto(e) {
    return me(() => {
      if (typeof e != "object" || typeof e.id != "number") throw new Error(`Incomplete device version: ${JSON.stringify(e)}`);
      const t = { id: e.id };
      return Promise.resolve(t);
    });
  }
  mapFinalFirmwareDto(e) {
    return me(() => {
      if (typeof e != "object" || typeof e.id != "number" || typeof e.version != "string" || typeof e.perso != "string" || e.firmware !== null && typeof e.firmware != "string" || e.firmware_key !== null && typeof e.firmware_key != "string" || e.hash !== null && typeof e.hash != "string" || e.bytes !== null && typeof e.bytes != "number" || !Array.isArray(e.mcu_versions)) throw new Error(`Incomplete final firmware: ${JSON.stringify(e)}`);
      const t = { id: e.id, version: e.version, perso: e.perso, firmware: e.firmware, firmwareKey: e.firmware_key, hash: e.hash, bytes: e.bytes, mcuVersions: e.mcu_versions };
      return Promise.resolve(t);
    });
  }
  mapLatestFirmwareDto(e) {
    return me(() => {
      if (e.result !== "success" || !e.se_firmware_osu_version) throw new Error(`Latest firmware could not be retrieved: ${e.result}`);
      const t = e.se_firmware_osu_version;
      return Promise.resolve(t);
    }).chain((t) => this.mapOsuFirmwareDto(t));
  }
  mapOsuFirmwareDto(e) {
    return me(() => {
      if (typeof e != "object" || typeof e.id != "number" || typeof e.perso != "string" || typeof e.firmware != "string" || typeof e.firmware_key != "string" || e.hash !== null && typeof e.hash != "string" || typeof e.next_se_firmware_final_version != "number") throw new Error(`Incomplete latest firmware: ${JSON.stringify(e)}`);
      const t = { id: e.id, perso: e.perso, firmware: e.firmware, firmwareKey: e.firmware_key, hash: e.hash, nextFinalFirmware: e.next_se_firmware_final_version };
      return Promise.resolve(t);
    });
  }
  mapLanguagesDtoToLanguages(e) {
    return me(() => Promise.resolve(e.map((t) => this.mapLanguageDto(t))));
  }
  mapLanguageDto(e) {
    if (typeof e != "object" || typeof e.language != "string" || typeof e.languagePackageVersionId != "number" || typeof e.version != "string" || typeof e.language_package_id != "number" || typeof e.apdu_install_url != "string" || typeof e.apdu_uninstall_url != "string" || typeof e.bytes != "number" || typeof e.date_creation != "string" || typeof e.date_last_modified != "string") throw new Error(`Incomplete language version: ${JSON.stringify(e)}`);
    return { language: e.language, languagePackageVersionId: e.languagePackageVersionId, version: e.version, languagePackageId: e.language_package_id, apduInstallUrl: e.apdu_install_url, apduUninstallUrl: e.apdu_uninstall_url, bytes: e.bytes, dateCreation: e.date_creation, dateLastModified: e.date_last_modified };
  }
};
dE = g9([le(), m9(0, X(xi.DmkConfig))], dE);
var y9 = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, v9 = (r, e) => (t, n) => e(t, n, r);
let hE = class {
  constructor(e) {
    this.dataSource = e;
  }
  getAppList(e) {
    const t = { targetId: e.targetId.toString(), firmwareVersionName: e.seVersion };
    return this.dataSource.getAppList(t);
  }
  getDeviceVersion(e) {
    const t = { targetId: e.targetId.toString() };
    return this.dataSource.getDeviceVersion(t);
  }
  getFirmwareVersion(e, t) {
    const n = { version: e.seVersion, deviceId: t.id };
    return this.dataSource.getFirmwareVersion(n);
  }
  getOsuFirmwareVersion(e, t) {
    const n = { version: e.seVersion, deviceId: t.id };
    return this.dataSource.getOsuFirmwareVersion(n);
  }
  getLatestFirmwareVersion(e, t) {
    const n = { currentFinalFirmwareId: e.id, deviceId: t.id };
    return this.dataSource.getLatestFirmwareVersion(n);
  }
  getNextFirmwareVersion(e) {
    return this.dataSource.getFirmwareVersionById(e.nextFinalFirmware);
  }
  getLanguagePackages(e, t) {
    const n = { deviceId: e.id, currentFinalFirmwareId: t.id };
    return this.dataSource.getLanguagePackages(n);
  }
  getMcuList() {
    return this.dataSource.getMcuList();
  }
  getAppsByHash(e) {
    const t = { hashes: e };
    return me(async ({ fromPromise: n, throwE: i }) => {
      if (t.hashes.length === 0) return [];
      try {
        return await n(this.dataSource.getAppsByHash(t));
      } catch (s) {
        return s instanceof ns ? i(s) : i(new ns(s));
      }
    });
  }
};
hE = y9([le(), v9(0, X(xi.ManagerApiDataSource))], hE);
var b9 = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Uk = (r, e) => (t, n) => e(t, n, r);
let fE = class {
  constructor(e, t) {
    this.sessionService = e, this.managerApiDataSource = t;
  }
  execute(e) {
    for (const t of this.sessionService.getDeviceSessions()) {
      const n = t.getDeviceSessionState();
      n.sessionStateType !== wr.Connected && t.setDeviceSessionState({ ...n, firmwareUpdateContext: void 0, installedApps: [], appsUpdates: void 0, catalog: void 0 });
    }
    this.managerApiDataSource.setProvider(e);
  }
};
fE = b9([le(), Uk(0, X(Vt.DeviceSessionService)), Uk(1, X(xi.ManagerApiDataSource))], fE);
const w9 = ({ stub: r, config: e }) => new mt(({ bind: t, rebindSync: n }) => {
  t(xi.DmkConfig).toConstantValue(e), t(xi.ManagerApiDataSource).to(dE).inSingletonScope(), t(xi.ManagerApiService).to(hE).inSingletonScope(), t(xi.SetProviderUseCase).to(fE), r && (n(xi.ManagerApiDataSource).to(Ur), n(xi.ManagerApiService).to(Ur), n(xi.SetProviderUseCase).to(Ur));
});
var Oc = {}, np = { exports: {} };
/*! https://mths.be/punycode v1.4.1 by @mathias */
var _9 = np.exports, Fk;
function S9() {
  return Fk || (Fk = 1, (function(r, e) {
    (function(t) {
      var n = e && !e.nodeType && e, i = r && !r.nodeType && r, s = typeof As == "object" && As;
      (s.global === s || s.window === s || s.self === s) && (t = s);
      var o, a = 2147483647, c = 36, u = 1, l = 26, d = 38, f = 700, p = 72, y = 128, g = "-", v = /^xn--/, _ = /[^\x20-\x7E]/, w = /[\x2E\u3002\uFF0E\uFF61]/g, E = {
        overflow: "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, I = c - u, S = Math.floor, T = String.fromCharCode, b;
      function C(F) {
        throw new RangeError(E[F]);
      }
      function P(F, j) {
        for (var re = F.length, z = []; re--; )
          z[re] = j(F[re]);
        return z;
      }
      function Z(F, j) {
        var re = F.split("@"), z = "";
        re.length > 1 && (z = re[0] + "@", F = re[1]), F = F.replace(w, ".");
        var ce = F.split("."), he = P(ce, j).join(".");
        return z + he;
      }
      function Y(F) {
        for (var j = [], re = 0, z = F.length, ce, he; re < z; )
          ce = F.charCodeAt(re++), ce >= 55296 && ce <= 56319 && re < z ? (he = F.charCodeAt(re++), (he & 64512) == 56320 ? j.push(((ce & 1023) << 10) + (he & 1023) + 65536) : (j.push(ce), re--)) : j.push(ce);
        return j;
      }
      function q(F) {
        return P(F, function(j) {
          var re = "";
          return j > 65535 && (j -= 65536, re += T(j >>> 10 & 1023 | 55296), j = 56320 | j & 1023), re += T(j), re;
        }).join("");
      }
      function J(F) {
        return F - 48 < 10 ? F - 22 : F - 65 < 26 ? F - 65 : F - 97 < 26 ? F - 97 : c;
      }
      function O(F, j) {
        return F + 22 + 75 * (F < 26) - ((j != 0) << 5);
      }
      function x(F, j, re) {
        var z = 0;
        for (F = re ? S(F / f) : F >> 1, F += S(F / j); F > I * l >> 1; z += c)
          F = S(F / I);
        return S(z + (I + 1) * F / (F + d));
      }
      function k(F) {
        var j = [], re = F.length, z, ce = 0, he = y, de = p, xe, Ze, Se, be, Ie, Re, Ue, Xe, vt;
        for (xe = F.lastIndexOf(g), xe < 0 && (xe = 0), Ze = 0; Ze < xe; ++Ze)
          F.charCodeAt(Ze) >= 128 && C("not-basic"), j.push(F.charCodeAt(Ze));
        for (Se = xe > 0 ? xe + 1 : 0; Se < re; ) {
          for (be = ce, Ie = 1, Re = c; Se >= re && C("invalid-input"), Ue = J(F.charCodeAt(Se++)), (Ue >= c || Ue > S((a - ce) / Ie)) && C("overflow"), ce += Ue * Ie, Xe = Re <= de ? u : Re >= de + l ? l : Re - de, !(Ue < Xe); Re += c)
            vt = c - Xe, Ie > S(a / vt) && C("overflow"), Ie *= vt;
          z = j.length + 1, de = x(ce - be, z, be == 0), S(ce / z) > a - he && C("overflow"), he += S(ce / z), ce %= z, j.splice(ce++, 0, he);
        }
        return q(j);
      }
      function B(F) {
        var j, re, z, ce, he, de, xe, Ze, Se, be, Ie, Re = [], Ue, Xe, vt, at;
        for (F = Y(F), Ue = F.length, j = y, re = 0, he = p, de = 0; de < Ue; ++de)
          Ie = F[de], Ie < 128 && Re.push(T(Ie));
        for (z = ce = Re.length, ce && Re.push(g); z < Ue; ) {
          for (xe = a, de = 0; de < Ue; ++de)
            Ie = F[de], Ie >= j && Ie < xe && (xe = Ie);
          for (Xe = z + 1, xe - j > S((a - re) / Xe) && C("overflow"), re += (xe - j) * Xe, j = xe, de = 0; de < Ue; ++de)
            if (Ie = F[de], Ie < j && ++re > a && C("overflow"), Ie == j) {
              for (Ze = re, Se = c; be = Se <= he ? u : Se >= he + l ? l : Se - he, !(Ze < be); Se += c)
                at = Ze - be, vt = c - be, Re.push(
                  T(O(be + at % vt, 0))
                ), Ze = S(at / vt);
              Re.push(T(O(Ze, 0))), he = x(re, Xe, z == ce), re = 0, ++z;
            }
          ++re, ++j;
        }
        return Re.join("");
      }
      function A(F) {
        return Z(F, function(j) {
          return v.test(j) ? k(j.slice(4).toLowerCase()) : j;
        });
      }
      function K(F) {
        return Z(F, function(j) {
          return _.test(j) ? "xn--" + B(j) : j;
        });
      }
      if (o = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        version: "1.4.1",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        ucs2: {
          decode: Y,
          encode: q
        },
        decode: k,
        encode: B,
        toASCII: K,
        toUnicode: A
      }, n && i)
        if (r.exports == n)
          i.exports = o;
        else
          for (b in o)
            o.hasOwnProperty(b) && (n[b] = o[b]);
      else
        t.punycode = o;
    })(_9);
  })(np, np.exports)), np.exports;
}
var Jb, Mk;
function hf() {
  return Mk || (Mk = 1, Jb = TypeError), Jb;
}
const E9 = {}, x9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: E9
}, Symbol.toStringTag, { value: "Module" })), rF = /* @__PURE__ */ P8(x9);
var Xb, Vk;
function Gv() {
  if (Vk) return Xb;
  Vk = 1;
  var r = typeof Map == "function" && Map.prototype, e = Object.getOwnPropertyDescriptor && r ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, t = r && e && typeof e.get == "function" ? e.get : null, n = r && Map.prototype.forEach, i = typeof Set == "function" && Set.prototype, s = Object.getOwnPropertyDescriptor && i ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, o = i && s && typeof s.get == "function" ? s.get : null, a = i && Set.prototype.forEach, c = typeof WeakMap == "function" && WeakMap.prototype, u = c ? WeakMap.prototype.has : null, l = typeof WeakSet == "function" && WeakSet.prototype, d = l ? WeakSet.prototype.has : null, f = typeof WeakRef == "function" && WeakRef.prototype, p = f ? WeakRef.prototype.deref : null, y = Boolean.prototype.valueOf, g = Object.prototype.toString, v = Function.prototype.toString, _ = String.prototype.match, w = String.prototype.slice, E = String.prototype.replace, I = String.prototype.toUpperCase, S = String.prototype.toLowerCase, T = RegExp.prototype.test, b = Array.prototype.concat, C = Array.prototype.join, P = Array.prototype.slice, Z = Math.floor, Y = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, q = Object.getOwnPropertySymbols, J = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, O = typeof Symbol == "function" && typeof Symbol.iterator == "object", x = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === O || !0) ? Symbol.toStringTag : null, k = Object.prototype.propertyIsEnumerable, B = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function($) {
    return $.__proto__;
  } : null);
  function A($, V) {
    if ($ === 1 / 0 || $ === -1 / 0 || $ !== $ || $ && $ > -1e3 && $ < 1e3 || T.call(/e/, V))
      return V;
    var Te = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof $ == "number") {
      var Ce = $ < 0 ? -Z(-$) : Z($);
      if (Ce !== $) {
        var ge = String(Ce), ue = w.call(V, ge.length + 1);
        return E.call(ge, Te, "$&_") + "." + E.call(E.call(ue, /([0-9]{3})/g, "$&_"), /_$/, "");
      }
    }
    return E.call(V, Te, "$&_");
  }
  var K = rF, F = K.custom, j = Xe(F) ? F : null, re = {
    __proto__: null,
    double: '"',
    single: "'"
  }, z = {
    __proto__: null,
    double: /(["\\])/g,
    single: /(['\\])/g
  };
  Xb = function $(V, Te, Ce, ge) {
    var ue = Te || {};
    if (Tt(ue, "quoteStyle") && !Tt(re, ue.quoteStyle))
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    if (Tt(ue, "maxStringLength") && (typeof ue.maxStringLength == "number" ? ue.maxStringLength < 0 && ue.maxStringLength !== 1 / 0 : ue.maxStringLength !== null))
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    var Ee = Tt(ue, "customInspect") ? ue.customInspect : !0;
    if (typeof Ee != "boolean" && Ee !== "symbol")
      throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    if (Tt(ue, "indent") && ue.indent !== null && ue.indent !== "	" && !(parseInt(ue.indent, 10) === ue.indent && ue.indent > 0))
      throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    if (Tt(ue, "numericSeparator") && typeof ue.numericSeparator != "boolean")
      throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    var Ae = ue.numericSeparator;
    if (typeof V > "u")
      return "undefined";
    if (V === null)
      return "null";
    if (typeof V == "boolean")
      return V ? "true" : "false";
    if (typeof V == "string")
      return Ve(V, ue);
    if (typeof V == "number") {
      if (V === 0)
        return 1 / 0 / V > 0 ? "0" : "-0";
      var Je = String(V);
      return Ae ? A(V, Je) : Je;
    }
    if (typeof V == "bigint") {
      var ft = String(V) + "n";
      return Ae ? A(V, ft) : ft;
    }
    var Mt = typeof ue.depth > "u" ? 5 : ue.depth;
    if (typeof Ce > "u" && (Ce = 0), Ce >= Mt && Mt > 0 && typeof V == "object")
      return xe(V) ? "[Array]" : "[Object]";
    var Pr = G(ue, Ce);
    if (typeof ge > "u")
      ge = [];
    else if (di(ge, V) >= 0)
      return "[Circular]";
    function Ln(_l, cm, O8) {
      if (cm && (ge = P.call(ge), ge.push(cm)), O8) {
        var fD = {
          depth: ue.depth
        };
        return Tt(ue, "quoteStyle") && (fD.quoteStyle = ue.quoteStyle), $(_l, fD, Ce + 1, ge);
      }
      return $(_l, ue, Ce + 1, ge);
    }
    if (typeof V == "function" && !Se(V)) {
      var sm = rs(V), om = se(V, Ln);
      return "[Function" + (sm ? ": " + sm : " (anonymous)") + "]" + (om.length > 0 ? " { " + C.call(om, ", ") + " }" : "");
    }
    if (Xe(V)) {
      var cD = O ? E.call(String(V), /^(Symbol\(.*\))_[^)]*$/, "$1") : J.call(V);
      return typeof V == "object" && !O ? tr(cD) : cD;
    }
    if (we(V)) {
      for (var Af = "<" + S.call(String(V.nodeName)), O0 = V.attributes || [], am = 0; am < O0.length; am++)
        Af += " " + O0[am].name + "=" + ce(he(O0[am].value), "double", ue);
      return Af += ">", V.childNodes && V.childNodes.length && (Af += "..."), Af += "</" + S.call(String(V.nodeName)) + ">", Af;
    }
    if (xe(V)) {
      if (V.length === 0)
        return "[]";
      var $0 = se(V, Ln);
      return Pr && !U($0) ? "[" + W($0, Pr) + "]" : "[ " + C.call($0, ", ") + " ]";
    }
    if (be(V)) {
      var R0 = se(V, Ln);
      return !("cause" in Error.prototype) && "cause" in V && !k.call(V, "cause") ? "{ [" + String(V) + "] " + C.call(b.call("[cause]: " + Ln(V.cause), R0), ", ") + " }" : R0.length === 0 ? "[" + String(V) + "]" : "{ [" + String(V) + "] " + C.call(R0, ", ") + " }";
    }
    if (typeof V == "object" && Ee) {
      if (j && typeof V[j] == "function" && K)
        return K(V, { depth: Mt - Ce });
      if (Ee !== "symbol" && typeof V.inspect == "function")
        return V.inspect();
    }
    if (on(V)) {
      var uD = [];
      return n && n.call(V, function(_l, cm) {
        uD.push(Ln(cm, V, !0) + " => " + Ln(_l, V));
      }), Rr("Map", t.call(V), uD, Pr);
    }
    if (ae(V)) {
      var lD = [];
      return a && a.call(V, function(_l) {
        lD.push(Ln(_l, V));
      }), Rr("Set", o.call(V), lD, Pr);
    }
    if (an(V))
      return bn("WeakMap");
    if (fe(V))
      return bn("WeakSet");
    if (ee(V))
      return bn("WeakRef");
    if (Re(V))
      return tr(Ln(Number(V)));
    if (vt(V))
      return tr(Ln(Y.call(V)));
    if (Ue(V))
      return tr(y.call(V));
    if (Ie(V))
      return tr(Ln(String(V)));
    if (typeof window < "u" && V === window)
      return "{ [object Window] }";
    if (typeof globalThis < "u" && V === globalThis || typeof As < "u" && V === As)
      return "{ [object globalThis] }";
    if (!Ze(V) && !Se(V)) {
      var P0 = se(V, Ln), dD = B ? B(V) === Object.prototype : V instanceof Object || V.constructor === Object, N0 = V instanceof Object ? "" : "null prototype", hD = !dD && x && Object(V) === V && x in V ? w.call(xr(V), 8, -1) : N0 ? "Object" : "", k8 = dD || typeof V.constructor != "function" ? "" : V.constructor.name ? V.constructor.name + " " : "", B0 = k8 + (hD || N0 ? "[" + C.call(b.call([], hD || [], N0 || []), ": ") + "] " : "");
      return P0.length === 0 ? B0 + "{}" : Pr ? B0 + "{" + W(P0, Pr) + "}" : B0 + "{ " + C.call(P0, ", ") + " }";
    }
    return String(V);
  };
  function ce($, V, Te) {
    var Ce = Te.quoteStyle || V, ge = re[Ce];
    return ge + $ + ge;
  }
  function he($) {
    return E.call(String($), /"/g, "&quot;");
  }
  function de($) {
    return !x || !(typeof $ == "object" && (x in $ || typeof $[x] < "u"));
  }
  function xe($) {
    return xr($) === "[object Array]" && de($);
  }
  function Ze($) {
    return xr($) === "[object Date]" && de($);
  }
  function Se($) {
    return xr($) === "[object RegExp]" && de($);
  }
  function be($) {
    return xr($) === "[object Error]" && de($);
  }
  function Ie($) {
    return xr($) === "[object String]" && de($);
  }
  function Re($) {
    return xr($) === "[object Number]" && de($);
  }
  function Ue($) {
    return xr($) === "[object Boolean]" && de($);
  }
  function Xe($) {
    if (O)
      return $ && typeof $ == "object" && $ instanceof Symbol;
    if (typeof $ == "symbol")
      return !0;
    if (!$ || typeof $ != "object" || !J)
      return !1;
    try {
      return J.call($), !0;
    } catch {
    }
    return !1;
  }
  function vt($) {
    if (!$ || typeof $ != "object" || !Y)
      return !1;
    try {
      return Y.call($), !0;
    } catch {
    }
    return !1;
  }
  var at = Object.prototype.hasOwnProperty || function($) {
    return $ in this;
  };
  function Tt($, V) {
    return at.call($, V);
  }
  function xr($) {
    return g.call($);
  }
  function rs($) {
    if ($.name)
      return $.name;
    var V = _.call(v.call($), /^function\s*([\w$]+)/);
    return V ? V[1] : null;
  }
  function di($, V) {
    if ($.indexOf)
      return $.indexOf(V);
    for (var Te = 0, Ce = $.length; Te < Ce; Te++)
      if ($[Te] === V)
        return Te;
    return -1;
  }
  function on($) {
    if (!t || !$ || typeof $ != "object")
      return !1;
    try {
      t.call($);
      try {
        o.call($);
      } catch {
        return !0;
      }
      return $ instanceof Map;
    } catch {
    }
    return !1;
  }
  function an($) {
    if (!u || !$ || typeof $ != "object")
      return !1;
    try {
      u.call($, u);
      try {
        d.call($, d);
      } catch {
        return !0;
      }
      return $ instanceof WeakMap;
    } catch {
    }
    return !1;
  }
  function ee($) {
    if (!p || !$ || typeof $ != "object")
      return !1;
    try {
      return p.call($), !0;
    } catch {
    }
    return !1;
  }
  function ae($) {
    if (!o || !$ || typeof $ != "object")
      return !1;
    try {
      o.call($);
      try {
        t.call($);
      } catch {
        return !0;
      }
      return $ instanceof Set;
    } catch {
    }
    return !1;
  }
  function fe($) {
    if (!d || !$ || typeof $ != "object")
      return !1;
    try {
      d.call($, d);
      try {
        u.call($, u);
      } catch {
        return !0;
      }
      return $ instanceof WeakSet;
    } catch {
    }
    return !1;
  }
  function we($) {
    return !$ || typeof $ != "object" ? !1 : typeof HTMLElement < "u" && $ instanceof HTMLElement ? !0 : typeof $.nodeName == "string" && typeof $.getAttribute == "function";
  }
  function Ve($, V) {
    if ($.length > V.maxStringLength) {
      var Te = $.length - V.maxStringLength, Ce = "... " + Te + " more character" + (Te > 1 ? "s" : "");
      return Ve(w.call($, 0, V.maxStringLength), V) + Ce;
    }
    var ge = z[V.quoteStyle || "single"];
    ge.lastIndex = 0;
    var ue = E.call(E.call($, ge, "\\$1"), /[\x00-\x1f]/g, jr);
    return ce(ue, "single", V);
  }
  function jr($) {
    var V = $.charCodeAt(0), Te = {
      8: "b",
      9: "t",
      10: "n",
      12: "f",
      13: "r"
    }[V];
    return Te ? "\\" + Te : "\\x" + (V < 16 ? "0" : "") + I.call(V.toString(16));
  }
  function tr($) {
    return "Object(" + $ + ")";
  }
  function bn($) {
    return $ + " { ? }";
  }
  function Rr($, V, Te, Ce) {
    var ge = Ce ? W(Te, Ce) : C.call(Te, ", ");
    return $ + " (" + V + ") {" + ge + "}";
  }
  function U($) {
    for (var V = 0; V < $.length; V++)
      if (di($[V], `
`) >= 0)
        return !1;
    return !0;
  }
  function G($, V) {
    var Te;
    if ($.indent === "	")
      Te = "	";
    else if (typeof $.indent == "number" && $.indent > 0)
      Te = C.call(Array($.indent + 1), " ");
    else
      return null;
    return {
      base: Te,
      prev: C.call(Array(V + 1), Te)
    };
  }
  function W($, V) {
    if ($.length === 0)
      return "";
    var Te = `
` + V.prev + V.base;
    return Te + C.call($, "," + Te) + `
` + V.prev;
  }
  function se($, V) {
    var Te = xe($), Ce = [];
    if (Te) {
      Ce.length = $.length;
      for (var ge = 0; ge < $.length; ge++)
        Ce[ge] = Tt($, ge) ? V($[ge], $) : "";
    }
    var ue = typeof q == "function" ? q($) : [], Ee;
    if (O) {
      Ee = {};
      for (var Ae = 0; Ae < ue.length; Ae++)
        Ee["$" + ue[Ae]] = ue[Ae];
    }
    for (var Je in $)
      Tt($, Je) && (Te && String(Number(Je)) === Je && Je < $.length || O && Ee["$" + Je] instanceof Symbol || (T.call(/[^\w$]/, Je) ? Ce.push(V(Je, $) + ": " + V($[Je], $)) : Ce.push(Je + ": " + V($[Je], $))));
    if (typeof q == "function")
      for (var ft = 0; ft < ue.length; ft++)
        k.call($, ue[ft]) && Ce.push("[" + V(ue[ft]) + "]: " + V($[ue[ft]], $));
    return Ce;
  }
  return Xb;
}
var Yb, zk;
function A9() {
  if (zk) return Yb;
  zk = 1;
  var r = /* @__PURE__ */ Gv(), e = /* @__PURE__ */ hf(), t = function(a, c, u) {
    for (var l = a, d; (d = l.next) != null; l = d)
      if (d.key === c)
        return l.next = d.next, u || (d.next = /** @type {NonNullable<typeof list.next>} */
        a.next, a.next = d), d;
  }, n = function(a, c) {
    if (a) {
      var u = t(a, c);
      return u && u.value;
    }
  }, i = function(a, c, u) {
    var l = t(a, c);
    l ? l.value = u : a.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */
    {
      // eslint-disable-line no-param-reassign, no-extra-parens
      key: c,
      next: a.next,
      value: u
    };
  }, s = function(a, c) {
    return a ? !!t(a, c) : !1;
  }, o = function(a, c) {
    if (a)
      return t(a, c, !0);
  };
  return Yb = function() {
    var c, u = {
      assert: function(l) {
        if (!u.has(l))
          throw new e("Side channel does not contain " + r(l));
      },
      delete: function(l) {
        var d = c && c.next, f = o(c, l);
        return f && d && d === f && (c = void 0), !!f;
      },
      get: function(l) {
        return n(c, l);
      },
      has: function(l) {
        return s(c, l);
      },
      set: function(l, d) {
        c || (c = {
          next: void 0
        }), i(
          /** @type {NonNullable<typeof $o>} */
          c,
          l,
          d
        );
      }
    };
    return u;
  }, Yb;
}
var Qb, jk;
function nF() {
  return jk || (jk = 1, Qb = Object), Qb;
}
var ew, Hk;
function I9() {
  return Hk || (Hk = 1, ew = Error), ew;
}
var tw, Gk;
function C9() {
  return Gk || (Gk = 1, tw = EvalError), tw;
}
var rw, Kk;
function D9() {
  return Kk || (Kk = 1, rw = RangeError), rw;
}
var nw, qk;
function T9() {
  return qk || (qk = 1, nw = ReferenceError), nw;
}
var iw, Wk;
function k9() {
  return Wk || (Wk = 1, iw = SyntaxError), iw;
}
var sw, Zk;
function O9() {
  return Zk || (Zk = 1, sw = URIError), sw;
}
var ow, Jk;
function $9() {
  return Jk || (Jk = 1, ow = Math.abs), ow;
}
var aw, Xk;
function R9() {
  return Xk || (Xk = 1, aw = Math.floor), aw;
}
var cw, Yk;
function P9() {
  return Yk || (Yk = 1, cw = Math.max), cw;
}
var uw, Qk;
function N9() {
  return Qk || (Qk = 1, uw = Math.min), uw;
}
var lw, e2;
function B9() {
  return e2 || (e2 = 1, lw = Math.pow), lw;
}
var dw, t2;
function L9() {
  return t2 || (t2 = 1, dw = Math.round), dw;
}
var hw, r2;
function U9() {
  return r2 || (r2 = 1, hw = Number.isNaN || function(e) {
    return e !== e;
  }), hw;
}
var fw, n2;
function F9() {
  if (n2) return fw;
  n2 = 1;
  var r = /* @__PURE__ */ U9();
  return fw = function(t) {
    return r(t) || t === 0 ? t : t < 0 ? -1 : 1;
  }, fw;
}
var pw, i2;
function M9() {
  return i2 || (i2 = 1, pw = Object.getOwnPropertyDescriptor), pw;
}
var gw, s2;
function iF() {
  if (s2) return gw;
  s2 = 1;
  var r = /* @__PURE__ */ M9();
  if (r)
    try {
      r([], "length");
    } catch {
      r = null;
    }
  return gw = r, gw;
}
var mw, o2;
function V9() {
  if (o2) return mw;
  o2 = 1;
  var r = Object.defineProperty || !1;
  if (r)
    try {
      r({}, "a", { value: 1 });
    } catch {
      r = !1;
    }
  return mw = r, mw;
}
var yw, a2;
function z9() {
  return a2 || (a2 = 1, yw = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var e = {}, t = Symbol("test"), n = Object(t);
    if (typeof t == "string" || Object.prototype.toString.call(t) !== "[object Symbol]" || Object.prototype.toString.call(n) !== "[object Symbol]")
      return !1;
    var i = 42;
    e[t] = i;
    for (var s in e)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0)
      return !1;
    var o = Object.getOwnPropertySymbols(e);
    if (o.length !== 1 || o[0] !== t || !Object.prototype.propertyIsEnumerable.call(e, t))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var a = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(e, t)
      );
      if (a.value !== i || a.enumerable !== !0)
        return !1;
    }
    return !0;
  }), yw;
}
var vw, c2;
function j9() {
  if (c2) return vw;
  c2 = 1;
  var r = typeof Symbol < "u" && Symbol, e = z9();
  return vw = function() {
    return typeof r != "function" || typeof Symbol != "function" || typeof r("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : e();
  }, vw;
}
var bw, u2;
function sF() {
  return u2 || (u2 = 1, bw = typeof Reflect < "u" && Reflect.getPrototypeOf || null), bw;
}
var ww, l2;
function oF() {
  if (l2) return ww;
  l2 = 1;
  var r = /* @__PURE__ */ nF();
  return ww = r.getPrototypeOf || null, ww;
}
var _w, d2;
function H9() {
  if (d2) return _w;
  d2 = 1;
  var r = "Function.prototype.bind called on incompatible ", e = Object.prototype.toString, t = Math.max, n = "[object Function]", i = function(c, u) {
    for (var l = [], d = 0; d < c.length; d += 1)
      l[d] = c[d];
    for (var f = 0; f < u.length; f += 1)
      l[f + c.length] = u[f];
    return l;
  }, s = function(c, u) {
    for (var l = [], d = u, f = 0; d < c.length; d += 1, f += 1)
      l[f] = c[d];
    return l;
  }, o = function(a, c) {
    for (var u = "", l = 0; l < a.length; l += 1)
      u += a[l], l + 1 < a.length && (u += c);
    return u;
  };
  return _w = function(c) {
    var u = this;
    if (typeof u != "function" || e.apply(u) !== n)
      throw new TypeError(r + u);
    for (var l = s(arguments, 1), d, f = function() {
      if (this instanceof d) {
        var _ = u.apply(
          this,
          i(l, arguments)
        );
        return Object(_) === _ ? _ : this;
      }
      return u.apply(
        c,
        i(l, arguments)
      );
    }, p = t(0, u.length - l.length), y = [], g = 0; g < p; g++)
      y[g] = "$" + g;
    if (d = Function("binder", "return function (" + o(y, ",") + "){ return binder.apply(this,arguments); }")(f), u.prototype) {
      var v = function() {
      };
      v.prototype = u.prototype, d.prototype = new v(), v.prototype = null;
    }
    return d;
  }, _w;
}
var Sw, h2;
function Kv() {
  if (h2) return Sw;
  h2 = 1;
  var r = H9();
  return Sw = Function.prototype.bind || r, Sw;
}
var Ew, f2;
function H1() {
  return f2 || (f2 = 1, Ew = Function.prototype.call), Ew;
}
var xw, p2;
function aF() {
  return p2 || (p2 = 1, xw = Function.prototype.apply), xw;
}
var Aw, g2;
function G9() {
  return g2 || (g2 = 1, Aw = typeof Reflect < "u" && Reflect && Reflect.apply), Aw;
}
var Iw, m2;
function K9() {
  if (m2) return Iw;
  m2 = 1;
  var r = Kv(), e = aF(), t = H1(), n = G9();
  return Iw = n || r.call(t, e), Iw;
}
var Cw, y2;
function cF() {
  if (y2) return Cw;
  y2 = 1;
  var r = Kv(), e = /* @__PURE__ */ hf(), t = H1(), n = K9();
  return Cw = function(s) {
    if (s.length < 1 || typeof s[0] != "function")
      throw new e("a function is required");
    return n(r, t, s);
  }, Cw;
}
var Dw, v2;
function q9() {
  if (v2) return Dw;
  v2 = 1;
  var r = cF(), e = /* @__PURE__ */ iF(), t;
  try {
    t = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (o) {
    if (!o || typeof o != "object" || !("code" in o) || o.code !== "ERR_PROTO_ACCESS")
      throw o;
  }
  var n = !!t && e && e(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  ), i = Object, s = i.getPrototypeOf;
  return Dw = n && typeof n.get == "function" ? r([n.get]) : typeof s == "function" ? (
    /** @type {import('./get')} */
    function(a) {
      return s(a == null ? a : i(a));
    }
  ) : !1, Dw;
}
var Tw, b2;
function W9() {
  if (b2) return Tw;
  b2 = 1;
  var r = sF(), e = oF(), t = /* @__PURE__ */ q9();
  return Tw = r ? function(i) {
    return r(i);
  } : e ? function(i) {
    if (!i || typeof i != "object" && typeof i != "function")
      throw new TypeError("getProto: not an object");
    return e(i);
  } : t ? function(i) {
    return t(i);
  } : null, Tw;
}
var kw, w2;
function Z9() {
  if (w2) return kw;
  w2 = 1;
  var r = Function.prototype.call, e = Object.prototype.hasOwnProperty, t = Kv();
  return kw = t.call(r, e), kw;
}
var Ow, _2;
function G1() {
  if (_2) return Ow;
  _2 = 1;
  var r, e = /* @__PURE__ */ nF(), t = /* @__PURE__ */ I9(), n = /* @__PURE__ */ C9(), i = /* @__PURE__ */ D9(), s = /* @__PURE__ */ T9(), o = /* @__PURE__ */ k9(), a = /* @__PURE__ */ hf(), c = /* @__PURE__ */ O9(), u = /* @__PURE__ */ $9(), l = /* @__PURE__ */ R9(), d = /* @__PURE__ */ P9(), f = /* @__PURE__ */ N9(), p = /* @__PURE__ */ B9(), y = /* @__PURE__ */ L9(), g = /* @__PURE__ */ F9(), v = Function, _ = function(Se) {
    try {
      return v('"use strict"; return (' + Se + ").constructor;")();
    } catch {
    }
  }, w = /* @__PURE__ */ iF(), E = /* @__PURE__ */ V9(), I = function() {
    throw new a();
  }, S = w ? (function() {
    try {
      return arguments.callee, I;
    } catch {
      try {
        return w(arguments, "callee").get;
      } catch {
        return I;
      }
    }
  })() : I, T = j9()(), b = W9(), C = oF(), P = sF(), Z = aF(), Y = H1(), q = {}, J = typeof Uint8Array > "u" || !b ? r : b(Uint8Array), O = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? r : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? r : ArrayBuffer,
    "%ArrayIteratorPrototype%": T && b ? b([][Symbol.iterator]()) : r,
    "%AsyncFromSyncIteratorPrototype%": r,
    "%AsyncFunction%": q,
    "%AsyncGenerator%": q,
    "%AsyncGeneratorFunction%": q,
    "%AsyncIteratorPrototype%": q,
    "%Atomics%": typeof Atomics > "u" ? r : Atomics,
    "%BigInt%": typeof BigInt > "u" ? r : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? r : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? r : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? r : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": t,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": n,
    "%Float16Array%": typeof Float16Array > "u" ? r : Float16Array,
    "%Float32Array%": typeof Float32Array > "u" ? r : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? r : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? r : FinalizationRegistry,
    "%Function%": v,
    "%GeneratorFunction%": q,
    "%Int8Array%": typeof Int8Array > "u" ? r : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? r : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? r : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": T && b ? b(b([][Symbol.iterator]())) : r,
    "%JSON%": typeof JSON == "object" ? JSON : r,
    "%Map%": typeof Map > "u" ? r : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !T || !b ? r : b((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": e,
    "%Object.getOwnPropertyDescriptor%": w,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? r : Promise,
    "%Proxy%": typeof Proxy > "u" ? r : Proxy,
    "%RangeError%": i,
    "%ReferenceError%": s,
    "%Reflect%": typeof Reflect > "u" ? r : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? r : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !T || !b ? r : b((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? r : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": T && b ? b(""[Symbol.iterator]()) : r,
    "%Symbol%": T ? Symbol : r,
    "%SyntaxError%": o,
    "%ThrowTypeError%": S,
    "%TypedArray%": J,
    "%TypeError%": a,
    "%Uint8Array%": typeof Uint8Array > "u" ? r : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? r : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? r : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? r : Uint32Array,
    "%URIError%": c,
    "%WeakMap%": typeof WeakMap > "u" ? r : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? r : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? r : WeakSet,
    "%Function.prototype.call%": Y,
    "%Function.prototype.apply%": Z,
    "%Object.defineProperty%": E,
    "%Object.getPrototypeOf%": C,
    "%Math.abs%": u,
    "%Math.floor%": l,
    "%Math.max%": d,
    "%Math.min%": f,
    "%Math.pow%": p,
    "%Math.round%": y,
    "%Math.sign%": g,
    "%Reflect.getPrototypeOf%": P
  };
  if (b)
    try {
      null.error;
    } catch (Se) {
      var x = b(b(Se));
      O["%Error.prototype%"] = x;
    }
  var k = function Se(be) {
    var Ie;
    if (be === "%AsyncFunction%")
      Ie = _("async function () {}");
    else if (be === "%GeneratorFunction%")
      Ie = _("function* () {}");
    else if (be === "%AsyncGeneratorFunction%")
      Ie = _("async function* () {}");
    else if (be === "%AsyncGenerator%") {
      var Re = Se("%AsyncGeneratorFunction%");
      Re && (Ie = Re.prototype);
    } else if (be === "%AsyncIteratorPrototype%") {
      var Ue = Se("%AsyncGenerator%");
      Ue && b && (Ie = b(Ue.prototype));
    }
    return O[be] = Ie, Ie;
  }, B = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, A = Kv(), K = /* @__PURE__ */ Z9(), F = A.call(Y, Array.prototype.concat), j = A.call(Z, Array.prototype.splice), re = A.call(Y, String.prototype.replace), z = A.call(Y, String.prototype.slice), ce = A.call(Y, RegExp.prototype.exec), he = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, de = /\\(\\)?/g, xe = function(be) {
    var Ie = z(be, 0, 1), Re = z(be, -1);
    if (Ie === "%" && Re !== "%")
      throw new o("invalid intrinsic syntax, expected closing `%`");
    if (Re === "%" && Ie !== "%")
      throw new o("invalid intrinsic syntax, expected opening `%`");
    var Ue = [];
    return re(be, he, function(Xe, vt, at, Tt) {
      Ue[Ue.length] = at ? re(Tt, de, "$1") : vt || Xe;
    }), Ue;
  }, Ze = function(be, Ie) {
    var Re = be, Ue;
    if (K(B, Re) && (Ue = B[Re], Re = "%" + Ue[0] + "%"), K(O, Re)) {
      var Xe = O[Re];
      if (Xe === q && (Xe = k(Re)), typeof Xe > "u" && !Ie)
        throw new a("intrinsic " + be + " exists, but is not available. Please file an issue!");
      return {
        alias: Ue,
        name: Re,
        value: Xe
      };
    }
    throw new o("intrinsic " + be + " does not exist!");
  };
  return Ow = function(be, Ie) {
    if (typeof be != "string" || be.length === 0)
      throw new a("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof Ie != "boolean")
      throw new a('"allowMissing" argument must be a boolean');
    if (ce(/^%?[^%]*%?$/, be) === null)
      throw new o("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var Re = xe(be), Ue = Re.length > 0 ? Re[0] : "", Xe = Ze("%" + Ue + "%", Ie), vt = Xe.name, at = Xe.value, Tt = !1, xr = Xe.alias;
    xr && (Ue = xr[0], j(Re, F([0, 1], xr)));
    for (var rs = 1, di = !0; rs < Re.length; rs += 1) {
      var on = Re[rs], an = z(on, 0, 1), ee = z(on, -1);
      if ((an === '"' || an === "'" || an === "`" || ee === '"' || ee === "'" || ee === "`") && an !== ee)
        throw new o("property names with quotes must have matching quotes");
      if ((on === "constructor" || !di) && (Tt = !0), Ue += "." + on, vt = "%" + Ue + "%", K(O, vt))
        at = O[vt];
      else if (at != null) {
        if (!(on in at)) {
          if (!Ie)
            throw new a("base intrinsic for " + be + " exists, but the property is not available.");
          return;
        }
        if (w && rs + 1 >= Re.length) {
          var ae = w(at, on);
          di = !!ae, di && "get" in ae && !("originalValue" in ae.get) ? at = ae.get : at = at[on];
        } else
          di = K(at, on), at = at[on];
        di && !Tt && (O[vt] = at);
      }
    }
    return at;
  }, Ow;
}
var $w, S2;
function uF() {
  if (S2) return $w;
  S2 = 1;
  var r = /* @__PURE__ */ G1(), e = cF(), t = e([r("%String.prototype.indexOf%")]);
  return $w = function(i, s) {
    var o = (
      /** @type {(this: unknown, ...args: unknown[]) => unknown} */
      r(i, !!s)
    );
    return typeof o == "function" && t(i, ".prototype.") > -1 ? e(
      /** @type {const} */
      [o]
    ) : o;
  }, $w;
}
var Rw, E2;
function lF() {
  if (E2) return Rw;
  E2 = 1;
  var r = /* @__PURE__ */ G1(), e = /* @__PURE__ */ uF(), t = /* @__PURE__ */ Gv(), n = /* @__PURE__ */ hf(), i = r("%Map%", !0), s = e("Map.prototype.get", !0), o = e("Map.prototype.set", !0), a = e("Map.prototype.has", !0), c = e("Map.prototype.delete", !0), u = e("Map.prototype.size", !0);
  return Rw = !!i && /** @type {Exclude<import('.'), false>} */
  function() {
    var d, f = {
      assert: function(p) {
        if (!f.has(p))
          throw new n("Side channel does not contain " + t(p));
      },
      delete: function(p) {
        if (d) {
          var y = c(d, p);
          return u(d) === 0 && (d = void 0), y;
        }
        return !1;
      },
      get: function(p) {
        if (d)
          return s(d, p);
      },
      has: function(p) {
        return d ? a(d, p) : !1;
      },
      set: function(p, y) {
        d || (d = new i()), o(d, p, y);
      }
    };
    return f;
  }, Rw;
}
var Pw, x2;
function J9() {
  if (x2) return Pw;
  x2 = 1;
  var r = /* @__PURE__ */ G1(), e = /* @__PURE__ */ uF(), t = /* @__PURE__ */ Gv(), n = lF(), i = /* @__PURE__ */ hf(), s = r("%WeakMap%", !0), o = e("WeakMap.prototype.get", !0), a = e("WeakMap.prototype.set", !0), c = e("WeakMap.prototype.has", !0), u = e("WeakMap.prototype.delete", !0);
  return Pw = s ? (
    /** @type {Exclude<import('.'), false>} */
    function() {
      var d, f, p = {
        assert: function(y) {
          if (!p.has(y))
            throw new i("Side channel does not contain " + t(y));
        },
        delete: function(y) {
          if (s && y && (typeof y == "object" || typeof y == "function")) {
            if (d)
              return u(d, y);
          } else if (n && f)
            return f.delete(y);
          return !1;
        },
        get: function(y) {
          return s && y && (typeof y == "object" || typeof y == "function") && d ? o(d, y) : f && f.get(y);
        },
        has: function(y) {
          return s && y && (typeof y == "object" || typeof y == "function") && d ? c(d, y) : !!f && f.has(y);
        },
        set: function(y, g) {
          s && y && (typeof y == "object" || typeof y == "function") ? (d || (d = new s()), a(d, y, g)) : n && (f || (f = n()), f.set(y, g));
        }
      };
      return p;
    }
  ) : n, Pw;
}
var Nw, A2;
function dF() {
  if (A2) return Nw;
  A2 = 1;
  var r = /* @__PURE__ */ hf(), e = /* @__PURE__ */ Gv(), t = A9(), n = lF(), i = J9(), s = i || n || t;
  return Nw = function() {
    var a, c = {
      assert: function(u) {
        if (!c.has(u))
          throw new r("Side channel does not contain " + e(u));
      },
      delete: function(u) {
        return !!a && a.delete(u);
      },
      get: function(u) {
        return a && a.get(u);
      },
      has: function(u) {
        return !!a && a.has(u);
      },
      set: function(u, l) {
        a || (a = s()), a.set(u, l);
      }
    };
    return c;
  }, Nw;
}
var Bw, I2;
function K1() {
  if (I2) return Bw;
  I2 = 1;
  var r = String.prototype.replace, e = /%20/g, t = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
  };
  return Bw = {
    default: t.RFC3986,
    formatters: {
      RFC1738: function(n) {
        return r.call(n, e, "+");
      },
      RFC3986: function(n) {
        return String(n);
      }
    },
    RFC1738: t.RFC1738,
    RFC3986: t.RFC3986
  }, Bw;
}
var Lw, C2;
function hF() {
  if (C2) return Lw;
  C2 = 1;
  var r = /* @__PURE__ */ K1(), e = dF(), t = Object.prototype.hasOwnProperty, n = Array.isArray, i = e(), s = function(b, C) {
    return i.set(b, C), b;
  }, o = function(b) {
    return i.has(b);
  }, a = function(b) {
    return i.get(b);
  }, c = function(b, C) {
    i.set(b, C);
  }, u = (function() {
    for (var T = [], b = 0; b < 256; ++b)
      T.push("%" + ((b < 16 ? "0" : "") + b.toString(16)).toUpperCase());
    return T;
  })(), l = function(b) {
    for (; b.length > 1; ) {
      var C = b.pop(), P = C.obj[C.prop];
      if (n(P)) {
        for (var Z = [], Y = 0; Y < P.length; ++Y)
          typeof P[Y] < "u" && Z.push(P[Y]);
        C.obj[C.prop] = Z;
      }
    }
  }, d = function(b, C) {
    for (var P = C && C.plainObjects ? { __proto__: null } : {}, Z = 0; Z < b.length; ++Z)
      typeof b[Z] < "u" && (P[Z] = b[Z]);
    return P;
  }, f = function T(b, C, P) {
    if (!C)
      return b;
    if (typeof C != "object" && typeof C != "function") {
      if (n(b))
        b.push(C);
      else if (b && typeof b == "object")
        if (o(b)) {
          var Z = a(b) + 1;
          b[Z] = C, c(b, Z);
        } else (P && (P.plainObjects || P.allowPrototypes) || !t.call(Object.prototype, C)) && (b[C] = !0);
      else
        return [b, C];
      return b;
    }
    if (!b || typeof b != "object") {
      if (o(C)) {
        for (var Y = Object.keys(C), q = P && P.plainObjects ? { __proto__: null, 0: b } : { 0: b }, J = 0; J < Y.length; J++) {
          var O = parseInt(Y[J], 10);
          q[O + 1] = C[Y[J]];
        }
        return s(q, a(C) + 1);
      }
      return [b].concat(C);
    }
    var x = b;
    return n(b) && !n(C) && (x = d(b, P)), n(b) && n(C) ? (C.forEach(function(k, B) {
      if (t.call(b, B)) {
        var A = b[B];
        A && typeof A == "object" && k && typeof k == "object" ? b[B] = T(A, k, P) : b.push(k);
      } else
        b[B] = k;
    }), b) : Object.keys(C).reduce(function(k, B) {
      var A = C[B];
      return t.call(k, B) ? k[B] = T(k[B], A, P) : k[B] = A, k;
    }, x);
  }, p = function(b, C) {
    return Object.keys(C).reduce(function(P, Z) {
      return P[Z] = C[Z], P;
    }, b);
  }, y = function(T, b, C) {
    var P = T.replace(/\+/g, " ");
    if (C === "iso-8859-1")
      return P.replace(/%[0-9a-f]{2}/gi, unescape);
    try {
      return decodeURIComponent(P);
    } catch {
      return P;
    }
  }, g = 1024, v = function(b, C, P, Z, Y) {
    if (b.length === 0)
      return b;
    var q = b;
    if (typeof b == "symbol" ? q = Symbol.prototype.toString.call(b) : typeof b != "string" && (q = String(b)), P === "iso-8859-1")
      return escape(q).replace(/%u[0-9a-f]{4}/gi, function(K) {
        return "%26%23" + parseInt(K.slice(2), 16) + "%3B";
      });
    for (var J = "", O = 0; O < q.length; O += g) {
      for (var x = q.length >= g ? q.slice(O, O + g) : q, k = [], B = 0; B < x.length; ++B) {
        var A = x.charCodeAt(B);
        if (A === 45 || A === 46 || A === 95 || A === 126 || A >= 48 && A <= 57 || A >= 65 && A <= 90 || A >= 97 && A <= 122 || Y === r.RFC1738 && (A === 40 || A === 41)) {
          k[k.length] = x.charAt(B);
          continue;
        }
        if (A < 128) {
          k[k.length] = u[A];
          continue;
        }
        if (A < 2048) {
          k[k.length] = u[192 | A >> 6] + u[128 | A & 63];
          continue;
        }
        if (A < 55296 || A >= 57344) {
          k[k.length] = u[224 | A >> 12] + u[128 | A >> 6 & 63] + u[128 | A & 63];
          continue;
        }
        B += 1, A = 65536 + ((A & 1023) << 10 | x.charCodeAt(B) & 1023), k[k.length] = u[240 | A >> 18] + u[128 | A >> 12 & 63] + u[128 | A >> 6 & 63] + u[128 | A & 63];
      }
      J += k.join("");
    }
    return J;
  }, _ = function(b) {
    for (var C = [{ obj: { o: b }, prop: "o" }], P = [], Z = 0; Z < C.length; ++Z)
      for (var Y = C[Z], q = Y.obj[Y.prop], J = Object.keys(q), O = 0; O < J.length; ++O) {
        var x = J[O], k = q[x];
        typeof k == "object" && k !== null && P.indexOf(k) === -1 && (C.push({ obj: q, prop: x }), P.push(k));
      }
    return l(C), b;
  }, w = function(b) {
    return Object.prototype.toString.call(b) === "[object RegExp]";
  }, E = function(b) {
    return !b || typeof b != "object" ? !1 : !!(b.constructor && b.constructor.isBuffer && b.constructor.isBuffer(b));
  }, I = function(b, C, P, Z) {
    if (o(b)) {
      var Y = a(b) + 1;
      return b[Y] = C, c(b, Y), b;
    }
    var q = [].concat(b, C);
    return q.length > P ? s(d(q, { plainObjects: Z }), q.length - 1) : q;
  }, S = function(b, C) {
    if (n(b)) {
      for (var P = [], Z = 0; Z < b.length; Z += 1)
        P.push(C(b[Z]));
      return P;
    }
    return C(b);
  };
  return Lw = {
    arrayToObject: d,
    assign: p,
    combine: I,
    compact: _,
    decode: y,
    encode: v,
    isBuffer: E,
    isOverflow: o,
    isRegExp: w,
    maybeMap: S,
    merge: f
  }, Lw;
}
var Uw, D2;
function X9() {
  if (D2) return Uw;
  D2 = 1;
  var r = dF(), e = /* @__PURE__ */ hF(), t = /* @__PURE__ */ K1(), n = Object.prototype.hasOwnProperty, i = {
    brackets: function(v) {
      return v + "[]";
    },
    comma: "comma",
    indices: function(v, _) {
      return v + "[" + _ + "]";
    },
    repeat: function(v) {
      return v;
    }
  }, s = Array.isArray, o = Array.prototype.push, a = function(g, v) {
    o.apply(g, s(v) ? v : [v]);
  }, c = Date.prototype.toISOString, u = t.default, l = {
    addQueryPrefix: !1,
    allowDots: !1,
    allowEmptyArrays: !1,
    arrayFormat: "indices",
    charset: "utf-8",
    charsetSentinel: !1,
    commaRoundTrip: !1,
    delimiter: "&",
    encode: !0,
    encodeDotInKeys: !1,
    encoder: e.encode,
    encodeValuesOnly: !1,
    filter: void 0,
    format: u,
    formatter: t.formatters[u],
    // deprecated
    indices: !1,
    serializeDate: function(v) {
      return c.call(v);
    },
    skipNulls: !1,
    strictNullHandling: !1
  }, d = function(v) {
    return typeof v == "string" || typeof v == "number" || typeof v == "boolean" || typeof v == "symbol" || typeof v == "bigint";
  }, f = {}, p = function g(v, _, w, E, I, S, T, b, C, P, Z, Y, q, J, O, x, k, B) {
    for (var A = v, K = B, F = 0, j = !1; (K = K.get(f)) !== void 0 && !j; ) {
      var re = K.get(v);
      if (F += 1, typeof re < "u") {
        if (re === F)
          throw new RangeError("Cyclic object value");
        j = !0;
      }
      typeof K.get(f) > "u" && (F = 0);
    }
    if (typeof P == "function" ? A = P(_, A) : A instanceof Date ? A = q(A) : w === "comma" && s(A) && (A = e.maybeMap(A, function(vt) {
      return vt instanceof Date ? q(vt) : vt;
    })), A === null) {
      if (S)
        return C && !x ? C(_, l.encoder, k, "key", J) : _;
      A = "";
    }
    if (d(A) || e.isBuffer(A)) {
      if (C) {
        var z = x ? _ : C(_, l.encoder, k, "key", J);
        return [O(z) + "=" + O(C(A, l.encoder, k, "value", J))];
      }
      return [O(_) + "=" + O(String(A))];
    }
    var ce = [];
    if (typeof A > "u")
      return ce;
    var he;
    if (w === "comma" && s(A))
      x && C && (A = e.maybeMap(A, C)), he = [{ value: A.length > 0 ? A.join(",") || null : void 0 }];
    else if (s(P))
      he = P;
    else {
      var de = Object.keys(A);
      he = Z ? de.sort(Z) : de;
    }
    var xe = b ? String(_).replace(/\./g, "%2E") : String(_), Ze = E && s(A) && A.length === 1 ? xe + "[]" : xe;
    if (I && s(A) && A.length === 0)
      return Ze + "[]";
    for (var Se = 0; Se < he.length; ++Se) {
      var be = he[Se], Ie = typeof be == "object" && be && typeof be.value < "u" ? be.value : A[be];
      if (!(T && Ie === null)) {
        var Re = Y && b ? String(be).replace(/\./g, "%2E") : String(be), Ue = s(A) ? typeof w == "function" ? w(Ze, Re) : Ze : Ze + (Y ? "." + Re : "[" + Re + "]");
        B.set(v, F);
        var Xe = r();
        Xe.set(f, B), a(ce, g(
          Ie,
          Ue,
          w,
          E,
          I,
          S,
          T,
          b,
          w === "comma" && x && s(A) ? null : C,
          P,
          Z,
          Y,
          q,
          J,
          O,
          x,
          k,
          Xe
        ));
      }
    }
    return ce;
  }, y = function(v) {
    if (!v)
      return l;
    if (typeof v.allowEmptyArrays < "u" && typeof v.allowEmptyArrays != "boolean")
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    if (typeof v.encodeDotInKeys < "u" && typeof v.encodeDotInKeys != "boolean")
      throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
    if (v.encoder !== null && typeof v.encoder < "u" && typeof v.encoder != "function")
      throw new TypeError("Encoder has to be a function.");
    var _ = v.charset || l.charset;
    if (typeof v.charset < "u" && v.charset !== "utf-8" && v.charset !== "iso-8859-1")
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    var w = t.default;
    if (typeof v.format < "u") {
      if (!n.call(t.formatters, v.format))
        throw new TypeError("Unknown format option provided.");
      w = v.format;
    }
    var E = t.formatters[w], I = l.filter;
    (typeof v.filter == "function" || s(v.filter)) && (I = v.filter);
    var S;
    if (v.arrayFormat in i ? S = v.arrayFormat : "indices" in v ? S = v.indices ? "indices" : "repeat" : S = l.arrayFormat, "commaRoundTrip" in v && typeof v.commaRoundTrip != "boolean")
      throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    var T = typeof v.allowDots > "u" ? v.encodeDotInKeys === !0 ? !0 : l.allowDots : !!v.allowDots;
    return {
      addQueryPrefix: typeof v.addQueryPrefix == "boolean" ? v.addQueryPrefix : l.addQueryPrefix,
      allowDots: T,
      allowEmptyArrays: typeof v.allowEmptyArrays == "boolean" ? !!v.allowEmptyArrays : l.allowEmptyArrays,
      arrayFormat: S,
      charset: _,
      charsetSentinel: typeof v.charsetSentinel == "boolean" ? v.charsetSentinel : l.charsetSentinel,
      commaRoundTrip: !!v.commaRoundTrip,
      delimiter: typeof v.delimiter > "u" ? l.delimiter : v.delimiter,
      encode: typeof v.encode == "boolean" ? v.encode : l.encode,
      encodeDotInKeys: typeof v.encodeDotInKeys == "boolean" ? v.encodeDotInKeys : l.encodeDotInKeys,
      encoder: typeof v.encoder == "function" ? v.encoder : l.encoder,
      encodeValuesOnly: typeof v.encodeValuesOnly == "boolean" ? v.encodeValuesOnly : l.encodeValuesOnly,
      filter: I,
      format: w,
      formatter: E,
      serializeDate: typeof v.serializeDate == "function" ? v.serializeDate : l.serializeDate,
      skipNulls: typeof v.skipNulls == "boolean" ? v.skipNulls : l.skipNulls,
      sort: typeof v.sort == "function" ? v.sort : null,
      strictNullHandling: typeof v.strictNullHandling == "boolean" ? v.strictNullHandling : l.strictNullHandling
    };
  };
  return Uw = function(g, v) {
    var _ = g, w = y(v), E, I;
    typeof w.filter == "function" ? (I = w.filter, _ = I("", _)) : s(w.filter) && (I = w.filter, E = I);
    var S = [];
    if (typeof _ != "object" || _ === null)
      return "";
    var T = i[w.arrayFormat], b = T === "comma" && w.commaRoundTrip;
    E || (E = Object.keys(_)), w.sort && E.sort(w.sort);
    for (var C = r(), P = 0; P < E.length; ++P) {
      var Z = E[P], Y = _[Z];
      w.skipNulls && Y === null || a(S, p(
        Y,
        Z,
        T,
        b,
        w.allowEmptyArrays,
        w.strictNullHandling,
        w.skipNulls,
        w.encodeDotInKeys,
        w.encode ? w.encoder : null,
        w.filter,
        w.sort,
        w.allowDots,
        w.serializeDate,
        w.format,
        w.formatter,
        w.encodeValuesOnly,
        w.charset,
        C
      ));
    }
    var q = S.join(w.delimiter), J = w.addQueryPrefix === !0 ? "?" : "";
    return w.charsetSentinel && (w.charset === "iso-8859-1" ? J += "utf8=%26%2310003%3B&" : J += "utf8=%E2%9C%93&"), q.length > 0 ? J + q : "";
  }, Uw;
}
var Fw, T2;
function Y9() {
  if (T2) return Fw;
  T2 = 1;
  var r = /* @__PURE__ */ hF(), e = Object.prototype.hasOwnProperty, t = Array.isArray, n = {
    allowDots: !1,
    allowEmptyArrays: !1,
    allowPrototypes: !1,
    allowSparse: !1,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: !1,
    comma: !1,
    decodeDotInKeys: !1,
    decoder: r.decode,
    delimiter: "&",
    depth: 5,
    duplicates: "combine",
    ignoreQueryPrefix: !1,
    interpretNumericEntities: !1,
    parameterLimit: 1e3,
    parseArrays: !0,
    plainObjects: !1,
    strictDepth: !1,
    strictNullHandling: !1,
    throwOnLimitExceeded: !1
  }, i = function(p) {
    return p.replace(/&#(\d+);/g, function(y, g) {
      return String.fromCharCode(parseInt(g, 10));
    });
  }, s = function(p, y, g) {
    if (p && typeof p == "string" && y.comma && p.indexOf(",") > -1)
      return p.split(",");
    if (y.throwOnLimitExceeded && g >= y.arrayLimit)
      throw new RangeError("Array limit exceeded. Only " + y.arrayLimit + " element" + (y.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
    return p;
  }, o = "utf8=%26%2310003%3B", a = "utf8=%E2%9C%93", c = function(y, g) {
    var v = { __proto__: null }, _ = g.ignoreQueryPrefix ? y.replace(/^\?/, "") : y;
    _ = _.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    var w = g.parameterLimit === 1 / 0 ? void 0 : g.parameterLimit, E = _.split(
      g.delimiter,
      g.throwOnLimitExceeded ? w + 1 : w
    );
    if (g.throwOnLimitExceeded && E.length > w)
      throw new RangeError("Parameter limit exceeded. Only " + w + " parameter" + (w === 1 ? "" : "s") + " allowed.");
    var I = -1, S, T = g.charset;
    if (g.charsetSentinel)
      for (S = 0; S < E.length; ++S)
        E[S].indexOf("utf8=") === 0 && (E[S] === a ? T = "utf-8" : E[S] === o && (T = "iso-8859-1"), I = S, S = E.length);
    for (S = 0; S < E.length; ++S)
      if (S !== I) {
        var b = E[S], C = b.indexOf("]="), P = C === -1 ? b.indexOf("=") : C + 1, Z, Y;
        if (P === -1 ? (Z = g.decoder(b, n.decoder, T, "key"), Y = g.strictNullHandling ? null : "") : (Z = g.decoder(b.slice(0, P), n.decoder, T, "key"), Z !== null && (Y = r.maybeMap(
          s(
            b.slice(P + 1),
            g,
            t(v[Z]) ? v[Z].length : 0
          ),
          function(J) {
            return g.decoder(J, n.decoder, T, "value");
          }
        ))), Y && g.interpretNumericEntities && T === "iso-8859-1" && (Y = i(String(Y))), b.indexOf("[]=") > -1 && (Y = t(Y) ? [Y] : Y), Z !== null) {
          var q = e.call(v, Z);
          q && g.duplicates === "combine" ? v[Z] = r.combine(
            v[Z],
            Y,
            g.arrayLimit,
            g.plainObjects
          ) : (!q || g.duplicates === "last") && (v[Z] = Y);
        }
      }
    return v;
  }, u = function(p, y, g, v) {
    var _ = 0;
    if (p.length > 0 && p[p.length - 1] === "[]") {
      var w = p.slice(0, -1).join("");
      _ = Array.isArray(y) && y[w] ? y[w].length : 0;
    }
    for (var E = v ? y : s(y, g, _), I = p.length - 1; I >= 0; --I) {
      var S, T = p[I];
      if (T === "[]" && g.parseArrays)
        r.isOverflow(E) ? S = E : S = g.allowEmptyArrays && (E === "" || g.strictNullHandling && E === null) ? [] : r.combine(
          [],
          E,
          g.arrayLimit,
          g.plainObjects
        );
      else {
        S = g.plainObjects ? { __proto__: null } : {};
        var b = T.charAt(0) === "[" && T.charAt(T.length - 1) === "]" ? T.slice(1, -1) : T, C = g.decodeDotInKeys ? b.replace(/%2E/g, ".") : b, P = parseInt(C, 10);
        !g.parseArrays && C === "" ? S = { 0: E } : !isNaN(P) && T !== C && String(P) === C && P >= 0 && g.parseArrays && P <= g.arrayLimit ? (S = [], S[P] = E) : C !== "__proto__" && (S[C] = E);
      }
      E = S;
    }
    return E;
  }, l = function(y, g) {
    var v = g.allowDots ? y.replace(/\.([^.[]+)/g, "[$1]") : y;
    if (g.depth <= 0)
      return !g.plainObjects && e.call(Object.prototype, v) && !g.allowPrototypes ? void 0 : [v];
    var _ = /(\[[^[\]]*])/, w = /(\[[^[\]]*])/g, E = _.exec(v), I = E ? v.slice(0, E.index) : v, S = [];
    if (I) {
      if (!g.plainObjects && e.call(Object.prototype, I) && !g.allowPrototypes)
        return;
      S.push(I);
    }
    for (var T = 0; (E = w.exec(v)) !== null && T < g.depth; ) {
      T += 1;
      var b = E[1].slice(1, -1);
      if (!g.plainObjects && e.call(Object.prototype, b) && !g.allowPrototypes)
        return;
      S.push(E[1]);
    }
    if (E) {
      if (g.strictDepth === !0)
        throw new RangeError("Input depth exceeded depth option of " + g.depth + " and strictDepth is true");
      S.push("[" + v.slice(E.index) + "]");
    }
    return S;
  }, d = function(y, g, v, _) {
    if (y) {
      var w = l(y, v);
      if (w)
        return u(w, g, v, _);
    }
  }, f = function(y) {
    if (!y)
      return n;
    if (typeof y.allowEmptyArrays < "u" && typeof y.allowEmptyArrays != "boolean")
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    if (typeof y.decodeDotInKeys < "u" && typeof y.decodeDotInKeys != "boolean")
      throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
    if (y.decoder !== null && typeof y.decoder < "u" && typeof y.decoder != "function")
      throw new TypeError("Decoder has to be a function.");
    if (typeof y.charset < "u" && y.charset !== "utf-8" && y.charset !== "iso-8859-1")
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    if (typeof y.throwOnLimitExceeded < "u" && typeof y.throwOnLimitExceeded != "boolean")
      throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
    var g = typeof y.charset > "u" ? n.charset : y.charset, v = typeof y.duplicates > "u" ? n.duplicates : y.duplicates;
    if (v !== "combine" && v !== "first" && v !== "last")
      throw new TypeError("The duplicates option must be either combine, first, or last");
    var _ = typeof y.allowDots > "u" ? y.decodeDotInKeys === !0 ? !0 : n.allowDots : !!y.allowDots;
    return {
      allowDots: _,
      allowEmptyArrays: typeof y.allowEmptyArrays == "boolean" ? !!y.allowEmptyArrays : n.allowEmptyArrays,
      allowPrototypes: typeof y.allowPrototypes == "boolean" ? y.allowPrototypes : n.allowPrototypes,
      allowSparse: typeof y.allowSparse == "boolean" ? y.allowSparse : n.allowSparse,
      arrayLimit: typeof y.arrayLimit == "number" ? y.arrayLimit : n.arrayLimit,
      charset: g,
      charsetSentinel: typeof y.charsetSentinel == "boolean" ? y.charsetSentinel : n.charsetSentinel,
      comma: typeof y.comma == "boolean" ? y.comma : n.comma,
      decodeDotInKeys: typeof y.decodeDotInKeys == "boolean" ? y.decodeDotInKeys : n.decodeDotInKeys,
      decoder: typeof y.decoder == "function" ? y.decoder : n.decoder,
      delimiter: typeof y.delimiter == "string" || r.isRegExp(y.delimiter) ? y.delimiter : n.delimiter,
      // eslint-disable-next-line no-implicit-coercion, no-extra-parens
      depth: typeof y.depth == "number" || y.depth === !1 ? +y.depth : n.depth,
      duplicates: v,
      ignoreQueryPrefix: y.ignoreQueryPrefix === !0,
      interpretNumericEntities: typeof y.interpretNumericEntities == "boolean" ? y.interpretNumericEntities : n.interpretNumericEntities,
      parameterLimit: typeof y.parameterLimit == "number" ? y.parameterLimit : n.parameterLimit,
      parseArrays: y.parseArrays !== !1,
      plainObjects: typeof y.plainObjects == "boolean" ? y.plainObjects : n.plainObjects,
      strictDepth: typeof y.strictDepth == "boolean" ? !!y.strictDepth : n.strictDepth,
      strictNullHandling: typeof y.strictNullHandling == "boolean" ? y.strictNullHandling : n.strictNullHandling,
      throwOnLimitExceeded: typeof y.throwOnLimitExceeded == "boolean" ? y.throwOnLimitExceeded : !1
    };
  };
  return Fw = function(p, y) {
    var g = f(y);
    if (p === "" || p === null || typeof p > "u")
      return g.plainObjects ? { __proto__: null } : {};
    for (var v = typeof p == "string" ? c(p, g) : p, _ = g.plainObjects ? { __proto__: null } : {}, w = Object.keys(v), E = 0; E < w.length; ++E) {
      var I = w[E], S = d(I, v[I], g, typeof p == "string");
      _ = r.merge(_, S, g);
    }
    return g.allowSparse === !0 ? _ : r.compact(_);
  }, Fw;
}
var Mw, k2;
function Q9() {
  if (k2) return Mw;
  k2 = 1;
  var r = /* @__PURE__ */ X9(), e = /* @__PURE__ */ Y9(), t = /* @__PURE__ */ K1();
  return Mw = {
    formats: t,
    parse: e,
    stringify: r
  }, Mw;
}
var O2;
function eG() {
  if (O2) return Oc;
  O2 = 1;
  var r = S9();
  function e() {
    this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
  }
  var t = /^([a-z0-9.+-]+:)/i, n = /:[0-9]*$/, i = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/, s = [
    "<",
    ">",
    '"',
    "`",
    " ",
    "\r",
    `
`,
    "	"
  ], o = [
    "{",
    "}",
    "|",
    "\\",
    "^",
    "`"
  ].concat(s), a = ["'"].concat(o), c = [
    "%",
    "/",
    "?",
    ";",
    "#"
  ].concat(a), u = [
    "/",
    "?",
    "#"
  ], l = 255, d = /^[+a-z0-9A-Z_-]{0,63}$/, f = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, p = {
    javascript: !0,
    "javascript:": !0
  }, y = {
    javascript: !0,
    "javascript:": !0
  }, g = {
    http: !0,
    https: !0,
    ftp: !0,
    gopher: !0,
    file: !0,
    "http:": !0,
    "https:": !0,
    "ftp:": !0,
    "gopher:": !0,
    "file:": !0
  }, v = /* @__PURE__ */ Q9();
  function _(S, T, b) {
    if (S && typeof S == "object" && S instanceof e)
      return S;
    var C = new e();
    return C.parse(S, T, b), C;
  }
  e.prototype.parse = function(S, T, b) {
    if (typeof S != "string")
      throw new TypeError("Parameter 'url' must be a string, not " + typeof S);
    var C = S.indexOf("?"), P = C !== -1 && C < S.indexOf("#") ? "?" : "#", Z = S.split(P), Y = /\\/g;
    Z[0] = Z[0].replace(Y, "/"), S = Z.join(P);
    var q = S;
    if (q = q.trim(), !b && S.split("#").length === 1) {
      var J = i.exec(q);
      if (J)
        return this.path = q, this.href = q, this.pathname = J[1], J[2] ? (this.search = J[2], T ? this.query = v.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : T && (this.search = "", this.query = {}), this;
    }
    var O = t.exec(q);
    if (O) {
      O = O[0];
      var x = O.toLowerCase();
      this.protocol = x, q = q.substr(O.length);
    }
    if (b || O || q.match(/^\/\/[^@/]+@[^@/]+/)) {
      var k = q.substr(0, 2) === "//";
      k && !(O && y[O]) && (q = q.substr(2), this.slashes = !0);
    }
    if (!y[O] && (k || O && !g[O])) {
      for (var B = -1, A = 0; A < u.length; A++) {
        var K = q.indexOf(u[A]);
        K !== -1 && (B === -1 || K < B) && (B = K);
      }
      var F, j;
      B === -1 ? j = q.lastIndexOf("@") : j = q.lastIndexOf("@", B), j !== -1 && (F = q.slice(0, j), q = q.slice(j + 1), this.auth = decodeURIComponent(F)), B = -1;
      for (var A = 0; A < c.length; A++) {
        var K = q.indexOf(c[A]);
        K !== -1 && (B === -1 || K < B) && (B = K);
      }
      B === -1 && (B = q.length), this.host = q.slice(0, B), q = q.slice(B), this.parseHost(), this.hostname = this.hostname || "";
      var re = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
      if (!re)
        for (var z = this.hostname.split(/\./), A = 0, ce = z.length; A < ce; A++) {
          var he = z[A];
          if (he && !he.match(d)) {
            for (var de = "", xe = 0, Ze = he.length; xe < Ze; xe++)
              he.charCodeAt(xe) > 127 ? de += "x" : de += he[xe];
            if (!de.match(d)) {
              var Se = z.slice(0, A), be = z.slice(A + 1), Ie = he.match(f);
              Ie && (Se.push(Ie[1]), be.unshift(Ie[2])), be.length && (q = "/" + be.join(".") + q), this.hostname = Se.join(".");
              break;
            }
          }
        }
      this.hostname.length > l ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), re || (this.hostname = r.toASCII(this.hostname));
      var Re = this.port ? ":" + this.port : "", Ue = this.hostname || "";
      this.host = Ue + Re, this.href += this.host, re && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), q[0] !== "/" && (q = "/" + q));
    }
    if (!p[x])
      for (var A = 0, ce = a.length; A < ce; A++) {
        var Xe = a[A];
        if (q.indexOf(Xe) !== -1) {
          var vt = encodeURIComponent(Xe);
          vt === Xe && (vt = escape(Xe)), q = q.split(Xe).join(vt);
        }
      }
    var at = q.indexOf("#");
    at !== -1 && (this.hash = q.substr(at), q = q.slice(0, at));
    var Tt = q.indexOf("?");
    if (Tt !== -1 ? (this.search = q.substr(Tt), this.query = q.substr(Tt + 1), T && (this.query = v.parse(this.query)), q = q.slice(0, Tt)) : T && (this.search = "", this.query = {}), q && (this.pathname = q), g[x] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
      var Re = this.pathname || "", xr = this.search || "";
      this.path = Re + xr;
    }
    return this.href = this.format(), this;
  };
  function w(S) {
    return typeof S == "string" && (S = _(S)), S instanceof e ? S.format() : e.prototype.format.call(S);
  }
  e.prototype.format = function() {
    var S = this.auth || "";
    S && (S = encodeURIComponent(S), S = S.replace(/%3A/i, ":"), S += "@");
    var T = this.protocol || "", b = this.pathname || "", C = this.hash || "", P = !1, Z = "";
    this.host ? P = S + this.host : this.hostname && (P = S + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (P += ":" + this.port)), this.query && typeof this.query == "object" && Object.keys(this.query).length && (Z = v.stringify(this.query, {
      arrayFormat: "repeat",
      addQueryPrefix: !1
    }));
    var Y = this.search || Z && "?" + Z || "";
    return T && T.substr(-1) !== ":" && (T += ":"), this.slashes || (!T || g[T]) && P !== !1 ? (P = "//" + (P || ""), b && b.charAt(0) !== "/" && (b = "/" + b)) : P || (P = ""), C && C.charAt(0) !== "#" && (C = "#" + C), Y && Y.charAt(0) !== "?" && (Y = "?" + Y), b = b.replace(/[?#]/g, function(q) {
      return encodeURIComponent(q);
    }), Y = Y.replace("#", "%23"), T + P + b + Y + C;
  };
  function E(S, T) {
    return _(S, !1, !0).resolve(T);
  }
  e.prototype.resolve = function(S) {
    return this.resolveObject(_(S, !1, !0)).format();
  };
  function I(S, T) {
    return S ? _(S, !1, !0).resolveObject(T) : T;
  }
  return e.prototype.resolveObject = function(S) {
    if (typeof S == "string") {
      var T = new e();
      T.parse(S, !1, !0), S = T;
    }
    for (var b = new e(), C = Object.keys(this), P = 0; P < C.length; P++) {
      var Z = C[P];
      b[Z] = this[Z];
    }
    if (b.hash = S.hash, S.href === "")
      return b.href = b.format(), b;
    if (S.slashes && !S.protocol) {
      for (var Y = Object.keys(S), q = 0; q < Y.length; q++) {
        var J = Y[q];
        J !== "protocol" && (b[J] = S[J]);
      }
      return g[b.protocol] && b.hostname && !b.pathname && (b.pathname = "/", b.path = b.pathname), b.href = b.format(), b;
    }
    if (S.protocol && S.protocol !== b.protocol) {
      if (!g[S.protocol]) {
        for (var O = Object.keys(S), x = 0; x < O.length; x++) {
          var k = O[x];
          b[k] = S[k];
        }
        return b.href = b.format(), b;
      }
      if (b.protocol = S.protocol, !S.host && !y[S.protocol]) {
        for (var ce = (S.pathname || "").split("/"); ce.length && !(S.host = ce.shift()); )
          ;
        S.host || (S.host = ""), S.hostname || (S.hostname = ""), ce[0] !== "" && ce.unshift(""), ce.length < 2 && ce.unshift(""), b.pathname = ce.join("/");
      } else
        b.pathname = S.pathname;
      if (b.search = S.search, b.query = S.query, b.host = S.host || "", b.auth = S.auth, b.hostname = S.hostname || S.host, b.port = S.port, b.pathname || b.search) {
        var B = b.pathname || "", A = b.search || "";
        b.path = B + A;
      }
      return b.slashes = b.slashes || S.slashes, b.href = b.format(), b;
    }
    var K = b.pathname && b.pathname.charAt(0) === "/", F = S.host || S.pathname && S.pathname.charAt(0) === "/", j = F || K || b.host && S.pathname, re = j, z = b.pathname && b.pathname.split("/") || [], ce = S.pathname && S.pathname.split("/") || [], he = b.protocol && !g[b.protocol];
    if (he && (b.hostname = "", b.port = null, b.host && (z[0] === "" ? z[0] = b.host : z.unshift(b.host)), b.host = "", S.protocol && (S.hostname = null, S.port = null, S.host && (ce[0] === "" ? ce[0] = S.host : ce.unshift(S.host)), S.host = null), j = j && (ce[0] === "" || z[0] === "")), F)
      b.host = S.host || S.host === "" ? S.host : b.host, b.hostname = S.hostname || S.hostname === "" ? S.hostname : b.hostname, b.search = S.search, b.query = S.query, z = ce;
    else if (ce.length)
      z || (z = []), z.pop(), z = z.concat(ce), b.search = S.search, b.query = S.query;
    else if (S.search != null) {
      if (he) {
        b.host = z.shift(), b.hostname = b.host;
        var de = b.host && b.host.indexOf("@") > 0 ? b.host.split("@") : !1;
        de && (b.auth = de.shift(), b.hostname = de.shift(), b.host = b.hostname);
      }
      return b.search = S.search, b.query = S.query, (b.pathname !== null || b.search !== null) && (b.path = (b.pathname ? b.pathname : "") + (b.search ? b.search : "")), b.href = b.format(), b;
    }
    if (!z.length)
      return b.pathname = null, b.search ? b.path = "/" + b.search : b.path = null, b.href = b.format(), b;
    for (var xe = z.slice(-1)[0], Ze = (b.host || S.host || z.length > 1) && (xe === "." || xe === "..") || xe === "", Se = 0, be = z.length; be >= 0; be--)
      xe = z[be], xe === "." ? z.splice(be, 1) : xe === ".." ? (z.splice(be, 1), Se++) : Se && (z.splice(be, 1), Se--);
    if (!j && !re)
      for (; Se--; Se)
        z.unshift("..");
    j && z[0] !== "" && (!z[0] || z[0].charAt(0) !== "/") && z.unshift(""), Ze && z.join("/").substr(-1) !== "/" && z.push("");
    var Ie = z[0] === "" || z[0] && z[0].charAt(0) === "/";
    if (he) {
      b.hostname = Ie ? "" : z.length ? z.shift() : "", b.host = b.hostname;
      var de = b.host && b.host.indexOf("@") > 0 ? b.host.split("@") : !1;
      de && (b.auth = de.shift(), b.hostname = de.shift(), b.host = b.hostname);
    }
    return j = j || b.host && z.length, j && !Ie && z.unshift(""), z.length > 0 ? b.pathname = z.join("/") : (b.pathname = null, b.path = null), (b.pathname !== null || b.search !== null) && (b.path = (b.pathname ? b.pathname : "") + (b.search ? b.search : "")), b.auth = S.auth || b.auth, b.slashes = b.slashes || S.slashes, b.href = b.format(), b;
  }, e.prototype.parseHost = function() {
    var S = this.host, T = n.exec(S);
    T && (T = T[0], T !== ":" && (this.port = T.substr(1)), S = S.substr(0, S.length - T.length)), S && (this.hostname = S);
  }, Oc.parse = _, Oc.resolve = E, Oc.resolveObject = I, Oc.format = w, Oc.Url = e, Oc;
}
var tG = eG();
const ji = /* @__PURE__ */ KI(tG);
var rG = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, nG = (r, e) => (t, n) => e(t, n, r);
let pE = class {
  constructor({ webSocketUrl: e }) {
    h(this, "webSocketBaseUrl");
    this.webSocketBaseUrl = e;
  }
  genuineCheck(e) {
    const t = ji.format({ pathname: `${this.webSocketBaseUrl}/genuine`, query: e });
    return this._connectWebSocket(t);
  }
  installApp(e) {
    const t = ji.format({ pathname: `${this.webSocketBaseUrl}/install`, query: e });
    return this._connectWebSocket(t);
  }
  listInstalledApps(e) {
    const t = ji.format({ pathname: `${this.webSocketBaseUrl}/apps/list`, query: e });
    return this._connectWebSocket(t);
  }
  uninstallApp(e) {
    const t = ji.format({ pathname: `${this.webSocketBaseUrl}/install`, query: e });
    return this._connectWebSocket(t);
  }
  updateFirmware(e) {
    const t = ji.format({ pathname: `${this.webSocketBaseUrl}/install`, query: e });
    return this._connectWebSocket(t);
  }
  updateMcu(e) {
    const t = ji.format({ pathname: `${this.webSocketBaseUrl}/mcu`, query: e });
    return this._connectWebSocket(t);
  }
  _connectWebSocket(e) {
    try {
      return te(new D1(e));
    } catch (t) {
      return N(new Hz(t));
    }
  }
};
pE = rG([le(), nG(0, X(hd.DmkConfig))], pE);
var iG = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, sG = (r, e) => (t, n) => e(t, n, r);
let gE = class {
  constructor(e) {
    this.dataSource = e;
  }
  genuineCheck(e, t) {
    const n = { targetId: e.targetId.toString(), perso: t.perso };
    return this.dataSource.genuineCheck(n);
  }
  installApp(e, t) {
    const { perso: n, firmware: i, firmwareKey: s, hash: o } = t, a = { targetId: e.targetId.toString(), perso: n, firmware: i, firmwareKey: s, hash: o };
    return this.dataSource.installApp(a);
  }
  listInstalledApps(e, t) {
    const n = { targetId: e.targetId.toString(), perso: t.perso };
    return this.dataSource.listInstalledApps(n);
  }
  uninstallApp(e, t) {
    const { perso: n, delete: i, deleteKey: s, hash: o } = t, a = { targetId: e.targetId.toString(), perso: n, firmware: i, firmwareKey: s, hash: o };
    return this.dataSource.uninstallApp(a);
  }
  updateFirmware(e, t) {
    const n = { targetId: e.targetId.toString(), perso: t.perso, firmware: t.firmware, firmwareKey: t.firmwareKey };
    return this.dataSource.updateFirmware(n);
  }
  updateMcu(e, t) {
    const n = { targetId: e.targetId.toString(), version: t.version };
    return this.dataSource.updateMcu(n);
  }
};
gE = iG([le(), sG(0, X(hd.SecureChannelDataSource))], gE);
const oG = ({ stub: r, config: e }) => new mt(({ bind: t }) => {
  t(hd.DmkConfig).toConstantValue(e), t(hd.SecureChannelDataSource).to(pE), t(hd.SecureChannelService).to(gE);
}), fF = "wss://scriptrunner.api.live.ledger.com/update";
var aG = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, $2 = (r, e) => (t, n) => e(t, n, r);
let mE = class {
  constructor(e, t) {
    h(this, "_sessionService");
    h(this, "_logger");
    this._sessionService = e, this._logger = t("SendApduUseCase");
  }
  async execute({ sessionId: e, apdu: t, abortTimeout: n, triggersDisconnection: i }) {
    return this._sessionService.getDeviceSessionById(e).caseOf({ Right: async (s) => (await s.sendApdu(t, { abortTimeout: n, triggersDisconnection: i })).caseOf({ Right: (o) => o, Left: (o) => {
      throw this._logger.error("Error sending APDU", { data: { sessionId: e, apdu: t, error: o } }), o;
    } }), Left: (s) => {
      throw this._logger.error("Error getting deviceSession", { data: { error: s } }), s;
    } });
  }
};
mE = aG([le(), $2(0, X(Vt.DeviceSessionService)), $2(1, X(Er.LoggerPublisherServiceFactory))], mE);
const cG = ({ stub: r = !1 }) => new mt(({ bind: e, rebindSync: t }) => {
  e(NS.SendApduUseCase).to(mE), r && t(NS.SendApduUseCase).to(Ur);
});
var uG = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Al = (r, e) => (t, n) => e(t, n, r);
let yE = class {
  constructor(e, t, n, i, s, o) {
    h(this, "_transports", /* @__PURE__ */ new Map());
    h(this, "_logger");
    if (this._config = t, this._loggerModuleFactory = n, this._deviceModelDataSource = i, this._apduSenderServiceFactory = s, this._apduReceiverServiceFactory = o, this._logger = n("TransportService"), e.length === 0) throw this._logger.warn("No transports provided, please check your configuration"), new Oz("No transports provided, please check your configuration");
    for (const a of e) {
      const c = this.addTransport(a);
      if (c.isLeft()) throw c.extract();
    }
  }
  addTransport(e) {
    const t = e({ deviceModelDataSource: this._deviceModelDataSource, loggerServiceFactory: this._loggerModuleFactory, config: this._config, apduSenderServiceFactory: this._apduSenderServiceFactory, apduReceiverServiceFactory: this._apduReceiverServiceFactory });
    return this.addTransportInternal(t);
  }
  addTransportInternal(e) {
    return this.getTransport(e.getIdentifier()).isJust() ? (this._logger.warn(`Transport ${e.getIdentifier()} already exists, please check your configuration`), N(new Tz(`Transport ${e.getIdentifier()} already exists, please check your configuration`))) : (this._transports.set(e.getIdentifier(), e), te(void 0));
  }
  getTransport(e) {
    return pe.fromNullable(this._transports.get(e));
  }
  getAllTransports() {
    return Array.from(this._transports.values());
  }
  closeConnection(e) {
    this.getTransport(e.transport).map((t) => t.disconnect({ connectedDevice: e }));
  }
};
yE = uG([le(), Al(0, X(Ki.TransportsInput)), Al(1, X(Ki.DmkConfig)), Al(2, X(Er.LoggerPublisherServiceFactory)), Al(3, X(TU.DeviceModelDataSource)), Al(4, X(Vt.ApduSenderServiceFactory)), Al(5, X(Vt.ApduReceiverServiceFactory))], yE);
const lG = ({ stub: r = !1, transports: e = [], config: t } = {}) => new mt(({ bind: n }) => {
  n(Ki.TransportsInput).toConstantValue(e), n(Ki.TransportService).to(yE).inSingletonScope(), n(Ki.DmkConfig).toConstantValue(t);
}), dG = ({ stub: r = !1, transports: e = [], loggers: t = [], config: n = { mockUrl: tF, managerApiUrl: eF, webSocketUrl: fF, provider: z1, firmwareDistributionSalt: j1 } }) => {
  const i = new Uv();
  return i.loadSync(hH({ stub: r }), fH({ stub: r }), lG({ stub: r, transports: e, config: n }), w9({ stub: r, config: n }), oG({ stub: r, config: n }), LH({ stub: r }), FH({ subscribers: t }), bH({ stub: r }), cG({ stub: r }), Zj({ stub: r }), Xj({ stub: r })), i;
};
let hG = class {
  constructor({ stub: e, transports: t, loggers: n, config: i } = {}) {
    h(this, "container");
    this.container = dG({ stub: e, transports: t, loggers: n, config: i });
  }
  getVersion() {
    return this.container.get(ro.GetDmkVersionUseCase).getDmkVersion();
  }
  startDiscovering(e) {
    return this.container.get(Yt.StartDiscoveringUseCase).execute(e);
  }
  stopDiscovering() {
    return this.container.get(Yt.StopDiscoveringUseCase).execute();
  }
  listenToAvailableDevices(e) {
    return this.container.get(Yt.ListenToAvailableDevicesUseCase).execute(e);
  }
  connect(e) {
    return this.container.get(Yt.ConnectUseCase).execute(e);
  }
  disconnect(e) {
    return this.container.get(Yt.DisconnectUseCase).execute(e);
  }
  sendApdu(e) {
    return this.container.get(NS.SendApduUseCase).execute(e);
  }
  sendCommand(e) {
    return this.container.get(PS.SendCommandUseCase).execute(e);
  }
  executeDeviceAction(e) {
    return this.container.get(US.ExecuteDeviceActionUseCase).execute(e);
  }
  getConnectedDevice(e) {
    return this.container.get(Yt.GetConnectedDeviceUseCase).execute(e);
  }
  getDeviceSessionState(e) {
    return this.container.get(Vt.GetDeviceSessionStateUseCase).execute(e);
  }
  close() {
    return this.container.get(Vt.CloseSessionsUseCase).execute();
  }
  listConnectedDevices() {
    return this.container.get(Yt.ListConnectedDevicesUseCase).execute();
  }
  listenToConnectedDevice() {
    return this.container.get(Yt.ListenToConnectedDeviceUseCase).execute();
  }
  disableDeviceSessionRefresher(e) {
    return this.container.get(Vt.DisableDeviceSessionRefresherUseCase).execute(e);
  }
  setProvider(e) {
    return this.container.get(xi.SetProviderUseCase).execute(e);
  }
  getProvider() {
    return this.container.get(xi.ManagerApiDataSource).getProvider();
  }
  isEnvironmentSupported() {
    return this.container.get(Ki.TransportService).getAllTransports().some((e) => e.isSupported());
  }
}, fG = class {
  constructor() {
    h(this, "stub", !1);
    h(this, "loggers", []);
    h(this, "transports", []);
    h(this, "config", { managerApiUrl: eF, mockUrl: tF, webSocketUrl: fF, provider: z1, firmwareDistributionSalt: j1 });
  }
  build() {
    return new hG({ stub: this.stub, transports: this.transports, loggers: this.loggers, config: this.config });
  }
  setStub(e) {
    return this.stub = e, this;
  }
  addTransport(e) {
    return this.transports.push(e), this;
  }
  addLogger(e) {
    return this.loggers.push(e), this;
  }
  addConfig(e) {
    return this.config = { ...this.config, ...e }, this;
  }
}, pG = class {
  constructor(e = Wr.Debug) {
    h(this, "maxLevel");
    this.maxLevel = e;
  }
  log(e, t, n) {
    const i = `[${n.tag}]`;
    switch (e) {
      case Wr.Info: {
        this.maxLevel >= Wr.Info && this.logWithData(i, console.info, t, n);
        break;
      }
      case Wr.Warning: {
        this.maxLevel >= Wr.Warning && this.logWithData(i, console.warn, t, n);
        break;
      }
      case Wr.Debug: {
        this.maxLevel >= Wr.Debug && this.logWithData(i, console.debug, t, n);
        break;
      }
      case Wr.Error: {
        this.maxLevel >= Wr.Error && this.logWithData(i, console.error, t, n);
        break;
      }
      case Wr.Fatal: {
        this.maxLevel >= Wr.Fatal && this.logWithData(i, console.error, t, n);
        break;
      }
      default:
        this.logWithData(i, console.log, t, n);
    }
  }
  logWithData(e, t, n, i) {
    i.data ? t(e, n, i.data) : t(e, n);
  }
}, pF = class {
  constructor(e) {
    h(this, "deviceId");
    h(this, "deviceAdpuSender");
    h(this, "machineActor");
    h(this, "timeoutDuration");
    h(this, "timeout", null);
    this.deviceId = e.deviceId, this.deviceAdpuSender = e.deviceApduSender, this.timeoutDuration = e.timeoutDuration, this.machineActor = Gu(gG({ sendApduFn: (t, n, i) => this.sendApduToDeviceConnection(t, n, i), startReconnectionTimeout: () => this.startReconnectionTimeout(), cancelReconnectionTimeout: () => {
      this.timeout && (clearTimeout(this.timeout), this.timeout = null);
    }, tryToReconnect: () => {
      e.tryToReconnect(this.timeoutDuration);
    }, onTerminated: e.onTerminated, closeConnection: () => {
      this.deviceAdpuSender.closeConnection();
    } })), this.machineActor.start();
  }
  startReconnectionTimeout() {
    this.timeout = setTimeout(() => {
      this.machineActor.send({ type: "ReconnectionTimedOut" });
    }, this.timeoutDuration);
  }
  sendApduToDeviceConnection(e, t, n) {
    this.deviceAdpuSender.sendApdu(e, t, n).then((i) => {
      i.caseOf({ Left: (s) => {
        this.machineActor.send({ type: "ApduSendingError", error: s });
      }, Right: (s) => {
        this.machineActor.send({ type: "ApduResponseReceived", apduResponse: s });
      } });
    }).catch((i) => {
      this.machineActor.send({ type: "ApduSendingError", error: new JI(i) });
    });
  }
  getDependencies() {
    return this.deviceAdpuSender.getDependencies();
  }
  setDependencies(e) {
    this.deviceAdpuSender.setDependencies(e);
  }
  getDeviceId() {
    return this.deviceId;
  }
  sendApdu(e, t, n) {
    return new Promise((i) => {
      this.machineActor.send({ type: "SendApduCalled", apdu: e, triggersDisconnection: !!t, abortTimeout: n, responseCallback: i });
    });
  }
  async setupConnection() {
    await this.deviceAdpuSender.setupConnection();
  }
  eventDeviceConnected() {
    this.machineActor.send({ type: "DeviceConnected" });
  }
  eventDeviceDisconnected() {
    this.machineActor.send({ type: "DeviceDisconnected" });
  }
  closeConnection() {
    this.machineActor.send({ type: "CloseConnectionCalled" });
  }
};
function gG({ sendApduFn: r, startReconnectionTimeout: e, cancelReconnectionTimeout: t, tryToReconnect: n, onTerminated: i, closeConnection: s }) {
  return Or({ actions: { startTimer: () => {
    e();
  }, cancelTimer: () => {
    t();
  }, reconnectionTimeoutEvent: pL({ type: "ReconnectionTimedOut" }), sendApdu: ({ context: o }) => {
    o.apduInProgress.map(({ apdu: a, abortTimeout: c }) => {
      r(a, !1, c);
    });
  }, sendApduResponse: ({ context: o }, a) => {
    o.apduInProgress.map(({ responseCallback: c }) => c(a.response));
  }, sendGetAppAndVersion: () => {
    r(new Oh().getApdu().getRawApdu(), !1);
  }, tryToReconnect: () => {
    n();
  }, clearApduInProgress: Q({ apduInProgress: ve }), clearApduResponse: Q({ apduResponse: ve }), signalTermination: () => {
    i();
  }, closeConnection: () => {
    s();
  } }, guards: { isApduThatTriggersDisconnection: ({ context: o, event: a }) => a.type !== "ApduResponseReceived" ? !1 : o.apduInProgress.caseOf({ Just: ({ triggersDisconnection: c, apdu: u }) => (c || Jr.isApduThatTriggersDisconnection(u)) && Jr.isSuccessResponse(a.apduResponse), Nothing: () => !1 }), isSendApduBusyError: ({ event: o }) => o.type !== "ApduResponseReceived" ? !1 : o.apduResponse.statusCode[0] === 102 && o.apduResponse.statusCode[1] === 1 } }).createMachine({ id: "deviceConnection", initial: "Connected", context: { apduInProgress: ve, apduResponse: ve }, states: { Connected: { on: { DeviceDisconnected: { target: "WaitingForReconnection" }, SendApduCalled: { target: "SendingApdu", actions: Q({ apduInProgress: ({ event: o }) => pe.of({ apdu: o.apdu, triggersDisconnection: o.triggersDisconnection, abortTimeout: o.abortTimeout, responseCallback: o.responseCallback }) }) }, CloseConnectionCalled: { target: "Terminated" } } }, SendingApdu: { entry: "sendApdu", on: { ApduResponseReceived: [{ guard: "isApduThatTriggersDisconnection", target: "WaitingForDisconnection", actions: [Q({ apduResponse: ({ event: o }) => pe.of(o.apduResponse) })] }, { target: "Connected", actions: [{ type: "sendApduResponse", params: ({ event: o }) => ({ response: te(o.apduResponse) }) }, { type: "clearApduInProgress" }] }], ApduSendingError: { target: "Connected", actions: [{ type: "sendApduResponse", params: ({ event: o }) => ({ response: N(o.error) }) }, "clearApduInProgress"] }, DeviceDisconnected: { target: "WaitingForReconnection", actions: [{ type: "sendApduResponse", params: { response: N(new _s()) } }, "clearApduInProgress"] }, CloseConnectionCalled: { target: "Terminated", actions: [{ type: "sendApduResponse", params: { response: N(new _s()) } }, "clearApduInProgress"] }, SendApduCalled: { actions: ({ event: o }) => {
    o.responseCallback(N(new Pb()));
  } } } }, WaitingForDisconnection: { entry: ["sendGetAppAndVersion"], exit: [{ type: "sendApduResponse", params: ({ context: o }) => ({ response: o.apduResponse.caseOf({ Just: (a) => te(a), Nothing: () => N(new JI()) }) }) }, { type: "clearApduInProgress" }, { type: "clearApduResponse" }], on: { ApduResponseReceived: [{ guard: "isSendApduBusyError", actions: ["sendGetAppAndVersion"], target: "WaitingForDisconnection" }, { target: "Connected" }], ApduSendingError: [{ target: "WaitingForReconnection" }], SendApduCalled: { actions: ({ event: o }) => {
    o.responseCallback(N(new Pb()));
  } }, DeviceDisconnected: { target: "WaitingForReconnection" }, CloseConnectionCalled: { target: "Terminated" } } }, WaitingForReconnection: { entry: ["startTimer", "tryToReconnect"], on: { DeviceConnected: { target: "Connected", actions: "cancelTimer" }, SendApduCalled: { target: "WaitingForReconnectionWithQueuedSendApdu", actions: Q({ apduInProgress: ({ event: o }) => pe.of({ apdu: o.apdu, triggersDisconnection: o.triggersDisconnection, abortTimeout: o.abortTimeout, responseCallback: o.responseCallback }) }) }, ReconnectionTimedOut: { target: "Terminated" }, CloseConnectionCalled: { target: "Terminated" } } }, WaitingForReconnectionWithQueuedSendApdu: { on: { DeviceConnected: { target: "SendingApdu", actions: "cancelTimer" }, ReconnectionTimedOut: { target: "Terminated", actions: [{ type: "sendApduResponse", params: { response: N(new kz()) } }, { type: "clearApduInProgress" }] }, CloseConnectionCalled: { target: "Terminated", actions: [{ type: "sendApduResponse", params: { response: N(new _s()) } }, "clearApduInProgress"] }, SendApduCalled: { actions: ({ event: o }) => {
    o.responseCallback(N(new Pb()));
  } } } }, Terminated: { entry: ["signalTermination", "closeConnection"], type: "final" } } });
}
let vE = class {
  constructor({ id: e, deviceModel: t, type: n, transport: i, sendApdu: s }) {
    h(this, "id");
    h(this, "deviceModel");
    h(this, "sendApdu");
    h(this, "type");
    h(this, "transport");
    this.id = e, this.deviceModel = t, this.sendApdu = s, this.type = n, this.transport = i;
  }
};
function qg(r) {
  return bE[r] ?? 1;
}
function gF(r) {
  return Object.keys(bE).find(
    (e) => bE[e] === r
  );
}
const bE = {
  ethereum: 1,
  arbitrum: 42161,
  avalanche_c_chain: 43114,
  base: 8453,
  bsc: 56,
  linea: 59144,
  optimism: 10,
  polygon: 137,
  sonic: 146,
  zksync: 324
};
function hve(r) {
  const e = _r(r);
  if (!e)
    throw new Error("Invalid hex string");
  return new TextDecoder("utf-8").decode(e);
}
const Ot = {
  AccountService: Symbol.for("AccountService"),
  FetchAccountsUseCase: Symbol.for("FetchAccountsUseCase"),
  FetchAccountsWithBalanceUseCase: Symbol.for(
    "FetchAccountsWithBalanceUseCase"
  ),
  FetchCloudSyncAccountsUseCase: Symbol.for("FetchCloudSyncAccountsUseCase"),
  FetchSelectedAccountUseCase: Symbol.for("FetchSelectedAccountUseCase"),
  GetDetailedSelectedAccountUseCase: Symbol.for(
    "GetDetailedSelectedAccountUseCase"
  ),
  HydrateAccountWithTxHistoryUseCase: Symbol.for(
    "HydrateAccountWithTxHistoryUseCase"
  ),
  HydrateAccountWithFiatUseCase: Symbol.for("HydrateAccountWithFiatUseCase"),
  HydrateAccountWithBalanceUseCase: Symbol.for(
    "HydrateAccountWithBalanceUseCase"
  )
}, xc = {
  BackendService: Symbol.for("BackendService")
}, Dt = {
  Config: Symbol.for("Config")
}, zl = {
  ConsentService: Symbol.for("ConsentService")
}, ci = {
  ContextService: Symbol.for("ContextService")
}, mc = {
  DAppConfigService: Symbol("DAppConfigService")
}, gt = {
  DeviceManagementKitService: Symbol.for("DeviceManagementKitService"),
  DmkConfig: Symbol.for("DmkConfig"),
  ConnectDeviceUseCase: Symbol.for("ConnectDeviceUseCase"),
  DisconnectDeviceUseCase: Symbol.for("DisconnectDeviceUseCase"),
  SwitchDeviceUseCase: Symbol.for("SwitchDeviceUseCase"),
  SignRawTransactionUseCase: Symbol.for("SignRawTransactionUseCase"),
  SignTransactionUseCase: Symbol.for("SignTransactionUseCase"),
  SignTypedDataUseCase: Symbol.for("SignTypedDataUseCase"),
  SignPersonalMessageUseCase: Symbol.for("SignPersonalMessageUseCase"),
  BroadcastTransactionUseCase: Symbol.for("BroadcastTransactionUseCase"),
  ListAvailableDevicesUseCase: Symbol.for("ListAvailableDevicesUseCase")
};
function gr(r) {
  return (typeof r == "object" && r !== null || typeof r == "function") && typeof r.then == "function";
}
function Xr(r) {
  switch (typeof r) {
    case "string":
    case "symbol":
      return r.toString();
    case "function":
      return r.name;
    default:
      throw new Error(`Unexpected ${typeof r} service id type`);
  }
}
const Vw = Symbol.for("@inversifyjs/common/islazyServiceIdentifier");
var fB, dg, pB;
let Uy = (fB = Vw, pB = class {
  constructor(e) {
    h(this, fB);
    L(this, dg);
    D(this, dg, e), this[Vw] = !0;
  }
  static is(e) {
    return typeof e == "object" && e !== null && e[Vw] === !0;
  }
  unwrap() {
    return m(this, dg).call(this);
  }
}, dg = new WeakMap(), pB);
var R2 = {};
/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var P2;
function mG() {
  if (P2) return R2;
  P2 = 1;
  var r;
  return (function(e) {
    (function(t) {
      var n = typeof globalThis == "object" ? globalThis : typeof As == "object" ? As : typeof self == "object" ? self : typeof this == "object" ? this : o(), i = s(e);
      typeof n.Reflect < "u" && (i = s(n.Reflect, i)), t(i, n), typeof n.Reflect > "u" && (n.Reflect = e);
      function s(a, c) {
        return function(u, l) {
          Object.defineProperty(a, u, { configurable: !0, writable: !0, value: l }), c && c(u, l);
        };
      }
      function o() {
        throw new ReferenceError("globalThis could not be found. Please polyfill globalThis before loading this module.");
      }
    })(function(t, n) {
      var i = typeof Symbol == "function", s = i && typeof Symbol.toPrimitive < "u" ? Symbol.toPrimitive : Tt("Symbol.toPrimitive not found."), o = i && typeof Symbol.iterator < "u" ? Symbol.iterator : Tt("Symbol.iterator not found."), a = Object.getPrototypeOf(Function), c = typeof Map == "function" && typeof Map.prototype.entries == "function" ? Map : Tt("A valid Map constructor could not be found."), u = typeof Set == "function" && typeof Set.prototype.entries == "function" ? Set : Tt("A valid Set constructor could not be found."), l = typeof WeakMap == "function" ? WeakMap : Tt("A valid WeakMap constructor could not be found."), d = i ? Symbol.for("@reflect-metadata:registry") : void 0, f = rs(), p = di(f);
      function y(ee, ae, fe, we) {
        if (A(fe)) {
          if (!xe(ee))
            throw new TypeError();
          if (!Se(ae))
            throw new TypeError();
          return C(ee, ae);
        } else {
          if (!xe(ee))
            throw new TypeError();
          if (!j(ae))
            throw new TypeError();
          if (!j(we) && !A(we) && !K(we))
            throw new TypeError();
          return K(we) && (we = void 0), fe = de(fe), P(ee, ae, fe, we);
        }
      }
      t("decorate", y);
      function g(ee, ae) {
        function fe(we, Ve) {
          if (!j(we))
            throw new TypeError();
          if (!A(Ve) && !be(Ve))
            throw new TypeError();
          O(ee, ae, we, Ve);
        }
        return fe;
      }
      t("metadata", g);
      function v(ee, ae, fe, we) {
        if (!j(fe))
          throw new TypeError();
        return A(we) || (we = de(we)), O(ee, ae, fe, we);
      }
      t("defineMetadata", v);
      function _(ee, ae, fe) {
        if (!j(ae))
          throw new TypeError();
        return A(fe) || (fe = de(fe)), Z(ee, ae, fe);
      }
      t("hasMetadata", _);
      function w(ee, ae, fe) {
        if (!j(ae))
          throw new TypeError();
        return A(fe) || (fe = de(fe)), Y(ee, ae, fe);
      }
      t("hasOwnMetadata", w);
      function E(ee, ae, fe) {
        if (!j(ae))
          throw new TypeError();
        return A(fe) || (fe = de(fe)), q(ee, ae, fe);
      }
      t("getMetadata", E);
      function I(ee, ae, fe) {
        if (!j(ae))
          throw new TypeError();
        return A(fe) || (fe = de(fe)), J(ee, ae, fe);
      }
      t("getOwnMetadata", I);
      function S(ee, ae) {
        if (!j(ee))
          throw new TypeError();
        return A(ae) || (ae = de(ae)), x(ee, ae);
      }
      t("getMetadataKeys", S);
      function T(ee, ae) {
        if (!j(ee))
          throw new TypeError();
        return A(ae) || (ae = de(ae)), k(ee, ae);
      }
      t("getOwnMetadataKeys", T);
      function b(ee, ae, fe) {
        if (!j(ae))
          throw new TypeError();
        A(fe) || (fe = de(fe));
        var we = an(
          ae,
          fe,
          /*Create*/
          !1
        );
        return A(we) ? !1 : we.OrdinaryDeleteMetadata(ee, ae, fe);
      }
      t("deleteMetadata", b);
      function C(ee, ae) {
        for (var fe = ee.length - 1; fe >= 0; --fe) {
          var we = ee[fe], Ve = we(ae);
          if (!A(Ve) && !K(Ve)) {
            if (!Se(Ve))
              throw new TypeError();
            ae = Ve;
          }
        }
        return ae;
      }
      function P(ee, ae, fe, we) {
        for (var Ve = ee.length - 1; Ve >= 0; --Ve) {
          var jr = ee[Ve], tr = jr(ae, fe, we);
          if (!A(tr) && !K(tr)) {
            if (!j(tr))
              throw new TypeError();
            we = tr;
          }
        }
        return we;
      }
      function Z(ee, ae, fe) {
        var we = Y(ee, ae, fe);
        if (we)
          return !0;
        var Ve = at(ae);
        return K(Ve) ? !1 : Z(ee, Ve, fe);
      }
      function Y(ee, ae, fe) {
        var we = an(
          ae,
          fe,
          /*Create*/
          !1
        );
        return A(we) ? !1 : ce(we.OrdinaryHasOwnMetadata(ee, ae, fe));
      }
      function q(ee, ae, fe) {
        var we = Y(ee, ae, fe);
        if (we)
          return J(ee, ae, fe);
        var Ve = at(ae);
        if (!K(Ve))
          return q(ee, Ve, fe);
      }
      function J(ee, ae, fe) {
        var we = an(
          ae,
          fe,
          /*Create*/
          !1
        );
        if (!A(we))
          return we.OrdinaryGetOwnMetadata(ee, ae, fe);
      }
      function O(ee, ae, fe, we) {
        var Ve = an(
          fe,
          we,
          /*Create*/
          !0
        );
        Ve.OrdinaryDefineOwnMetadata(ee, ae, fe, we);
      }
      function x(ee, ae) {
        var fe = k(ee, ae), we = at(ee);
        if (we === null)
          return fe;
        var Ve = x(we, ae);
        if (Ve.length <= 0)
          return fe;
        if (fe.length <= 0)
          return Ve;
        for (var jr = new u(), tr = [], bn = 0, Rr = fe; bn < Rr.length; bn++) {
          var U = Rr[bn], G = jr.has(U);
          G || (jr.add(U), tr.push(U));
        }
        for (var W = 0, se = Ve; W < se.length; W++) {
          var U = se[W], G = jr.has(U);
          G || (jr.add(U), tr.push(U));
        }
        return tr;
      }
      function k(ee, ae) {
        var fe = an(
          ee,
          ae,
          /*create*/
          !1
        );
        return fe ? fe.OrdinaryOwnMetadataKeys(ee, ae) : [];
      }
      function B(ee) {
        if (ee === null)
          return 1;
        switch (typeof ee) {
          case "undefined":
            return 0;
          case "boolean":
            return 2;
          case "string":
            return 3;
          case "symbol":
            return 4;
          case "number":
            return 5;
          case "object":
            return ee === null ? 1 : 6;
          default:
            return 6;
        }
      }
      function A(ee) {
        return ee === void 0;
      }
      function K(ee) {
        return ee === null;
      }
      function F(ee) {
        return typeof ee == "symbol";
      }
      function j(ee) {
        return typeof ee == "object" ? ee !== null : typeof ee == "function";
      }
      function re(ee, ae) {
        switch (B(ee)) {
          case 0:
            return ee;
          case 1:
            return ee;
          case 2:
            return ee;
          case 3:
            return ee;
          case 4:
            return ee;
          case 5:
            return ee;
        }
        var fe = "string", we = Ie(ee, s);
        if (we !== void 0) {
          var Ve = we.call(ee, fe);
          if (j(Ve))
            throw new TypeError();
          return Ve;
        }
        return z(ee);
      }
      function z(ee, ae) {
        var fe, we;
        {
          var Ve = ee.toString;
          if (Ze(Ve)) {
            var we = Ve.call(ee);
            if (!j(we))
              return we;
          }
          var fe = ee.valueOf;
          if (Ze(fe)) {
            var we = fe.call(ee);
            if (!j(we))
              return we;
          }
        }
        throw new TypeError();
      }
      function ce(ee) {
        return !!ee;
      }
      function he(ee) {
        return "" + ee;
      }
      function de(ee) {
        var ae = re(ee);
        return F(ae) ? ae : he(ae);
      }
      function xe(ee) {
        return Array.isArray ? Array.isArray(ee) : ee instanceof Object ? ee instanceof Array : Object.prototype.toString.call(ee) === "[object Array]";
      }
      function Ze(ee) {
        return typeof ee == "function";
      }
      function Se(ee) {
        return typeof ee == "function";
      }
      function be(ee) {
        switch (B(ee)) {
          case 3:
            return !0;
          case 4:
            return !0;
          default:
            return !1;
        }
      }
      function Ie(ee, ae) {
        var fe = ee[ae];
        if (fe != null) {
          if (!Ze(fe))
            throw new TypeError();
          return fe;
        }
      }
      function Re(ee) {
        var ae = Ie(ee, o);
        if (!Ze(ae))
          throw new TypeError();
        var fe = ae.call(ee);
        if (!j(fe))
          throw new TypeError();
        return fe;
      }
      function Ue(ee) {
        return ee.value;
      }
      function Xe(ee) {
        var ae = ee.next();
        return ae.done ? !1 : ae;
      }
      function vt(ee) {
        var ae = ee.return;
        ae && ae.call(ee);
      }
      function at(ee) {
        var ae = Object.getPrototypeOf(ee);
        if (typeof ee != "function" || ee === a || ae !== a)
          return ae;
        var fe = ee.prototype, we = fe && Object.getPrototypeOf(fe);
        if (we == null || we === Object.prototype)
          return ae;
        var Ve = we.constructor;
        return typeof Ve != "function" || Ve === ee ? ae : Ve;
      }
      function Tt(ee) {
        throw ee;
      }
      function xr() {
        var ee;
        !A(d) && typeof n.Reflect < "u" && !(d in n.Reflect) && typeof n.Reflect.defineMetadata == "function" && (ee = on(n.Reflect));
        var ae, fe, we, Ve = new l(), jr = {
          registerProvider: tr,
          getProvider: Rr,
          setProvider: G
        };
        return jr;
        function tr(W) {
          if (!Object.isExtensible(jr))
            throw new Error("Cannot add provider to a frozen registry.");
          switch (!0) {
            case ee === W:
              break;
            case A(ae):
              ae = W;
              break;
            case ae === W:
              break;
            case A(fe):
              fe = W;
              break;
            case fe === W:
              break;
            default:
              we === void 0 && (we = new u()), we.add(W);
              break;
          }
        }
        function bn(W, se) {
          if (!A(ae)) {
            if (ae.isProviderFor(W, se))
              return ae;
            if (!A(fe)) {
              if (fe.isProviderFor(W, se))
                return ae;
              if (!A(we))
                for (var $ = Re(we); ; ) {
                  var V = Xe($);
                  if (!V)
                    return;
                  var Te = Ue(V);
                  if (Te.isProviderFor(W, se))
                    return vt($), Te;
                }
            }
          }
          if (!A(ee) && ee.isProviderFor(W, se))
            return ee;
        }
        function Rr(W, se) {
          var $ = Ve.get(W), V;
          return A($) || (V = $.get(se)), A(V) && (V = bn(W, se), A(V) || (A($) && ($ = new c(), Ve.set(W, $)), $.set(se, V))), V;
        }
        function U(W) {
          if (A(W))
            throw new TypeError();
          return ae === W || fe === W || !A(we) && we.has(W);
        }
        function G(W, se, $) {
          if (!U($))
            throw new Error("Metadata provider not registered.");
          var V = Rr(W, se);
          if (V !== $) {
            if (!A(V))
              return !1;
            var Te = Ve.get(W);
            A(Te) && (Te = new c(), Ve.set(W, Te)), Te.set(se, $);
          }
          return !0;
        }
      }
      function rs() {
        var ee;
        return !A(d) && j(n.Reflect) && Object.isExtensible(n.Reflect) && (ee = n.Reflect[d]), A(ee) && (ee = xr()), !A(d) && j(n.Reflect) && Object.isExtensible(n.Reflect) && Object.defineProperty(n.Reflect, d, {
          enumerable: !1,
          configurable: !1,
          writable: !1,
          value: ee
        }), ee;
      }
      function di(ee) {
        var ae = new l(), fe = {
          isProviderFor: function(U, G) {
            var W = ae.get(U);
            return A(W) ? !1 : W.has(G);
          },
          OrdinaryDefineOwnMetadata: tr,
          OrdinaryHasOwnMetadata: Ve,
          OrdinaryGetOwnMetadata: jr,
          OrdinaryOwnMetadataKeys: bn,
          OrdinaryDeleteMetadata: Rr
        };
        return f.registerProvider(fe), fe;
        function we(U, G, W) {
          var se = ae.get(U), $ = !1;
          if (A(se)) {
            if (!W)
              return;
            se = new c(), ae.set(U, se), $ = !0;
          }
          var V = se.get(G);
          if (A(V)) {
            if (!W)
              return;
            if (V = new c(), se.set(G, V), !ee.setProvider(U, G, fe))
              throw se.delete(G), $ && ae.delete(U), new Error("Wrong provider for target.");
          }
          return V;
        }
        function Ve(U, G, W) {
          var se = we(
            G,
            W,
            /*Create*/
            !1
          );
          return A(se) ? !1 : ce(se.has(U));
        }
        function jr(U, G, W) {
          var se = we(
            G,
            W,
            /*Create*/
            !1
          );
          if (!A(se))
            return se.get(U);
        }
        function tr(U, G, W, se) {
          var $ = we(
            W,
            se,
            /*Create*/
            !0
          );
          $.set(U, G);
        }
        function bn(U, G) {
          var W = [], se = we(
            U,
            G,
            /*Create*/
            !1
          );
          if (A(se))
            return W;
          for (var $ = se.keys(), V = Re($), Te = 0; ; ) {
            var Ce = Xe(V);
            if (!Ce)
              return W.length = Te, W;
            var ge = Ue(Ce);
            try {
              W[Te] = ge;
            } catch (ue) {
              try {
                vt(V);
              } finally {
                throw ue;
              }
            }
            Te++;
          }
        }
        function Rr(U, G, W) {
          var se = we(
            G,
            W,
            /*Create*/
            !1
          );
          if (A(se) || !se.delete(U))
            return !1;
          if (se.size === 0) {
            var $ = ae.get(G);
            A($) || ($.delete(W), $.size === 0 && ae.delete($));
          }
          return !0;
        }
      }
      function on(ee) {
        var ae = ee.defineMetadata, fe = ee.hasOwnMetadata, we = ee.getOwnMetadata, Ve = ee.getOwnMetadataKeys, jr = ee.deleteMetadata, tr = new l(), bn = {
          isProviderFor: function(Rr, U) {
            var G = tr.get(Rr);
            return !A(G) && G.has(U) ? !0 : Ve(Rr, U).length ? (A(G) && (G = new u(), tr.set(Rr, G)), G.add(U), !0) : !1;
          },
          OrdinaryDefineOwnMetadata: ae,
          OrdinaryHasOwnMetadata: fe,
          OrdinaryGetOwnMetadata: we,
          OrdinaryOwnMetadataKeys: Ve,
          OrdinaryDeleteMetadata: jr
        };
        return bn;
      }
      function an(ee, ae, fe) {
        var we = f.getProvider(ee, ae);
        if (!A(we))
          return we;
        if (fe) {
          if (f.setProvider(ee, ae, p))
            return p;
          throw new Error("Illegal state.");
        }
      }
    });
  })(r || (r = {})), R2;
}
mG();
function Ju(r, e, t) {
  return Reflect.getOwnMetadata(e, r, t);
}
function q1(r, e, t, n) {
  Reflect.defineMetadata(e, t, r, n);
}
function cc(r, e, t, n, i) {
  const s = n(Ju(r, e, i) ?? t());
  Reflect.defineMetadata(e, s, r, i);
}
const zw = "@inversifyjs/container/bindingId";
function Da() {
  const r = Ju(Object, zw) ?? 0;
  return r === Number.MAX_SAFE_INTEGER ? q1(Object, zw, Number.MIN_SAFE_INTEGER) : cc(Object, zw, () => r, (e) => e + 1), r;
}
const qi = { Request: "Request", Singleton: "Singleton", Transient: "Transient" }, yt = { ConstantValue: "ConstantValue", DynamicValue: "DynamicValue", Factory: "Factory", Instance: "Instance", Provider: "Provider", ResolvedValue: "ResolvedValue", ServiceRedirection: "ServiceRedirection" };
function* mF(...r) {
  for (const e of r) yield* e;
}
var Mi, wi, Ld, ir, yF, vF, bF, wF, wE, _F, SF, EF, xF, AF, Ud;
let W1 = (Ud = class {
  constructor(e) {
    L(this, ir);
    L(this, Mi);
    L(this, wi);
    L(this, Ld);
    D(this, Mi, /* @__PURE__ */ new Map()), D(this, wi, {});
    for (const t of Reflect.ownKeys(e)) m(this, wi)[t] = /* @__PURE__ */ new Map();
    D(this, Ld, e);
  }
  add(e, t) {
    R(this, ir, bF).call(this, e).push(t);
    for (const n of Reflect.ownKeys(t)) R(this, ir, wF).call(this, n, t[n]).push(e);
  }
  clone() {
    const e = R(this, ir, yF).call(this), t = R(this, ir, vF).call(this), n = Reflect.ownKeys(m(this, Ld)), i = this._buildNewInstance(m(this, Ld));
    R(this, ir, EF).call(this, m(this, Mi), m(i, Mi), e, t);
    for (const s of n) R(this, ir, SF).call(this, m(this, wi)[s], m(i, wi)[s], e);
    return i;
  }
  get(e, t) {
    return m(this, wi)[e].get(t);
  }
  getAllKeys(e) {
    return m(this, wi)[e].keys();
  }
  removeByRelation(e, t) {
    const n = this.get(e, t);
    if (n === void 0) return;
    const i = new Set(n);
    for (const s of i) {
      const o = m(this, Mi).get(s);
      if (o === void 0) throw new Error("Expecting model relation, none found");
      for (const a of o) a[e] === t && R(this, ir, xF).call(this, s, a);
      m(this, Mi).delete(s);
    }
  }
  _buildNewInstance(e) {
    return new Ud(e);
  }
  _cloneModel(e) {
    return e;
  }
  _cloneRelation(e) {
    return e;
  }
}, Mi = new WeakMap(), wi = new WeakMap(), Ld = new WeakMap(), ir = new WeakSet(), yF = function() {
  const e = /* @__PURE__ */ new Map();
  for (const t of m(this, Mi).keys()) {
    const n = this._cloneModel(t);
    e.set(t, n);
  }
  return e;
}, vF = function() {
  const e = /* @__PURE__ */ new Map();
  for (const t of m(this, Mi).values()) for (const n of t) {
    const i = this._cloneRelation(n);
    e.set(n, i);
  }
  return e;
}, bF = function(e) {
  let t = m(this, Mi).get(e);
  return t === void 0 && (t = [], m(this, Mi).set(e, t)), t;
}, wF = function(e, t) {
  let n = m(this, wi)[e].get(t);
  return n === void 0 && (n = [], m(this, wi)[e].set(t, n)), n;
}, wE = function(e, t) {
  const n = t.get(e);
  if (n === void 0) throw new Error("Expecting model to be cloned, none found");
  return n;
}, _F = function(e, t) {
  const n = t.get(e);
  if (n === void 0) throw new Error("Expecting relation to be cloned, none found");
  return n;
}, SF = function(e, t, n) {
  for (const [i, s] of e) {
    const o = new Array();
    for (const a of s) o.push(R(this, ir, wE).call(this, a, n));
    t.set(i, o);
  }
}, EF = function(e, t, n, i) {
  for (const [s, o] of e) {
    const a = new Array();
    for (const c of o) a.push(R(this, ir, _F).call(this, c, i));
    t.set(R(this, ir, wE).call(this, s, n), a);
  }
}, xF = function(e, t) {
  for (const n of Reflect.ownKeys(t)) R(this, ir, AF).call(this, e, n, t[n]);
}, AF = function(e, t, n) {
  const i = m(this, wi)[t].get(n);
  if (i !== void 0) {
    const s = i.indexOf(e);
    s !== -1 && i.splice(s, 1), i.length === 0 && m(this, wi)[t].delete(n);
  }
}, Ud);
var Dp;
(function(r) {
  r.moduleId = "moduleId", r.serviceId = "serviceId";
})(Dp || (Dp = {}));
var Wo, Fd, zu;
let N2 = (zu = class {
  constructor(e, t) {
    L(this, Wo);
    L(this, Fd);
    D(this, Wo, t ?? new W1({ moduleId: { isOptional: !0 }, serviceId: { isOptional: !1 } })), D(this, Fd, e);
  }
  static build(e) {
    return new zu(e);
  }
  add(e, t) {
    m(this, Wo).add(e, t);
  }
  clone() {
    return new zu(m(this, Fd), m(this, Wo).clone());
  }
  get(e) {
    var s;
    const t = [], n = m(this, Wo).get(Dp.serviceId, e);
    n !== void 0 && t.push(n);
    const i = (s = m(this, Fd).call(this)) == null ? void 0 : s.get(e);
    if (i !== void 0 && t.push(i), t.length !== 0) return mF(...t);
  }
  removeAllByModuleId(e) {
    m(this, Wo).removeByRelation(Dp.moduleId, e);
  }
  removeAllByServiceId(e) {
    m(this, Wo).removeByRelation(Dp.serviceId, e);
  }
}, Wo = new WeakMap(), Fd = new WeakMap(), zu);
const fd = "@inversifyjs/core/classMetadataReflectKey";
function pd() {
  return { constructorArguments: [], lifecycle: { postConstructMethodNames: /* @__PURE__ */ new Set(), preDestroyMethodNames: /* @__PURE__ */ new Set() }, properties: /* @__PURE__ */ new Map(), scope: void 0 };
}
const IF = "@inversifyjs/core/pendingClassMetadataCountReflectKey", jw = Symbol.for("@inversifyjs/core/InversifyCoreError");
var gB, mB;
let Ft = class CF extends (mB = Error, gB = jw, mB) {
  constructor(t, n, i) {
    super(n, i);
    h(this, gB);
    h(this, "kind");
    this[jw] = !0, this.kind = t;
  }
  static is(t) {
    return typeof t == "object" && t !== null && t[jw] === !0;
  }
  static isErrorOfKind(t, n) {
    return CF.is(t) && t.kind === n;
  }
};
var Ct, Fh, fi, Tp, ii;
function qv(r) {
  const e = Ju(r, fd) ?? pd();
  if (!(function(t) {
    const n = Ju(t, IF);
    return n !== void 0 && n !== 0;
  })(r)) return (function(t, n) {
    const i = [];
    if (n.length < t.length) throw new Ft(Ct.missingInjectionDecorator, `Found unexpected missing metadata on type "${t.name}". "${t.name}" constructor requires at least ${t.length.toString()} arguments, found ${n.length.toString()} instead.
Are you using @inject, @multiInject or @unmanaged decorators in every non optional constructor argument?

If you're using typescript and want to rely on auto injection, set "emitDecoratorMetadata" compiler option to true`);
    for (let s = 0; s < n.length; ++s) n[s] === void 0 && i.push(s);
    if (i.length > 0) throw new Ft(Ct.missingInjectionDecorator, `Found unexpected missing metadata on type "${t.name}" at constructor indexes "${i.join('", "')}".

Are you using @inject, @multiInject or @unmanaged decorators at those indexes?

If you're using typescript and want to rely on auto injection, set "emitDecoratorMetadata" compiler option to true`);
  })(r, e.constructorArguments), e;
  (function(t, n) {
    const i = [];
    for (let s = 0; s < n.constructorArguments.length; ++s) {
      const o = n.constructorArguments[s];
      o !== void 0 && o.kind !== Fh.unknown || i.push(`  - Missing or incomplete metadata for type "${t.name}" at constructor argument with index ${s.toString()}.
Every constructor parameter must be decorated either with @inject, @multiInject or @unmanaged decorator.`);
    }
    for (const [s, o] of n.properties) o.kind === Fh.unknown && i.push(`  - Missing or incomplete metadata for type "${t.name}" at property "${s.toString()}".
This property must be decorated either with @inject or @multiInject decorator.`);
    throw i.length === 0 ? new Ft(Ct.unknown, `Unexpected class metadata for type "${t.name}" with uncompletion traces.
This might be caused by one of the following reasons:

1. A third party library is targeting inversify reflection metadata.
2. A bug is causing the issue. Consider submiting an issue to fix it.`) : new Ft(Ct.missingInjectionDecorator, `Invalid class metadata at type ${t.name}:

${i.join(`

`)}`);
  })(r, e);
}
function DF(r, e) {
  const t = qv(e).scope ?? r.scope;
  return { cache: { isRight: !1, value: void 0 }, id: Da(), implementationType: e, isSatisfiedBy: () => !0, moduleId: void 0, onActivation: void 0, onDeactivation: void 0, scope: t, serviceIdentifier: e, type: yt.Instance };
}
function Rf(r) {
  return r.isRight ? { isRight: !0, value: r.value } : r;
}
function yG(r) {
  switch (r.type) {
    case yt.ConstantValue:
    case yt.DynamicValue:
      return (function(e) {
        return { cache: Rf(e.cache), id: e.id, isSatisfiedBy: e.isSatisfiedBy, moduleId: e.moduleId, onActivation: e.onActivation, onDeactivation: e.onDeactivation, scope: e.scope, serviceIdentifier: e.serviceIdentifier, type: e.type, value: e.value };
      })(r);
    case yt.Factory:
      return (function(e) {
        return { cache: Rf(e.cache), factory: e.factory, id: e.id, isSatisfiedBy: e.isSatisfiedBy, moduleId: e.moduleId, onActivation: e.onActivation, onDeactivation: e.onDeactivation, scope: e.scope, serviceIdentifier: e.serviceIdentifier, type: e.type };
      })(r);
    case yt.Instance:
      return (function(e) {
        return { cache: Rf(e.cache), id: e.id, implementationType: e.implementationType, isSatisfiedBy: e.isSatisfiedBy, moduleId: e.moduleId, onActivation: e.onActivation, onDeactivation: e.onDeactivation, scope: e.scope, serviceIdentifier: e.serviceIdentifier, type: e.type };
      })(r);
    case yt.Provider:
      return (function(e) {
        return { cache: Rf(e.cache), id: e.id, isSatisfiedBy: e.isSatisfiedBy, moduleId: e.moduleId, onActivation: e.onActivation, onDeactivation: e.onDeactivation, provider: e.provider, scope: e.scope, serviceIdentifier: e.serviceIdentifier, type: e.type };
      })(r);
    case yt.ResolvedValue:
      return (function(e) {
        return { cache: Rf(e.cache), factory: e.factory, id: e.id, isSatisfiedBy: e.isSatisfiedBy, metadata: e.metadata, moduleId: e.moduleId, onActivation: e.onActivation, onDeactivation: e.onDeactivation, scope: e.scope, serviceIdentifier: e.serviceIdentifier, type: e.type };
      })(r);
    case yt.ServiceRedirection:
      return (function(e) {
        return { id: e.id, isSatisfiedBy: e.isSatisfiedBy, moduleId: e.moduleId, serviceIdentifier: e.serviceIdentifier, targetServiceIdentifier: e.targetServiceIdentifier, type: e.type };
      })(r);
  }
}
(function(r) {
  r[r.injectionDecoratorConflict = 0] = "injectionDecoratorConflict", r[r.missingInjectionDecorator = 1] = "missingInjectionDecorator", r[r.planning = 2] = "planning", r[r.resolution = 3] = "resolution", r[r.unknown = 4] = "unknown";
})(Ct || (Ct = {})), (function(r) {
  r[r.unknown = 32] = "unknown";
})(Fh || (Fh = {})), (function(r) {
  r.id = "id", r.moduleId = "moduleId", r.serviceId = "serviceId";
})(fi || (fi = {}));
let vG = class TF extends W1 {
  _buildNewInstance(e) {
    return new TF(e);
  }
  _cloneModel(e) {
    return yG(e);
  }
};
var fu, Vn, Ws, hg, _E, ju;
let B2 = (ju = class {
  constructor(e, t, n) {
    L(this, hg);
    L(this, fu);
    L(this, Vn);
    L(this, Ws);
    D(this, Vn, n ?? new vG({ id: { isOptional: !1 }, moduleId: { isOptional: !0 }, serviceId: { isOptional: !1 } })), D(this, Ws, e), D(this, fu, t);
  }
  static build(e, t) {
    return new ju(e, t);
  }
  clone() {
    return new ju(m(this, Ws), m(this, fu), m(this, Vn).clone());
  }
  get(e) {
    var i;
    const t = this.getNonParentBindings(e) ?? ((i = m(this, Ws).call(this)) == null ? void 0 : i.get(e));
    if (t !== void 0) return t;
    const n = R(this, hg, _E).call(this, e);
    return n === void 0 ? n : [n];
  }
  *getChained(e) {
    const t = this.getNonParentBindings(e);
    t !== void 0 && (yield* t);
    const n = m(this, Ws).call(this);
    if (n === void 0) {
      if (t === void 0) {
        const i = R(this, hg, _E).call(this, e);
        i !== void 0 && (yield i);
      }
    } else yield* n.getChained(e);
  }
  getBoundServices() {
    const e = new Set(m(this, Vn).getAllKeys(fi.serviceId)), t = m(this, Ws).call(this);
    if (t !== void 0) for (const n of t.getBoundServices()) e.add(n);
    return e;
  }
  getById(e) {
    var t;
    return m(this, Vn).get(fi.id, e) ?? ((t = m(this, Ws).call(this)) == null ? void 0 : t.getById(e));
  }
  getByModuleId(e) {
    var t;
    return m(this, Vn).get(fi.moduleId, e) ?? ((t = m(this, Ws).call(this)) == null ? void 0 : t.getByModuleId(e));
  }
  getNonParentBindings(e) {
    return m(this, Vn).get(fi.serviceId, e);
  }
  getNonParentBoundServices() {
    return m(this, Vn).getAllKeys(fi.serviceId);
  }
  removeById(e) {
    m(this, Vn).removeByRelation(fi.id, e);
  }
  removeAllByModuleId(e) {
    m(this, Vn).removeByRelation(fi.moduleId, e);
  }
  removeAllByServiceId(e) {
    m(this, Vn).removeByRelation(fi.serviceId, e);
  }
  set(e) {
    const t = { [fi.id]: e.id, [fi.serviceId]: e.serviceIdentifier };
    e.moduleId !== void 0 && (t[fi.moduleId] = e.moduleId), m(this, Vn).add(e, t);
  }
}, fu = new WeakMap(), Vn = new WeakMap(), Ws = new WeakMap(), hg = new WeakSet(), _E = function(e) {
  if (m(this, fu) === void 0 || typeof e != "function") return;
  const t = DF(m(this, fu), e);
  return this.set(t), t;
}, ju);
(function(r) {
  r.moduleId = "moduleId", r.serviceId = "serviceId";
})(Tp || (Tp = {}));
var Zo, Md, Hu;
let L2 = (Hu = class {
  constructor(e, t) {
    L(this, Zo);
    L(this, Md);
    D(this, Zo, t ?? new W1({ moduleId: { isOptional: !0 }, serviceId: { isOptional: !1 } })), D(this, Md, e);
  }
  static build(e) {
    return new Hu(e);
  }
  add(e, t) {
    m(this, Zo).add(e, t);
  }
  clone() {
    return new Hu(m(this, Md), m(this, Zo).clone());
  }
  get(e) {
    var s;
    const t = [], n = m(this, Zo).get(Tp.serviceId, e);
    n !== void 0 && t.push(n);
    const i = (s = m(this, Md).call(this)) == null ? void 0 : s.get(e);
    if (i !== void 0 && t.push(i), t.length !== 0) return mF(...t);
  }
  removeAllByModuleId(e) {
    m(this, Zo).removeByRelation(Tp.moduleId, e);
  }
  removeAllByServiceId(e) {
    m(this, Zo).removeByRelation(Tp.serviceId, e);
  }
}, Zo = new WeakMap(), Md = new WeakMap(), Hu);
function bG() {
  return 0;
}
function kF(r) {
  return (e) => {
    e !== void 0 && e.kind === Fh.unknown && cc(r, IF, bG, (t) => t - 1);
  };
}
function wG(r, e) {
  return (...t) => (n) => {
    if (n === void 0) return r(...t);
    if (n.kind === ii.unmanaged) throw new Ft(Ct.injectionDecoratorConflict, "Unexpected injection found. Multiple @inject, @multiInject or @unmanaged decorators found");
    return e(n, ...t);
  };
}
function _G(r) {
  if (r.kind !== Fh.unknown && r.isFromTypescriptParamType !== !0) throw new Ft(Ct.injectionDecoratorConflict, "Unexpected injection found. Multiple @inject, @multiInject or @unmanaged decorators found");
}
(function(r) {
  r[r.multipleInjection = 0] = "multipleInjection", r[r.singleInjection = 1] = "singleInjection", r[r.unmanaged = 2] = "unmanaged";
})(ii || (ii = {}));
const OF = wG(function(r, e, t) {
  return r === ii.multipleInjection ? { chained: (t == null ? void 0 : t.chained) ?? !1, kind: r, name: void 0, optional: !1, tags: /* @__PURE__ */ new Map(), value: e } : { kind: r, name: void 0, optional: !1, tags: /* @__PURE__ */ new Map(), value: e };
}, function(r, e, t, n) {
  return _G(r), e === ii.multipleInjection ? { ...r, chained: (n == null ? void 0 : n.chained) ?? !1, kind: e, value: t } : { ...r, kind: e, value: t };
});
function U2(r, e) {
  return (t) => {
    const n = t.properties.get(e);
    return t.properties.set(e, r(n)), t;
  };
}
var Oa;
function $F(r, e, t, n) {
  if (Ft.isErrorOfKind(n, Ct.injectionDecoratorConflict)) {
    const i = (function(s, o, a) {
      if (a === void 0) {
        if (o === void 0) throw new Ft(Ct.unknown, "Unexpected undefined property and index values");
        return { kind: Oa.property, property: o, targetClass: s.constructor };
      }
      return typeof a == "number" ? { index: a, kind: Oa.parameter, targetClass: s } : { kind: Oa.method, method: o, targetClass: s };
    })(r, e, t);
    throw new Ft(Ct.injectionDecoratorConflict, `Unexpected injection error.

Cause:

${n.message}

Details

${(function(s) {
      switch (s.kind) {
        case Oa.method:
          return `[class: "${s.targetClass.name}", method: "${s.method.toString()}"]`;
        case Oa.parameter:
          return `[class: "${s.targetClass.name}", index: "${s.index.toString()}"]`;
        case Oa.property:
          return `[class: "${s.targetClass.name}", property: "${s.property.toString()}"]`;
      }
    })(i)}`, { cause: n });
  }
  throw n;
}
function RF(r, e) {
  return (t, n, i) => {
    try {
      i === void 0 ? (function(s, o) {
        const a = Hw(s, o);
        return (c, u) => {
          cc(c.constructor, fd, pd, U2(a(c), u));
        };
      })(r, e)(t, n) : typeof i == "number" ? (function(s, o) {
        const a = Hw(s, o);
        return (c, u, l) => {
          if (!/* @__PURE__ */ (function(d, f) {
            return typeof d == "function" && f === void 0;
          })(c, u)) throw new Ft(Ct.injectionDecoratorConflict, `Found an @inject decorator in a non constructor parameter.
Found @inject decorator at method "${(u == null ? void 0 : u.toString()) ?? ""}" at class "${c.constructor.name}"`);
          cc(c, fd, pd, /* @__PURE__ */ (function(d, f) {
            return (p) => {
              const y = p.constructorArguments[f];
              return p.constructorArguments[f] = d(y), p;
            };
          })(a(c), l));
        };
      })(r, e)(t, n, i) : (function(s, o) {
        const a = Hw(s, o);
        return (c, u, l) => {
          if (!(function(d) {
            return d.set !== void 0;
          })(l)) throw new Ft(Ct.injectionDecoratorConflict, `Found an @inject decorator in a non setter property method.
Found @inject decorator at method "${u.toString()}" at class "${c.constructor.name}"`);
          cc(c.constructor, fd, pd, U2(a(c), u));
        };
      })(r, e)(t, n, i);
    } catch (s) {
      $F(t, n, i, s);
    }
  };
}
function Hw(r, e) {
  return (t) => {
    const n = e(t);
    return (i) => (n(i), r(i));
  };
}
function H(r) {
  return RF(OF(ii.singleInjection, r), kF);
}
(function(r) {
  r[r.method = 0] = "method", r[r.parameter = 1] = "parameter", r[r.property = 2] = "property";
})(Oa || (Oa = {}));
const F2 = "@inversifyjs/core/classIsInjectableFlagReflectKey", SG = [Array, BigInt, Boolean, Function, Number, Object, String];
function EG(r) {
  const e = Ju(r, "design:paramtypes");
  e !== void 0 && cc(r, fd, pd, /* @__PURE__ */ (function(t) {
    return (n) => (t.forEach((i, s) => {
      var o;
      n.constructorArguments[s] !== void 0 || (o = i, SG.includes(o)) || (n.constructorArguments[s] = (function(a) {
        return { isFromTypescriptParamType: !0, kind: ii.singleInjection, name: void 0, optional: !1, tags: /* @__PURE__ */ new Map(), value: a };
      })(i));
    }), n);
  })(e));
}
function ke(r) {
  return (e) => {
    (function(t) {
      if (Ju(t, F2) !== void 0) throw new Ft(Ct.injectionDecoratorConflict, `Cannot apply @injectable decorator multiple times at class "${t.name}"`);
      q1(t, F2, !0);
    })(e), EG(e);
  };
}
function xG(r, e) {
  return RF(OF(ii.multipleInjection, r, e), kF);
}
function AG() {
  return (r, e, t) => {
    try {
      cc(r.constructor, fd, pd, (n = e, (i) => {
        if (i.lifecycle.preDestroyMethodNames.has(n)) throw new Ft(Ct.injectionDecoratorConflict, `Unexpected duplicated preDestroy method ${n.toString()}`);
        return i.lifecycle.preDestroyMethodNames.add(n), i;
      }));
    } catch (i) {
      $F(r, e, void 0, i);
    }
    var n;
  };
}
var oa;
(function(r) {
  r[r.multipleInjection = 0] = "multipleInjection", r[r.singleInjection = 1] = "singleInjection";
})(oa || (oa = {}));
const IG = /stack space|call stack|too much recursion/i, CG = /too much recursion/;
function Z1(r) {
  try {
    return r instanceof Error && (r instanceof RangeError && IG.test(r.message) || r.name === "InternalError" && CG.test(r.message));
  } catch (e) {
    return e instanceof SyntaxError && e.message.includes("Stack overflow");
  }
}
function DG(r, e) {
  if (Z1(e)) {
    const t = (function(n) {
      const i = [...n];
      return i.length === 0 ? "(No dependency trace)" : i.map(Xr).join(" -> ");
    })((function(n) {
      const i = /* @__PURE__ */ new Set();
      for (const s of n.servicesBranch) {
        if (i.has(s)) return [...i, s];
        i.add(s);
      }
      return [...i];
    })(r));
    throw new Ft(Ct.planning, `Circular dependency found: ${t}`, { cause: e });
  }
  throw e;
}
const Gw = Symbol.for("@inversifyjs/core/LazyPlanServiceNode");
var yB;
yB = Gw;
class Ai {
  constructor(e, t) {
    h(this, yB);
    h(this, "_serviceIdentifier");
    h(this, "_serviceNode");
    this[Gw] = !0, this._serviceNode = e, this._serviceIdentifier = t;
  }
  get bindings() {
    return this._getNode().bindings;
  }
  get isContextFree() {
    return this._getNode().isContextFree;
  }
  get serviceIdentifier() {
    return this._serviceIdentifier;
  }
  set bindings(e) {
    this._getNode().bindings = e;
  }
  set isContextFree(e) {
    this._getNode().isContextFree = e;
  }
  static is(e) {
    return typeof e == "object" && e !== null && e[Gw] === !0;
  }
  invalidate() {
    this._serviceNode = void 0;
  }
  isExpanded() {
    return this._serviceNode !== void 0;
  }
  _getNode() {
    return this._serviceNode === void 0 && (this._serviceNode = this._buildPlanServiceNode()), this._serviceNode;
  }
}
var Zs;
const oD = class oD {
  constructor(e) {
    L(this, Zs);
    D(this, Zs, e);
  }
  get name() {
    return m(this, Zs).elem.name;
  }
  get serviceIdentifier() {
    return m(this, Zs).elem.serviceIdentifier;
  }
  get tags() {
    return m(this, Zs).elem.tags;
  }
  getAncestor() {
    if (m(this, Zs).elem.getAncestorsCalled = !0, m(this, Zs).previous !== void 0) return new oD(m(this, Zs).previous);
  }
};
Zs = new WeakMap();
let yc = oD;
function Wv(r, e, t) {
  const n = (t == null ? void 0 : t.customServiceIdentifier) ?? e.serviceIdentifier, i = ((t == null ? void 0 : t.chained) === !0 ? [...r.operations.getBindingsChained(n)] : [...r.operations.getBindings(n) ?? []]).filter((s) => s.isSatisfiedBy(e));
  if (i.length === 0 && r.autobindOptions !== void 0 && typeof n == "function") {
    const s = DF(r.autobindOptions, n);
    r.operations.setBinding(s), s.isSatisfiedBy(e) && i.push(s);
  }
  return i;
}
class J1 {
  constructor(e) {
    h(this, "last");
    this.last = e;
  }
  concat(e) {
    return new J1({ elem: e, previous: this.last });
  }
  [Symbol.iterator]() {
    let e = this.last;
    return { next: () => {
      if (e === void 0) return { done: !0, value: void 0 };
      const t = e.elem;
      return e = e.previous, { done: !1, value: t };
    } };
  }
}
function SE(r) {
  const e = /* @__PURE__ */ new Map();
  return r.rootConstraints.tag !== void 0 && e.set(r.rootConstraints.tag.key, r.rootConstraints.tag.value), new J1({ elem: { getAncestorsCalled: !1, name: r.rootConstraints.name, serviceIdentifier: r.rootConstraints.serviceIdentifier, tags: e }, previous: void 0 });
}
function Xu(r) {
  return r.redirections !== void 0;
}
function PF(r, e, t, n) {
  var o;
  const i = t.elem.serviceIdentifier, s = (o = t.previous) == null ? void 0 : o.elem.serviceIdentifier;
  Array.isArray(r) ? (function(a, c, u, l, d, f) {
    if (a.length !== 0) {
      const p = f[f.length - 1] ?? u, y = `Ambiguous bindings found for service: "${Xr(p)}".${LF(f)}

Registered bindings:

${a.map((g) => (function(v) {
        switch (v.type) {
          case yt.Instance:
            return `[ type: "${v.type}", serviceIdentifier: "${Xr(v.serviceIdentifier)}", scope: "${v.scope}", implementationType: "${v.implementationType.name}" ]`;
          case yt.ServiceRedirection:
            return `[ type: "${v.type}", serviceIdentifier: "${Xr(v.serviceIdentifier)}", redirection: "${Xr(v.targetServiceIdentifier)}" ]`;
          default:
            return `[ type: "${v.type}", serviceIdentifier: "${Xr(v.serviceIdentifier)}", scope: "${v.scope}" ]`;
        }
      })(g.binding)).join(`
`)}

Trying to resolve bindings for "${NF(u, l)}".${BF(d)}`;
      throw new Ft(Ct.planning, y);
    }
    c || M2(u, l, d, f);
  })(r, e, i, s, t.elem, n) : (function(a, c, u, l, d, f) {
    a !== void 0 || c || M2(u, l, d, f);
  })(r, e, i, s, t.elem, n);
}
function M2(r, e, t, n) {
  const i = n[n.length - 1] ?? r, s = `No bindings found for service: "${Xr(i)}".

Trying to resolve bindings for "${NF(r, e)}".${LF(n)}${BF(t)}`;
  throw new Ft(Ct.planning, s);
}
function NF(r, e) {
  return e === void 0 ? `${Xr(r)} (Root service)` : Xr(e);
}
function BF(r) {
  var t;
  const e = r.tags.size === 0 ? "" : `
- tags:
  - ${[...r.tags.keys()].map((n) => n.toString()).join(`
  - `)}`;
  return `

Binding constraints:
- service identifier: ${Xr(r.serviceIdentifier)}
- name: ${((t = r.name) == null ? void 0 : t.toString()) ?? "-"}${e}`;
}
function LF(r) {
  return r.length === 0 ? "" : `

- service redirections:
  - ${r.map((e) => Xr(e)).join(`
  - `)}`;
}
function UF(r, e, t, n) {
  if (r.redirections.length === 1) {
    const [i] = r.redirections;
    return void (Xu(i) && UF(i, e, t, [...n, i.binding.targetServiceIdentifier]));
  }
  PF(r.redirections, e, t, n);
}
function X1(r, e, t) {
  if (Array.isArray(r.bindings) && r.bindings.length === 1) {
    const [n] = r.bindings;
    return void (Xu(n) && UF(n, e, t, [n.binding.targetServiceIdentifier]));
  }
  PF(r.bindings, e, t, []);
}
function Zv(r) {
  return Uy.is(r) ? r.unwrap() : r;
}
function FF(r) {
  return (e, t, n) => {
    const i = Zv(n.value), s = t.concat({ getAncestorsCalled: !1, name: n.name, serviceIdentifier: i, tags: n.tags }), o = new yc(s.last), a = n.kind === ii.multipleInjection && n.chained, c = Wv(e, o, { chained: a }), u = [], l = { bindings: u, isContextFree: !0, serviceIdentifier: i };
    if (u.push(...r(e, s, c, l, a)), l.isContextFree = !s.last.elem.getAncestorsCalled, n.kind === ii.singleInjection) {
      X1(l, n.optional, s.last);
      const [d] = u;
      l.bindings = d;
    }
    return l;
  };
}
function MF(r) {
  return (e, t, n) => {
    const i = Zv(n.value), s = t.concat({ getAncestorsCalled: !1, name: n.name, serviceIdentifier: i, tags: n.tags }), o = new yc(s.last), a = n.kind === oa.multipleInjection && n.chained, c = Wv(e, o, { chained: a }), u = [], l = { bindings: u, isContextFree: !0, serviceIdentifier: i };
    if (u.push(...r(e, s, c, l, a)), l.isContextFree = !s.last.elem.getAncestorsCalled, n.kind === oa.singleInjection) {
      X1(l, n.optional, s.last);
      const [d] = u;
      l.bindings = d;
    }
    return l;
  };
}
function VF(r) {
  const e = /* @__PURE__ */ (function(s) {
    return (o, a, c) => {
      const u = { binding: a, classMetadata: o.operations.getClassMetadata(a.implementationType), constructorParams: [], propertyParams: /* @__PURE__ */ new Map() }, l = { autobindOptions: o.autobindOptions, node: u, operations: o.operations, servicesBranch: o.servicesBranch };
      return s(l, c);
    };
  })(r), t = /* @__PURE__ */ (function(s) {
    return (o, a, c) => {
      const u = { binding: a, params: [] }, l = { autobindOptions: o.autobindOptions, node: u, operations: o.operations, servicesBranch: o.servicesBranch };
      return s(l, c);
    };
  })(r), n = (s, o, a, c, u) => {
    const l = Xu(c) ? c.binding.targetServiceIdentifier : c.serviceIdentifier;
    s.servicesBranch.push(l);
    const d = [];
    for (const f of a) switch (f.type) {
      case yt.Instance:
        d.push(e(s, f, o));
        break;
      case yt.ResolvedValue:
        d.push(t(s, f, o));
        break;
      case yt.ServiceRedirection: {
        const p = i(s, o, f, u);
        d.push(p);
        break;
      }
      default:
        d.push({ binding: f });
    }
    return s.servicesBranch.pop(), d;
  }, i = /* @__PURE__ */ (function(s) {
    return (o, a, c, u) => {
      const l = { binding: c, redirections: [] }, d = Wv(o, new yc(a.last), { chained: u, customServiceIdentifier: c.targetServiceIdentifier });
      return l.redirections.push(...s(o, a, d, l, u)), l;
    };
  })(n);
  return n;
}
function V2(r, e, t, n) {
  if (r !== void 0 && (Ai.is(t) && !t.isExpanded() || t.isContextFree)) {
    const i = { tree: { root: t } };
    e.setPlan(r, i);
  } else e.setNonCachedServiceNode(t, n);
}
var fg, pg, gg, mg;
class TG extends Ai {
  constructor(t, n, i, s, o) {
    super(o, Zv(s.value));
    L(this, fg);
    L(this, pg);
    L(this, gg);
    L(this, mg);
    D(this, pg, n), D(this, fg, t), D(this, gg, i), D(this, mg, s);
  }
  _buildPlanServiceNode() {
    return m(this, pg).call(this, m(this, fg), m(this, gg), m(this, mg));
  }
}
fg = new WeakMap(), pg = new WeakMap(), gg = new WeakMap(), mg = new WeakMap();
var yg, vg, bg, wg;
class kG extends Ai {
  constructor(t, n, i, s, o) {
    super(o, Zv(s.value));
    L(this, yg);
    L(this, vg);
    L(this, bg);
    L(this, wg);
    D(this, yg, t), D(this, vg, n), D(this, bg, i), D(this, wg, s);
  }
  _buildPlanServiceNode() {
    return m(this, vg).call(this, m(this, yg), m(this, bg), m(this, wg));
  }
}
yg = new WeakMap(), vg = new WeakMap(), bg = new WeakMap(), wg = new WeakMap();
function zF(r, e, t, n) {
  const i = /* @__PURE__ */ (function(o, a) {
    const c = /* @__PURE__ */ (function(u, l) {
      return (d, f, p) => {
        if (p.kind === ii.unmanaged) return;
        const y = (function(_) {
          let w;
          if (_.tags.size === 0) w = void 0;
          else {
            if (_.tags.size !== 1) return;
            {
              const [I, S] = _.tags.entries().next().value;
              w = { key: I, value: S };
            }
          }
          const E = Uy.is(_.value) ? _.value.unwrap() : _.value;
          return _.kind === ii.multipleInjection ? { chained: _.chained, isMultiple: !0, name: _.name, optional: _.optional, serviceIdentifier: E, tag: w } : { isMultiple: !1, name: _.name, optional: _.optional, serviceIdentifier: E, tag: w };
        })(p);
        if (y !== void 0) {
          const _ = d.operations.getPlan(y);
          if (_ !== void 0 && _.tree.root.isContextFree) return _.tree.root;
        }
        const g = l(d, f, p), v = new TG(d, u, f, p, g);
        return V2(y, d.operations, v, { bindingConstraintsList: f, chainedBindings: p.kind === ii.multipleInjection && p.chained, optionalBindings: p.optional }), v;
      };
    })(o, a);
    return (u, l, d) => {
      const f = l.classMetadata;
      for (const [p, y] of f.constructorArguments.entries()) l.constructorParams[p] = c(u, d, y);
      for (const [p, y] of f.properties) {
        const g = c(u, d, y);
        g !== void 0 && l.propertyParams.set(p, g);
      }
      return u.node;
    };
  })(r, t), s = /* @__PURE__ */ (function(o, a) {
    const c = /* @__PURE__ */ (function(u, l) {
      return (d, f, p) => {
        const y = (function(_) {
          let w;
          if (_.tags.size === 0) w = void 0;
          else {
            if (_.tags.size !== 1) return;
            {
              const [I, S] = _.tags.entries().next().value;
              w = { key: I, value: S };
            }
          }
          const E = Uy.is(_.value) ? _.value.unwrap() : _.value;
          return _.kind === oa.multipleInjection ? { chained: _.chained, isMultiple: !0, name: _.name, optional: _.optional, serviceIdentifier: E, tag: w } : { isMultiple: !1, name: _.name, optional: _.optional, serviceIdentifier: E, tag: w };
        })(p);
        if (y !== void 0) {
          const _ = d.operations.getPlan(y);
          if (_ !== void 0 && _.tree.root.isContextFree) return _.tree.root;
        }
        const g = l(d, f, p), v = new kG(d, u, f, p, g);
        return V2(y, d.operations, v, { bindingConstraintsList: f, chainedBindings: p.kind === oa.multipleInjection && p.chained, optionalBindings: p.optional }), v;
      };
    })(o, a);
    return (u, l, d) => {
      const f = l.binding.metadata;
      for (const [p, y] of f.arguments.entries()) l.params[p] = c(u, d, y);
      return u.node;
    };
  })(e, n);
  return (o, a) => o.node.binding.type === yt.Instance ? i(o, o.node, a) : s(o, o.node, a);
}
var _g;
class OG extends Ai {
  constructor(t, n) {
    super(n, n.serviceIdentifier);
    L(this, _g);
    D(this, _g, t);
  }
  _buildPlanServiceNode() {
    return GF(m(this, _g));
  }
}
_g = new WeakMap();
const EE = FF(HF), xE = MF(HF), jF = VF(zF(EE, xE, EE, xE));
function HF(r, e, t, n, i) {
  return jF(r, e, t, n, i);
}
const GF = /* @__PURE__ */ (function(r) {
  return (e) => {
    const t = SE(e), n = new yc(t.last), i = e.rootConstraints.isMultiple && e.rootConstraints.chained, s = Wv(e, n, { chained: i }), o = [], a = { bindings: o, isContextFree: !0, serviceIdentifier: e.rootConstraints.serviceIdentifier };
    if (o.push(...r(e, t, s, a, i)), a.isContextFree = !t.last.elem.getAncestorsCalled, !e.rootConstraints.isMultiple) {
      X1(a, e.rootConstraints.isOptional ?? !1, t.last);
      const [c] = o;
      a.bindings = c;
    }
    return a;
  };
})(jF);
function $G(r) {
  try {
    const e = (function(s) {
      return s.rootConstraints.isMultiple ? { chained: s.rootConstraints.chained, isMultiple: !0, name: s.rootConstraints.name, optional: s.rootConstraints.isOptional ?? !1, serviceIdentifier: s.rootConstraints.serviceIdentifier, tag: s.rootConstraints.tag } : { isMultiple: !1, name: s.rootConstraints.name, optional: s.rootConstraints.isOptional ?? !1, serviceIdentifier: s.rootConstraints.serviceIdentifier, tag: s.rootConstraints.tag };
    })(r), t = r.operations.getPlan(e);
    if (t !== void 0) return t;
    const n = GF(r), i = { tree: { root: new OG(r, n) } };
    return r.operations.setPlan(e, i), i;
  } catch (e) {
    DG(r, e);
  }
}
var xs;
(function(r) {
  r.bindingAdded = "bindingAdded", r.bindingRemoved = "bindingRemoved";
})(xs || (xs = {}));
var zn, Vd, Sg, Ec, AE, IE;
class RG {
  constructor() {
    L(this, Ec);
    L(this, zn);
    L(this, Vd);
    L(this, Sg);
    D(this, zn, []), D(this, Vd, 8), D(this, Sg, 1024);
  }
  *[Symbol.iterator]() {
    let e = 0;
    for (const t of m(this, zn)) {
      const n = t.deref();
      n === void 0 ? ++e : yield n;
    }
    m(this, zn).length >= m(this, Vd) && R(this, Ec, IE).call(this, e) && R(this, Ec, AE).call(this, e);
  }
  push(e) {
    const t = new WeakRef(e);
    if (m(this, zn).push(t), m(this, zn).length >= m(this, Vd) && m(this, zn).length % m(this, Sg) === 0) {
      let n = 0;
      for (const i of m(this, zn)) i.deref() === void 0 && ++n;
      R(this, Ec, IE).call(this, n) && R(this, Ec, AE).call(this, n);
    }
  }
}
zn = new WeakMap(), Vd = new WeakMap(), Sg = new WeakMap(), Ec = new WeakSet(), AE = function(e) {
  const t = new Array(m(this, zn).length - e);
  let n = 0;
  for (const i of m(this, zn)) i.deref() && (t[n++] = i);
  D(this, zn, t);
}, IE = function(e) {
  return e >= 0.5 * m(this, zn).length;
};
const Y1 = VF(zF(EE, xE, function(r, e, t) {
  return PG(r, e, t);
}, function(r, e, t) {
  return NG(r, e, t);
})), PG = (function(r) {
  const e = FF(r);
  return (t, n, i) => {
    try {
      return e(t, n, i);
    } catch (s) {
      if (Ft.isErrorOfKind(s, Ct.planning)) return;
      throw s;
    }
  };
})(Y1), NG = (function(r) {
  const e = MF(r);
  return (t, n, i) => {
    try {
      return e(t, n, i);
    } catch (s) {
      if (Ft.isErrorOfKind(s, Ct.planning)) return;
      throw s;
    }
  };
})(Y1);
function z2(r, e, t, n, i) {
  if (Ai.is(e) && !e.isExpanded()) return { isContextFreeBinding: !0, shouldInvalidateServiceNode: !1 };
  const s = new yc(n.last);
  return !t.isSatisfiedBy(s) || n.last.elem.getAncestorsCalled ? { isContextFreeBinding: !n.last.elem.getAncestorsCalled, shouldInvalidateServiceNode: !1 } : (function(o, a, c, u, l) {
    let d;
    try {
      [d] = Y1(o, u, [c], a, l);
    } catch (f) {
      if (Z1(f)) return { isContextFreeBinding: !1, shouldInvalidateServiceNode: !0 };
      throw f;
    }
    return (function(f, p) {
      if (Array.isArray(f.bindings)) f.bindings.push(p);
      else {
        if (f.bindings !== void 0) {
          if (!Ai.is(f)) throw new Ft(Ct.planning, "Unexpected non-lazy plan service node. This is likely a bug in the planning logic. Please, report this issue");
          return { isContextFreeBinding: !0, shouldInvalidateServiceNode: !0 };
        }
        f.bindings = p;
      }
      return { isContextFreeBinding: !0, shouldInvalidateServiceNode: !1 };
    })(a, d);
  })(r, e, t, n, i);
}
function j2(r, e, t, n) {
  var o;
  if (Ai.is(r) && !r.isExpanded()) return { bindingNodeRemoved: void 0, isContextFreeBinding: !0 };
  const i = new yc(t.last);
  if (!e.isSatisfiedBy(i) || t.last.elem.getAncestorsCalled) return { bindingNodeRemoved: void 0, isContextFreeBinding: !t.last.elem.getAncestorsCalled };
  let s;
  if (Array.isArray(r.bindings)) r.bindings = r.bindings.filter((a) => a.binding !== e || (s = a, !1));
  else if (((o = r.bindings) == null ? void 0 : o.binding) === e) if (s = r.bindings, n) r.bindings = void 0;
  else {
    if (!Ai.is(r)) throw new Ft(Ct.planning, "Unexpected non-lazy plan service node. This is likely a bug in the planning logic. Please, report this issue");
    r.invalidate();
  }
  return { bindingNodeRemoved: s, isContextFreeBinding: !0 };
}
var Jo, Va, za, ja, Ha, pu, Be, ip, KF, Fc, No, qF, WF, ZF, JF, jl, ly, dy, XF, YF, QF, sp;
class H2 {
  constructor() {
    L(this, Be);
    L(this, Jo);
    L(this, Va);
    L(this, za);
    L(this, ja);
    L(this, Ha);
    L(this, pu);
    D(this, Jo, /* @__PURE__ */ new Map()), D(this, Va, R(this, Be, ip).call(this)), D(this, za, R(this, Be, ip).call(this)), D(this, ja, R(this, Be, ip).call(this)), D(this, Ha, R(this, Be, ip).call(this)), D(this, pu, new RG());
  }
  clearCache() {
    for (const e of R(this, Be, qF).call(this)) e.clear();
    for (const e of m(this, pu)) e.clearCache();
  }
  get(e) {
    var t, n, i, s, o, a;
    return e.name === void 0 ? e.tag === void 0 ? R(this, Be, No).call(this, m(this, Va), e).get(e.serviceIdentifier) : (n = (t = R(this, Be, No).call(this, m(this, Ha), e).get(e.serviceIdentifier)) == null ? void 0 : t.get(e.tag.key)) == null ? void 0 : n.get(e.tag.value) : e.tag === void 0 ? (i = R(this, Be, No).call(this, m(this, za), e).get(e.serviceIdentifier)) == null ? void 0 : i.get(e.name) : (a = (o = (s = R(this, Be, No).call(this, m(this, ja), e).get(e.serviceIdentifier)) == null ? void 0 : s.get(e.name)) == null ? void 0 : o.get(e.tag.key)) == null ? void 0 : a.get(e.tag.value);
  }
  invalidateServiceBinding(e) {
    R(this, Be, YF).call(this, e), R(this, Be, ZF).call(this, e), R(this, Be, JF).call(this, e), R(this, Be, QF).call(this, e), R(this, Be, XF).call(this, e);
    for (const t of m(this, pu)) t.invalidateServiceBinding(e);
  }
  set(e, t) {
    e.name === void 0 ? e.tag === void 0 ? R(this, Be, No).call(this, m(this, Va), e).set(e.serviceIdentifier, t) : R(this, Be, Fc).call(this, R(this, Be, Fc).call(this, R(this, Be, No).call(this, m(this, Ha), e), e.serviceIdentifier), e.tag.key).set(e.tag.value, t) : e.tag === void 0 ? R(this, Be, Fc).call(this, R(this, Be, No).call(this, m(this, za), e), e.serviceIdentifier).set(e.name, t) : R(this, Be, Fc).call(this, R(this, Be, Fc).call(this, R(this, Be, Fc).call(this, R(this, Be, No).call(this, m(this, ja), e), e.serviceIdentifier), e.name), e.tag.key).set(e.tag.value, t);
  }
  setNonCachedServiceNode(e, t) {
    let n = m(this, Jo).get(e.serviceIdentifier);
    n === void 0 && (n = /* @__PURE__ */ new Map(), m(this, Jo).set(e.serviceIdentifier, n)), n.set(e, t);
  }
  subscribe(e) {
    m(this, pu).push(e);
  }
}
Jo = new WeakMap(), Va = new WeakMap(), za = new WeakMap(), ja = new WeakMap(), Ha = new WeakMap(), pu = new WeakMap(), Be = new WeakSet(), ip = function() {
  const e = new Array(8);
  for (let t = 0; t < e.length; ++t) e[t] = /* @__PURE__ */ new Map();
  return e;
}, KF = function(e, t, n, i) {
  const s = !!(2 & t);
  let o;
  return s ? o = { chained: !!(0 & t), isMultiple: s, serviceIdentifier: e.binding.serviceIdentifier } : o = { isMultiple: s, serviceIdentifier: e.binding.serviceIdentifier }, 1 & t && (o.isOptional = !0), n !== void 0 && (o.name = n), i !== void 0 && (o.tag = i), { autobindOptions: void 0, operations: e.operations, rootConstraints: o, servicesBranch: [] };
}, Fc = function(e, t) {
  let n = e.get(t);
  return n === void 0 && (n = /* @__PURE__ */ new Map(), e.set(t, n)), n;
}, No = function(e, t) {
  return e[R(this, Be, WF).call(this, t)];
}, qF = function() {
  return [m(this, Jo), ...m(this, Va), ...m(this, za), ...m(this, ja), ...m(this, Ha)];
}, WF = function(e) {
  return e.isMultiple ? (e.chained ? 4 : 0) | (e.optional ? 1 : 0) | 2 : e.optional ? 1 : 0;
}, ZF = function(e) {
  for (const [t, n] of m(this, za).entries()) {
    const i = n.get(e.binding.serviceIdentifier);
    if (i !== void 0) for (const [s, o] of i.entries()) R(this, Be, sp).call(this, e, o, t, s, void 0);
  }
}, JF = function(e) {
  for (const [t, n] of m(this, ja).entries()) {
    const i = n.get(e.binding.serviceIdentifier);
    if (i !== void 0) for (const [s, o] of i.entries()) for (const [a, c] of o.entries()) for (const [u, l] of c.entries()) R(this, Be, sp).call(this, e, l, t, s, { key: a, value: u });
  }
}, jl = function(e) {
  switch (e.binding.type) {
    case yt.ServiceRedirection:
      for (const t of e.redirections) R(this, Be, jl).call(this, t);
      break;
    case yt.Instance:
      for (const t of e.constructorParams) t !== void 0 && R(this, Be, ly).call(this, t);
      for (const t of e.propertyParams.values()) R(this, Be, ly).call(this, t);
      break;
    case yt.ResolvedValue:
      for (const t of e.params) R(this, Be, ly).call(this, t);
  }
}, ly = function(e) {
  const t = m(this, Jo).get(e.serviceIdentifier);
  t !== void 0 && t.has(e) && (t.delete(e), R(this, Be, dy).call(this, e));
}, dy = function(e) {
  if ((!Ai.is(e) || e.isExpanded()) && e.bindings !== void 0) if (Array.isArray(e.bindings)) for (const t of e.bindings) R(this, Be, jl).call(this, t);
  else R(this, Be, jl).call(this, e.bindings);
}, XF = function(e) {
  const t = m(this, Jo).get(e.binding.serviceIdentifier);
  if (t !== void 0) switch (e.kind) {
    case xs.bindingAdded:
      for (const [n, i] of t) {
        const s = z2({ autobindOptions: void 0, operations: e.operations, servicesBranch: [] }, n, e.binding, i.bindingConstraintsList, i.chainedBindings);
        s.isContextFreeBinding ? s.shouldInvalidateServiceNode && Ai.is(n) && (R(this, Be, dy).call(this, n), n.invalidate()) : this.clearCache();
      }
      break;
    case xs.bindingRemoved:
      for (const [n, i] of t) {
        const s = j2(n, e.binding, i.bindingConstraintsList, i.optionalBindings);
        s.isContextFreeBinding ? s.bindingNodeRemoved !== void 0 && R(this, Be, jl).call(this, s.bindingNodeRemoved) : this.clearCache();
      }
  }
}, YF = function(e) {
  for (const [t, n] of m(this, Va).entries()) {
    const i = n.get(e.binding.serviceIdentifier);
    R(this, Be, sp).call(this, e, i, t, void 0, void 0);
  }
}, QF = function(e) {
  for (const [t, n] of m(this, Ha).entries()) {
    const i = n.get(e.binding.serviceIdentifier);
    if (i !== void 0) for (const [s, o] of i.entries()) for (const [a, c] of o.entries()) R(this, Be, sp).call(this, e, c, t, void 0, { key: s, value: a });
  }
}, sp = function(e, t, n, i, s) {
  if (t !== void 0 && Ai.is(t.tree.root)) {
    const u = R(this, Be, KF).call(this, e, n, i, s);
    switch (e.kind) {
      case xs.bindingAdded:
        {
          const l = (o = u, a = t.tree.root, c = e.binding, Ai.is(a) && !a.isExpanded() ? { isContextFreeBinding: !0, shouldInvalidateServiceNode: !1 } : z2(o, a, c, SE(o), o.rootConstraints.isMultiple && o.rootConstraints.chained));
          l.isContextFreeBinding ? l.shouldInvalidateServiceNode && (R(this, Be, dy).call(this, t.tree.root), t.tree.root.invalidate()) : this.clearCache();
        }
        break;
      case xs.bindingRemoved: {
        const l = (function(d, f, p) {
          return Ai.is(f) && !f.isExpanded() ? { bindingNodeRemoved: void 0, isContextFreeBinding: !0 } : j2(f, p, SE(d), d.rootConstraints.isOptional ?? !1);
        })(u, t.tree.root, e.binding);
        l.isContextFreeBinding ? l.bindingNodeRemoved !== void 0 && R(this, Be, jl).call(this, l.bindingNodeRemoved) : this.clearCache();
      }
    }
  }
  var o, a, c;
};
function BG(r, e) {
  if (Z1(e)) {
    const t = (function(n) {
      const i = [...n];
      return i.length === 0 ? "(No dependency trace)" : i.map(Xr).join(" -> ");
    })((function(n) {
      const i = n.planResult.tree.root, s = [];
      function o(a) {
        const c = s.indexOf(a);
        if (c !== -1)
          return [...s.slice(c), a].map((u) => u.serviceIdentifier);
        s.push(a);
        try {
          for (const u of (function(l) {
            const d = [], f = l.bindings;
            if (f === void 0) return d;
            const p = (y) => {
              if (Xu(y)) for (const g of y.redirections) p(g);
              else switch (y.binding.type) {
                case yt.Instance: {
                  const g = y;
                  for (const v of g.constructorParams) v !== void 0 && d.push(v);
                  for (const v of g.propertyParams.values()) d.push(v);
                  break;
                }
                case yt.ResolvedValue: {
                  const g = y;
                  for (const v of g.params) d.push(v);
                  break;
                }
              }
            };
            if (Array.isArray(f)) for (const y of f) p(y);
            else p(f);
            return d;
          })(a)) {
            const l = o(u);
            if (l !== void 0) return l;
          }
        } finally {
          s.pop();
        }
      }
      return o(i) ?? [];
    })(r));
    throw new Ft(Ct.planning, `Circular dependency found: ${t}`, { cause: e });
  }
  throw e;
}
function eM(r, e) {
  return gr(e) ? (r.cache = { isRight: !0, value: e }, e.then((t) => G2(r, t))) : G2(r, e);
}
function G2(r, e) {
  return r.cache = { isRight: !0, value: e }, e;
}
function LG(r, e, t) {
  const n = r.getActivations(e);
  return n === void 0 ? t : gr(t) ? K2(r, t, n[Symbol.iterator]()) : (function(i, s, o) {
    let a = s, c = o.next();
    for (; c.done !== !0; ) {
      const u = c.value(i.context, a);
      if (gr(u)) return K2(i, u, o);
      a = u, c = o.next();
    }
    return a;
  })(r, t, n[Symbol.iterator]());
}
async function K2(r, e, t) {
  let n = await e, i = t.next();
  for (; i.done !== !0; ) n = await i.value(r.context, n), i = t.next();
  return n;
}
function hy(r, e, t) {
  let n = t;
  if (e.onActivation !== void 0) {
    const i = e.onActivation;
    n = gr(n) ? n.then((s) => i(r.context, s)) : i(r.context, n);
  }
  return LG(r, e.serviceIdentifier, n);
}
function Q1(r) {
  return (e, t) => t.cache.isRight ? t.cache.value : eM(t, hy(e, t, r(e, t)));
}
const UG = Q1(function(r, e) {
  return e.value;
});
function FG(r) {
  return r;
}
function eC(r, e) {
  return (t, n) => {
    const i = r(n);
    switch (i.scope) {
      case qi.Singleton:
        return i.cache.isRight ? i.cache.value : eM(i, hy(t, i, e(t, n)));
      case qi.Request: {
        if (t.requestScopeCache.has(i.id)) return t.requestScopeCache.get(i.id);
        const s = hy(t, i, e(t, n));
        return t.requestScopeCache.set(i.id, s), s;
      }
      case qi.Transient:
        return hy(t, i, e(t, n));
    }
  };
}
const MG = ((r) => eC(FG, r))(function(r, e) {
  return e.value(r.context);
}), VG = Q1(function(r, e) {
  return e.factory(r.context);
});
function q2(r, e, t) {
  const n = (function(i, s, o) {
    if (!(o in i)) throw new Ft(Ct.resolution, `Expecting a "${o.toString()}" property when resolving "${s.implementationType.name}" class @postConstruct decorated method, none found.`);
    if (typeof i[o] != "function") throw new Ft(Ct.resolution, `Expecting a "${o.toString()}" method when resolving "${s.implementationType.name}" class @postConstruct decorated method, a non function property was found instead.`);
    {
      let a;
      try {
        a = i[o]();
      } catch (c) {
        throw new Ft(Ct.resolution, `Unexpected error found when calling "${o.toString()}" @postConstruct decorated method on class "${s.implementationType.name}"`, { cause: c });
      }
      if (gr(a)) return (async function(c, u, l) {
        try {
          await l;
        } catch (d) {
          throw new Ft(Ct.resolution, `Unexpected error found when calling "${u.toString()}" @postConstruct decorated method on class "${c.implementationType.name}"`, { cause: d });
        }
      })(s, o, a);
    }
  })(r, e, t);
  return gr(n) ? n.then(() => r) : r;
}
function W2(r, e, t) {
  if (t.size === 0) return r;
  let n = r;
  for (const i of t) n = gr(n) ? n.then((s) => q2(s, e, i)) : q2(n, e, i);
  return n;
}
function Z2(r) {
  return (e, t, n) => {
    const i = new n.binding.implementationType(...e), s = r(t, i, n);
    return gr(s) ? s.then(() => W2(i, n.binding, n.classMetadata.lifecycle.postConstructMethodNames)) : W2(i, n.binding, n.classMetadata.lifecycle.postConstructMethodNames);
  };
}
const zG = Q1(function(r, e) {
  return e.provider(r.context);
});
function jG(r) {
  return r.binding;
}
function HG(r) {
  return r.binding;
}
const J2 = /* @__PURE__ */ (function(r) {
  return (e, t, n) => {
    const i = [];
    for (const [s, o] of n.propertyParams) {
      const a = n.classMetadata.properties.get(s);
      if (a === void 0) throw new Ft(Ct.resolution, `Expecting metadata at property "${s.toString()}", none found`);
      a.kind !== ii.unmanaged && o.bindings !== void 0 && (t[s] = r(e, o), gr(t[s]) && i.push((async () => {
        t[s] = await t[s];
      })()));
    }
    if (i.length > 0) return Promise.all(i).then(() => {
    });
  };
})(Jv), X2 = /* @__PURE__ */ (function(r) {
  return function e(t, n) {
    const i = [];
    for (const s of n.redirections) Xu(s) ? i.push(...e(t, s)) : i.push(r(t, s));
    return i;
  };
})(CE), GG = /* @__PURE__ */ (function(r, e, t) {
  return (n, i) => {
    const s = r(n, i);
    return gr(s) ? e(s, n, i) : t(s, n, i);
  };
})(/* @__PURE__ */ (function(r) {
  return (e, t) => {
    const n = [];
    for (const i of t.constructorParams) i === void 0 ? n.push(void 0) : n.push(r(e, i));
    return n.some(gr) ? Promise.all(n) : n;
  };
})(Jv), /* @__PURE__ */ (function(r) {
  return async (e, t, n) => {
    const i = await e;
    return r(i, t, n);
  };
})(Z2(J2)), Z2(J2)), KG = /* @__PURE__ */ (function(r) {
  return (e, t) => {
    const n = r(e, t);
    return gr(n) ? n.then((i) => t.binding.factory(...i)) : t.binding.factory(...n);
  };
})(/* @__PURE__ */ (function(r) {
  return (e, t) => {
    const n = [];
    for (const i of t.params) n.push(r(e, i));
    return n.some(gr) ? Promise.all(n) : n;
  };
})(Jv)), qG = ((r) => eC(jG, r))(GG), WG = ((r) => eC(HG, r))(KG);
function ZG(r) {
  try {
    return Jv(r, r.planResult.tree.root);
  } catch (e) {
    BG(r, e);
  }
}
function CE(r, e) {
  switch (e.binding.type) {
    case yt.ConstantValue:
      return UG(r, e.binding);
    case yt.DynamicValue:
      return MG(r, e.binding);
    case yt.Factory:
      return VG(r, e.binding);
    case yt.Instance:
      return qG(r, e);
    case yt.Provider:
      return zG(r, e.binding);
    case yt.ResolvedValue:
      return WG(r, e);
  }
}
function Jv(r, e) {
  if (e.bindings !== void 0) return Array.isArray(e.bindings) ? (function(t, n) {
    const i = [];
    for (const s of n) Xu(s) ? i.push(...X2(t, s)) : i.push(CE(t, s));
    return i.some(gr) ? Promise.all(i) : i;
  })(r, e.bindings) : (function(t, n) {
    if (Xu(n)) {
      const i = X2(t, n);
      if (i.length === 1) return i[0];
      throw new Ft(Ct.resolution, "Unexpected multiple resolved values on single injection");
    }
    return CE(t, n);
  })(r, e.bindings);
}
function JG(r) {
  return r.scope !== void 0;
}
function Y2(r, e) {
  if (typeof r[e] == "function")
    return r[e]();
}
function Q2(r, e) {
  const t = r.lifecycle.preDestroyMethodNames;
  if (t.size === 0) return;
  let n;
  for (const i of t) n = n === void 0 ? Y2(e, i) : n.then(() => Y2(e, i));
  return n;
}
function eO(r, e, t) {
  const n = r.getDeactivations(e);
  if (n !== void 0) return gr(t) ? tO(t, n[Symbol.iterator]()) : (function(i, s) {
    let o = s.next();
    for (; o.done !== !0; ) {
      const a = o.value(i);
      if (gr(a)) return tO(i, s);
      o = s.next();
    }
  })(t, n[Symbol.iterator]());
}
async function tO(r, e) {
  const t = await r;
  let n = e.next();
  for (; n.done !== !0; ) await n.value(t), n = e.next();
}
function XG(r, e) {
  const t = (function(n, i) {
    if (i.type === yt.Instance) {
      const s = n.getClassMetadata(i.implementationType), o = i.cache.value;
      return gr(o) ? o.then((a) => Q2(s, a)) : Q2(s, o);
    }
  })(r, e);
  return t === void 0 ? rO(r, e) : t.then(() => rO(r, e));
}
function rO(r, e) {
  const t = e.cache;
  return gr(t.value) ? t.value.then((n) => nO(r, e, n)) : nO(r, e, t.value);
}
function nO(r, e, t) {
  let n;
  return e.onDeactivation !== void 0 && (n = (0, e.onDeactivation)(t)), n === void 0 ? eO(r, e.serviceIdentifier, t) : n.then(() => eO(r, e.serviceIdentifier, t));
}
function Fy(r, e) {
  if (e === void 0) return;
  const t = (function(i) {
    const s = [];
    for (const o of i) JG(o) && o.scope === qi.Singleton && o.cache.isRight && s.push(o);
    return s;
  })(e), n = [];
  for (const i of t) {
    const s = XG(r, i);
    s !== void 0 && n.push(s);
  }
  return n.length > 0 ? Promise.all(n).then(() => {
  }) : void 0;
}
function YG(r, e) {
  const t = r.getBindingsFromModule(e);
  return Fy(r, t);
}
function QG(r, e) {
  const t = r.getBindings(e);
  return Fy(r, t);
}
const eK = Symbol.for("@inversifyjs/plugin/isPlugin"), Kw = "@inversifyjs/container/bindingId";
var Eg, xg, vB;
let $r = (vB = class {
  constructor(e) {
    L(this, Eg);
    L(this, xg);
    D(this, Eg, (function() {
      const t = Ju(Object, Kw) ?? 0;
      return t === Number.MAX_SAFE_INTEGER ? q1(Object, Kw, Number.MIN_SAFE_INTEGER) : cc(Object, Kw, () => t, (n) => n + 1), t;
    })()), D(this, xg, e);
  }
  get id() {
    return m(this, Eg);
  }
  load(e) {
    return m(this, xg).call(this, e);
  }
}, Eg = new WeakMap(), xg = new WeakMap(), vB);
const tM = Symbol.for("@inversifyjs/container/bindingIdentifier");
function iO(r) {
  return typeof r == "object" && r !== null && r[tM] === !0;
}
var sS;
let $c = (sS = class {
}, h(sS, "always", (e) => !0), sS);
const qw = Symbol.for("@inversifyjs/container/InversifyContainerError");
var bB, wB;
let _o = class rM extends (wB = Error, bB = qw, wB) {
  constructor(t, n, i) {
    super(n, i);
    h(this, bB);
    h(this, "kind");
    this[qw] = !0, this.kind = t;
  }
  static is(t) {
    return typeof t == "object" && t !== null && t[qw] === !0;
  }
  static isErrorOfKind(t, n) {
    return rM.is(t) && t.kind === n;
  }
};
var Xi;
function tC(r) {
  return { [tM]: !0, id: r.id };
}
function op(r) {
  return (e) => {
    for (let t = e.getAncestor(); t !== void 0; t = t.getAncestor()) if (r(t)) return !0;
    return !1;
  };
}
function Pf(r) {
  return (e) => e.name === r;
}
function bm(r) {
  return (e) => e.serviceIdentifier === r;
}
function Nf(r, e) {
  return (t) => t.tags.has(r) && t.tags.get(r) === e;
}
function tK(r) {
  return r.name === void 0 && r.tags.size === 0;
}
function wm(r) {
  const e = op(r);
  return (t) => !e(t);
}
function _m(r) {
  return (e) => {
    const t = e.getAncestor();
    return t === void 0 || !r(t);
  };
}
function Sm(r) {
  return (e) => {
    const t = e.getAncestor();
    return t !== void 0 && r(t);
  };
}
(function(r) {
  r[r.invalidOperation = 0] = "invalidOperation";
})(Xi || (Xi = {}));
var hs, _B;
let rK = (_B = class {
  constructor(e) {
    L(this, hs);
    D(this, hs, e);
  }
  getIdentifier() {
    return tC(m(this, hs));
  }
  inRequestScope() {
    return m(this, hs).scope = qi.Request, new Ou(m(this, hs));
  }
  inSingletonScope() {
    return m(this, hs).scope = qi.Singleton, new Ou(m(this, hs));
  }
  inTransientScope() {
    return m(this, hs).scope = qi.Transient, new Ou(m(this, hs));
  }
}, hs = new WeakMap(), _B);
var fs, ps, gu, _i, wv, iM, SB;
let nM = (SB = class {
  constructor(e, t, n, i) {
    L(this, wv);
    L(this, fs);
    L(this, ps);
    L(this, gu);
    L(this, _i);
    D(this, fs, e), D(this, ps, t), D(this, gu, n), D(this, _i, i);
  }
  to(e) {
    const t = qv(e), n = { cache: { isRight: !1, value: void 0 }, id: Da(), implementationType: e, isSatisfiedBy: $c.always, moduleId: m(this, ps), onActivation: void 0, onDeactivation: void 0, scope: t.scope ?? m(this, gu), serviceIdentifier: m(this, _i), type: yt.Instance };
    return m(this, fs).call(this, n), new Ww(n);
  }
  toSelf() {
    if (typeof m(this, _i) != "function") throw new Error('"toSelf" function can only be applied when a newable function is used as service identifier');
    return this.to(m(this, _i));
  }
  toConstantValue(e) {
    const t = { cache: { isRight: !1, value: void 0 }, id: Da(), isSatisfiedBy: $c.always, moduleId: m(this, ps), onActivation: void 0, onDeactivation: void 0, scope: qi.Singleton, serviceIdentifier: m(this, _i), type: yt.ConstantValue, value: e };
    return m(this, fs).call(this, t), new Ou(t);
  }
  toDynamicValue(e) {
    const t = { cache: { isRight: !1, value: void 0 }, id: Da(), isSatisfiedBy: $c.always, moduleId: m(this, ps), onActivation: void 0, onDeactivation: void 0, scope: m(this, gu), serviceIdentifier: m(this, _i), type: yt.DynamicValue, value: e };
    return m(this, fs).call(this, t), new Ww(t);
  }
  toResolvedValue(e, t) {
    const n = { cache: { isRight: !1, value: void 0 }, factory: e, id: Da(), isSatisfiedBy: $c.always, metadata: R(this, wv, iM).call(this, t), moduleId: m(this, ps), onActivation: void 0, onDeactivation: void 0, scope: m(this, gu), serviceIdentifier: m(this, _i), type: yt.ResolvedValue };
    return m(this, fs).call(this, n), new Ww(n);
  }
  toFactory(e) {
    const t = { cache: { isRight: !1, value: void 0 }, factory: e, id: Da(), isSatisfiedBy: $c.always, moduleId: m(this, ps), onActivation: void 0, onDeactivation: void 0, scope: qi.Singleton, serviceIdentifier: m(this, _i), type: yt.Factory };
    return m(this, fs).call(this, t), new Ou(t);
  }
  toProvider(e) {
    const t = { cache: { isRight: !1, value: void 0 }, id: Da(), isSatisfiedBy: $c.always, moduleId: m(this, ps), onActivation: void 0, onDeactivation: void 0, provider: e, scope: qi.Singleton, serviceIdentifier: m(this, _i), type: yt.Provider };
    return m(this, fs).call(this, t), new Ou(t);
  }
  toService(e) {
    const t = { id: Da(), isSatisfiedBy: $c.always, moduleId: m(this, ps), serviceIdentifier: m(this, _i), targetServiceIdentifier: e, type: yt.ServiceRedirection };
    m(this, fs).call(this, t);
  }
}, fs = new WeakMap(), ps = new WeakMap(), gu = new WeakMap(), _i = new WeakMap(), wv = new WeakSet(), iM = function(e) {
  return { arguments: (e ?? []).map((t) => (function(n) {
    return typeof n == "object" && !Uy.is(n);
  })(t) ? (function(n) {
    return n.isMultiple === !0;
  })(t) ? { chained: t.chained ?? !1, kind: oa.multipleInjection, name: t.name, optional: t.optional ?? !1, tags: new Map((t.tags ?? []).map((n) => [n.key, n.value])), value: t.serviceIdentifier } : { kind: oa.singleInjection, name: t.name, optional: t.optional ?? !1, tags: new Map((t.tags ?? []).map((n) => [n.key, n.value])), value: t.serviceIdentifier } : { kind: oa.singleInjection, name: void 0, optional: !1, tags: /* @__PURE__ */ new Map(), value: t }) };
}, SB);
var gs;
class sM {
  constructor(e) {
    L(this, gs);
    D(this, gs, e);
  }
  getIdentifier() {
    return tC(m(this, gs));
  }
  onActivation(e) {
    return m(this, gs).onActivation = e, new DE(m(this, gs));
  }
  onDeactivation(e) {
    if (m(this, gs).onDeactivation = e, m(this, gs).scope !== qi.Singleton) throw new _o(Xi.invalidOperation, `Binding for service "${Xr(m(this, gs).serviceIdentifier)}" has a deactivation function, but its scope is not singleton. Deactivation functions can only be used with singleton bindings.`);
    return new DE(m(this, gs));
  }
}
gs = new WeakMap();
var mu, EB;
let DE = (EB = class {
  constructor(e) {
    L(this, mu);
    D(this, mu, e);
  }
  getIdentifier() {
    return tC(m(this, mu));
  }
  when(e) {
    return m(this, mu).isSatisfiedBy = e, new sM(m(this, mu));
  }
  whenAnyAncestor(e) {
    return this.when(op(e));
  }
  whenAnyAncestorIs(e) {
    return this.when(op(bm(e)));
  }
  whenAnyAncestorNamed(e) {
    return this.when((function(t) {
      return op(Pf(t));
    })(e));
  }
  whenAnyAncestorTagged(e, t) {
    return this.when((function(n, i) {
      return op(Nf(n, i));
    })(e, t));
  }
  whenDefault() {
    return this.when(tK);
  }
  whenNamed(e) {
    return this.when(Pf(e));
  }
  whenNoParent(e) {
    return this.when(_m(e));
  }
  whenNoParentIs(e) {
    return this.when(_m(bm(e)));
  }
  whenNoParentNamed(e) {
    return this.when((function(t) {
      return _m(Pf(t));
    })(e));
  }
  whenNoParentTagged(e, t) {
    return this.when((function(n, i) {
      return _m(Nf(n, i));
    })(e, t));
  }
  whenParent(e) {
    return this.when(Sm(e));
  }
  whenParentIs(e) {
    return this.when(Sm(bm(e)));
  }
  whenParentNamed(e) {
    return this.when((function(t) {
      return Sm(Pf(t));
    })(e));
  }
  whenParentTagged(e, t) {
    return this.when((function(n, i) {
      return Sm(Nf(n, i));
    })(e, t));
  }
  whenTagged(e, t) {
    return this.when(Nf(e, t));
  }
  whenNoAncestor(e) {
    return this.when(wm(e));
  }
  whenNoAncestorIs(e) {
    return this.when(wm(bm(e)));
  }
  whenNoAncestorNamed(e) {
    return this.when((function(t) {
      return wm(Pf(t));
    })(e));
  }
  whenNoAncestorTagged(e, t) {
    return this.when((function(n, i) {
      return wm(Nf(n, i));
    })(e, t));
  }
}, mu = new WeakMap(), EB);
var zd, xB;
let Ou = (xB = class extends DE {
  constructor(t) {
    super(t);
    L(this, zd);
    D(this, zd, new sM(t));
  }
  onActivation(t) {
    return m(this, zd).onActivation(t);
  }
  onDeactivation(t) {
    return m(this, zd).onDeactivation(t);
  }
}, zd = new WeakMap(), xB);
var yu, AB;
let Ww = (AB = class extends Ou {
  constructor(t) {
    super(t);
    L(this, yu);
    D(this, yu, new rK(t));
  }
  inRequestScope() {
    return m(this, yu).inRequestScope();
  }
  inSingletonScope() {
    return m(this, yu).inSingletonScope();
  }
  inTransientScope() {
    return m(this, yu).inTransientScope();
  }
}, yu = new WeakMap(), AB);
var vu, Ag, bu, Ar, Nt, oM, aM, TE, cM, kE, OE, $E, uM, RE, PE, IB;
let nK = (IB = class {
  constructor(e, t, n, i) {
    L(this, Nt);
    L(this, vu);
    L(this, Ag);
    L(this, bu);
    L(this, Ar);
    D(this, vu, e), D(this, Ag, t), D(this, bu, n), D(this, Ar, i);
  }
  bind(e) {
    return new nM((t) => {
      R(this, Nt, oM).call(this, t);
    }, void 0, m(this, Ag), e);
  }
  isBound(e, t) {
    const n = m(this, Ar).bindingService.get(e);
    return R(this, Nt, PE).call(this, e, n, t);
  }
  isCurrentBound(e, t) {
    const n = m(this, Ar).bindingService.getNonParentBindings(e);
    return R(this, Nt, PE).call(this, e, n, t);
  }
  async rebind(e) {
    return await this.unbind(e), this.bind(e);
  }
  rebindSync(e) {
    return this.unbindSync(e), this.bind(e);
  }
  async unbind(e) {
    await R(this, Nt, TE).call(this, e);
  }
  async unbindAll() {
    await R(this, Nt, OE).call(this);
  }
  unbindAllSync() {
    if (R(this, Nt, OE).call(this) !== void 0) throw new _o(Xi.invalidOperation, "Unexpected asynchronous deactivation when unbinding all services. Consider using Container.unbindAll() instead.");
  }
  unbindSync(e) {
    R(this, Nt, TE).call(this, e) !== void 0 && R(this, Nt, aM).call(this, e);
  }
}, vu = new WeakMap(), Ag = new WeakMap(), bu = new WeakMap(), Ar = new WeakMap(), Nt = new WeakSet(), oM = function(e) {
  m(this, Ar).bindingService.set(e), m(this, bu).invalidateService({ binding: e, kind: xs.bindingAdded });
}, aM = function(e) {
  var i;
  let t;
  if (iO(e)) {
    const s = m(this, Ar).bindingService.getById(e.id), o = (i = (n = s, (function(a) {
      if (a === void 0) return;
      const c = a.next();
      return c.done !== !0 ? c.value : void 0;
    })(n == null ? void 0 : n[Symbol.iterator]()))) == null ? void 0 : i.serviceIdentifier;
    t = o === void 0 ? "Unexpected asynchronous deactivation when unbinding binding identifier. Consider using Container.unbind() instead." : `Unexpected asynchronous deactivation when unbinding "${Xr(o)}" binding. Consider using Container.unbind() instead.`;
  } else t = `Unexpected asynchronous deactivation when unbinding "${Xr(e)}" service. Consider using Container.unbind() instead.`;
  var n;
  throw new _o(Xi.invalidOperation, t);
}, TE = function(e) {
  return iO(e) ? R(this, Nt, cM).call(this, e) : R(this, Nt, uM).call(this, e);
}, cM = function(e) {
  const t = m(this, Ar).bindingService.getById(e.id), n = t === void 0 ? void 0 : [...t], i = Fy(m(this, vu), t);
  if (i !== void 0) return i.then(() => {
    R(this, Nt, kE).call(this, n, e);
  });
  R(this, Nt, kE).call(this, n, e);
}, kE = function(e, t) {
  if (m(this, Ar).bindingService.removeById(t.id), e !== void 0) for (const n of e) m(this, bu).invalidateService({ binding: n, kind: xs.bindingRemoved });
}, OE = function() {
  const e = [...m(this, Ar).bindingService.getNonParentBoundServices()], t = e.map((n) => QG(m(this, vu), n));
  if (t.some((n) => gr(n))) return Promise.all(t).then(() => {
    R(this, Nt, $E).call(this, e);
  });
  R(this, Nt, $E).call(this, e);
}, $E = function(e) {
  for (const t of e) m(this, Ar).activationService.removeAllByServiceId(t), m(this, Ar).bindingService.removeAllByServiceId(t), m(this, Ar).deactivationService.removeAllByServiceId(t);
  m(this, Ar).planResultCacheService.clearCache();
}, uM = function(e) {
  const t = m(this, Ar).bindingService.get(e), n = t === void 0 ? void 0 : [...t], i = Fy(m(this, vu), t);
  if (i !== void 0) return i.then(() => {
    R(this, Nt, RE).call(this, e, n);
  });
  R(this, Nt, RE).call(this, e, n);
}, RE = function(e, t) {
  if (m(this, Ar).activationService.removeAllByServiceId(e), m(this, Ar).bindingService.removeAllByServiceId(e), m(this, Ar).deactivationService.removeAllByServiceId(e), t !== void 0) for (const n of t) m(this, bu).invalidateService({ binding: n, kind: xs.bindingRemoved });
}, PE = function(e, t, n) {
  if (t === void 0) return !1;
  const i = { getAncestor: () => {
  }, name: n == null ? void 0 : n.name, serviceIdentifier: e, tags: /* @__PURE__ */ new Map() };
  (n == null ? void 0 : n.tag) !== void 0 && i.tags.set(n.tag.key, n.tag.value);
  for (const s of t) if (s.isSatisfiedBy(i)) return !0;
  return !1;
}, IB);
var jn, Ig, Cg, Dg, ms, Pn, lM, NE, BE, dM, LE, CB;
let iK = (CB = class {
  constructor(e, t, n, i, s) {
    L(this, Pn);
    L(this, jn);
    L(this, Ig);
    L(this, Cg);
    L(this, Dg);
    L(this, ms);
    D(this, jn, e), D(this, Ig, t), D(this, Cg, n), D(this, Dg, i), D(this, ms, s);
  }
  async load(...e) {
    await Promise.all(R(this, Pn, BE).call(this, ...e));
  }
  loadSync(...e) {
    const t = R(this, Pn, BE).call(this, ...e);
    for (const n of t) if (n !== void 0) throw new _o(Xi.invalidOperation, "Unexpected asynchronous module load. Consider using Container.load() instead.");
  }
  async unload(...e) {
    await Promise.all(R(this, Pn, LE).call(this, ...e)), R(this, Pn, NE).call(this, e);
  }
  unloadSync(...e) {
    const t = R(this, Pn, LE).call(this, ...e);
    for (const n of t) if (n !== void 0) throw new _o(Xi.invalidOperation, "Unexpected asynchronous module unload. Consider using Container.unload() instead.");
    R(this, Pn, NE).call(this, e);
  }
}, jn = new WeakMap(), Ig = new WeakMap(), Cg = new WeakMap(), Dg = new WeakMap(), ms = new WeakMap(), Pn = new WeakSet(), lM = function(e) {
  return { bind: (t) => new nM((n) => {
    R(this, Pn, dM).call(this, n);
  }, e, m(this, Cg), t), isBound: m(this, jn).isBound.bind(m(this, jn)), onActivation: (t, n) => {
    m(this, ms).activationService.add(n, { moduleId: e, serviceId: t });
  }, onDeactivation: (t, n) => {
    m(this, ms).deactivationService.add(n, { moduleId: e, serviceId: t });
  }, rebind: m(this, jn).rebind.bind(m(this, jn)), rebindSync: m(this, jn).rebindSync.bind(m(this, jn)), unbind: m(this, jn).unbind.bind(m(this, jn)), unbindSync: m(this, jn).unbindSync.bind(m(this, jn)) };
}, NE = function(e) {
  for (const t of e) m(this, ms).activationService.removeAllByModuleId(t.id), m(this, ms).bindingService.removeAllByModuleId(t.id), m(this, ms).deactivationService.removeAllByModuleId(t.id);
  m(this, ms).planResultCacheService.clearCache();
}, BE = function(...e) {
  return e.map((t) => t.load(R(this, Pn, lM).call(this, t.id)));
}, dM = function(e) {
  m(this, ms).bindingService.set(e), m(this, Dg).invalidateService({ binding: e, kind: xs.bindingAdded });
}, LE = function(...e) {
  return e.map((t) => YG(m(this, Ig), t.id));
}, CB), sK = class {
  constructor(e) {
    h(this, "deactivationParams");
    this.deactivationParams = (function(t) {
      return { getBindings: t.bindingService.get.bind(t.bindingService), getBindingsFromModule: t.bindingService.getByModuleId.bind(t.bindingService), getClassMetadata: qv, getDeactivations: t.deactivationService.get.bind(t.deactivationService) };
    })(e), e.onReset(() => {
      (function(t, n) {
        n.getBindings = t.bindingService.get.bind(t.bindingService), n.getBindingsFromModule = t.bindingService.getByModuleId.bind(t.bindingService), n.getDeactivations = t.deactivationService.get.bind(t.deactivationService);
      })(e, this.deactivationParams);
    });
  }
};
var ur, ul, hM, UE;
class oK {
  constructor(e) {
    L(this, ul);
    h(this, "planParamsOperations");
    L(this, ur);
    D(this, ur, e), this.planParamsOperations = { getBindings: m(this, ur).bindingService.get.bind(m(this, ur).bindingService), getBindingsChained: m(this, ur).bindingService.getChained.bind(m(this, ur).bindingService), getClassMetadata: qv, getPlan: m(this, ur).planResultCacheService.get.bind(m(this, ur).planResultCacheService), setBinding: R(this, ul, UE).bind(this), setNonCachedServiceNode: m(this, ur).planResultCacheService.setNonCachedServiceNode.bind(m(this, ur).planResultCacheService), setPlan: m(this, ur).planResultCacheService.set.bind(m(this, ur).planResultCacheService) }, m(this, ur).onReset(() => {
      R(this, ul, hM).call(this);
    });
  }
}
ur = new WeakMap(), ul = new WeakSet(), hM = function() {
  this.planParamsOperations.getBindings = m(this, ur).bindingService.get.bind(m(this, ur).bindingService), this.planParamsOperations.getBindingsChained = m(this, ur).bindingService.getChained.bind(m(this, ur).bindingService), this.planParamsOperations.setBinding = R(this, ul, UE).bind(this);
}, UE = function(e) {
  m(this, ur).bindingService.set(e), m(this, ur).planResultCacheService.invalidateServiceBinding({ binding: e, kind: xs.bindingAdded, operations: this.planParamsOperations });
};
var Tg, kg;
class aK {
  constructor(e, t) {
    L(this, Tg);
    L(this, kg);
    D(this, Tg, e), D(this, kg, t);
  }
  invalidateService(e) {
    m(this, kg).planResultCacheService.invalidateServiceBinding({ ...e, operations: m(this, Tg).planParamsOperations });
  }
}
Tg = new WeakMap(), kg = new WeakMap();
var Og, $g, jd, Rg, nf, fM, pM;
class cK {
  constructor(e, t, n) {
    L(this, nf);
    L(this, Og);
    L(this, $g);
    L(this, jd);
    L(this, Rg);
    D(this, Rg, t), D(this, jd, n), D(this, Og, R(this, nf, fM).call(this, e)), D(this, $g, R(this, nf, pM).call(this));
  }
  register(e, t) {
    const n = new t(e, m(this, $g));
    if (n[eK] !== !0) throw new _o(Xi.invalidOperation, "Invalid plugin. The plugin must extend the Plugin class");
    n.load(m(this, Og));
  }
}
Og = new WeakMap(), $g = new WeakMap(), jd = new WeakMap(), Rg = new WeakMap(), nf = new WeakSet(), fM = function(e) {
  return { define: (t, n) => {
    if (Object.prototype.hasOwnProperty.call(e, t)) throw new _o(Xi.invalidOperation, `Container already has a method named "${String(t)}"`);
    e[t] = n;
  }, onPlan: m(this, jd).onPlan.bind(m(this, jd)) };
}, pM = function() {
  const e = m(this, Rg);
  return { get activationService() {
    return e.activationService;
  }, get bindingService() {
    return e.bindingService;
  }, get deactivationService() {
    return e.deactivationService;
  }, get planResultCacheService() {
    return e.planResultCacheService;
  } };
};
var Hd, DB;
let sO = (DB = class {
  constructor(e, t, n, i) {
    h(this, "activationService");
    h(this, "bindingService");
    h(this, "deactivationService");
    h(this, "planResultCacheService");
    L(this, Hd);
    this.activationService = e, this.bindingService = t, this.deactivationService = n, this.planResultCacheService = i, D(this, Hd, []);
  }
  reset(e, t, n) {
    this.activationService = e, this.bindingService = t, this.deactivationService = n, this.planResultCacheService.clearCache();
    for (const i of m(this, Hd)) i();
  }
  onReset(e) {
    m(this, Hd).push(e);
  }
}, Hd = new WeakMap(), DB);
var Pg, Ng, Bg, Gd, Kd, Lg, wu, Gt, gM, mM, yM, vM, ap, FE, cp, bM;
class uK {
  constructor(e, t, n, i) {
    L(this, Gt);
    L(this, Pg);
    L(this, Ng);
    L(this, Bg);
    L(this, Gd);
    L(this, Kd);
    L(this, Lg);
    L(this, wu);
    D(this, Lg, e), D(this, wu, t), D(this, Gd, R(this, Gt, FE).call(this)), D(this, Pg, n), D(this, Ng, i), D(this, Bg, (s) => m(this, wu).activationService.get(s)), D(this, Kd, []), m(this, wu).onReset(() => {
      R(this, Gt, gM).call(this);
    });
  }
  get(e, t) {
    const n = R(this, Gt, ap).call(this, !1, e, t), i = R(this, Gt, cp).call(this, n);
    if (gr(i)) throw new _o(Xi.invalidOperation, `Unexpected asynchronous service when resolving service "${Xr(e)}"`);
    return i;
  }
  getAll(e, t) {
    const n = R(this, Gt, ap).call(this, !0, e, t), i = R(this, Gt, cp).call(this, n);
    if (gr(i)) throw new _o(Xi.invalidOperation, `Unexpected asynchronous service when resolving service "${Xr(e)}"`);
    return i;
  }
  async getAllAsync(e, t) {
    const n = R(this, Gt, ap).call(this, !0, e, t);
    return R(this, Gt, cp).call(this, n);
  }
  async getAsync(e, t) {
    const n = R(this, Gt, ap).call(this, !1, e, t);
    return R(this, Gt, cp).call(this, n);
  }
  onPlan(e) {
    m(this, Kd).push(e);
  }
}
Pg = new WeakMap(), Ng = new WeakMap(), Bg = new WeakMap(), Gd = new WeakMap(), Kd = new WeakMap(), Lg = new WeakMap(), wu = new WeakMap(), Gt = new WeakSet(), gM = function() {
  D(this, Gd, R(this, Gt, FE).call(this));
}, mM = function(e, t, n) {
  const i = n == null ? void 0 : n.name, s = (n == null ? void 0 : n.optional) ?? !1, o = n == null ? void 0 : n.tag;
  return e ? { chained: (n == null ? void 0 : n.chained) ?? !1, isMultiple: e, name: i, optional: s, serviceIdentifier: t, tag: o } : { isMultiple: e, name: i, optional: s, serviceIdentifier: t, tag: o };
}, yM = function(e, t, n) {
  const i = { autobindOptions: (n == null ? void 0 : n.autobind) ?? m(this, Pg) ? { scope: m(this, Ng) } : void 0, operations: m(this, Lg).planParamsOperations, rootConstraints: R(this, Gt, vM).call(this, e, t, n), servicesBranch: [] };
  return R(this, Gt, bM).call(this, i, n), i;
}, vM = function(e, t, n) {
  return t ? { chained: (n == null ? void 0 : n.chained) ?? !1, isMultiple: t, serviceIdentifier: e } : { isMultiple: t, serviceIdentifier: e };
}, ap = function(e, t, n) {
  const i = R(this, Gt, mM).call(this, e, t, n), s = m(this, wu).planResultCacheService.get(i);
  if (s !== void 0) return s;
  const o = $G(R(this, Gt, yM).call(this, t, e, n));
  for (const a of m(this, Kd)) a(i, o);
  return o;
}, FE = function() {
  return { get: this.get.bind(this), getAll: this.getAll.bind(this), getAllAsync: this.getAllAsync.bind(this), getAsync: this.getAsync.bind(this) };
}, cp = function(e) {
  return ZG({ context: m(this, Gd), getActivations: m(this, Bg), planResult: e, requestScopeCache: /* @__PURE__ */ new Map() });
}, bM = function(e, t) {
  t !== void 0 && (t.name !== void 0 && (e.rootConstraints.name = t.name), t.optional === !0 && (e.rootConstraints.isOptional = !0), t.tag !== void 0 && (e.rootConstraints.tag = { key: t.tag.key, value: t.tag.value }), e.rootConstraints.isMultiple && (e.rootConstraints.chained = (t == null ? void 0 : t.chained) ?? !1));
};
var Ga, qd;
class lK {
  constructor(e) {
    L(this, Ga);
    L(this, qd);
    D(this, Ga, e), D(this, qd, []);
  }
  restore() {
    const e = m(this, qd).pop();
    if (e === void 0) throw new _o(Xi.invalidOperation, "No snapshot available to restore");
    m(this, Ga).reset(e.activationService, e.bindingService, e.deactivationService);
  }
  snapshot() {
    m(this, qd).push({ activationService: m(this, Ga).activationService.clone(), bindingService: m(this, Ga).bindingService.clone(), deactivationService: m(this, Ga).deactivationService.clone() });
  }
}
Ga = new WeakMap(), qd = new WeakMap();
const dK = qi.Transient;
var Hn, Ka, Ug, Nr, Xo, Wd, sf, wM, _M;
class hK {
  constructor(e) {
    L(this, sf);
    L(this, Hn);
    L(this, Ka);
    L(this, Ug);
    L(this, Nr);
    L(this, Xo);
    L(this, Wd);
    const t = (e == null ? void 0 : e.autobind) ?? !1, n = (e == null ? void 0 : e.defaultScope) ?? dK;
    D(this, Nr, R(this, sf, _M).call(this, e, t, n));
    const i = new oK(m(this, Nr)), s = new aK(i, m(this, Nr)), o = new sK(m(this, Nr));
    D(this, Hn, new nK(o.deactivationParams, n, s, m(this, Nr))), D(this, Ka, new iK(m(this, Hn), o.deactivationParams, n, s, m(this, Nr))), D(this, Xo, new uK(i, m(this, Nr), t, n)), D(this, Ug, new cK(this, m(this, Nr), m(this, Xo))), D(this, Wd, new lK(m(this, Nr)));
  }
  bind(e) {
    return m(this, Hn).bind(e);
  }
  get(e, t) {
    return m(this, Xo).get(e, t);
  }
  getAll(e, t) {
    return m(this, Xo).getAll(e, t);
  }
  async getAllAsync(e, t) {
    return m(this, Xo).getAllAsync(e, t);
  }
  async getAsync(e, t) {
    return m(this, Xo).getAsync(e, t);
  }
  isBound(e, t) {
    return m(this, Hn).isBound(e, t);
  }
  isCurrentBound(e, t) {
    return m(this, Hn).isCurrentBound(e, t);
  }
  async load(...e) {
    return m(this, Ka).load(...e);
  }
  loadSync(...e) {
    m(this, Ka).loadSync(...e);
  }
  onActivation(e, t) {
    m(this, Nr).activationService.add(t, { serviceId: e });
  }
  onDeactivation(e, t) {
    m(this, Nr).deactivationService.add(t, { serviceId: e });
  }
  register(e) {
    m(this, Ug).register(this, e);
  }
  restore() {
    m(this, Wd).restore();
  }
  async rebind(e) {
    return m(this, Hn).rebind(e);
  }
  rebindSync(e) {
    return m(this, Hn).rebindSync(e);
  }
  snapshot() {
    m(this, Wd).snapshot();
  }
  async unbind(e) {
    await m(this, Hn).unbind(e);
  }
  async unbindAll() {
    await m(this, Hn).unbindAll();
  }
  unbindAllSync() {
    m(this, Hn).unbindAllSync();
  }
  unbindSync(e) {
    m(this, Hn).unbindSync(e);
  }
  async unload(...e) {
    return m(this, Ka).unload(...e);
  }
  unloadSync(...e) {
    m(this, Ka).unloadSync(...e);
  }
}
Hn = new WeakMap(), Ka = new WeakMap(), Ug = new WeakMap(), Nr = new WeakMap(), Xo = new WeakMap(), Wd = new WeakMap(), sf = new WeakSet(), wM = function(e, t) {
  if (e) return { scope: t };
}, _M = function(e, t, n) {
  const i = R(this, sf, wM).call(this, t, n);
  if ((e == null ? void 0 : e.parent) === void 0) return new sO(N2.build(() => {
  }), B2.build(() => {
  }, i), L2.build(() => {
  }), new H2());
  const s = new H2(), o = e.parent;
  return m(o, Nr).planResultCacheService.subscribe(s), new sO(N2.build(() => m(o, Nr).activationService), B2.build(() => m(o, Nr).bindingService, i), L2.build(() => m(o, Nr).deactivationService), s);
};
const Me = {
  LoggerPublisher: Symbol.for("LoggerPublisher"),
  LoggerSubscriber: Symbol.for("LoggerSubscriber")
}, zt = {
  StorageService: Symbol.for("StorageService"),
  IndexedDbService: Symbol.for("IndexedDbService"),
  MigrateDbUseCase: Symbol.for("MigrateDbUseCase"),
  KeyPairMigrationService: Symbol.for("KeyPairMigrationService")
};
var fK = Object.getOwnPropertyDescriptor, pK = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? fK(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, Em = (r, e) => (t, n) => e(t, n, r);
let ME = class {
  constructor(r, e, t, n) {
    h(this, "logger");
    h(this, "accounts", []);
    h(this, "selectedAccount", null);
    this.loggerFactory = r, this.storageService = e, this.dAppConfigService = t, this.hydrateAccountWithBalanceUseCase = n, this.logger = this.loggerFactory("[Account Service]");
  }
  async setAccountsFromCloudSyncData(r) {
    const e = await this.mapCloudSyncDataToAccounts(r);
    this.setAccounts(e);
  }
  selectAccount(r) {
    const e = this.accounts.find((t) => t.id === r.id);
    e && (this.selectedAccount = e, this.logger.info("Account selected, saving to storage", {
      account: e
    }), this.storageService.saveSelectedAccount(e));
  }
  getSelectedAccount() {
    return this.selectedAccount;
  }
  getAccounts() {
    return this.accounts;
  }
  setAccounts(r) {
    if (this.accounts = r, this.logger.debug("saving accounts", { accounts: this.accounts }), this.selectedAccount) {
      const e = r.find(
        (t) => {
          var n;
          return t.id === ((n = this.selectedAccount) == null ? void 0 : n.id);
        }
      );
      e && (this.selectedAccount = e, this.storageService.saveSelectedAccount(e));
    }
  }
  async mapCloudSyncDataToAccounts(r) {
    const { accounts: e, accountNames: t } = r, n = (await this.dAppConfigService.getDAppConfig()).supportedBlockchains, i = e.map((s) => {
      const o = n.find(
        (u) => u.currency_id === s.currencyId
      ), a = t[s.id] ?? `${o == null ? void 0 : o.currency_name} Account ${s.index}`, c = o == null ? void 0 : o.currency_ticker;
      return c ? {
        ...s,
        name: a,
        ticker: c,
        derivationMode: s.derivationMode ? s.derivationMode : "",
        balance: void 0,
        tokens: []
      } : void 0;
    }).filter((s) => s !== void 0);
    if (i.length === 0)
      throw new z8("No accounts found", {
        networks: n.map((s) => s.currency_name)
      });
    return i;
  }
  async getBalanceAndTokensForAccount(r, e) {
    return this.hydrateAccountWithBalanceUseCase.execute(r, e);
  }
};
ME = pK([
  ke(),
  Em(0, H(Me.LoggerPublisher)),
  Em(1, H(zt.StorageService)),
  Em(2, H(mc.DAppConfigService)),
  Em(3, H(Ot.HydrateAccountWithBalanceUseCase))
], ME);
var gK = Object.getOwnPropertyDescriptor, mK = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? gK(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, oO = (r, e) => (t, n) => e(t, n, r);
let VE = class {
  constructor(r, e) {
    this.fetchCloudSyncAccountsUseCase = r, this.accountService = e;
  }
  async execute() {
    const r = await this.fetchCloudSyncAccountsUseCase.execute();
    return await this.accountService.setAccountsFromCloudSyncData(r), this.accountService.getAccounts();
  }
};
VE = mK([
  ke(),
  oO(0, H(Ot.FetchCloudSyncAccountsUseCase)),
  oO(1, H(Ot.AccountService))
], VE);
var yK = Object.getOwnPropertyDescriptor, vK = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? yK(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, Zw = (r, e) => (t, n) => e(t, n, r);
let zE = class {
  constructor(r, e, t) {
    h(this, "logger");
    this.fetchAccountsUseCase = e, this.hydrateAccountWithBalanceUseCase = t, this.logger = r("[FetchAccountsWithBalanceUseCase]");
  }
  execute() {
    return rn(this.fetchAccountsUseCase.execute()).pipe(
      Qr((r) => {
        const e = this.initializeAccountsWithEmptyBalances(r);
        if (e.length === 0)
          return Ji(e);
        const t = e.map(
          (n) => this.createBalanceObservable(n)
        );
        return x1(...t).pipe(
          A1(
            (n, i) => this.mergeAccountUpdate(n, i),
            e
          ),
          Iz(e)
        );
      })
    );
  }
  initializeAccountsWithEmptyBalances(r) {
    return r.map((e) => ({
      ...e,
      balance: void 0,
      tokens: []
    }));
  }
  createBalanceObservable(r) {
    return rn(
      this.hydrateAccountWithBalanceUseCase.execute(r, !0)
    ).pipe(
      jL((e) => (this.logger.warn(
        "Failed to fetch balance for account, keeping original",
        {
          accountId: r.id,
          error: e
        }
      ), Ji(r))),
      cr(
        (e) => ({
          accountId: r.id,
          account: e
        })
      )
    );
  }
  mergeAccountUpdate(r, e) {
    const t = r.findIndex((n) => n.id === e.accountId);
    if (t !== -1) {
      const n = [...r];
      return n[t] = e.account, n;
    }
    return r;
  }
};
zE = vK([
  ke(),
  Zw(0, H(Me.LoggerPublisher)),
  Zw(1, H(Ot.FetchAccountsUseCase)),
  Zw(2, H(Ot.HydrateAccountWithBalanceUseCase))
], zE);
function bK(r) {
  return Uint8Array.from(atob(r), (e) => e.charCodeAt(0));
}
const SM = {
  CloudSyncService: Symbol.for("CloudSyncService")
}, Xv = {
  LedgerSyncService: Symbol.for("LedgerSyncService")
};
var wK = Object.getOwnPropertyDescriptor, _K = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? wK(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, Jw = (r, e) => (t, n) => e(t, n, r);
let jE = class {
  constructor(r, e, t) {
    h(this, "logger");
    this.ledgerSyncService = e, this.cloudSyncService = t, this.logger = r("FetchCloudSyncAccountsUseCase");
  }
  async execute() {
    await this.authenticateWithKeyPair();
    const r = this.getAuthContextOrThrow(), e = await this.fetchAndDecryptAccounts(r);
    return this.logger.info("Accounts fetched from cloud sync", e), e;
  }
  getAuthContextOrThrow() {
    const r = this.ledgerSyncService.authContext;
    if (!r) {
      const e = new TB(
        "No auth context available"
      );
      throw this.logger.error("Missing auth context for fetching accounts", {
        error: e
      }), e;
    }
    return r;
  }
  async authenticateWithKeyPair() {
    await S1(this.ledgerSyncService.authenticate());
  }
  async fetchAndDecryptAccounts(r) {
    const e = await this.cloudSyncService.fetchEncryptedAccounts(r), t = bK(e.payload), n = await this.ledgerSyncService.decrypt(t);
    return JSON.parse(new TextDecoder().decode(n));
  }
};
jE = _K([
  ke(),
  Jw(0, H(Me.LoggerPublisher)),
  Jw(1, H(Xv.LedgerSyncService)),
  Jw(2, H(SM.CloudSyncService))
], jE);
var SK = Object.getOwnPropertyDescriptor, EK = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? SK(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, Rc = (r, e) => (t, n) => e(t, n, r);
let HE = class {
  constructor(r, e, t, n, i, s, o) {
    h(this, "logger");
    this.contextService = e, this.ledgerSyncService = t, this.fetchAccountsUseCase = n, this.hydrateWithBalanceUseCase = i, this.hydrateWithFiatUseCase = s, this.hydrateWithTxHistoryUseCase = o, this.logger = r("FetchSelectedAccountUseCase");
  }
  async execute() {
    var n;
    const r = await this.getSelectedAccountFromContext();
    if (r.isLeft())
      return r;
    const e = r.unsafeCoerce(), t = await this.hydrateDetailedAccount(e);
    return this.emitAccountChangedEvent(t), this.logger.info("Selected account fetched with details", {
      address: t.freshAddress,
      hasBalance: !!t.balance,
      hasFiat: !!t.fiatBalance,
      txCount: ((n = t.transactionHistory) == null ? void 0 : n.length) ?? 0
    }), te(t);
  }
  async getSelectedAccountFromContext() {
    var n, i;
    const r = this.contextService.getContext();
    if (!r.selectedAccount)
      return N(new G8());
    await S1(this.ledgerSyncService.authenticate());
    const t = (await this.fetchAccountsUseCase.execute()).find(
      (s) => {
        var o, a;
        return s.freshAddress === ((o = r.selectedAccount) == null ? void 0 : o.freshAddress) && s.currencyId === ((a = r.selectedAccount) == null ? void 0 : a.currencyId);
      }
    );
    return t ? te(t) : (this.logger.error("Selected account not found in Ledger Sync accounts", {
      address: (n = r.selectedAccount) == null ? void 0 : n.freshAddress,
      currencyId: (i = r.selectedAccount) == null ? void 0 : i.currencyId
    }), N(
      new K8(
        "Selected account not found in Ledger Sync accounts",
        {
          address: r.selectedAccount.freshAddress
        }
      )
    ));
  }
  async hydrateDetailedAccount(r) {
    const e = await this.hydrateWithBalanceUseCase.execute(r), [t, n] = await Promise.all([
      this.hydrateWithFiatUseCase.execute(e),
      this.hydrateWithTxHistoryUseCase.execute(e)
    ]);
    return this.mergeHydrations(e, t, n);
  }
  mergeHydrations(r, e, t) {
    return {
      ...r,
      fiatBalance: e.fiatBalance,
      tokens: e.tokens,
      transactionHistory: t.transactionHistory
    };
  }
  emitAccountChangedEvent(r) {
    this.contextService.onEvent({
      type: "account_changed",
      account: r
    });
  }
};
HE = EK([
  ke(),
  Rc(0, H(Me.LoggerPublisher)),
  Rc(1, H(ci.ContextService)),
  Rc(2, H(Xv.LedgerSyncService)),
  Rc(3, H(Ot.FetchAccountsUseCase)),
  Rc(4, H(Ot.HydrateAccountWithBalanceUseCase)),
  Rc(5, H(Ot.HydrateAccountWithFiatUseCase)),
  Rc(6, H(Ot.HydrateAccountWithTxHistoryUseCase))
], HE);
var xK = Object.getOwnPropertyDescriptor, AK = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? xK(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, Xw = (r, e) => (t, n) => e(t, n, r);
let GE = class {
  constructor(r, e, t) {
    h(this, "logger");
    this.contextService = e, this.fetchSelectedAccountUseCase = t, this.logger = r("[GetDetailedSelectedAccountUseCase]");
  }
  async execute() {
    const r = this.contextService.getContext().selectedAccount;
    return this.isSelectedAccountHydrated(r) ? (this.logger.debug("Selected account already hydrated", {
      selectedAccount: r
    }), te(r)) : this.fetchSelectedAccountUseCase.execute();
  }
  isSelectedAccountHydrated(r) {
    const e = r;
    return !!(r != null && r.name) && r.name.length > 0 && (e == null ? void 0 : e.transactionHistory) !== void 0;
  }
};
GE = AK([
  ke(),
  Xw(0, H(Me.LoggerPublisher)),
  Xw(1, H(ci.ContextService)),
  Xw(2, H(Ot.FetchSelectedAccountUseCase))
], GE);
const IK = "6.16.0";
function KE(r, e, t) {
  for (let n in e) {
    let i = e[n];
    Object.defineProperty(r, n, { enumerable: !0, value: i, writable: !1 });
  }
}
function Yl(r, e) {
  if (r == null)
    return "null";
  if (e == null && (e = /* @__PURE__ */ new Set()), typeof r == "object") {
    if (e.has(r))
      return "[Circular]";
    e.add(r);
  }
  if (Array.isArray(r))
    return "[ " + r.map((t) => Yl(t, e)).join(", ") + " ]";
  if (r instanceof Uint8Array) {
    const t = "0123456789abcdef";
    let n = "0x";
    for (let i = 0; i < r.length; i++)
      n += t[r[i] >> 4], n += t[r[i] & 15];
    return n;
  }
  if (typeof r == "object" && typeof r.toJSON == "function")
    return Yl(r.toJSON(), e);
  switch (typeof r) {
    case "boolean":
    case "number":
    case "symbol":
      return r.toString();
    case "bigint":
      return BigInt(r).toString();
    case "string":
      return JSON.stringify(r);
    case "object": {
      const t = Object.keys(r);
      return t.sort(), "{ " + t.map((n) => `${Yl(n, e)}: ${Yl(r[n], e)}`).join(", ") + " }";
    }
  }
  return "[ COULD NOT SERIALIZE ]";
}
function CK(r, e, t) {
  let n = r;
  {
    const s = [];
    if (t) {
      if ("message" in t || "code" in t || "name" in t)
        throw new Error(`value will overwrite populated values: ${Yl(t)}`);
      for (const o in t) {
        if (o === "shortMessage")
          continue;
        const a = t[o];
        s.push(o + "=" + Yl(a));
      }
    }
    s.push(`code=${e}`), s.push(`version=${IK}`), s.length && (r += " (" + s.join(", ") + ")");
  }
  let i;
  switch (e) {
    case "INVALID_ARGUMENT":
      i = new TypeError(r);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      i = new RangeError(r);
      break;
    default:
      i = new Error(r);
  }
  return KE(i, { code: e }), t && Object.assign(i, t), i.shortMessage == null && KE(i, { shortMessage: n }), i;
}
function Qt(r, e, t, n) {
  if (!r)
    throw CK(e, t, n);
}
function _e(r, e, t, n) {
  Qt(r, e, "INVALID_ARGUMENT", { argument: t, value: n });
}
["NFD", "NFC", "NFKD", "NFKC"].reduce((r, e) => {
  try {
    if ("test".normalize(e) !== "test")
      throw new Error("bad");
    if (e === "NFD" && "".normalize("NFD") !== "e")
      throw new Error("broken");
    r.push(e);
  } catch {
  }
  return r;
}, []);
function EM(r, e, t) {
  if (t == null && (t = ""), r !== e) {
    let n = t, i = "new";
    t && (n += ".", i += " " + t), Qt(!1, `private constructor; use ${n}from* methods`, "UNSUPPORTED_OPERATION", {
      operation: i
    });
  }
}
function xM(r, e, t) {
  if (r instanceof Uint8Array)
    return t ? new Uint8Array(r) : r;
  if (typeof r == "string" && r.length % 2 === 0 && r.match(/^0x[0-9a-f]*$/i)) {
    const n = new Uint8Array((r.length - 2) / 2);
    let i = 2;
    for (let s = 0; s < n.length; s++)
      n[s] = parseInt(r.substring(i, i + 2), 16), i += 2;
    return n;
  }
  _e(!1, "invalid BytesLike value", e || "value", r);
}
function Ut(r, e) {
  return xM(r, e, !1);
}
function Bf(r, e) {
  return xM(r, e, !0);
}
function vc(r, e) {
  return !(typeof r != "string" || !r.match(/^0x[0-9A-Fa-f]*$/) || typeof e == "number" && r.length !== 2 + 2 * e || e === !0 && r.length % 2 !== 0);
}
function DK(r) {
  return vc(r, !0) || r instanceof Uint8Array;
}
const aO = "0123456789abcdef";
function et(r) {
  const e = Ut(r);
  let t = "0x";
  for (let n = 0; n < e.length; n++) {
    const i = e[n];
    t += aO[(i & 240) >> 4] + aO[i & 15];
  }
  return t;
}
function go(r) {
  return "0x" + r.map((e) => et(e).substring(2)).join("");
}
function kp(r) {
  return vc(r, !0) ? (r.length - 2) / 2 : Ut(r).length;
}
function TK(r, e, t) {
  const n = Ut(r);
  Qt(e >= n.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(n),
    length: e,
    offset: e + 1
  });
  const i = new Uint8Array(e);
  return i.fill(0), i.set(n, e - n.length), et(i);
}
function Yu(r, e) {
  return TK(r, e);
}
const Yv = BigInt(0), Ql = BigInt(1), ed = 9007199254740991;
function qE(r, e) {
  const t = Qv(r, "value"), n = BigInt(Wi(e, "width"));
  if (Qt(t >> n === Yv, "overflow", "NUMERIC_FAULT", {
    operation: "fromTwos",
    fault: "overflow",
    value: r
  }), t >> n - Ql) {
    const i = (Ql << n) - Ql;
    return -((~t & i) + Ql);
  }
  return t;
}
function cO(r, e) {
  const t = Qv(r, "value"), n = BigInt(Wi(e, "bits"));
  return t & (Ql << n) - Ql;
}
function Dr(r, e) {
  switch (typeof r) {
    case "bigint":
      return r;
    case "number":
      return _e(Number.isInteger(r), "underflow", e || "value", r), _e(r >= -ed && r <= ed, "overflow", e || "value", r), BigInt(r);
    case "string":
      try {
        if (r === "")
          throw new Error("empty string");
        return r[0] === "-" && r[1] !== "-" ? -BigInt(r.substring(1)) : BigInt(r);
      } catch (t) {
        _e(!1, `invalid BigNumberish string: ${t.message}`, e || "value", r);
      }
  }
  _e(!1, "invalid BigNumberish value", e || "value", r);
}
function Qv(r, e) {
  const t = Dr(r, e);
  return Qt(t >= Yv, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value: r
  }), t;
}
const uO = "0123456789abcdef";
function kK(r) {
  if (r instanceof Uint8Array) {
    let e = "0x0";
    for (const t of r)
      e += uO[t >> 4], e += uO[t & 15];
    return BigInt(e);
  }
  return Dr(r);
}
function Wi(r, e) {
  switch (typeof r) {
    case "bigint":
      return _e(r >= -ed && r <= ed, "overflow", e || "value", r), Number(r);
    case "number":
      return _e(Number.isInteger(r), "underflow", e || "value", r), _e(r >= -ed && r <= ed, "overflow", e || "value", r), r;
    case "string":
      try {
        if (r === "")
          throw new Error("empty string");
        return Wi(BigInt(r), e);
      } catch (t) {
        _e(!1, `invalid numeric string: ${t.message}`, e || "value", r);
      }
  }
  _e(!1, "invalid numeric value", e || "value", r);
}
function lO(r, e) {
  const t = Qv(r, "value");
  let n = t.toString(16);
  {
    const i = Wi(e, "width");
    if (i === 0 && t === Yv)
      return "0x";
    for (Qt(i * 2 >= n.length, `value exceeds width (${i} bytes)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: r
    }); n.length < i * 2; )
      n = "0" + n;
  }
  return "0x" + n;
}
function en(r, e) {
  const t = Qv(r, "value");
  if (t === Yv)
    return new Uint8Array(0);
  let n = t.toString(16);
  n.length % 2 && (n = "0" + n);
  const i = new Uint8Array(n.length / 2);
  for (let s = 0; s < i.length; s++) {
    const o = s * 2;
    i[s] = parseInt(n.substring(o, o + 2), 16);
  }
  return i;
}
const OK = BigInt(-1), is = BigInt(0), td = BigInt(1), $K = BigInt(5), Il = {};
let gd = "0000";
for (; gd.length < 80; )
  gd += gd;
function Pc(r) {
  let e = gd;
  for (; e.length < r; )
    e += e;
  return BigInt("1" + e.substring(0, r));
}
function Lf(r, e, t) {
  const n = BigInt(e.width);
  if (e.signed) {
    const i = td << n - td;
    Qt(t == null || r >= -i && r < i, "overflow", "NUMERIC_FAULT", {
      operation: t,
      fault: "overflow",
      value: r
    }), r > is ? r = qE(cO(r, n), n) : r = -qE(cO(-r, n), n);
  } else {
    const i = td << n;
    Qt(t == null || r >= 0 && r < i, "overflow", "NUMERIC_FAULT", {
      operation: t,
      fault: "overflow",
      value: r
    }), r = (r % i + i) % i & i - td;
  }
  return r;
}
function Yw(r) {
  typeof r == "number" && (r = `fixed128x${r}`);
  let e = !0, t = 128, n = 18;
  if (typeof r == "string") {
    if (r !== "fixed") if (r === "ufixed")
      e = !1;
    else {
      const s = r.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
      _e(s, "invalid fixed format", "format", r), e = s[1] !== "u", t = parseInt(s[2]), n = parseInt(s[3]);
    }
  } else if (r) {
    const s = r, o = (a, c, u) => s[a] == null ? u : (_e(typeof s[a] === c, "invalid fixed format (" + a + " not " + c + ")", "format." + a, s[a]), s[a]);
    e = o("signed", "boolean", e), t = o("width", "number", t), n = o("decimals", "number", n);
  }
  _e(t % 8 === 0, "invalid FixedNumber width (not byte aligned)", "format.width", t), _e(n <= 80, "invalid FixedNumber decimals (too large)", "format.decimals", n);
  const i = (e ? "" : "u") + "fixed" + String(t) + "x" + String(n);
  return { signed: e, width: t, decimals: n, name: i };
}
function RK(r, e) {
  let t = "";
  r < is && (t = "-", r *= OK);
  let n = r.toString();
  if (e === 0)
    return t + n;
  for (; n.length <= e; )
    n = gd + n;
  const i = n.length - e;
  for (n = n.substring(0, i) + "." + n.substring(i); n[0] === "0" && n[1] !== "."; )
    n = n.substring(1);
  for (; n[n.length - 1] === "0" && n[n.length - 2] !== "."; )
    n = n.substring(0, n.length - 1);
  return t + n;
}
var ys, kt, En, xt, Mc, Bo, ZE, JE, XE, YE;
const Ra = class Ra {
  // Use this when changing this file to get some typing info,
  // but then switch to any to mask the internal type
  //constructor(guard: any, value: bigint, format: _FixedFormat) {
  /**
   *  @private
   */
  constructor(e, t, n) {
    L(this, xt);
    /**
     *  The specific fixed-point arithmetic field for this value.
     */
    h(this, "format");
    L(this, ys);
    // The actual value (accounting for decimals)
    L(this, kt);
    // A base-10 value to multiple values by to maintain the magnitude
    L(this, En);
    /**
     *  This is a property so console.log shows a human-meaningful value.
     *
     *  @private
     */
    h(this, "_value");
    EM(e, Il, "FixedNumber"), D(this, kt, t), D(this, ys, n);
    const i = RK(t, n.decimals);
    KE(this, { format: n.name, _value: i }), D(this, En, Pc(n.decimals));
  }
  /**
   *  If true, negative values are permitted, otherwise only
   *  positive values and zero are allowed.
   */
  get signed() {
    return m(this, ys).signed;
  }
  /**
   *  The number of bits available to store the value.
   */
  get width() {
    return m(this, ys).width;
  }
  /**
   *  The number of decimal places in the fixed-point arithment field.
   */
  get decimals() {
    return m(this, ys).decimals;
  }
  /**
   *  The value as an integer, based on the smallest unit the
   *  [[decimals]] allow.
   */
  get value() {
    return m(this, kt);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% added
   *  to %%other%%, ignoring overflow.
   */
  addUnsafe(e) {
    return R(this, xt, ZE).call(this, e);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% added
   *  to %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  add(e) {
    return R(this, xt, ZE).call(this, e, "add");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
   *  from %%this%%, ignoring overflow.
   */
  subUnsafe(e) {
    return R(this, xt, JE).call(this, e);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
   *  from %%this%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  sub(e) {
    return R(this, xt, JE).call(this, e, "sub");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%, ignoring overflow and underflow (precision loss).
   */
  mulUnsafe(e) {
    return R(this, xt, XE).call(this, e);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  mul(e) {
    return R(this, xt, XE).call(this, e, "mul");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs or if underflow (precision loss) occurs.
   */
  mulSignal(e) {
    R(this, xt, Mc).call(this, e);
    const t = m(this, kt) * m(e, kt);
    return Qt(t % m(this, En) === is, "precision lost during signalling mul", "NUMERIC_FAULT", {
      operation: "mulSignal",
      fault: "underflow",
      value: this
    }), R(this, xt, Bo).call(this, t / m(this, En), "mulSignal");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%, ignoring underflow (precision loss). A
   *  [[NumericFaultError]] is thrown if overflow occurs.
   */
  divUnsafe(e) {
    return R(this, xt, YE).call(this, e);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%, ignoring underflow (precision loss). A
   *  [[NumericFaultError]] is thrown if overflow occurs.
   */
  div(e) {
    return R(this, xt, YE).call(this, e, "div");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%. A [[NumericFaultError]] is thrown if underflow
   *  (precision loss) occurs.
   */
  divSignal(e) {
    Qt(m(e, kt) !== is, "division by zero", "NUMERIC_FAULT", {
      operation: "div",
      fault: "divide-by-zero",
      value: this
    }), R(this, xt, Mc).call(this, e);
    const t = m(this, kt) * m(this, En);
    return Qt(t % m(e, kt) === is, "precision lost during signalling div", "NUMERIC_FAULT", {
      operation: "divSignal",
      fault: "underflow",
      value: this
    }), R(this, xt, Bo).call(this, t / m(e, kt), "divSignal");
  }
  /**
   *  Returns a comparison result between %%this%% and %%other%%.
   *
   *  This is suitable for use in sorting, where ``-1`` implies %%this%%
   *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies
   *  both are equal.
   */
  cmp(e) {
    let t = this.value, n = e.value;
    const i = this.decimals - e.decimals;
    return i > 0 ? n *= Pc(i) : i < 0 && (t *= Pc(-i)), t < n ? -1 : t > n ? 1 : 0;
  }
  /**
   *  Returns true if %%other%% is equal to %%this%%.
   */
  eq(e) {
    return this.cmp(e) === 0;
  }
  /**
   *  Returns true if %%other%% is less than to %%this%%.
   */
  lt(e) {
    return this.cmp(e) < 0;
  }
  /**
   *  Returns true if %%other%% is less than or equal to %%this%%.
   */
  lte(e) {
    return this.cmp(e) <= 0;
  }
  /**
   *  Returns true if %%other%% is greater than to %%this%%.
   */
  gt(e) {
    return this.cmp(e) > 0;
  }
  /**
   *  Returns true if %%other%% is greater than or equal to %%this%%.
   */
  gte(e) {
    return this.cmp(e) >= 0;
  }
  /**
   *  Returns a new [[FixedNumber]] which is the largest **integer**
   *  that is less than or equal to %%this%%.
   *
   *  The decimal component of the result will always be ``0``.
   */
  floor() {
    let e = m(this, kt);
    return m(this, kt) < is && (e -= m(this, En) - td), e = m(this, kt) / m(this, En) * m(this, En), R(this, xt, Bo).call(this, e, "floor");
  }
  /**
   *  Returns a new [[FixedNumber]] which is the smallest **integer**
   *  that is greater than or equal to %%this%%.
   *
   *  The decimal component of the result will always be ``0``.
   */
  ceiling() {
    let e = m(this, kt);
    return m(this, kt) > is && (e += m(this, En) - td), e = m(this, kt) / m(this, En) * m(this, En), R(this, xt, Bo).call(this, e, "ceiling");
  }
  /**
   *  Returns a new [[FixedNumber]] with the decimal component
   *  rounded up on ties at %%decimals%% places.
   */
  round(e) {
    if (e == null && (e = 0), e >= this.decimals)
      return this;
    const t = this.decimals - e, n = $K * Pc(t - 1);
    let i = this.value + n;
    const s = Pc(t);
    return i = i / s * s, Lf(i, m(this, ys), "round"), new Ra(Il, i, m(this, ys));
  }
  /**
   *  Returns true if %%this%% is equal to ``0``.
   */
  isZero() {
    return m(this, kt) === is;
  }
  /**
   *  Returns true if %%this%% is less than ``0``.
   */
  isNegative() {
    return m(this, kt) < is;
  }
  /**
   *  Returns the string representation of %%this%%.
   */
  toString() {
    return this._value;
  }
  /**
   *  Returns a float approximation.
   *
   *  Due to IEEE 754 precission (or lack thereof), this function
   *  can only return an approximation and most values will contain
   *  rounding errors.
   */
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  /**
   *  Return a new [[FixedNumber]] with the same value but has had
   *  its field set to %%format%%.
   *
   *  This will throw if the value cannot fit into %%format%%.
   */
  toFormat(e) {
    return Ra.fromString(this.toString(), e);
  }
  /**
   *  Creates a new [[FixedNumber]] for %%value%% divided by
   *  %%decimal%% places with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted
   *  for %%decimals%%) cannot fit in %%format%%, either due to overflow
   *  or underflow (precision loss).
   */
  static fromValue(e, t, n) {
    const i = t == null ? 0 : Wi(t), s = Yw(n);
    let o = Dr(e, "value");
    const a = i - s.decimals;
    if (a > 0) {
      const c = Pc(a);
      Qt(o % c === is, "value loses precision for format", "NUMERIC_FAULT", {
        operation: "fromValue",
        fault: "underflow",
        value: e
      }), o /= c;
    } else a < 0 && (o *= Pc(-a));
    return Lf(o, s, "fromValue"), new Ra(Il, o, s);
  }
  /**
   *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
   *  in %%format%%, either due to overflow or underflow (precision loss).
   */
  static fromString(e, t) {
    const n = e.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
    _e(n && n[2].length + n[3].length > 0, "invalid FixedNumber string value", "value", e);
    const i = Yw(t);
    let s = n[2] || "0", o = n[3] || "";
    for (; o.length < i.decimals; )
      o += gd;
    Qt(o.substring(i.decimals).match(/^0*$/), "too many decimals for format", "NUMERIC_FAULT", {
      operation: "fromString",
      fault: "underflow",
      value: e
    }), o = o.substring(0, i.decimals);
    const a = BigInt(n[1] + s + o);
    return Lf(a, i, "fromString"), new Ra(Il, a, i);
  }
  /**
   *  Creates a new [[FixedNumber]] with the big-endian representation
   *  %%value%% with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
   *  in %%format%% due to overflow.
   */
  static fromBytes(e, t) {
    let n = kK(Ut(e, "value"));
    const i = Yw(t);
    return i.signed && (n = qE(n, i.width)), Lf(n, i, "fromBytes"), new Ra(Il, n, i);
  }
};
ys = new WeakMap(), kt = new WeakMap(), En = new WeakMap(), xt = new WeakSet(), Mc = function(e) {
  _e(this.format === e.format, "incompatible format; use fixedNumber.toFormat", "other", e);
}, Bo = function(e, t) {
  return e = Lf(e, m(this, ys), t), new Ra(Il, e, m(this, ys));
}, ZE = function(e, t) {
  return R(this, xt, Mc).call(this, e), R(this, xt, Bo).call(this, m(this, kt) + m(e, kt), t);
}, JE = function(e, t) {
  return R(this, xt, Mc).call(this, e), R(this, xt, Bo).call(this, m(this, kt) - m(e, kt), t);
}, XE = function(e, t) {
  return R(this, xt, Mc).call(this, e), R(this, xt, Bo).call(this, m(this, kt) * m(e, kt) / m(this, En), t);
}, YE = function(e, t) {
  return Qt(m(e, kt) !== is, "division by zero", "NUMERIC_FAULT", {
    operation: "div",
    fault: "divide-by-zero",
    value: this
  }), R(this, xt, Mc).call(this, e), R(this, xt, Bo).call(this, m(this, kt) * m(this, En) / m(e, kt), t);
};
let WE = Ra;
function PK(r) {
  let e = r.toString(16);
  for (; e.length < 2; )
    e = "0" + e;
  return "0x" + e;
}
function dO(r, e, t) {
  let n = 0;
  for (let i = 0; i < t; i++)
    n = n * 256 + r[e + i];
  return n;
}
function hO(r, e, t, n) {
  const i = [];
  for (; t < e + 1 + n; ) {
    const s = AM(r, t);
    i.push(s.result), t += s.consumed, Qt(t <= e + 1 + n, "child data too short", "BUFFER_OVERRUN", {
      buffer: r,
      length: n,
      offset: e
    });
  }
  return { consumed: 1 + n, result: i };
}
function AM(r, e) {
  Qt(r.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: r,
    length: 0,
    offset: 1
  });
  const t = (n) => {
    Qt(n <= r.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: r,
      length: r.length,
      offset: n
    });
  };
  if (r[e] >= 248) {
    const n = r[e] - 247;
    t(e + 1 + n);
    const i = dO(r, e + 1, n);
    return t(e + 1 + n + i), hO(r, e, e + 1 + n, n + i);
  } else if (r[e] >= 192) {
    const n = r[e] - 192;
    return t(e + 1 + n), hO(r, e, e + 1, n);
  } else if (r[e] >= 184) {
    const n = r[e] - 183;
    t(e + 1 + n);
    const i = dO(r, e + 1, n);
    t(e + 1 + n + i);
    const s = et(r.slice(e + 1 + n, e + 1 + n + i));
    return { consumed: 1 + n + i, result: s };
  } else if (r[e] >= 128) {
    const n = r[e] - 128;
    t(e + 1 + n);
    const i = et(r.slice(e + 1, e + 1 + n));
    return { consumed: 1 + n, result: i };
  }
  return { consumed: 1, result: PK(r[e]) };
}
function Wg(r) {
  const e = Ut(r, "data"), t = AM(e, 0);
  return _e(t.consumed === e.length, "unexpected junk after rlp payload", "data", r), t.result;
}
function fO(r) {
  const e = [];
  for (; r; )
    e.unshift(r & 255), r >>= 8;
  return e;
}
function IM(r) {
  if (Array.isArray(r)) {
    let n = [];
    if (r.forEach(function(s) {
      n = n.concat(IM(s));
    }), n.length <= 55)
      return n.unshift(192 + n.length), n;
    const i = fO(n.length);
    return i.unshift(247 + i.length), i.concat(n);
  }
  const e = Array.prototype.slice.call(Ut(r, "object"));
  if (e.length === 1 && e[0] <= 127)
    return e;
  if (e.length <= 55)
    return e.unshift(128 + e.length), e;
  const t = fO(e.length);
  return t.unshift(183 + t.length), t.concat(e);
}
const pO = "0123456789abcdef";
function uc(r) {
  let e = "0x";
  for (const t of IM(r))
    e += pO[t >> 4], e += pO[t & 15];
  return e;
}
function NK(r, e) {
  let t = 18;
  return t = Wi(e, "unit"), WE.fromValue(r, t, { decimals: t, width: 512 }).toString();
}
function BK(r) {
  return NK(r, 18);
}
function My(r) {
  if (!Number.isSafeInteger(r) || r < 0)
    throw new Error(`Wrong positive integer: ${r}`);
}
function rC(r, ...e) {
  if (!(r instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (e.length > 0 && !e.includes(r.length))
    throw new Error(`Expected Uint8Array of length ${e}, not of length=${r.length}`);
}
function LK(r) {
  if (typeof r != "function" || typeof r.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  My(r.outputLen), My(r.blockLen);
}
function Mh(r, e = !0) {
  if (r.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && r.finished)
    throw new Error("Hash#digest() has already been called");
}
function CM(r, e) {
  rC(r);
  const t = e.outputLen;
  if (r.length < t)
    throw new Error(`digestInto() expects output buffer of length at least ${t}`);
}
const Qw = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const DM = (r) => r instanceof Uint8Array, UK = (r) => new Uint32Array(r.buffer, r.byteOffset, Math.floor(r.byteLength / 4)), e_ = (r) => new DataView(r.buffer, r.byteOffset, r.byteLength), Ms = (r, e) => r << 32 - e | r >>> e, FK = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!FK)
  throw new Error("Non little-endian hardware is not supported");
function MK(r) {
  if (typeof r != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof r}`);
  return new Uint8Array(new TextEncoder().encode(r));
}
function e0(r) {
  if (typeof r == "string" && (r = MK(r)), !DM(r))
    throw new Error(`expected Uint8Array, got ${typeof r}`);
  return r;
}
function VK(...r) {
  const e = new Uint8Array(r.reduce((n, i) => n + i.length, 0));
  let t = 0;
  return r.forEach((n) => {
    if (!DM(n))
      throw new Error("Uint8Array expected");
    e.set(n, t), t += n.length;
  }), e;
}
let nC = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function iC(r) {
  const e = (n) => r().update(e0(n)).digest(), t = r();
  return e.outputLen = t.outputLen, e.blockLen = t.blockLen, e.create = () => r(), e;
}
function zK(r = 32) {
  if (Qw && typeof Qw.getRandomValues == "function")
    return Qw.getRandomValues(new Uint8Array(r));
  throw new Error("crypto.getRandomValues must be defined");
}
let TM = class extends nC {
  constructor(e, t) {
    super(), this.finished = !1, this.destroyed = !1, LK(e);
    const n = e0(t);
    if (this.iHash = e.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const i = this.blockLen, s = new Uint8Array(i);
    s.set(n.length > i ? e.create().update(n).digest() : n);
    for (let o = 0; o < s.length; o++)
      s[o] ^= 54;
    this.iHash.update(s), this.oHash = e.create();
    for (let o = 0; o < s.length; o++)
      s[o] ^= 106;
    this.oHash.update(s), s.fill(0);
  }
  update(e) {
    return Mh(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    Mh(this), rC(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: t, iHash: n, finished: i, destroyed: s, blockLen: o, outputLen: a } = this;
    return e = e, e.finished = i, e.destroyed = s, e.blockLen = o, e.outputLen = a, e.oHash = t._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const kM = (r, e, t) => new TM(r, e).update(t).digest();
kM.create = (r, e) => new TM(r, e);
function jK(r, e, t, n) {
  if (typeof r.setBigUint64 == "function")
    return r.setBigUint64(e, t, n);
  const i = BigInt(32), s = BigInt(4294967295), o = Number(t >> i & s), a = Number(t & s), c = n ? 4 : 0, u = n ? 0 : 4;
  r.setUint32(e + c, o, n), r.setUint32(e + u, a, n);
}
class OM extends nC {
  constructor(e, t, n, i) {
    super(), this.blockLen = e, this.outputLen = t, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = e_(this.buffer);
  }
  update(e) {
    Mh(this);
    const { view: t, buffer: n, blockLen: i } = this;
    e = e0(e);
    const s = e.length;
    for (let o = 0; o < s; ) {
      const a = Math.min(i - this.pos, s - o);
      if (a === i) {
        const c = e_(e);
        for (; i <= s - o; o += i)
          this.process(c, o);
        continue;
      }
      n.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === i && (this.process(t, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Mh(this), CM(e, this), this.finished = !0;
    const { buffer: t, view: n, blockLen: i, isLE: s } = this;
    let { pos: o } = this;
    t[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > i - o && (this.process(n, 0), o = 0);
    for (let d = o; d < i; d++)
      t[d] = 0;
    jK(n, i - 8, BigInt(this.length * 8), s), this.process(n, 0);
    const a = e_(e), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4, l = this.get();
    if (u > l.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let d = 0; d < u; d++)
      a.setUint32(4 * d, l[d], s);
  }
  digest() {
    const { buffer: e, outputLen: t } = this;
    this.digestInto(e);
    const n = e.slice(0, t);
    return this.destroy(), n;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: t, buffer: n, length: i, finished: s, destroyed: o, pos: a } = this;
    return e.length = i, e.pos = a, e.finished = s, e.destroyed = o, i % t && e.buffer.set(n), e;
  }
}
const HK = (r, e, t) => r & e ^ ~r & t, GK = (r, e, t) => r & e ^ r & t ^ e & t, KK = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), va = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), ba = /* @__PURE__ */ new Uint32Array(64);
let qK = class extends OM {
  constructor() {
    super(64, 32, 8, !1), this.A = va[0] | 0, this.B = va[1] | 0, this.C = va[2] | 0, this.D = va[3] | 0, this.E = va[4] | 0, this.F = va[5] | 0, this.G = va[6] | 0, this.H = va[7] | 0;
  }
  get() {
    const { A: e, B: t, C: n, D: i, E: s, F: o, G: a, H: c } = this;
    return [e, t, n, i, s, o, a, c];
  }
  // prettier-ignore
  set(e, t, n, i, s, o, a, c) {
    this.A = e | 0, this.B = t | 0, this.C = n | 0, this.D = i | 0, this.E = s | 0, this.F = o | 0, this.G = a | 0, this.H = c | 0;
  }
  process(e, t) {
    for (let d = 0; d < 16; d++, t += 4)
      ba[d] = e.getUint32(t, !1);
    for (let d = 16; d < 64; d++) {
      const f = ba[d - 15], p = ba[d - 2], y = Ms(f, 7) ^ Ms(f, 18) ^ f >>> 3, g = Ms(p, 17) ^ Ms(p, 19) ^ p >>> 10;
      ba[d] = g + ba[d - 7] + y + ba[d - 16] | 0;
    }
    let { A: n, B: i, C: s, D: o, E: a, F: c, G: u, H: l } = this;
    for (let d = 0; d < 64; d++) {
      const f = Ms(a, 6) ^ Ms(a, 11) ^ Ms(a, 25), p = l + f + HK(a, c, u) + KK[d] + ba[d] | 0, g = (Ms(n, 2) ^ Ms(n, 13) ^ Ms(n, 22)) + GK(n, i, s) | 0;
      l = u, u = c, c = a, a = o + p | 0, o = s, s = i, i = n, n = p + g | 0;
    }
    n = n + this.A | 0, i = i + this.B | 0, s = s + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, u = u + this.G | 0, l = l + this.H | 0, this.set(n, i, s, o, a, c, u, l);
  }
  roundClean() {
    ba.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
const sC = /* @__PURE__ */ iC(() => new qK()), xm = /* @__PURE__ */ BigInt(2 ** 32 - 1), QE = /* @__PURE__ */ BigInt(32);
function $M(r, e = !1) {
  return e ? { h: Number(r & xm), l: Number(r >> QE & xm) } : { h: Number(r >> QE & xm) | 0, l: Number(r & xm) | 0 };
}
function RM(r, e = !1) {
  let t = new Uint32Array(r.length), n = new Uint32Array(r.length);
  for (let i = 0; i < r.length; i++) {
    const { h: s, l: o } = $M(r[i], e);
    [t[i], n[i]] = [s, o];
  }
  return [t, n];
}
const WK = (r, e) => BigInt(r >>> 0) << QE | BigInt(e >>> 0), ZK = (r, e, t) => r >>> t, JK = (r, e, t) => r << 32 - t | e >>> t, XK = (r, e, t) => r >>> t | e << 32 - t, YK = (r, e, t) => r << 32 - t | e >>> t, QK = (r, e, t) => r << 64 - t | e >>> t - 32, eq = (r, e, t) => r >>> t - 32 | e << 64 - t, tq = (r, e) => e, rq = (r, e) => r, PM = (r, e, t) => r << t | e >>> 32 - t, NM = (r, e, t) => e << t | r >>> 32 - t, BM = (r, e, t) => e << t - 32 | r >>> 64 - t, LM = (r, e, t) => r << t - 32 | e >>> 64 - t;
function nq(r, e, t, n) {
  const i = (e >>> 0) + (n >>> 0);
  return { h: r + t + (i / 2 ** 32 | 0) | 0, l: i | 0 };
}
const iq = (r, e, t) => (r >>> 0) + (e >>> 0) + (t >>> 0), sq = (r, e, t, n) => e + t + n + (r / 2 ** 32 | 0) | 0, oq = (r, e, t, n) => (r >>> 0) + (e >>> 0) + (t >>> 0) + (n >>> 0), aq = (r, e, t, n, i) => e + t + n + i + (r / 2 ** 32 | 0) | 0, cq = (r, e, t, n, i) => (r >>> 0) + (e >>> 0) + (t >>> 0) + (n >>> 0) + (i >>> 0), uq = (r, e, t, n, i, s) => e + t + n + i + s + (r / 2 ** 32 | 0) | 0, Qe = {
  fromBig: $M,
  split: RM,
  toBig: WK,
  shrSH: ZK,
  shrSL: JK,
  rotrSH: XK,
  rotrSL: YK,
  rotrBH: QK,
  rotrBL: eq,
  rotr32H: tq,
  rotr32L: rq,
  rotlSH: PM,
  rotlSL: NM,
  rotlBH: BM,
  rotlBL: LM,
  add: nq,
  add3L: iq,
  add3H: sq,
  add4L: oq,
  add4H: aq,
  add5H: uq,
  add5L: cq
}, [lq, dq] = Qe.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((r) => BigInt(r))), wa = /* @__PURE__ */ new Uint32Array(80), _a = /* @__PURE__ */ new Uint32Array(80);
let hq = class extends OM {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: e, Al: t, Bh: n, Bl: i, Ch: s, Cl: o, Dh: a, Dl: c, Eh: u, El: l, Fh: d, Fl: f, Gh: p, Gl: y, Hh: g, Hl: v } = this;
    return [e, t, n, i, s, o, a, c, u, l, d, f, p, y, g, v];
  }
  // prettier-ignore
  set(e, t, n, i, s, o, a, c, u, l, d, f, p, y, g, v) {
    this.Ah = e | 0, this.Al = t | 0, this.Bh = n | 0, this.Bl = i | 0, this.Ch = s | 0, this.Cl = o | 0, this.Dh = a | 0, this.Dl = c | 0, this.Eh = u | 0, this.El = l | 0, this.Fh = d | 0, this.Fl = f | 0, this.Gh = p | 0, this.Gl = y | 0, this.Hh = g | 0, this.Hl = v | 0;
  }
  process(e, t) {
    for (let E = 0; E < 16; E++, t += 4)
      wa[E] = e.getUint32(t), _a[E] = e.getUint32(t += 4);
    for (let E = 16; E < 80; E++) {
      const I = wa[E - 15] | 0, S = _a[E - 15] | 0, T = Qe.rotrSH(I, S, 1) ^ Qe.rotrSH(I, S, 8) ^ Qe.shrSH(I, S, 7), b = Qe.rotrSL(I, S, 1) ^ Qe.rotrSL(I, S, 8) ^ Qe.shrSL(I, S, 7), C = wa[E - 2] | 0, P = _a[E - 2] | 0, Z = Qe.rotrSH(C, P, 19) ^ Qe.rotrBH(C, P, 61) ^ Qe.shrSH(C, P, 6), Y = Qe.rotrSL(C, P, 19) ^ Qe.rotrBL(C, P, 61) ^ Qe.shrSL(C, P, 6), q = Qe.add4L(b, Y, _a[E - 7], _a[E - 16]), J = Qe.add4H(q, T, Z, wa[E - 7], wa[E - 16]);
      wa[E] = J | 0, _a[E] = q | 0;
    }
    let { Ah: n, Al: i, Bh: s, Bl: o, Ch: a, Cl: c, Dh: u, Dl: l, Eh: d, El: f, Fh: p, Fl: y, Gh: g, Gl: v, Hh: _, Hl: w } = this;
    for (let E = 0; E < 80; E++) {
      const I = Qe.rotrSH(d, f, 14) ^ Qe.rotrSH(d, f, 18) ^ Qe.rotrBH(d, f, 41), S = Qe.rotrSL(d, f, 14) ^ Qe.rotrSL(d, f, 18) ^ Qe.rotrBL(d, f, 41), T = d & p ^ ~d & g, b = f & y ^ ~f & v, C = Qe.add5L(w, S, b, dq[E], _a[E]), P = Qe.add5H(C, _, I, T, lq[E], wa[E]), Z = C | 0, Y = Qe.rotrSH(n, i, 28) ^ Qe.rotrBH(n, i, 34) ^ Qe.rotrBH(n, i, 39), q = Qe.rotrSL(n, i, 28) ^ Qe.rotrBL(n, i, 34) ^ Qe.rotrBL(n, i, 39), J = n & s ^ n & a ^ s & a, O = i & o ^ i & c ^ o & c;
      _ = g | 0, w = v | 0, g = p | 0, v = y | 0, p = d | 0, y = f | 0, { h: d, l: f } = Qe.add(u | 0, l | 0, P | 0, Z | 0), u = a | 0, l = c | 0, a = s | 0, c = o | 0, s = n | 0, o = i | 0;
      const x = Qe.add3L(Z, q, O);
      n = Qe.add3H(x, P, Y, J), i = x | 0;
    }
    ({ h: n, l: i } = Qe.add(this.Ah | 0, this.Al | 0, n | 0, i | 0)), { h: s, l: o } = Qe.add(this.Bh | 0, this.Bl | 0, s | 0, o | 0), { h: a, l: c } = Qe.add(this.Ch | 0, this.Cl | 0, a | 0, c | 0), { h: u, l } = Qe.add(this.Dh | 0, this.Dl | 0, u | 0, l | 0), { h: d, l: f } = Qe.add(this.Eh | 0, this.El | 0, d | 0, f | 0), { h: p, l: y } = Qe.add(this.Fh | 0, this.Fl | 0, p | 0, y | 0), { h: g, l: v } = Qe.add(this.Gh | 0, this.Gl | 0, g | 0, v | 0), { h: _, l: w } = Qe.add(this.Hh | 0, this.Hl | 0, _ | 0, w | 0), this.set(n, i, s, o, a, c, u, l, d, f, p, y, g, v, _, w);
  }
  roundClean() {
    wa.fill(0), _a.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
const UM = /* @__PURE__ */ iC(() => new hq());
function fq() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
  throw new Error("unable to locate global object");
}
const gO = fq();
gO.crypto || gO.msCrypto;
function pq(r) {
  switch (r) {
    case "sha256":
      return sC.create();
    case "sha512":
      return UM.create();
  }
  _e(!1, "invalid hashing algorithm name", "algorithm", r);
}
const [FM, MM, VM] = [[], [], []], gq = /* @__PURE__ */ BigInt(0), Uf = /* @__PURE__ */ BigInt(1), mq = /* @__PURE__ */ BigInt(2), yq = /* @__PURE__ */ BigInt(7), vq = /* @__PURE__ */ BigInt(256), bq = /* @__PURE__ */ BigInt(113);
for (let r = 0, e = Uf, t = 1, n = 0; r < 24; r++) {
  [t, n] = [n, (2 * t + 3 * n) % 5], FM.push(2 * (5 * n + t)), MM.push((r + 1) * (r + 2) / 2 % 64);
  let i = gq;
  for (let s = 0; s < 7; s++)
    e = (e << Uf ^ (e >> yq) * bq) % vq, e & mq && (i ^= Uf << (Uf << /* @__PURE__ */ BigInt(s)) - Uf);
  VM.push(i);
}
const [wq, _q] = /* @__PURE__ */ RM(VM, !0), mO = (r, e, t) => t > 32 ? BM(r, e, t) : PM(r, e, t), yO = (r, e, t) => t > 32 ? LM(r, e, t) : NM(r, e, t);
function Sq(r, e = 24) {
  const t = new Uint32Array(10);
  for (let n = 24 - e; n < 24; n++) {
    for (let o = 0; o < 10; o++)
      t[o] = r[o] ^ r[o + 10] ^ r[o + 20] ^ r[o + 30] ^ r[o + 40];
    for (let o = 0; o < 10; o += 2) {
      const a = (o + 8) % 10, c = (o + 2) % 10, u = t[c], l = t[c + 1], d = mO(u, l, 1) ^ t[a], f = yO(u, l, 1) ^ t[a + 1];
      for (let p = 0; p < 50; p += 10)
        r[o + p] ^= d, r[o + p + 1] ^= f;
    }
    let i = r[2], s = r[3];
    for (let o = 0; o < 24; o++) {
      const a = MM[o], c = mO(i, s, a), u = yO(i, s, a), l = FM[o];
      i = r[l], s = r[l + 1], r[l] = c, r[l + 1] = u;
    }
    for (let o = 0; o < 50; o += 10) {
      for (let a = 0; a < 10; a++)
        t[a] = r[o + a];
      for (let a = 0; a < 10; a++)
        r[o + a] ^= ~t[(a + 2) % 10] & t[(a + 4) % 10];
    }
    r[0] ^= wq[n], r[1] ^= _q[n];
  }
  t.fill(0);
}
class oC extends nC {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(e, t, n, i = !1, s = 24) {
    if (super(), this.blockLen = e, this.suffix = t, this.outputLen = n, this.enableXOF = i, this.rounds = s, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, My(n), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = UK(this.state);
  }
  keccak() {
    Sq(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    Mh(this);
    const { blockLen: t, state: n } = this;
    e = e0(e);
    const i = e.length;
    for (let s = 0; s < i; ) {
      const o = Math.min(t - this.pos, i - s);
      for (let a = 0; a < o; a++)
        n[this.pos++] ^= e[s++];
      this.pos === t && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: e, suffix: t, pos: n, blockLen: i } = this;
    e[n] ^= t, (t & 128) !== 0 && n === i - 1 && this.keccak(), e[i - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    Mh(this, !1), rC(e), this.finish();
    const t = this.state, { blockLen: n } = this;
    for (let i = 0, s = e.length; i < s; ) {
      this.posOut >= n && this.keccak();
      const o = Math.min(n - this.posOut, s - i);
      e.set(t.subarray(this.posOut, this.posOut + o), i), this.posOut += o, i += o;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return My(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (CM(e, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(e) {
    const { blockLen: t, suffix: n, outputLen: i, rounds: s, enableXOF: o } = this;
    return e || (e = new oC(t, n, i, o, s)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = s, e.suffix = n, e.outputLen = i, e.enableXOF = o, e.destroyed = this.destroyed, e;
  }
}
const Eq = (r, e, t) => iC(() => new oC(e, r, t)), zM = /* @__PURE__ */ Eq(1, 136, 256 / 8);
let jM = !1;
const HM = function(r) {
  return zM(r);
};
let GM = HM;
function bc(r) {
  const e = Ut(r, "data");
  return et(GM(e));
}
bc._ = HM;
bc.lock = function() {
  jM = !0;
};
bc.register = function(r) {
  if (jM)
    throw new TypeError("keccak256 is locked");
  GM = r;
};
Object.freeze(bc);
const KM = function(r) {
  return pq("sha256").update(r).digest();
};
let qM = KM, WM = !1;
function ga(r) {
  const e = Ut(r, "data");
  return et(qM(e));
}
ga._ = KM;
ga.lock = function() {
  WM = !0;
};
ga.register = function(r) {
  if (WM)
    throw new Error("sha256 is locked");
  qM = r;
};
Object.freeze(ga);
Object.freeze(ga);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
BigInt(0);
const xq = BigInt(1), Aq = BigInt(2), t0 = (r) => r instanceof Uint8Array, Iq = /* @__PURE__ */ Array.from({ length: 256 }, (r, e) => e.toString(16).padStart(2, "0"));
function Vh(r) {
  if (!t0(r))
    throw new Error("Uint8Array expected");
  let e = "";
  for (let t = 0; t < r.length; t++)
    e += Iq[r[t]];
  return e;
}
function aC(r) {
  if (typeof r != "string")
    throw new Error("hex string expected, got " + typeof r);
  return BigInt(r === "" ? "0" : `0x${r}`);
}
function Vp(r) {
  if (typeof r != "string")
    throw new Error("hex string expected, got " + typeof r);
  const e = r.length;
  if (e % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + e);
  const t = new Uint8Array(e / 2);
  for (let n = 0; n < t.length; n++) {
    const i = n * 2, s = r.slice(i, i + 2), o = Number.parseInt(s, 16);
    if (Number.isNaN(o) || o < 0)
      throw new Error("Invalid byte sequence");
    t[n] = o;
  }
  return t;
}
function $u(r) {
  return aC(Vh(r));
}
function cC(r) {
  if (!t0(r))
    throw new Error("Uint8Array expected");
  return aC(Vh(Uint8Array.from(r).reverse()));
}
function zh(r, e) {
  return Vp(r.toString(16).padStart(e * 2, "0"));
}
function uC(r, e) {
  return zh(r, e).reverse();
}
function as(r, e, t) {
  let n;
  if (typeof e == "string")
    try {
      n = Vp(e);
    } catch (s) {
      throw new Error(`${r} must be valid hex string, got "${e}". Cause: ${s}`);
    }
  else if (t0(e))
    n = Uint8Array.from(e);
  else
    throw new Error(`${r} must be hex string or Uint8Array`);
  const i = n.length;
  if (typeof t == "number" && i !== t)
    throw new Error(`${r} expected ${t} bytes, got ${i}`);
  return n;
}
function zp(...r) {
  const e = new Uint8Array(r.reduce((n, i) => n + i.length, 0));
  let t = 0;
  return r.forEach((n) => {
    if (!t0(n))
      throw new Error("Uint8Array expected");
    e.set(n, t), t += n.length;
  }), e;
}
const lC = (r) => (Aq << BigInt(r - 1)) - xq, t_ = (r) => new Uint8Array(r), vO = (r) => Uint8Array.from(r);
function ZM(r, e, t) {
  if (typeof r != "number" || r < 2)
    throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2)
    throw new Error("qByteLen must be a number");
  if (typeof t != "function")
    throw new Error("hmacFn must be a function");
  let n = t_(r), i = t_(r), s = 0;
  const o = () => {
    n.fill(1), i.fill(0), s = 0;
  }, a = (...d) => t(i, n, ...d), c = (d = t_()) => {
    i = a(vO([0]), d), n = a(), d.length !== 0 && (i = a(vO([1]), d), n = a());
  }, u = () => {
    if (s++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let d = 0;
    const f = [];
    for (; d < e; ) {
      n = a();
      const p = n.slice();
      f.push(p), d += n.length;
    }
    return zp(...f);
  };
  return (d, f) => {
    o(), c(d);
    let p;
    for (; !(p = f(u())); )
      c();
    return o(), p;
  };
}
const Cq = {
  bigint: (r) => typeof r == "bigint",
  function: (r) => typeof r == "function",
  boolean: (r) => typeof r == "boolean",
  string: (r) => typeof r == "string",
  stringOrUint8Array: (r) => typeof r == "string" || r instanceof Uint8Array,
  isSafeInteger: (r) => Number.isSafeInteger(r),
  array: (r) => Array.isArray(r),
  field: (r, e) => e.Fp.isValid(r),
  hash: (r) => typeof r == "function" && Number.isSafeInteger(r.outputLen)
};
function Zg(r, e, t = {}) {
  const n = (i, s, o) => {
    const a = Cq[s];
    if (typeof a != "function")
      throw new Error(`Invalid validator "${s}", expected function`);
    const c = r[i];
    if (!(o && c === void 0) && !a(c, r))
      throw new Error(`Invalid param ${String(i)}=${c} (${typeof c}), expected ${s}`);
  };
  for (const [i, s] of Object.entries(e))
    n(i, s, !1);
  for (const [i, s] of Object.entries(t))
    n(i, s, !0);
  return r;
}
const Dq = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitMask: lC,
  bytesToHex: Vh,
  bytesToNumberBE: $u,
  bytesToNumberLE: cC,
  concatBytes: zp,
  createHmacDrbg: ZM,
  ensureBytes: as,
  hexToBytes: Vp,
  hexToNumber: aC,
  numberToBytesBE: zh,
  numberToBytesLE: uC,
  validateObject: Zg
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Vr = BigInt(0), hr = BigInt(1), Gc = BigInt(2), Tq = BigInt(3), ex = BigInt(4), bO = BigInt(5), wO = BigInt(8);
BigInt(9);
BigInt(16);
function qn(r, e) {
  const t = r % e;
  return t >= Vr ? t : e + t;
}
function kq(r, e, t) {
  if (t <= Vr || e < Vr)
    throw new Error("Expected power/modulo > 0");
  if (t === hr)
    return Vr;
  let n = hr;
  for (; e > Vr; )
    e & hr && (n = n * r % t), r = r * r % t, e >>= hr;
  return n;
}
function Pi(r, e, t) {
  let n = r;
  for (; e-- > Vr; )
    n *= n, n %= t;
  return n;
}
function tx(r, e) {
  if (r === Vr || e <= Vr)
    throw new Error(`invert: expected positive integers, got n=${r} mod=${e}`);
  let t = qn(r, e), n = e, i = Vr, s = hr;
  for (; t !== Vr; ) {
    const a = n / t, c = n % t, u = i - s * a;
    n = t, t = c, i = s, s = u;
  }
  if (n !== hr)
    throw new Error("invert: does not exist");
  return qn(i, e);
}
function Oq(r) {
  const e = (r - hr) / Gc;
  let t, n, i;
  for (t = r - hr, n = 0; t % Gc === Vr; t /= Gc, n++)
    ;
  for (i = Gc; i < r && kq(i, e, r) !== r - hr; i++)
    ;
  if (n === 1) {
    const o = (r + hr) / ex;
    return function(c, u) {
      const l = c.pow(u, o);
      if (!c.eql(c.sqr(l), u))
        throw new Error("Cannot find square root");
      return l;
    };
  }
  const s = (t + hr) / Gc;
  return function(a, c) {
    if (a.pow(c, e) === a.neg(a.ONE))
      throw new Error("Cannot find square root");
    let u = n, l = a.pow(a.mul(a.ONE, i), t), d = a.pow(c, s), f = a.pow(c, t);
    for (; !a.eql(f, a.ONE); ) {
      if (a.eql(f, a.ZERO))
        return a.ZERO;
      let p = 1;
      for (let g = a.sqr(f); p < u && !a.eql(g, a.ONE); p++)
        g = a.sqr(g);
      const y = a.pow(l, hr << BigInt(u - p - 1));
      l = a.sqr(y), d = a.mul(d, y), f = a.mul(f, l), u = p;
    }
    return d;
  };
}
function $q(r) {
  if (r % ex === Tq) {
    const e = (r + hr) / ex;
    return function(n, i) {
      const s = n.pow(i, e);
      if (!n.eql(n.sqr(s), i))
        throw new Error("Cannot find square root");
      return s;
    };
  }
  if (r % wO === bO) {
    const e = (r - bO) / wO;
    return function(n, i) {
      const s = n.mul(i, Gc), o = n.pow(s, e), a = n.mul(i, o), c = n.mul(n.mul(a, Gc), o), u = n.mul(a, n.sub(c, n.ONE));
      if (!n.eql(n.sqr(u), i))
        throw new Error("Cannot find square root");
      return u;
    };
  }
  return Oq(r);
}
const Rq = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function Pq(r) {
  const e = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, t = Rq.reduce((n, i) => (n[i] = "function", n), e);
  return Zg(r, t);
}
function Nq(r, e, t) {
  if (t < Vr)
    throw new Error("Expected power > 0");
  if (t === Vr)
    return r.ONE;
  if (t === hr)
    return e;
  let n = r.ONE, i = e;
  for (; t > Vr; )
    t & hr && (n = r.mul(n, i)), i = r.sqr(i), t >>= hr;
  return n;
}
function Bq(r, e) {
  const t = new Array(e.length), n = e.reduce((s, o, a) => r.is0(o) ? s : (t[a] = s, r.mul(s, o)), r.ONE), i = r.inv(n);
  return e.reduceRight((s, o, a) => r.is0(o) ? s : (t[a] = r.mul(s, t[a]), r.mul(s, o)), i), t;
}
function JM(r, e) {
  const t = e !== void 0 ? e : r.toString(2).length, n = Math.ceil(t / 8);
  return { nBitLength: t, nByteLength: n };
}
function Lq(r, e, t = !1, n = {}) {
  if (r <= Vr)
    throw new Error(`Expected Field ORDER > 0, got ${r}`);
  const { nBitLength: i, nByteLength: s } = JM(r, e);
  if (s > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const o = $q(r), a = Object.freeze({
    ORDER: r,
    BITS: i,
    BYTES: s,
    MASK: lC(i),
    ZERO: Vr,
    ONE: hr,
    create: (c) => qn(c, r),
    isValid: (c) => {
      if (typeof c != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);
      return Vr <= c && c < r;
    },
    is0: (c) => c === Vr,
    isOdd: (c) => (c & hr) === hr,
    neg: (c) => qn(-c, r),
    eql: (c, u) => c === u,
    sqr: (c) => qn(c * c, r),
    add: (c, u) => qn(c + u, r),
    sub: (c, u) => qn(c - u, r),
    mul: (c, u) => qn(c * u, r),
    pow: (c, u) => Nq(a, c, u),
    div: (c, u) => qn(c * tx(u, r), r),
    // Same as above, but doesn't normalize
    sqrN: (c) => c * c,
    addN: (c, u) => c + u,
    subN: (c, u) => c - u,
    mulN: (c, u) => c * u,
    inv: (c) => tx(c, r),
    sqrt: n.sqrt || ((c) => o(a, c)),
    invertBatch: (c) => Bq(a, c),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (c, u, l) => l ? u : c,
    toBytes: (c) => t ? uC(c, s) : zh(c, s),
    fromBytes: (c) => {
      if (c.length !== s)
        throw new Error(`Fp.fromBytes: expected ${s}, got ${c.length}`);
      return t ? cC(c) : $u(c);
    }
  });
  return Object.freeze(a);
}
function XM(r) {
  if (typeof r != "bigint")
    throw new Error("field order must be bigint");
  const e = r.toString(2).length;
  return Math.ceil(e / 8);
}
function YM(r) {
  const e = XM(r);
  return e + Math.ceil(e / 2);
}
function Uq(r, e, t = !1) {
  const n = r.length, i = XM(e), s = YM(e);
  if (n < 16 || n < s || n > 1024)
    throw new Error(`expected ${s}-1024 bytes of input, got ${n}`);
  const o = t ? $u(r) : cC(r), a = qn(o, e - hr) + hr;
  return t ? uC(a, i) : zh(a, i);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Fq = BigInt(0), r_ = BigInt(1);
function Mq(r, e) {
  const t = (i, s) => {
    const o = s.negate();
    return i ? o : s;
  }, n = (i) => {
    const s = Math.ceil(e / i) + 1, o = 2 ** (i - 1);
    return { windows: s, windowSize: o };
  };
  return {
    constTimeNegate: t,
    // non-const time multiplication ladder
    unsafeLadder(i, s) {
      let o = r.ZERO, a = i;
      for (; s > Fq; )
        s & r_ && (o = o.add(a)), a = a.double(), s >>= r_;
      return o;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(i, s) {
      const { windows: o, windowSize: a } = n(s), c = [];
      let u = i, l = u;
      for (let d = 0; d < o; d++) {
        l = u, c.push(l);
        for (let f = 1; f < a; f++)
          l = l.add(u), c.push(l);
        u = l.double();
      }
      return c;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(i, s, o) {
      const { windows: a, windowSize: c } = n(i);
      let u = r.ZERO, l = r.BASE;
      const d = BigInt(2 ** i - 1), f = 2 ** i, p = BigInt(i);
      for (let y = 0; y < a; y++) {
        const g = y * c;
        let v = Number(o & d);
        o >>= p, v > c && (v -= f, o += r_);
        const _ = g, w = g + Math.abs(v) - 1, E = y % 2 !== 0, I = v < 0;
        v === 0 ? l = l.add(t(E, s[_])) : u = u.add(t(I, s[w]));
      }
      return { p: u, f: l };
    },
    wNAFCached(i, s, o, a) {
      const c = i._WINDOW_SIZE || 1;
      let u = s.get(i);
      return u || (u = this.precomputeWindow(i, c), c !== 1 && s.set(i, a(u))), this.wNAF(c, u, o);
    }
  };
}
function QM(r) {
  return Pq(r.Fp), Zg(r, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...JM(r.n, r.nBitLength),
    ...r,
    p: r.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function Vq(r) {
  const e = QM(r);
  Zg(e, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: t, Fp: n, a: i } = e;
  if (t) {
    if (!n.eql(i, n.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof t != "object" || typeof t.beta != "bigint" || typeof t.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...e });
}
const { bytesToNumberBE: zq, hexToBytes: jq } = Dq, Xc = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(e = "") {
      super(e);
    }
  },
  _parseInt(r) {
    const { Err: e } = Xc;
    if (r.length < 2 || r[0] !== 2)
      throw new e("Invalid signature integer tag");
    const t = r[1], n = r.subarray(2, t + 2);
    if (!t || n.length !== t)
      throw new e("Invalid signature integer: wrong length");
    if (n[0] & 128)
      throw new e("Invalid signature integer: negative");
    if (n[0] === 0 && !(n[1] & 128))
      throw new e("Invalid signature integer: unnecessary leading zero");
    return { d: zq(n), l: r.subarray(t + 2) };
  },
  toSig(r) {
    const { Err: e } = Xc, t = typeof r == "string" ? jq(r) : r;
    if (!(t instanceof Uint8Array))
      throw new Error("ui8a expected");
    let n = t.length;
    if (n < 2 || t[0] != 48)
      throw new e("Invalid signature tag");
    if (t[1] !== n - 2)
      throw new e("Invalid signature: incorrect length");
    const { d: i, l: s } = Xc._parseInt(t.subarray(2)), { d: o, l: a } = Xc._parseInt(s);
    if (a.length)
      throw new e("Invalid signature: left bytes after parsing");
    return { r: i, s: o };
  },
  hexFromSig(r) {
    const e = (u) => Number.parseInt(u[0], 16) & 8 ? "00" + u : u, t = (u) => {
      const l = u.toString(16);
      return l.length & 1 ? `0${l}` : l;
    }, n = e(t(r.s)), i = e(t(r.r)), s = n.length / 2, o = i.length / 2, a = t(s), c = t(o);
    return `30${t(o + s + 4)}02${c}${i}02${a}${n}`;
  }
}, ra = BigInt(0), Vi = BigInt(1);
BigInt(2);
const _O = BigInt(3);
BigInt(4);
function Hq(r) {
  const e = Vq(r), { Fp: t } = e, n = e.toBytes || ((y, g, v) => {
    const _ = g.toAffine();
    return zp(Uint8Array.from([4]), t.toBytes(_.x), t.toBytes(_.y));
  }), i = e.fromBytes || ((y) => {
    const g = y.subarray(1), v = t.fromBytes(g.subarray(0, t.BYTES)), _ = t.fromBytes(g.subarray(t.BYTES, 2 * t.BYTES));
    return { x: v, y: _ };
  });
  function s(y) {
    const { a: g, b: v } = e, _ = t.sqr(y), w = t.mul(_, y);
    return t.add(t.add(w, t.mul(y, g)), v);
  }
  if (!t.eql(t.sqr(e.Gy), s(e.Gx)))
    throw new Error("bad generator point: equation left != right");
  function o(y) {
    return typeof y == "bigint" && ra < y && y < e.n;
  }
  function a(y) {
    if (!o(y))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function c(y) {
    const { allowedPrivateKeyLengths: g, nByteLength: v, wrapPrivateKey: _, n: w } = e;
    if (g && typeof y != "bigint") {
      if (y instanceof Uint8Array && (y = Vh(y)), typeof y != "string" || !g.includes(y.length))
        throw new Error("Invalid key");
      y = y.padStart(v * 2, "0");
    }
    let E;
    try {
      E = typeof y == "bigint" ? y : $u(as("private key", y, v));
    } catch {
      throw new Error(`private key must be ${v} bytes, hex or bigint, not ${typeof y}`);
    }
    return _ && (E = qn(E, w)), a(E), E;
  }
  const u = /* @__PURE__ */ new Map();
  function l(y) {
    if (!(y instanceof d))
      throw new Error("ProjectivePoint expected");
  }
  class d {
    constructor(g, v, _) {
      if (this.px = g, this.py = v, this.pz = _, g == null || !t.isValid(g))
        throw new Error("x required");
      if (v == null || !t.isValid(v))
        throw new Error("y required");
      if (_ == null || !t.isValid(_))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(g) {
      const { x: v, y: _ } = g || {};
      if (!g || !t.isValid(v) || !t.isValid(_))
        throw new Error("invalid affine point");
      if (g instanceof d)
        throw new Error("projective point not allowed");
      const w = (E) => t.eql(E, t.ZERO);
      return w(v) && w(_) ? d.ZERO : new d(v, _, t.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(g) {
      const v = t.invertBatch(g.map((_) => _.pz));
      return g.map((_, w) => _.toAffine(v[w])).map(d.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(g) {
      const v = d.fromAffine(i(as("pointHex", g)));
      return v.assertValidity(), v;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(g) {
      return d.BASE.multiply(c(g));
    }
    // "Private method", don't use it directly
    _setWindowSize(g) {
      this._WINDOW_SIZE = g, u.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (e.allowInfinityPoint && !t.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: g, y: v } = this.toAffine();
      if (!t.isValid(g) || !t.isValid(v))
        throw new Error("bad point: x or y not FE");
      const _ = t.sqr(v), w = s(g);
      if (!t.eql(_, w))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: g } = this.toAffine();
      if (t.isOdd)
        return !t.isOdd(g);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(g) {
      l(g);
      const { px: v, py: _, pz: w } = this, { px: E, py: I, pz: S } = g, T = t.eql(t.mul(v, S), t.mul(E, w)), b = t.eql(t.mul(_, S), t.mul(I, w));
      return T && b;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new d(this.px, t.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: g, b: v } = e, _ = t.mul(v, _O), { px: w, py: E, pz: I } = this;
      let S = t.ZERO, T = t.ZERO, b = t.ZERO, C = t.mul(w, w), P = t.mul(E, E), Z = t.mul(I, I), Y = t.mul(w, E);
      return Y = t.add(Y, Y), b = t.mul(w, I), b = t.add(b, b), S = t.mul(g, b), T = t.mul(_, Z), T = t.add(S, T), S = t.sub(P, T), T = t.add(P, T), T = t.mul(S, T), S = t.mul(Y, S), b = t.mul(_, b), Z = t.mul(g, Z), Y = t.sub(C, Z), Y = t.mul(g, Y), Y = t.add(Y, b), b = t.add(C, C), C = t.add(b, C), C = t.add(C, Z), C = t.mul(C, Y), T = t.add(T, C), Z = t.mul(E, I), Z = t.add(Z, Z), C = t.mul(Z, Y), S = t.sub(S, C), b = t.mul(Z, P), b = t.add(b, b), b = t.add(b, b), new d(S, T, b);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(g) {
      l(g);
      const { px: v, py: _, pz: w } = this, { px: E, py: I, pz: S } = g;
      let T = t.ZERO, b = t.ZERO, C = t.ZERO;
      const P = e.a, Z = t.mul(e.b, _O);
      let Y = t.mul(v, E), q = t.mul(_, I), J = t.mul(w, S), O = t.add(v, _), x = t.add(E, I);
      O = t.mul(O, x), x = t.add(Y, q), O = t.sub(O, x), x = t.add(v, w);
      let k = t.add(E, S);
      return x = t.mul(x, k), k = t.add(Y, J), x = t.sub(x, k), k = t.add(_, w), T = t.add(I, S), k = t.mul(k, T), T = t.add(q, J), k = t.sub(k, T), C = t.mul(P, x), T = t.mul(Z, J), C = t.add(T, C), T = t.sub(q, C), C = t.add(q, C), b = t.mul(T, C), q = t.add(Y, Y), q = t.add(q, Y), J = t.mul(P, J), x = t.mul(Z, x), q = t.add(q, J), J = t.sub(Y, J), J = t.mul(P, J), x = t.add(x, J), Y = t.mul(q, x), b = t.add(b, Y), Y = t.mul(k, x), T = t.mul(O, T), T = t.sub(T, Y), Y = t.mul(O, q), C = t.mul(k, C), C = t.add(C, Y), new d(T, b, C);
    }
    subtract(g) {
      return this.add(g.negate());
    }
    is0() {
      return this.equals(d.ZERO);
    }
    wNAF(g) {
      return p.wNAFCached(this, u, g, (v) => {
        const _ = t.invertBatch(v.map((w) => w.pz));
        return v.map((w, E) => w.toAffine(_[E])).map(d.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(g) {
      const v = d.ZERO;
      if (g === ra)
        return v;
      if (a(g), g === Vi)
        return this;
      const { endo: _ } = e;
      if (!_)
        return p.unsafeLadder(this, g);
      let { k1neg: w, k1: E, k2neg: I, k2: S } = _.splitScalar(g), T = v, b = v, C = this;
      for (; E > ra || S > ra; )
        E & Vi && (T = T.add(C)), S & Vi && (b = b.add(C)), C = C.double(), E >>= Vi, S >>= Vi;
      return w && (T = T.negate()), I && (b = b.negate()), b = new d(t.mul(b.px, _.beta), b.py, b.pz), T.add(b);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(g) {
      a(g);
      let v = g, _, w;
      const { endo: E } = e;
      if (E) {
        const { k1neg: I, k1: S, k2neg: T, k2: b } = E.splitScalar(v);
        let { p: C, f: P } = this.wNAF(S), { p: Z, f: Y } = this.wNAF(b);
        C = p.constTimeNegate(I, C), Z = p.constTimeNegate(T, Z), Z = new d(t.mul(Z.px, E.beta), Z.py, Z.pz), _ = C.add(Z), w = P.add(Y);
      } else {
        const { p: I, f: S } = this.wNAF(v);
        _ = I, w = S;
      }
      return d.normalizeZ([_, w])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(g, v, _) {
      const w = d.BASE, E = (S, T) => T === ra || T === Vi || !S.equals(w) ? S.multiplyUnsafe(T) : S.multiply(T), I = E(this, v).add(E(g, _));
      return I.is0() ? void 0 : I;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(g) {
      const { px: v, py: _, pz: w } = this, E = this.is0();
      g == null && (g = E ? t.ONE : t.inv(w));
      const I = t.mul(v, g), S = t.mul(_, g), T = t.mul(w, g);
      if (E)
        return { x: t.ZERO, y: t.ZERO };
      if (!t.eql(T, t.ONE))
        throw new Error("invZ was invalid");
      return { x: I, y: S };
    }
    isTorsionFree() {
      const { h: g, isTorsionFree: v } = e;
      if (g === Vi)
        return !0;
      if (v)
        return v(d, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: g, clearCofactor: v } = e;
      return g === Vi ? this : v ? v(d, this) : this.multiplyUnsafe(e.h);
    }
    toRawBytes(g = !0) {
      return this.assertValidity(), n(d, this, g);
    }
    toHex(g = !0) {
      return Vh(this.toRawBytes(g));
    }
  }
  d.BASE = new d(e.Gx, e.Gy, t.ONE), d.ZERO = new d(t.ZERO, t.ONE, t.ZERO);
  const f = e.nBitLength, p = Mq(d, e.endo ? Math.ceil(f / 2) : f);
  return {
    CURVE: e,
    ProjectivePoint: d,
    normPrivateKeyToScalar: c,
    weierstrassEquation: s,
    isWithinCurveOrder: o
  };
}
function Gq(r) {
  const e = QM(r);
  return Zg(e, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...e });
}
function Kq(r) {
  const e = Gq(r), { Fp: t, n } = e, i = t.BYTES + 1, s = 2 * t.BYTES + 1;
  function o(x) {
    return ra < x && x < t.ORDER;
  }
  function a(x) {
    return qn(x, n);
  }
  function c(x) {
    return tx(x, n);
  }
  const { ProjectivePoint: u, normPrivateKeyToScalar: l, weierstrassEquation: d, isWithinCurveOrder: f } = Hq({
    ...e,
    toBytes(x, k, B) {
      const A = k.toAffine(), K = t.toBytes(A.x), F = zp;
      return B ? F(Uint8Array.from([k.hasEvenY() ? 2 : 3]), K) : F(Uint8Array.from([4]), K, t.toBytes(A.y));
    },
    fromBytes(x) {
      const k = x.length, B = x[0], A = x.subarray(1);
      if (k === i && (B === 2 || B === 3)) {
        const K = $u(A);
        if (!o(K))
          throw new Error("Point is not on curve");
        const F = d(K);
        let j = t.sqrt(F);
        const re = (j & Vi) === Vi;
        return (B & 1) === 1 !== re && (j = t.neg(j)), { x: K, y: j };
      } else if (k === s && B === 4) {
        const K = t.fromBytes(A.subarray(0, t.BYTES)), F = t.fromBytes(A.subarray(t.BYTES, 2 * t.BYTES));
        return { x: K, y: F };
      } else
        throw new Error(`Point of length ${k} was invalid. Expected ${i} compressed bytes or ${s} uncompressed bytes`);
    }
  }), p = (x) => Vh(zh(x, e.nByteLength));
  function y(x) {
    const k = n >> Vi;
    return x > k;
  }
  function g(x) {
    return y(x) ? a(-x) : x;
  }
  const v = (x, k, B) => $u(x.slice(k, B));
  class _ {
    constructor(k, B, A) {
      this.r = k, this.s = B, this.recovery = A, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(k) {
      const B = e.nByteLength;
      return k = as("compactSignature", k, B * 2), new _(v(k, 0, B), v(k, B, 2 * B));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(k) {
      const { r: B, s: A } = Xc.toSig(as("DER", k));
      return new _(B, A);
    }
    assertValidity() {
      if (!f(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!f(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(k) {
      return new _(this.r, this.s, k);
    }
    recoverPublicKey(k) {
      const { r: B, s: A, recovery: K } = this, F = b(as("msgHash", k));
      if (K == null || ![0, 1, 2, 3].includes(K))
        throw new Error("recovery id invalid");
      const j = K === 2 || K === 3 ? B + e.n : B;
      if (j >= t.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const re = (K & 1) === 0 ? "02" : "03", z = u.fromHex(re + p(j)), ce = c(j), he = a(-F * ce), de = a(A * ce), xe = u.BASE.multiplyAndAddUnsafe(z, he, de);
      if (!xe)
        throw new Error("point at infinify");
      return xe.assertValidity(), xe;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return y(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new _(this.r, a(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return Vp(this.toDERHex());
    }
    toDERHex() {
      return Xc.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return Vp(this.toCompactHex());
    }
    toCompactHex() {
      return p(this.r) + p(this.s);
    }
  }
  const w = {
    isValidPrivateKey(x) {
      try {
        return l(x), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: l,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const x = YM(e.n);
      return Uq(e.randomBytes(x), e.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(x = 8, k = u.BASE) {
      return k._setWindowSize(x), k.multiply(BigInt(3)), k;
    }
  };
  function E(x, k = !0) {
    return u.fromPrivateKey(x).toRawBytes(k);
  }
  function I(x) {
    const k = x instanceof Uint8Array, B = typeof x == "string", A = (k || B) && x.length;
    return k ? A === i || A === s : B ? A === 2 * i || A === 2 * s : x instanceof u;
  }
  function S(x, k, B = !0) {
    if (I(x))
      throw new Error("first arg must be private key");
    if (!I(k))
      throw new Error("second arg must be public key");
    return u.fromHex(k).multiply(l(x)).toRawBytes(B);
  }
  const T = e.bits2int || function(x) {
    const k = $u(x), B = x.length * 8 - e.nBitLength;
    return B > 0 ? k >> BigInt(B) : k;
  }, b = e.bits2int_modN || function(x) {
    return a(T(x));
  }, C = lC(e.nBitLength);
  function P(x) {
    if (typeof x != "bigint")
      throw new Error("bigint expected");
    if (!(ra <= x && x < C))
      throw new Error(`bigint expected < 2^${e.nBitLength}`);
    return zh(x, e.nByteLength);
  }
  function Z(x, k, B = Y) {
    if (["recovered", "canonical"].some((Se) => Se in B))
      throw new Error("sign() legacy options not supported");
    const { hash: A, randomBytes: K } = e;
    let { lowS: F, prehash: j, extraEntropy: re } = B;
    F == null && (F = !0), x = as("msgHash", x), j && (x = as("prehashed msgHash", A(x)));
    const z = b(x), ce = l(k), he = [P(ce), P(z)];
    if (re != null) {
      const Se = re === !0 ? K(t.BYTES) : re;
      he.push(as("extraEntropy", Se));
    }
    const de = zp(...he), xe = z;
    function Ze(Se) {
      const be = T(Se);
      if (!f(be))
        return;
      const Ie = c(be), Re = u.BASE.multiply(be).toAffine(), Ue = a(Re.x);
      if (Ue === ra)
        return;
      const Xe = a(Ie * a(xe + Ue * ce));
      if (Xe === ra)
        return;
      let vt = (Re.x === Ue ? 0 : 2) | Number(Re.y & Vi), at = Xe;
      return F && y(Xe) && (at = g(Xe), vt ^= 1), new _(Ue, at, vt);
    }
    return { seed: de, k2sig: Ze };
  }
  const Y = { lowS: e.lowS, prehash: !1 }, q = { lowS: e.lowS, prehash: !1 };
  function J(x, k, B = Y) {
    const { seed: A, k2sig: K } = Z(x, k, B), F = e;
    return ZM(F.hash.outputLen, F.nByteLength, F.hmac)(A, K);
  }
  u.BASE._setWindowSize(8);
  function O(x, k, B, A = q) {
    var Re;
    const K = x;
    if (k = as("msgHash", k), B = as("publicKey", B), "strict" in A)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: F, prehash: j } = A;
    let re, z;
    try {
      if (typeof K == "string" || K instanceof Uint8Array)
        try {
          re = _.fromDER(K);
        } catch (Ue) {
          if (!(Ue instanceof Xc.Err))
            throw Ue;
          re = _.fromCompact(K);
        }
      else if (typeof K == "object" && typeof K.r == "bigint" && typeof K.s == "bigint") {
        const { r: Ue, s: Xe } = K;
        re = new _(Ue, Xe);
      } else
        throw new Error("PARSE");
      z = u.fromHex(B);
    } catch (Ue) {
      if (Ue.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (F && re.hasHighS())
      return !1;
    j && (k = e.hash(k));
    const { r: ce, s: he } = re, de = b(k), xe = c(he), Ze = a(de * xe), Se = a(ce * xe), be = (Re = u.BASE.multiplyAndAddUnsafe(z, Ze, Se)) == null ? void 0 : Re.toAffine();
    return be ? a(be.x) === ce : !1;
  }
  return {
    CURVE: e,
    getPublicKey: E,
    getSharedSecret: S,
    sign: J,
    verify: O,
    ProjectivePoint: u,
    Signature: _,
    utils: w
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function qq(r) {
  return {
    hash: r,
    hmac: (e, ...t) => kM(r, e, VK(...t)),
    randomBytes: zK
  };
}
function Wq(r, e) {
  const t = (n) => Kq({ ...r, ...qq(n) });
  return Object.freeze({ ...t(e), create: t });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const e3 = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), SO = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), Zq = BigInt(1), rx = BigInt(2), EO = (r, e) => (r + e / rx) / e;
function Jq(r) {
  const e = e3, t = BigInt(3), n = BigInt(6), i = BigInt(11), s = BigInt(22), o = BigInt(23), a = BigInt(44), c = BigInt(88), u = r * r * r % e, l = u * u * r % e, d = Pi(l, t, e) * l % e, f = Pi(d, t, e) * l % e, p = Pi(f, rx, e) * u % e, y = Pi(p, i, e) * p % e, g = Pi(y, s, e) * y % e, v = Pi(g, a, e) * g % e, _ = Pi(v, c, e) * v % e, w = Pi(_, a, e) * g % e, E = Pi(w, t, e) * l % e, I = Pi(E, o, e) * y % e, S = Pi(I, n, e) * u % e, T = Pi(S, rx, e);
  if (!nx.eql(nx.sqr(T), r))
    throw new Error("Cannot find square root");
  return T;
}
const nx = Lq(e3, void 0, void 0, { sqrt: Jq }), An = Wq({
  a: BigInt(0),
  b: BigInt(7),
  Fp: nx,
  n: SO,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: !0,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (r) => {
      const e = SO, t = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), n = -Zq * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), s = t, o = BigInt("0x100000000000000000000000000000000"), a = EO(s * r, e), c = EO(-n * r, e);
      let u = qn(r - a * t - c * i, e), l = qn(-a * n - c * s, e);
      const d = u > o, f = l > o;
      if (d && (u = e - u), f && (l = e - l), u > o || l > o)
        throw new Error("splitScalar: Endomorphism failed, k=" + r);
      return { k1neg: d, k1: u, k2neg: f, k2: l };
    }
  }
}, sC);
BigInt(0);
An.ProjectivePoint;
const t3 = "0x0000000000000000000000000000000000000000", xO = "0x0000000000000000000000000000000000000000000000000000000000000000", AO = BigInt(0), IO = BigInt(1), ix = BigInt(2), CO = BigInt(27), DO = BigInt(28), Am = BigInt(35), r3 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), Xq = r3 / ix, Yq = Symbol.for("nodejs.util.inspect.custom"), Nc = {};
function n_(r) {
  return Yu(en(r), 32);
}
var Zd, Js, Jd, qa, xn;
let So = (xn = class {
  /**
   *  @private
   */
  constructor(e, t, n, i) {
    L(this, Zd);
    L(this, Js);
    L(this, Jd);
    L(this, qa);
    EM(e, Nc, "Signature"), D(this, Zd, t), D(this, Js, n), D(this, Jd, i), D(this, qa, null);
  }
  /**
   *  The ``r`` value for a signature.
   *
   *  This represents the ``x`` coordinate of a "reference" or
   *  challenge point, from which the ``y`` can be computed.
   */
  get r() {
    return m(this, Zd);
  }
  set r(e) {
    _e(kp(e) === 32, "invalid r", "value", e), D(this, Zd, et(e));
  }
  /**
   *  The ``s`` value for a signature.
   */
  get s() {
    return _e(parseInt(m(this, Js).substring(0, 3)) < 8, "non-canonical s; use ._s", "s", m(this, Js)), m(this, Js);
  }
  set s(e) {
    _e(kp(e) === 32, "invalid s", "value", e), D(this, Js, et(e));
  }
  /**
   *  Return the s value, unchecked for EIP-2 compliance.
   *
   *  This should generally not be used and is for situations where
   *  a non-canonical S value might be relevant, such as Frontier blocks
   *  that were mined prior to EIP-2 or invalid Authorization List
   *  signatures.
   */
  get _s() {
    return m(this, Js);
  }
  /**
   *  Returns true if the Signature is valid for [[link-eip-2]] signatures.
   */
  isValid() {
    return BigInt(m(this, Js)) <= Xq;
  }
  /**
   *  The ``v`` value for a signature.
   *
   *  Since a given ``x`` value for ``r`` has two possible values for
   *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
   *  values to use.
   *
   *  It is normalized to the values ``27`` or ``28`` for legacy
   *  purposes.
   */
  get v() {
    return m(this, Jd);
  }
  set v(e) {
    const t = Wi(e, "value");
    _e(t === 27 || t === 28, "invalid v", "v", e), D(this, Jd, t);
  }
  /**
   *  The EIP-155 ``v`` for legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get networkV() {
    return m(this, qa);
  }
  /**
   *  The chain ID for EIP-155 legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get legacyChainId() {
    const e = this.networkV;
    return e == null ? null : xn.getChainId(e);
  }
  /**
   *  The ``yParity`` for the signature.
   *
   *  See ``v`` for more details on how this value is used.
   */
  get yParity() {
    return this.v === 27 ? 0 : 1;
  }
  /**
   *  The [[link-eip-2098]] compact representation of the ``yParity``
   *  and ``s`` compacted into a single ``bytes32``.
   */
  get yParityAndS() {
    const e = Ut(this.s);
    return this.yParity && (e[0] |= 128), et(e);
  }
  /**
   *  The [[link-eip-2098]] compact representation.
   */
  get compactSerialized() {
    return go([this.r, this.yParityAndS]);
  }
  /**
   *  The serialized representation.
   */
  get serialized() {
    return go([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
  }
  /**
   *  Returns the canonical signature.
   *
   *  This is only necessary when dealing with legacy transaction which
   *  did not enforce canonical S values (i.e. [[link-eip-2]]. Most
   *  developers should never require this.
   */
  getCanonical() {
    if (this.isValid())
      return this;
    const e = r3 - BigInt(this._s), t = 55 - this.v, n = new xn(Nc, this.r, n_(e), t);
    return this.networkV && D(n, qa, this.networkV), n;
  }
  /**
   *  Returns a new identical [[Signature]].
   */
  clone() {
    const e = new xn(Nc, this.r, this._s, this.v);
    return this.networkV && D(e, qa, this.networkV), e;
  }
  /**
   *  Returns a representation that is compatible with ``JSON.stringify``.
   */
  toJSON() {
    const e = this.networkV;
    return {
      _type: "signature",
      networkV: e != null ? e.toString() : null,
      r: this.r,
      s: this._s,
      v: this.v
    };
  }
  [Yq]() {
    return this.toString();
  }
  toString() {
    return this.isValid() ? `Signature { r: ${this.r}, s: ${this._s}, v: ${this.v} }` : `Signature { r: ${this.r}, s: ${this._s}, v: ${this.v}, valid: false }`;
  }
  /**
   *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
   *
   *  @example:
   *    Signature.getChainId(45)
   *    //_result:
   *
   *    Signature.getChainId(46)
   *    //_result:
   */
  static getChainId(e) {
    const t = Dr(e, "v");
    return t == CO || t == DO ? AO : (_e(t >= Am, "invalid EIP-155 v", "v", e), (t - Am) / ix);
  }
  /**
   *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
   *
   *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
   *  property to include the chain ID.
   *
   *  @example:
   *    Signature.getChainIdV(5, 27)
   *    //_result:
   *
   *    Signature.getChainIdV(5, 28)
   *    //_result:
   *
   */
  static getChainIdV(e, t) {
    return Dr(e) * ix + BigInt(35 + t - 27);
  }
  /**
   *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
   *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
   *
   *  @example:
   *    // The values 0 and 1 imply v is actually yParity
   *    Signature.getNormalizedV(0)
   *    //_result:
   *
   *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
   *    Signature.getNormalizedV(27)
   *    //_result:
   *
   *    // Legacy EIP-155 transaction (i.e. >= 35)
   *    Signature.getNormalizedV(46)
   *    //_result:
   *
   *    // Invalid values throw
   *    Signature.getNormalizedV(5)
   *    //_error:
   */
  static getNormalizedV(e) {
    const t = Dr(e);
    return t === AO || t === CO ? 27 : t === IO || t === DO ? 28 : (_e(t >= Am, "invalid v", "v", e), t & IO ? 27 : 28);
  }
  /**
   *  Creates a new [[Signature]].
   *
   *  If no %%sig%% is provided, a new [[Signature]] is created
   *  with default values.
   *
   *  If %%sig%% is a string, it is parsed.
   */
  static from(e) {
    function t(u, l) {
      _e(u, l, "signature", e);
    }
    if (e == null)
      return new xn(Nc, xO, xO, 27);
    if (typeof e == "string") {
      const u = Ut(e, "signature");
      if (u.length === 64) {
        const l = et(u.slice(0, 32)), d = u.slice(32, 64), f = d[0] & 128 ? 28 : 27;
        return d[0] &= 127, new xn(Nc, l, et(d), f);
      }
      if (u.length === 65) {
        const l = et(u.slice(0, 32)), d = et(u.slice(32, 64)), f = xn.getNormalizedV(u[64]);
        return new xn(Nc, l, d, f);
      }
      t(!1, "invalid raw signature length");
    }
    if (e instanceof xn)
      return e.clone();
    const n = e.r;
    t(n != null, "missing r");
    const i = n_(n), s = (function(u, l) {
      if (u != null)
        return n_(u);
      if (l != null) {
        t(vc(l, 32), "invalid yParityAndS");
        const d = Ut(l);
        return d[0] &= 127, et(d);
      }
      t(!1, "missing s");
    })(e.s, e.yParityAndS), { networkV: o, v: a } = (function(u, l, d) {
      if (u != null) {
        const f = Dr(u);
        return {
          networkV: f >= Am ? f : void 0,
          v: xn.getNormalizedV(f)
        };
      }
      if (l != null)
        return t(vc(l, 32), "invalid yParityAndS"), { v: Ut(l)[0] & 128 ? 28 : 27 };
      if (d != null) {
        switch (Wi(d, "sig.yParity")) {
          case 0:
            return { v: 27 };
          case 1:
            return { v: 28 };
        }
        t(!1, "invalid yParity");
      }
      t(!1, "missing v");
    })(e.v, e.yParityAndS, e.yParity), c = new xn(Nc, i, s, a);
    return o && D(c, qa, o), t(e.yParity == null || Wi(e.yParity, "sig.yParity") === c.yParity, "yParity mismatch"), t(e.yParityAndS == null || e.yParityAndS === c.yParityAndS, "yParityAndS mismatch"), c;
  }
}, Zd = new WeakMap(), Js = new WeakMap(), Jd = new WeakMap(), qa = new WeakMap(), xn);
var Yo, co;
let dC = (co = class {
  /**
   *  Creates a new **SigningKey** for %%privateKey%%.
   */
  constructor(e) {
    L(this, Yo);
    _e(kp(e) === 32, "invalid private key", "privateKey", "[REDACTED]"), D(this, Yo, et(e));
  }
  /**
   *  The private key.
   */
  get privateKey() {
    return m(this, Yo);
  }
  /**
   *  The uncompressed public key.
   *
   * This will always begin with the prefix ``0x04`` and be 132
   * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
   */
  get publicKey() {
    return co.computePublicKey(m(this, Yo));
  }
  /**
   *  The compressed public key.
   *
   *  This will always begin with either the prefix ``0x02`` or ``0x03``
   *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
   *  nibbles)
   */
  get compressedPublicKey() {
    return co.computePublicKey(m(this, Yo), !0);
  }
  /**
   *  Return the signature of the signed %%digest%%.
   */
  sign(e) {
    _e(kp(e) === 32, "invalid digest length", "digest", e);
    const t = An.sign(Bf(e), Bf(m(this, Yo)), {
      lowS: !0
    });
    return So.from({
      r: lO(t.r, 32),
      s: lO(t.s, 32),
      v: t.recovery ? 28 : 27
    });
  }
  /**
   *  Returns the [[link-wiki-ecdh]] shared secret between this
   *  private key and the %%other%% key.
   *
   *  The %%other%% key may be any type of key, a raw public key,
   *  a compressed/uncompressed pubic key or aprivate key.
   *
   *  Best practice is usually to use a cryptographic hash on the
   *  returned value before using it as a symetric secret.
   *
   *  @example:
   *    sign1 = new SigningKey(id("some-secret-1"))
   *    sign2 = new SigningKey(id("some-secret-2"))
   *
   *    // Notice that privA.computeSharedSecret(pubB)...
   *    sign1.computeSharedSecret(sign2.publicKey)
   *    //_result:
   *
   *    // ...is equal to privB.computeSharedSecret(pubA).
   *    sign2.computeSharedSecret(sign1.publicKey)
   *    //_result:
   */
  computeSharedSecret(e) {
    const t = co.computePublicKey(e);
    return et(An.getSharedSecret(Bf(m(this, Yo)), Ut(t), !1));
  }
  /**
   *  Compute the public key for %%key%%, optionally %%compressed%%.
   *
   *  The %%key%% may be any type of key, a raw public key, a
   *  compressed/uncompressed public key or private key.
   *
   *  @example:
   *    sign = new SigningKey(id("some-secret"));
   *
   *    // Compute the uncompressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey)
   *    //_result:
   *
   *    // Compute the compressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey, true)
   *    //_result:
   *
   *    // Compute the uncompressed public key
   *    SigningKey.computePublicKey(sign.publicKey, false);
   *    //_result:
   *
   *    // Compute the Compressed a public key
   *    SigningKey.computePublicKey(sign.publicKey, true);
   *    //_result:
   */
  static computePublicKey(e, t) {
    let n = Ut(e, "key");
    if (n.length === 32) {
      const s = An.getPublicKey(n, !!t);
      return et(s);
    }
    if (n.length === 64) {
      const s = new Uint8Array(65);
      s[0] = 4, s.set(n, 1), n = s;
    }
    const i = An.ProjectivePoint.fromHex(n);
    return et(i.toRawBytes(t));
  }
  /**
   *  Returns the public key for the private key which produced the
   *  %%signature%% for the given %%digest%%.
   *
   *  @example:
   *    key = new SigningKey(id("some-secret"))
   *    digest = id("hello world")
   *    sig = key.sign(digest)
   *
   *    // Notice the signer public key...
   *    key.publicKey
   *    //_result:
   *
   *    // ...is equal to the recovered public key
   *    SigningKey.recoverPublicKey(digest, sig)
   *    //_result:
   *
   */
  static recoverPublicKey(e, t) {
    _e(kp(e) === 32, "invalid digest length", "digest", e);
    const n = So.from(t);
    let i = An.Signature.fromCompact(Bf(go([n.r, n.s])));
    i = i.addRecoveryBit(n.yParity);
    const s = i.recoverPublicKey(Bf(e));
    return _e(s != null, "invalid signature for digest", "signature", t), "0x" + s.toHex(!1);
  }
  /**
   *  Returns the point resulting from adding the ellipic curve points
   *  %%p0%% and %%p1%%.
   *
   *  This is not a common function most developers should require, but
   *  can be useful for certain privacy-specific techniques.
   *
   *  For example, it is used by [[HDNodeWallet]] to compute child
   *  addresses from parent public keys and chain codes.
   */
  static addPoints(e, t, n) {
    const i = An.ProjectivePoint.fromHex(co.computePublicKey(e).substring(2)), s = An.ProjectivePoint.fromHex(co.computePublicKey(t).substring(2));
    return "0x" + i.add(s).toHex(!!n);
  }
}, Yo = new WeakMap(), co);
const Qq = BigInt(0), eW = BigInt(36);
function TO(r) {
  r = r.toLowerCase();
  const e = r.substring(2).split(""), t = new Uint8Array(40);
  for (let i = 0; i < 40; i++)
    t[i] = e[i].charCodeAt(0);
  const n = Ut(bc(t));
  for (let i = 0; i < 40; i += 2)
    n[i >> 1] >> 4 >= 8 && (e[i] = e[i].toUpperCase()), (n[i >> 1] & 15) >= 8 && (e[i + 1] = e[i + 1].toUpperCase());
  return "0x" + e.join("");
}
const hC = {};
for (let r = 0; r < 10; r++)
  hC[String(r)] = String(r);
for (let r = 0; r < 26; r++)
  hC[String.fromCharCode(65 + r)] = String(10 + r);
const kO = 15;
function tW(r) {
  r = r.toUpperCase(), r = r.substring(4) + r.substring(0, 2) + "00";
  let e = r.split("").map((n) => hC[n]).join("");
  for (; e.length >= kO; ) {
    let n = e.substring(0, kO);
    e = parseInt(n, 10) % 97 + e.substring(n.length);
  }
  let t = String(98 - parseInt(e, 10) % 97);
  for (; t.length < 2; )
    t = "0" + t;
  return t;
}
const rW = (function() {
  const r = {};
  for (let e = 0; e < 36; e++) {
    const t = "0123456789abcdefghijklmnopqrstuvwxyz"[e];
    r[t] = BigInt(e);
  }
  return r;
})();
function nW(r) {
  r = r.toLowerCase();
  let e = Qq;
  for (let t = 0; t < r.length; t++)
    e = e * eW + rW[r[t]];
  return e;
}
function Jg(r) {
  if (_e(typeof r == "string", "invalid address", "address", r), r.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    r.startsWith("0x") || (r = "0x" + r);
    const e = TO(r);
    return _e(!r.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || e === r, "bad address checksum", "address", r), e;
  }
  if (r.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    _e(r.substring(2, 4) === tW(r), "bad icap checksum", "address", r);
    let e = nW(r.substring(4)).toString(16);
    for (; e.length < 40; )
      e = "0" + e;
    return TO("0x" + e);
  }
  _e(!1, "invalid address", "address", r);
}
function i_(r, e) {
  return {
    address: Jg(r),
    storageKeys: e.map((t, n) => (_e(vc(t, 32), "invalid slot", `storageKeys[${n}]`, t), t.toLowerCase()))
  };
}
function fC(r) {
  if (Array.isArray(r))
    return r.map((t, n) => Array.isArray(t) ? (_e(t.length === 2, "invalid slot set", `value[${n}]`, t), i_(t[0], t[1])) : (_e(t != null && typeof t == "object", "invalid address-slot set", "value", r), i_(t.address, t.storageKeys)));
  _e(r != null && typeof r == "object", "invalid access list", "value", r);
  const e = Object.keys(r).map((t) => {
    const n = r[t].reduce((i, s) => (i[s] = !0, i), {});
    return i_(t, Object.keys(n).sort());
  });
  return e.sort((t, n) => t.address.localeCompare(n.address)), e;
}
function iW(r) {
  return {
    address: Jg(r.address),
    nonce: Dr(r.nonce != null ? r.nonce : 0),
    chainId: Dr(r.chainId != null ? r.chainId : 0),
    signature: So.from(r.signature)
  };
}
function sW(r) {
  let e;
  return typeof r == "string" ? e = dC.computePublicKey(r, !1) : e = r.publicKey, Jg(bc("0x" + e.substring(4)).substring(26));
}
function oW(r, e) {
  return sW(dC.recoverPublicKey(r, e));
}
const Fr = BigInt(0), aW = BigInt(2), cW = BigInt(27), uW = BigInt(28), lW = BigInt(35), dW = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), hW = Symbol.for("nodejs.util.inspect.custom"), s_ = 4096 * 32, fy = 128;
function fW(r) {
  return { blobToKzgCommitment: (n) => {
    if ("computeBlobProof" in r) {
      if ("blobToKzgCommitment" in r && typeof r.blobToKzgCommitment == "function")
        return Ut(r.blobToKzgCommitment(et(n)));
    } else if ("blobToKzgCommitment" in r && typeof r.blobToKzgCommitment == "function")
      return Ut(r.blobToKzgCommitment(n));
    if ("blobToKZGCommitment" in r && typeof r.blobToKZGCommitment == "function")
      return Ut(r.blobToKZGCommitment(et(n)));
    _e(!1, "unsupported KZG library", "kzg", r);
  }, computeBlobKzgProof: (n, i) => {
    if ("computeBlobProof" in r && typeof r.computeBlobProof == "function")
      return Ut(r.computeBlobProof(et(n), et(i)));
    if ("computeBlobKzgProof" in r && typeof r.computeBlobKzgProof == "function")
      return r.computeBlobKzgProof(n, i);
    if ("computeBlobKZGProof" in r && typeof r.computeBlobKZGProof == "function")
      return Ut(r.computeBlobKZGProof(et(n), et(i)));
    _e(!1, "unsupported KZG library", "kzg", r);
  } };
}
function OO(r, e) {
  let t = r.toString(16);
  for (; t.length < 2; )
    t = "0" + t;
  return t += ga(e).substring(4), "0x" + t;
}
function ff(r) {
  return r === "0x" ? null : Jg(r);
}
function r0(r, e) {
  try {
    return fC(r);
  } catch (t) {
    _e(!1, t.message, e, r);
  }
}
function pW(r, e) {
  try {
    if (!Array.isArray(r))
      throw new Error("authorizationList: invalid array");
    const t = [];
    for (let n = 0; n < r.length; n++) {
      const i = r[n];
      if (!Array.isArray(i))
        throw new Error(`authorization[${n}]: invalid array`);
      if (i.length !== 6)
        throw new Error(`authorization[${n}]: wrong length`);
      if (!i[1])
        throw new Error(`authorization[${n}]: null address`);
      t.push({
        address: ff(i[1]),
        nonce: $t(i[2], "nonce"),
        chainId: $t(i[0], "chainId"),
        signature: So.from({
          yParity: pl(i[3], "yParity"),
          r: Yu(i[4], 32),
          s: Yu(i[5], 32)
        })
      });
    }
    return t;
  } catch (t) {
    _e(!1, t.message, e, r);
  }
}
function pl(r, e) {
  return r === "0x" ? 0 : Wi(r, e);
}
function $t(r, e) {
  if (r === "0x")
    return Fr;
  const t = Dr(r, e);
  return _e(t <= dW, "value exceeds uint size", e, t), t;
}
function lt(r, e) {
  const t = Dr(r, "value"), n = en(t);
  return _e(n.length <= 32, "value too large", `tx.${e}`, t), n;
}
function n0(r) {
  return fC(r).map((e) => [e.address, e.storageKeys]);
}
function gW(r) {
  return r.map((e) => [
    lt(e.chainId, "chainId"),
    e.address,
    lt(e.nonce, "nonce"),
    lt(e.signature.yParity, "yParity"),
    en(e.signature.r),
    en(e.signature._s)
  ]);
}
function mW(r, e) {
  _e(Array.isArray(r), `invalid ${e}`, "value", r);
  for (let t = 0; t < r.length; t++)
    _e(vc(r[t], 32), "invalid ${ param } hash", `value[${t}]`, r[t]);
  return r;
}
function yW(r) {
  const e = Wg(r);
  _e(Array.isArray(e) && (e.length === 9 || e.length === 6), "invalid field count for legacy transaction", "data", r);
  const t = {
    type: 0,
    nonce: pl(e[0], "nonce"),
    gasPrice: $t(e[1], "gasPrice"),
    gasLimit: $t(e[2], "gasLimit"),
    to: ff(e[3]),
    value: $t(e[4], "value"),
    data: et(e[5]),
    chainId: Fr
  };
  if (e.length === 6)
    return t;
  const n = $t(e[6], "v"), i = $t(e[7], "r"), s = $t(e[8], "s");
  if (i === Fr && s === Fr)
    t.chainId = n;
  else {
    let o = (n - lW) / aW;
    o < Fr && (o = Fr), t.chainId = o, _e(o !== Fr || n === cW || n === uW, "non-canonical legacy v", "v", e[6]), t.signature = So.from({
      r: Yu(e[7], 32),
      s: Yu(e[8], 32),
      v: n
    });
  }
  return t;
}
function vW(r, e) {
  const t = [
    lt(r.nonce, "nonce"),
    lt(r.gasPrice || 0, "gasPrice"),
    lt(r.gasLimit, "gasLimit"),
    r.to || "0x",
    lt(r.value, "value"),
    r.data
  ];
  let n = Fr;
  if (r.chainId != Fr)
    n = Dr(r.chainId, "tx.chainId"), _e(!e || e.networkV == null || e.legacyChainId === n, "tx.chainId/sig.v mismatch", "sig", e);
  else if (r.signature) {
    const s = r.signature.legacyChainId;
    s != null && (n = s);
  }
  if (!e)
    return n !== Fr && (t.push(en(n)), t.push("0x"), t.push("0x")), uc(t);
  let i = BigInt(27 + e.yParity);
  return n !== Fr ? i = So.getChainIdV(n, e.v) : BigInt(e.v) !== i && _e(!1, "tx.chainId/sig.v mismatch", "sig", e), t.push(en(i)), t.push(en(e.r)), t.push(en(e._s)), uc(t);
}
function i0(r, e) {
  let t;
  try {
    if (t = pl(e[0], "yParity"), t !== 0 && t !== 1)
      throw new Error("bad yParity");
  } catch {
    _e(!1, "invalid yParity", "yParity", e[0]);
  }
  const n = Yu(e[1], 32), i = Yu(e[2], 32), s = So.from({ r: n, s: i, yParity: t });
  r.signature = s;
}
function bW(r) {
  const e = Wg(Ut(r).slice(1));
  _e(Array.isArray(e) && (e.length === 9 || e.length === 12), "invalid field count for transaction type: 2", "data", et(r));
  const t = {
    type: 2,
    chainId: $t(e[0], "chainId"),
    nonce: pl(e[1], "nonce"),
    maxPriorityFeePerGas: $t(e[2], "maxPriorityFeePerGas"),
    maxFeePerGas: $t(e[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: $t(e[4], "gasLimit"),
    to: ff(e[5]),
    value: $t(e[6], "value"),
    data: et(e[7]),
    accessList: r0(e[8], "accessList")
  };
  return e.length === 9 || i0(t, e.slice(9)), t;
}
function wW(r, e) {
  const t = [
    lt(r.chainId, "chainId"),
    lt(r.nonce, "nonce"),
    lt(r.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    lt(r.maxFeePerGas || 0, "maxFeePerGas"),
    lt(r.gasLimit, "gasLimit"),
    r.to || "0x",
    lt(r.value, "value"),
    r.data,
    n0(r.accessList || [])
  ];
  return e && (t.push(lt(e.yParity, "yParity")), t.push(en(e.r)), t.push(en(e.s))), go(["0x02", uc(t)]);
}
function _W(r) {
  const e = Wg(Ut(r).slice(1));
  _e(Array.isArray(e) && (e.length === 8 || e.length === 11), "invalid field count for transaction type: 1", "data", et(r));
  const t = {
    type: 1,
    chainId: $t(e[0], "chainId"),
    nonce: pl(e[1], "nonce"),
    gasPrice: $t(e[2], "gasPrice"),
    gasLimit: $t(e[3], "gasLimit"),
    to: ff(e[4]),
    value: $t(e[5], "value"),
    data: et(e[6]),
    accessList: r0(e[7], "accessList")
  };
  return e.length === 8 || i0(t, e.slice(8)), t;
}
function SW(r, e) {
  const t = [
    lt(r.chainId, "chainId"),
    lt(r.nonce, "nonce"),
    lt(r.gasPrice || 0, "gasPrice"),
    lt(r.gasLimit, "gasLimit"),
    r.to || "0x",
    lt(r.value, "value"),
    r.data,
    n0(r.accessList || [])
  ];
  return e && (t.push(lt(e.yParity, "recoveryParam")), t.push(en(e.r)), t.push(en(e.s))), go(["0x01", uc(t)]);
}
function EW(r) {
  let e = Wg(Ut(r).slice(1)), t = "3", n = null, i = null;
  if (e.length === 4 && Array.isArray(e[0])) {
    t = "3 (network format)";
    const o = e[1], a = e[2], c = e[3];
    _e(Array.isArray(o), "invalid network format: blobs not an array", "fields[1]", o), _e(Array.isArray(a), "invalid network format: commitments not an array", "fields[2]", a), _e(Array.isArray(c), "invalid network format: proofs not an array", "fields[3]", c), _e(o.length === a.length, "invalid network format: blobs/commitments length mismatch", "fields", e), _e(o.length === c.length, "invalid network format: blobs/proofs length mismatch", "fields", e), i = [];
    for (let u = 0; u < e[1].length; u++)
      i.push({
        data: o[u],
        commitment: a[u],
        proof: c[u]
      });
    e = e[0];
  } else if (e.length === 5 && Array.isArray(e[0])) {
    t = "3 (EIP-7594 network format)", n = Wi(e[1]);
    const o = e[2], a = e[3], c = e[4];
    _e(n === 1, `unsupported EIP-7594 network format version: ${n}`, "fields[1]", n), _e(Array.isArray(o), "invalid EIP-7594 network format: blobs not an array", "fields[2]", o), _e(Array.isArray(a), "invalid EIP-7594 network format: commitments not an array", "fields[3]", a), _e(Array.isArray(c), "invalid EIP-7594 network format: proofs not an array", "fields[4]", c), _e(o.length === a.length, "invalid network format: blobs/commitments length mismatch", "fields", e), _e(o.length * fy === c.length, "invalid network format: blobs/proofs length mismatch", "fields", e), i = [];
    for (let u = 0; u < o.length; u++) {
      const l = [];
      for (let d = 0; d < fy; d++)
        l.push(c[u * fy + d]);
      i.push({
        data: o[u],
        commitment: a[u],
        proof: go(l)
      });
    }
    e = e[0];
  }
  _e(Array.isArray(e) && (e.length === 11 || e.length === 14), `invalid field count for transaction type: ${t}`, "data", et(r));
  const s = {
    type: 3,
    chainId: $t(e[0], "chainId"),
    nonce: pl(e[1], "nonce"),
    maxPriorityFeePerGas: $t(e[2], "maxPriorityFeePerGas"),
    maxFeePerGas: $t(e[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: $t(e[4], "gasLimit"),
    to: ff(e[5]),
    value: $t(e[6], "value"),
    data: et(e[7]),
    accessList: r0(e[8], "accessList"),
    maxFeePerBlobGas: $t(e[9], "maxFeePerBlobGas"),
    blobVersionedHashes: e[10],
    blobWrapperVersion: n
  };
  i && (s.blobs = i), _e(s.to != null, `invalid address for transaction type: ${t}`, "data", r), _e(Array.isArray(s.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", r);
  for (let o = 0; o < s.blobVersionedHashes.length; o++)
    _e(vc(s.blobVersionedHashes[o], 32), `invalid blobVersionedHash at index ${o}: must be length 32`, "data", r);
  return e.length === 11 || i0(s, e.slice(11)), s;
}
function xW(r, e, t) {
  const n = [
    lt(r.chainId, "chainId"),
    lt(r.nonce, "nonce"),
    lt(r.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    lt(r.maxFeePerGas || 0, "maxFeePerGas"),
    lt(r.gasLimit, "gasLimit"),
    r.to || t3,
    lt(r.value, "value"),
    r.data,
    n0(r.accessList || []),
    lt(r.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
    mW(r.blobVersionedHashes || [], "blobVersionedHashes")
  ];
  if (e && (n.push(lt(e.yParity, "yParity")), n.push(en(e.r)), n.push(en(e.s)), t)) {
    if (r.blobWrapperVersion != null) {
      const i = en(r.blobWrapperVersion), s = [];
      for (const { proof: o } of t) {
        const a = Ut(o), c = a.length / fy;
        for (let u = 0; u < a.length; u += c)
          s.push(a.subarray(u, u + c));
      }
      return go([
        "0x03",
        uc([
          n,
          i,
          t.map((o) => o.data),
          t.map((o) => o.commitment),
          s
        ])
      ]);
    }
    return go([
      "0x03",
      uc([
        n,
        t.map((i) => i.data),
        t.map((i) => i.commitment),
        t.map((i) => i.proof)
      ])
    ]);
  }
  return go(["0x03", uc(n)]);
}
function AW(r) {
  const e = Wg(Ut(r).slice(1));
  _e(Array.isArray(e) && (e.length === 10 || e.length === 13), "invalid field count for transaction type: 4", "data", et(r));
  const t = {
    type: 4,
    chainId: $t(e[0], "chainId"),
    nonce: pl(e[1], "nonce"),
    maxPriorityFeePerGas: $t(e[2], "maxPriorityFeePerGas"),
    maxFeePerGas: $t(e[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: $t(e[4], "gasLimit"),
    to: ff(e[5]),
    value: $t(e[6], "value"),
    data: et(e[7]),
    accessList: r0(e[8], "accessList"),
    authorizationList: pW(e[9], "authorizationList")
  };
  return e.length === 10 || i0(t, e.slice(10)), t;
}
function IW(r, e) {
  const t = [
    lt(r.chainId, "chainId"),
    lt(r.nonce, "nonce"),
    lt(r.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    lt(r.maxFeePerGas || 0, "maxFeePerGas"),
    lt(r.gasLimit, "gasLimit"),
    r.to || "0x",
    lt(r.value, "value"),
    r.data,
    n0(r.accessList || []),
    gW(r.authorizationList || [])
  ];
  return e && (t.push(lt(e.yParity, "yParity")), t.push(en(e.r)), t.push(en(e.s))), go(["0x04", uc(t)]);
}
var vs, Xd, Yd, Qd, eh, th, rh, nh, ih, sh, oh, ah, _u, Wa, Xs, Za, ch, uh, lh, py, Ei;
let s0 = (Ei = class {
  /**
   *  Creates a new Transaction with default values.
   */
  constructor() {
    L(this, lh);
    L(this, vs);
    L(this, Xd);
    L(this, Yd);
    L(this, Qd);
    L(this, eh);
    L(this, th);
    L(this, rh);
    L(this, nh);
    L(this, ih);
    L(this, sh);
    L(this, oh);
    L(this, ah);
    L(this, _u);
    L(this, Wa);
    L(this, Xs);
    L(this, Za);
    L(this, ch);
    L(this, uh);
    D(this, vs, null), D(this, Xd, null), D(this, Qd, 0), D(this, eh, Fr), D(this, th, null), D(this, rh, null), D(this, nh, null), D(this, Yd, "0x"), D(this, ih, Fr), D(this, sh, Fr), D(this, oh, null), D(this, ah, null), D(this, _u, null), D(this, Wa, null), D(this, Xs, null), D(this, Za, null), D(this, ch, null), D(this, uh, null);
  }
  /**
   *  The transaction type.
   *
   *  If null, the type will be automatically inferred based on
   *  explicit properties.
   */
  get type() {
    return m(this, vs);
  }
  set type(e) {
    switch (e) {
      case null:
        D(this, vs, null);
        break;
      case 0:
      case "legacy":
        D(this, vs, 0);
        break;
      case 1:
      case "berlin":
      case "eip-2930":
        D(this, vs, 1);
        break;
      case 2:
      case "london":
      case "eip-1559":
        D(this, vs, 2);
        break;
      case 3:
      case "cancun":
      case "eip-4844":
        D(this, vs, 3);
        break;
      case 4:
      case "pectra":
      case "eip-7702":
        D(this, vs, 4);
        break;
      default:
        _e(!1, "unsupported transaction type", "type", e);
    }
  }
  /**
   *  The name of the transaction type.
   */
  get typeName() {
    switch (this.type) {
      case 0:
        return "legacy";
      case 1:
        return "eip-2930";
      case 2:
        return "eip-1559";
      case 3:
        return "eip-4844";
      case 4:
        return "eip-7702";
    }
    return null;
  }
  /**
   *  The ``to`` address for the transaction or ``null`` if the
   *  transaction is an ``init`` transaction.
   */
  get to() {
    const e = m(this, Xd);
    return e == null && this.type === 3 ? t3 : e;
  }
  set to(e) {
    D(this, Xd, e == null ? null : Jg(e));
  }
  /**
   *  The transaction nonce.
   */
  get nonce() {
    return m(this, Qd);
  }
  set nonce(e) {
    D(this, Qd, Wi(e, "value"));
  }
  /**
   *  The gas limit.
   */
  get gasLimit() {
    return m(this, eh);
  }
  set gasLimit(e) {
    D(this, eh, Dr(e));
  }
  /**
   *  The gas price.
   *
   *  On legacy networks this defines the fee that will be paid. On
   *  EIP-1559 networks, this should be ``null``.
   */
  get gasPrice() {
    const e = m(this, th);
    return e == null && (this.type === 0 || this.type === 1) ? Fr : e;
  }
  set gasPrice(e) {
    D(this, th, e == null ? null : Dr(e, "gasPrice"));
  }
  /**
   *  The maximum priority fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxPriorityFeePerGas() {
    const e = m(this, rh);
    return e ?? (this.type === 2 || this.type === 3 ? Fr : null);
  }
  set maxPriorityFeePerGas(e) {
    D(this, rh, e == null ? null : Dr(e, "maxPriorityFeePerGas"));
  }
  /**
   *  The maximum total fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxFeePerGas() {
    const e = m(this, nh);
    return e ?? (this.type === 2 || this.type === 3 ? Fr : null);
  }
  set maxFeePerGas(e) {
    D(this, nh, e == null ? null : Dr(e, "maxFeePerGas"));
  }
  /**
   *  The transaction data. For ``init`` transactions this is the
   *  deployment code.
   */
  get data() {
    return m(this, Yd);
  }
  set data(e) {
    D(this, Yd, et(e));
  }
  /**
   *  The amount of ether (in wei) to send in this transactions.
   */
  get value() {
    return m(this, ih);
  }
  set value(e) {
    D(this, ih, Dr(e, "value"));
  }
  /**
   *  The chain ID this transaction is valid on.
   */
  get chainId() {
    return m(this, sh);
  }
  set chainId(e) {
    D(this, sh, Dr(e));
  }
  /**
   *  If signed, the signature for this transaction.
   */
  get signature() {
    return m(this, oh) || null;
  }
  set signature(e) {
    D(this, oh, e == null ? null : So.from(e));
  }
  isValid() {
    const e = this.signature;
    if (e && !e.isValid())
      return !1;
    const t = this.authorizationList;
    if (t) {
      for (const n of t)
        if (!n.signature.isValid())
          return !1;
    }
    return !0;
  }
  /**
   *  The access list.
   *
   *  An access list permits discounted (but pre-paid) access to
   *  bytecode and state variable access within contract execution.
   */
  get accessList() {
    const e = m(this, ah) || null;
    return e ?? (this.type === 1 || this.type === 2 || this.type === 3 ? [] : null);
  }
  set accessList(e) {
    D(this, ah, e == null ? null : fC(e));
  }
  get authorizationList() {
    const e = m(this, ch) || null;
    return e == null && this.type === 4 ? [] : e;
  }
  set authorizationList(e) {
    D(this, ch, e == null ? null : e.map((t) => iW(t)));
  }
  /**
   *  The max fee per blob gas for Cancun transactions.
   */
  get maxFeePerBlobGas() {
    const e = m(this, _u);
    return e == null && this.type === 3 ? Fr : e;
  }
  set maxFeePerBlobGas(e) {
    D(this, _u, e == null ? null : Dr(e, "maxFeePerBlobGas"));
  }
  /**
   *  The BLOb versioned hashes for Cancun transactions.
   */
  get blobVersionedHashes() {
    let e = m(this, Wa);
    return e == null && this.type === 3 ? [] : e;
  }
  set blobVersionedHashes(e) {
    if (e != null) {
      _e(Array.isArray(e), "blobVersionedHashes must be an Array", "value", e), e = e.slice();
      for (let t = 0; t < e.length; t++)
        _e(vc(e[t], 32), "invalid blobVersionedHash", `value[${t}]`, e[t]);
    }
    D(this, Wa, e);
  }
  /**
   *  The BLObs for the Transaction, if any.
   *
   *  If ``blobs`` is non-``null``, then the [[seriailized]]
   *  will return the network formatted sidecar, otherwise it
   *  will return the standard [[link-eip-2718]] payload. The
   *  [[unsignedSerialized]] is unaffected regardless.
   *
   *  When setting ``blobs``, either fully valid [[Blob]] objects
   *  may be specified (i.e. correctly padded, with correct
   *  committments and proofs) or a raw [[BytesLike]] may
   *  be provided.
   *
   *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**
   *  be already set. The blob will be correctly padded and the
   *  [[KzgLibrary]] will be used to compute the committment and
   *  proof for the blob.
   *
   *  A BLOb is a sequence of field elements, each of which must
   *  be within the BLS field modulo, so some additional processing
   *  may be required to encode arbitrary data to ensure each 32 byte
   *  field is within the valid range.
   *
   *  Setting this automatically populates [[blobVersionedHashes]],
   *  overwriting any existing values. Setting this to ``null``
   *  does **not** remove the [[blobVersionedHashes]], leaving them
   *  present.
   */
  get blobs() {
    return m(this, Za) == null ? null : m(this, Za).map((e) => Object.assign({}, e));
  }
  set blobs(e) {
    if (e == null) {
      D(this, Za, null);
      return;
    }
    const t = [], n = [];
    for (let i = 0; i < e.length; i++) {
      const s = e[i];
      if (DK(s)) {
        Qt(m(this, Xs), "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
          operation: "set blobs()"
        });
        let o = Ut(s);
        if (_e(o.length <= s_, "blob is too large", `blobs[${i}]`, s), o.length !== s_) {
          const u = new Uint8Array(s_);
          u.set(o), o = u;
        }
        const a = m(this, Xs).blobToKzgCommitment(o), c = et(m(this, Xs).computeBlobKzgProof(o, a));
        t.push({
          data: et(o),
          commitment: et(a),
          proof: c
        }), n.push(OO(1, a));
      } else {
        const o = et(s.data), a = et(s.commitment), c = et(s.proof);
        t.push({ data: o, commitment: a, proof: c }), n.push(OO(1, a));
      }
    }
    D(this, Za, t), D(this, Wa, n);
  }
  get kzg() {
    return m(this, Xs);
  }
  set kzg(e) {
    e == null ? D(this, Xs, null) : D(this, Xs, fW(e));
  }
  get blobWrapperVersion() {
    return m(this, uh);
  }
  set blobWrapperVersion(e) {
    D(this, uh, e);
  }
  /**
   *  The transaction hash, if signed. Otherwise, ``null``.
   */
  get hash() {
    return this.signature == null ? null : bc(R(this, lh, py).call(this, !0, !1));
  }
  /**
   *  The pre-image hash of this transaction.
   *
   *  This is the digest that a [[Signer]] must sign to authorize
   *  this transaction.
   */
  get unsignedHash() {
    return bc(this.unsignedSerialized);
  }
  /**
   *  The sending address, if signed. Otherwise, ``null``.
   */
  get from() {
    return this.signature == null ? null : oW(this.unsignedHash, this.signature.getCanonical());
  }
  /**
   *  The public key of the sender, if signed. Otherwise, ``null``.
   */
  get fromPublicKey() {
    return this.signature == null ? null : dC.recoverPublicKey(this.unsignedHash, this.signature.getCanonical());
  }
  /**
   *  Returns true if signed.
   *
   *  This provides a Type Guard that properties requiring a signed
   *  transaction are non-null.
   */
  isSigned() {
    return this.signature != null;
  }
  /**
   *  The serialized transaction.
   *
   *  This throws if the transaction is unsigned. For the pre-image,
   *  use [[unsignedSerialized]].
   */
  get serialized() {
    return R(this, lh, py).call(this, !0, !0);
  }
  /**
   *  The transaction pre-image.
   *
   *  The hash of this is the digest which needs to be signed to
   *  authorize this transaction.
   */
  get unsignedSerialized() {
    return R(this, lh, py).call(this, !1, !1);
  }
  /**
   *  Return the most "likely" type; currently the highest
   *  supported transaction type.
   */
  inferType() {
    const e = this.inferTypes();
    return e.indexOf(2) >= 0 ? 2 : e.pop();
  }
  /**
   *  Validates the explicit properties and returns a list of compatible
   *  transaction types.
   */
  inferTypes() {
    const e = this.gasPrice != null, t = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null, n = this.accessList != null, i = m(this, _u) != null || m(this, Wa);
    this.maxFeePerGas != null && this.maxPriorityFeePerGas != null && Qt(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this }), Qt(!t || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this }), Qt(this.type !== 0 || !n, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
    const s = [];
    return this.type != null ? s.push(this.type) : this.authorizationList && this.authorizationList.length ? s.push(4) : t ? s.push(2) : e ? (s.push(1), n || s.push(0)) : n ? (s.push(1), s.push(2)) : (i && this.to || (s.push(0), s.push(1), s.push(2)), s.push(3)), s.sort(), s;
  }
  /**
   *  Returns true if this transaction is a legacy transaction (i.e.
   *  ``type === 0``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if this transaction is berlin hardform transaction (i.e.
   *  ``type === 1``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if this transaction is london hardform transaction (i.e.
   *  ``type === 2``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if this transaction is an [[link-eip-4844]] BLOB
   *  transaction.
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Create a copy of this transaciton.
   */
  clone() {
    return Ei.from(this);
  }
  /**
   *  Return a JSON-friendly object.
   */
  toJSON() {
    const e = (t) => t == null ? null : t.toString();
    return {
      type: this.type,
      to: this.to,
      //            from: this.from,
      data: this.data,
      nonce: this.nonce,
      gasLimit: e(this.gasLimit),
      gasPrice: e(this.gasPrice),
      maxPriorityFeePerGas: e(this.maxPriorityFeePerGas),
      maxFeePerGas: e(this.maxFeePerGas),
      value: e(this.value),
      chainId: e(this.chainId),
      sig: this.signature ? this.signature.toJSON() : null,
      accessList: this.accessList
    };
  }
  [hW]() {
    return this.toString();
  }
  toString() {
    const e = [], t = (i) => {
      let s = this[i];
      typeof s == "string" && (s = JSON.stringify(s)), e.push(`${i}: ${s}`);
    };
    this.type && t("type"), t("to"), t("data"), t("nonce"), t("gasLimit"), t("value"), this.chainId != null && t("chainId"), this.signature && (t("from"), e.push(`signature: ${this.signature.toString()}`));
    const n = this.authorizationList;
    if (n) {
      const i = [];
      for (const s of n) {
        const o = [];
        o.push(`address: ${JSON.stringify(s.address)}`), s.nonce != null && o.push(`nonce: ${s.nonce}`), s.chainId != null && o.push(`chainId: ${s.chainId}`), s.signature && o.push(`signature: ${s.signature.toString()}`), i.push(`Authorization { ${o.join(", ")} }`);
      }
      e.push(`authorizations: [ ${i.join(", ")} ]`);
    }
    return `Transaction { ${e.join(", ")} }`;
  }
  /**
   *  Create a **Transaction** from a serialized transaction or a
   *  Transaction-like object.
   */
  static from(e) {
    if (e == null)
      return new Ei();
    if (typeof e == "string") {
      const n = Ut(e);
      if (n[0] >= 127)
        return Ei.from(yW(n));
      switch (n[0]) {
        case 1:
          return Ei.from(_W(n));
        case 2:
          return Ei.from(bW(n));
        case 3:
          return Ei.from(EW(n));
        case 4:
          return Ei.from(AW(n));
      }
      Qt(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
    }
    const t = new Ei();
    return e.type != null && (t.type = e.type), e.to != null && (t.to = e.to), e.nonce != null && (t.nonce = e.nonce), e.gasLimit != null && (t.gasLimit = e.gasLimit), e.gasPrice != null && (t.gasPrice = e.gasPrice), e.maxPriorityFeePerGas != null && (t.maxPriorityFeePerGas = e.maxPriorityFeePerGas), e.maxFeePerGas != null && (t.maxFeePerGas = e.maxFeePerGas), e.maxFeePerBlobGas != null && (t.maxFeePerBlobGas = e.maxFeePerBlobGas), e.data != null && (t.data = e.data), e.value != null && (t.value = e.value), e.chainId != null && (t.chainId = e.chainId), e.signature != null && (t.signature = So.from(e.signature)), e.accessList != null && (t.accessList = e.accessList), e.authorizationList != null && (t.authorizationList = e.authorizationList), e.blobVersionedHashes != null && (t.blobVersionedHashes = e.blobVersionedHashes), e.kzg != null && (t.kzg = e.kzg), e.blobWrapperVersion != null && (t.blobWrapperVersion = e.blobWrapperVersion), e.blobs != null && (t.blobs = e.blobs), e.hash != null && (_e(t.isSigned(), "unsigned transaction cannot define '.hash'", "tx", e), _e(t.hash === e.hash, "hash mismatch", "tx", e)), e.from != null && (_e(t.isSigned(), "unsigned transaction cannot define '.from'", "tx", e), _e(t.from.toLowerCase() === (e.from || "").toLowerCase(), "from mismatch", "tx", e)), t;
  }
}, vs = new WeakMap(), Xd = new WeakMap(), Yd = new WeakMap(), Qd = new WeakMap(), eh = new WeakMap(), th = new WeakMap(), rh = new WeakMap(), nh = new WeakMap(), ih = new WeakMap(), sh = new WeakMap(), oh = new WeakMap(), ah = new WeakMap(), _u = new WeakMap(), Wa = new WeakMap(), Xs = new WeakMap(), Za = new WeakMap(), ch = new WeakMap(), uh = new WeakMap(), lh = new WeakSet(), py = function(e, t) {
  Qt(!e || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
  const n = e ? this.signature : null;
  switch (this.inferType()) {
    case 0:
      return vW(this, n);
    case 1:
      return SW(this, n);
    case 2:
      return wW(this, n);
    case 3:
      return xW(this, n, t ? this.blobs : null);
    case 4:
      return IW(this, n);
  }
  Qt(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
}, Ei);
const Ss = {
  BalanceService: Symbol.for("BalanceService"),
  AlpacaDataSource: Symbol.for("AlpacaDataSource"),
  CalDataSource: Symbol.for("CalDataSource"),
  CounterValueDataSource: Symbol.for("CounterValueDataSource"),
  GasFeeEstimationService: Symbol.for("GasFeeEstimationService")
};
var CW = Object.getOwnPropertyDescriptor, DW = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? CW(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, o_ = (r, e) => (t, n) => e(t, n, r);
let sx = class {
  constructor(r, e, t) {
    h(this, "logger");
    this.balanceService = e, this.backendService = t, this.logger = r("[HydrateAccountWithBalanceUseCase]");
  }
  async execute(r, e = !0) {
    this.logger.debug("Hydrating account with balance and tokens", {
      address: r.freshAddress,
      currencyId: r.currencyId
    });
    const t = await this.balanceService.getBalanceForAccount(
      r,
      e
    );
    return t.isRight() ? this.formatSuccessfulBalanceResult(
      r,
      t.extract()
    ) : this.handleBalanceServiceFailure(
      r,
      t.extract()
    );
  }
  formatSuccessfulBalanceResult(r, e) {
    const t = this.formatBalance(e.nativeBalance.balance), n = this.mapTokenBalances(e.tokenBalances);
    return this.logger.debug("Successfully hydrated account with balance and tokens", {
      address: r.freshAddress,
      balance: t,
      tokenCount: n.length
    }), { ...r, balance: t, tokens: n };
  }
  async handleBalanceServiceFailure(r, e) {
    this.logger.warn(
      "Failed to fetch balance from balance service (Alpaca), falling back to RPC node",
      {
        error: e,
        address: r.freshAddress
      }
    );
    const t = await this.fetchBalanceFromRpc(r);
    return { ...r, balance: t, tokens: [] };
  }
  async fetchBalanceFromRpc(r) {
    const e = qg(r.currencyId), t = await this.backendService.broadcast({
      blockchain: { name: "ethereum", chainId: e.toString() },
      rpc: {
        method: "eth_getBalance",
        params: [r.freshAddress, "latest"],
        id: 1,
        jsonrpc: "2.0"
      }
    });
    if (t.isRight()) {
      const n = t.extract();
      if ("result" in n) {
        const i = n.result;
        return this.formatBalance(i);
      }
    }
    return "0.0000";
  }
  formatBalance(r) {
    const e = BK(r), [t, n] = e.split("."), i = (n ?? "").padEnd(4, "0").slice(0, 4);
    return `${t}.${i}`;
  }
  mapTokenBalances(r) {
    return r.map((e) => ({
      ledgerId: e.ledgerId,
      ticker: e.ticker,
      name: e.name,
      balance: e.balanceFormatted,
      fiatBalance: void 0
    }));
  }
};
sx = DW([
  ke(),
  o_(0, H(Me.LoggerPublisher)),
  o_(1, H(Ss.BalanceService)),
  o_(2, H(xc.BackendService))
], sx);
var TW = Object.getOwnPropertyDescriptor, kW = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? TW(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, $O = (r, e) => (t, n) => e(t, n, r);
let ox = class {
  constructor(r, e) {
    h(this, "logger");
    this.counterValueDataSource = e, this.logger = r("[HydrateAccountWithFiatUseCase]");
  }
  async execute(r, e = "usd") {
    this.logHydrationStart(r);
    const t = r.balance;
    return t ? (await this.fetchCounterValues(
      r,
      e
    )).caseOf({
      Left: (i) => (this.logger.warn("Failed to fetch counter values", { error: i }), { ...r, fiatBalance: void 0 }),
      Right: (i) => {
        var c;
        const s = e.toUpperCase(), o = this.calculateAccountFiat(
          t,
          (c = i[0]) == null ? void 0 : c.rate,
          s
        ), a = this.hydrateTokensWithFiat(
          r.tokens,
          i.slice(1),
          s
        );
        return this.logHydrationSuccess(o, a, s), {
          ...r,
          fiatBalance: o,
          tokens: a
        };
      }
    }) : this.skipHydration(r, "No balance found");
  }
  logHydrationStart(r) {
    this.logger.debug("Hydrating account with fiat balance", {
      address: r.freshAddress,
      currencyId: r.currencyId,
      tokenCount: r.tokens.length
    });
  }
  skipHydration(r, e) {
    return this.logger.debug(`${e}, skipping fiat hydration`), { ...r, fiatBalance: void 0 };
  }
  async fetchCounterValues(r, e) {
    const t = this.buildLedgerIds(r);
    return this.logger.debug("Fetching counter values", { ledgerIds: t, targetCurrency: e }), this.counterValueDataSource.getCounterValues(
      t,
      e
    );
  }
  buildLedgerIds(r) {
    return [
      r.currencyId,
      ...r.tokens.map((e) => e.ledgerId)
    ];
  }
  logHydrationSuccess(r, e, t) {
    this.logger.debug("Successfully calculated fiat balances", {
      accountFiat: r == null ? void 0 : r.value,
      tokensWithFiat: e.filter((n) => n.fiatBalance).length,
      currency: t
    });
  }
  calculateAccountFiat(r, e, t) {
    const n = parseFloat(r);
    return Number.isNaN(n) || e === void 0 ? void 0 : {
      value: (n * e).toFixed(2),
      currency: t
    };
  }
  hydrateTokensWithFiat(r, e, t) {
    return r.map((n, i) => {
      var c;
      const s = (c = e[i]) == null ? void 0 : c.rate, o = parseFloat(n.balance);
      if (Number.isNaN(o) || s === void 0 || s === 0)
        return n;
      const a = o * s;
      return {
        ...n,
        fiatBalance: {
          value: a.toFixed(2),
          currency: t
        }
      };
    });
  }
};
ox = kW([
  ke(),
  $O(0, H(Me.LoggerPublisher)),
  $O(1, H(Ss.CounterValueDataSource))
], ox);
const Vy = {
  TransactionHistoryDataSource: Symbol.for("TransactionHistoryDataSource"),
  FetchTransactionHistoryUseCase: Symbol.for("FetchTransactionHistoryUseCase")
};
var OW = Object.getOwnPropertyDescriptor, $W = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? OW(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, RO = (r, e) => (t, n) => e(t, n, r);
let ax = class {
  constructor(r, e) {
    h(this, "logger");
    this.fetchTransactionHistoryUseCase = e, this.logger = r("HydrateAccountWithTxHistoryUseCase");
  }
  async execute(r) {
    const e = r.ticker.toLowerCase();
    return this.logger.debug("Fetching transaction history for account", {
      blockchain: e,
      address: r.freshAddress
    }), (await this.fetchTransactionHistoryUseCase.execute(
      e,
      r.freshAddress
    )).caseOf({
      Left: (n) => (this.logger.warn("Failed to fetch transaction history", {
        error: n.message,
        blockchain: e,
        address: r.freshAddress
      }), {
        ...r,
        transactionHistory: void 0
      }),
      Right: (n) => (this.logger.debug("Transaction history fetched successfully", {
        blockchain: e,
        transactionCount: n.transactions.length
      }), {
        ...r,
        transactionHistory: n.transactions
      })
    });
  }
};
ax = $W([
  ke(),
  RO(0, H(Me.LoggerPublisher)),
  RO(1, H(Vy.FetchTransactionHistoryUseCase))
], ax);
function RW(r) {
  return new $r(({ bind: e }) => {
    e(Ot.AccountService).to(ME).inSingletonScope(), e(Ot.FetchAccountsUseCase).to(VE), e(Ot.FetchAccountsWithBalanceUseCase).to(
      zE
    ), e(Ot.FetchCloudSyncAccountsUseCase).to(
      jE
    ), e(Ot.FetchSelectedAccountUseCase).to(
      HE
    ), e(Ot.GetDetailedSelectedAccountUseCase).to(
      GE
    ), e(Ot.HydrateAccountWithTxHistoryUseCase).to(
      ax
    ), e(Ot.HydrateAccountWithFiatUseCase).to(
      ox
    ), e(Ot.HydrateAccountWithBalanceUseCase).to(
      sx
    );
  });
}
const gl = {
  NetworkService: Symbol.for("NetworkService")
};
function oe(r, e, t) {
  function n(a, c) {
    if (a._zod || Object.defineProperty(a, "_zod", {
      value: {
        def: c,
        constr: o,
        traits: /* @__PURE__ */ new Set()
      },
      enumerable: !1
    }), a._zod.traits.has(r))
      return;
    a._zod.traits.add(r), e(a, c);
    const u = o.prototype, l = Object.keys(u);
    for (let d = 0; d < l.length; d++) {
      const f = l[d];
      f in a || (a[f] = u[f].bind(a));
    }
  }
  const i = (t == null ? void 0 : t.Parent) ?? Object;
  class s extends i {
  }
  Object.defineProperty(s, "name", { value: r });
  function o(a) {
    var c;
    const u = t != null && t.Parent ? new s() : this;
    n(u, a), (c = u._zod).deferred ?? (c.deferred = []);
    for (const l of u._zod.deferred)
      l();
    return u;
  }
  return Object.defineProperty(o, "init", { value: n }), Object.defineProperty(o, Symbol.hasInstance, {
    value: (a) => {
      var c, u;
      return t != null && t.Parent && a instanceof t.Parent ? !0 : (u = (c = a == null ? void 0 : a._zod) == null ? void 0 : c.traits) == null ? void 0 : u.has(r);
    }
  }), Object.defineProperty(o, "name", { value: r }), o;
}
class md extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
}
class n3 extends Error {
  constructor(e) {
    super(`Encountered unidirectional transform during encode: ${e}`), this.name = "ZodEncodeError";
  }
}
const i3 = {};
function Qu(r) {
  return i3;
}
function s3(r) {
  const e = Object.values(r).filter((n) => typeof n == "number");
  return Object.entries(r).filter(([n, i]) => e.indexOf(+n) === -1).map(([n, i]) => i);
}
function cx(r, e) {
  return typeof e == "bigint" ? e.toString() : e;
}
function o0(r) {
  return {
    get value() {
      {
        const e = r();
        return Object.defineProperty(this, "value", { value: e }), e;
      }
    }
  };
}
function pC(r) {
  return r == null;
}
function gC(r) {
  const e = r.startsWith("^") ? 1 : 0, t = r.endsWith("$") ? r.length - 1 : r.length;
  return r.slice(e, t);
}
function PW(r, e) {
  const t = (r.toString().split(".")[1] || "").length, n = e.toString();
  let i = (n.split(".")[1] || "").length;
  if (i === 0 && /\d?e-\d?/.test(n)) {
    const c = n.match(/\d?e-(\d?)/);
    c != null && c[1] && (i = Number.parseInt(c[1]));
  }
  const s = t > i ? t : i, o = Number.parseInt(r.toFixed(s).replace(".", "")), a = Number.parseInt(e.toFixed(s).replace(".", ""));
  return o % a / 10 ** s;
}
const PO = Symbol("evaluating");
function At(r, e, t) {
  let n;
  Object.defineProperty(r, e, {
    get() {
      if (n !== PO)
        return n === void 0 && (n = PO, n = t()), n;
    },
    set(i) {
      Object.defineProperty(r, e, {
        value: i
        // configurable: true,
      });
    },
    configurable: !0
  });
}
function ml(r, e, t) {
  Object.defineProperty(r, e, {
    value: t,
    writable: !0,
    enumerable: !0,
    configurable: !0
  });
}
function Ac(...r) {
  const e = {};
  for (const t of r) {
    const n = Object.getOwnPropertyDescriptors(t);
    Object.assign(e, n);
  }
  return Object.defineProperties({}, e);
}
function NO(r) {
  return JSON.stringify(r);
}
function NW(r) {
  return r.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
const o3 = "captureStackTrace" in Error ? Error.captureStackTrace : (...r) => {
};
function jp(r) {
  return typeof r == "object" && r !== null && !Array.isArray(r);
}
const BW = o0(() => {
  var r;
  if (typeof navigator < "u" && ((r = navigator == null ? void 0 : navigator.userAgent) != null && r.includes("Cloudflare")))
    return !1;
  try {
    const e = Function;
    return new e(""), !0;
  } catch {
    return !1;
  }
});
function Hp(r) {
  if (jp(r) === !1)
    return !1;
  const e = r.constructor;
  if (e === void 0 || typeof e != "function")
    return !0;
  const t = e.prototype;
  return !(jp(t) === !1 || Object.prototype.hasOwnProperty.call(t, "isPrototypeOf") === !1);
}
function a3(r) {
  return Hp(r) ? { ...r } : Array.isArray(r) ? [...r] : r;
}
const LW = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
function jh(r) {
  return r.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Ic(r, e, t) {
  const n = new r._zod.constr(e ?? r._zod.def);
  return (!e || t != null && t.parent) && (n._zod.parent = r), n;
}
function Fe(r) {
  const e = r;
  if (!e)
    return {};
  if (typeof e == "string")
    return { error: () => e };
  if ((e == null ? void 0 : e.message) !== void 0) {
    if ((e == null ? void 0 : e.error) !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    e.error = e.message;
  }
  return delete e.message, typeof e.error == "string" ? { ...e, error: () => e.error } : e;
}
function UW(r) {
  return Object.keys(r).filter((e) => r[e]._zod.optin === "optional" && r[e]._zod.optout === "optional");
}
const FW = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
function MW(r, e) {
  const t = r._zod.def, n = t.checks;
  if (n && n.length > 0)
    throw new Error(".pick() cannot be used on object schemas containing refinements");
  const s = Ac(r._zod.def, {
    get shape() {
      const o = {};
      for (const a in e) {
        if (!(a in t.shape))
          throw new Error(`Unrecognized key: "${a}"`);
        e[a] && (o[a] = t.shape[a]);
      }
      return ml(this, "shape", o), o;
    },
    checks: []
  });
  return Ic(r, s);
}
function VW(r, e) {
  const t = r._zod.def, n = t.checks;
  if (n && n.length > 0)
    throw new Error(".omit() cannot be used on object schemas containing refinements");
  const s = Ac(r._zod.def, {
    get shape() {
      const o = { ...r._zod.def.shape };
      for (const a in e) {
        if (!(a in t.shape))
          throw new Error(`Unrecognized key: "${a}"`);
        e[a] && delete o[a];
      }
      return ml(this, "shape", o), o;
    },
    checks: []
  });
  return Ic(r, s);
}
function zW(r, e) {
  if (!Hp(e))
    throw new Error("Invalid input to extend: expected a plain object");
  const t = r._zod.def.checks;
  if (t && t.length > 0) {
    const s = r._zod.def.shape;
    for (const o in e)
      if (Object.getOwnPropertyDescriptor(s, o) !== void 0)
        throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
  }
  const i = Ac(r._zod.def, {
    get shape() {
      const s = { ...r._zod.def.shape, ...e };
      return ml(this, "shape", s), s;
    }
  });
  return Ic(r, i);
}
function jW(r, e) {
  if (!Hp(e))
    throw new Error("Invalid input to safeExtend: expected a plain object");
  const t = Ac(r._zod.def, {
    get shape() {
      const n = { ...r._zod.def.shape, ...e };
      return ml(this, "shape", n), n;
    }
  });
  return Ic(r, t);
}
function HW(r, e) {
  const t = Ac(r._zod.def, {
    get shape() {
      const n = { ...r._zod.def.shape, ...e._zod.def.shape };
      return ml(this, "shape", n), n;
    },
    get catchall() {
      return e._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return Ic(r, t);
}
function GW(r, e, t) {
  const i = e._zod.def.checks;
  if (i && i.length > 0)
    throw new Error(".partial() cannot be used on object schemas containing refinements");
  const o = Ac(e._zod.def, {
    get shape() {
      const a = e._zod.def.shape, c = { ...a };
      if (t)
        for (const u in t) {
          if (!(u in a))
            throw new Error(`Unrecognized key: "${u}"`);
          t[u] && (c[u] = r ? new r({
            type: "optional",
            innerType: a[u]
          }) : a[u]);
        }
      else
        for (const u in a)
          c[u] = r ? new r({
            type: "optional",
            innerType: a[u]
          }) : a[u];
      return ml(this, "shape", c), c;
    },
    checks: []
  });
  return Ic(e, o);
}
function KW(r, e, t) {
  const n = Ac(e._zod.def, {
    get shape() {
      const i = e._zod.def.shape, s = { ...i };
      if (t)
        for (const o in t) {
          if (!(o in s))
            throw new Error(`Unrecognized key: "${o}"`);
          t[o] && (s[o] = new r({
            type: "nonoptional",
            innerType: i[o]
          }));
        }
      else
        for (const o in i)
          s[o] = new r({
            type: "nonoptional",
            innerType: i[o]
          });
      return ml(this, "shape", s), s;
    }
  });
  return Ic(e, n);
}
function rd(r, e = 0) {
  var t;
  if (r.aborted === !0)
    return !0;
  for (let n = e; n < r.issues.length; n++)
    if (((t = r.issues[n]) == null ? void 0 : t.continue) !== !0)
      return !0;
  return !1;
}
function c3(r, e) {
  return e.map((t) => {
    var n;
    return (n = t).path ?? (n.path = []), t.path.unshift(r), t;
  });
}
function Im(r) {
  return typeof r == "string" ? r : r == null ? void 0 : r.message;
}
function el(r, e, t) {
  var i, s, o, a, c, u;
  const n = { ...r, path: r.path ?? [] };
  if (!r.message) {
    const l = Im((o = (s = (i = r.inst) == null ? void 0 : i._zod.def) == null ? void 0 : s.error) == null ? void 0 : o.call(s, r)) ?? Im((a = e == null ? void 0 : e.error) == null ? void 0 : a.call(e, r)) ?? Im((c = t.customError) == null ? void 0 : c.call(t, r)) ?? Im((u = t.localeError) == null ? void 0 : u.call(t, r)) ?? "Invalid input";
    n.message = l;
  }
  return delete n.inst, delete n.continue, e != null && e.reportInput || delete n.input, n;
}
function mC(r) {
  return Array.isArray(r) ? "array" : typeof r == "string" ? "string" : "unknown";
}
function Gp(...r) {
  const [e, t, n] = r;
  return typeof e == "string" ? {
    message: e,
    code: "custom",
    input: t,
    inst: n
  } : { ...e };
}
const u3 = (r, e) => {
  r.name = "$ZodError", Object.defineProperty(r, "_zod", {
    value: r._zod,
    enumerable: !1
  }), Object.defineProperty(r, "issues", {
    value: e,
    enumerable: !1
  }), r.message = JSON.stringify(e, cx, 2), Object.defineProperty(r, "toString", {
    value: () => r.message,
    enumerable: !1
  });
}, l3 = oe("$ZodError", u3), d3 = oe("$ZodError", u3, { Parent: Error });
function qW(r, e = (t) => t.message) {
  const t = {}, n = [];
  for (const i of r.issues)
    i.path.length > 0 ? (t[i.path[0]] = t[i.path[0]] || [], t[i.path[0]].push(e(i))) : n.push(e(i));
  return { formErrors: n, fieldErrors: t };
}
function WW(r, e = (t) => t.message) {
  const t = { _errors: [] }, n = (i) => {
    for (const s of i.issues)
      if (s.code === "invalid_union" && s.errors.length)
        s.errors.map((o) => n({ issues: o }));
      else if (s.code === "invalid_key")
        n({ issues: s.issues });
      else if (s.code === "invalid_element")
        n({ issues: s.issues });
      else if (s.path.length === 0)
        t._errors.push(e(s));
      else {
        let o = t, a = 0;
        for (; a < s.path.length; ) {
          const c = s.path[a];
          a === s.path.length - 1 ? (o[c] = o[c] || { _errors: [] }, o[c]._errors.push(e(s))) : o[c] = o[c] || { _errors: [] }, o = o[c], a++;
        }
      }
  };
  return n(r), t;
}
const yC = (r) => (e, t, n, i) => {
  const s = n ? Object.assign(n, { async: !1 }) : { async: !1 }, o = e._zod.run({ value: t, issues: [] }, s);
  if (o instanceof Promise)
    throw new md();
  if (o.issues.length) {
    const a = new ((i == null ? void 0 : i.Err) ?? r)(o.issues.map((c) => el(c, s, Qu())));
    throw o3(a, i == null ? void 0 : i.callee), a;
  }
  return o.value;
}, vC = (r) => async (e, t, n, i) => {
  const s = n ? Object.assign(n, { async: !0 }) : { async: !0 };
  let o = e._zod.run({ value: t, issues: [] }, s);
  if (o instanceof Promise && (o = await o), o.issues.length) {
    const a = new ((i == null ? void 0 : i.Err) ?? r)(o.issues.map((c) => el(c, s, Qu())));
    throw o3(a, i == null ? void 0 : i.callee), a;
  }
  return o.value;
}, a0 = (r) => (e, t, n) => {
  const i = n ? { ...n, async: !1 } : { async: !1 }, s = e._zod.run({ value: t, issues: [] }, i);
  if (s instanceof Promise)
    throw new md();
  return s.issues.length ? {
    success: !1,
    error: new (r ?? l3)(s.issues.map((o) => el(o, i, Qu())))
  } : { success: !0, data: s.value };
}, ZW = /* @__PURE__ */ a0(d3), c0 = (r) => async (e, t, n) => {
  const i = n ? Object.assign(n, { async: !0 }) : { async: !0 };
  let s = e._zod.run({ value: t, issues: [] }, i);
  return s instanceof Promise && (s = await s), s.issues.length ? {
    success: !1,
    error: new r(s.issues.map((o) => el(o, i, Qu())))
  } : { success: !0, data: s.value };
}, JW = /* @__PURE__ */ c0(d3), XW = (r) => (e, t, n) => {
  const i = n ? Object.assign(n, { direction: "backward" }) : { direction: "backward" };
  return yC(r)(e, t, i);
}, YW = (r) => (e, t, n) => yC(r)(e, t, n), QW = (r) => async (e, t, n) => {
  const i = n ? Object.assign(n, { direction: "backward" }) : { direction: "backward" };
  return vC(r)(e, t, i);
}, eZ = (r) => async (e, t, n) => vC(r)(e, t, n), tZ = (r) => (e, t, n) => {
  const i = n ? Object.assign(n, { direction: "backward" }) : { direction: "backward" };
  return a0(r)(e, t, i);
}, rZ = (r) => (e, t, n) => a0(r)(e, t, n), nZ = (r) => async (e, t, n) => {
  const i = n ? Object.assign(n, { direction: "backward" }) : { direction: "backward" };
  return c0(r)(e, t, i);
}, iZ = (r) => async (e, t, n) => c0(r)(e, t, n), sZ = /^[cC][^\s-]{8,}$/, oZ = /^[0-9a-z]+$/, aZ = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, cZ = /^[0-9a-vA-V]{20}$/, uZ = /^[A-Za-z0-9]{27}$/, lZ = /^[a-zA-Z0-9_-]{21}$/, dZ = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, hZ = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, BO = (r) => r ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${r}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/, fZ = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, pZ = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function gZ() {
  return new RegExp(pZ, "u");
}
const mZ = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, yZ = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/, vZ = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, bZ = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, wZ = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, h3 = /^[A-Za-z0-9_-]*$/, _Z = /^\+[1-9]\d{6,14}$/, f3 = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", SZ = /* @__PURE__ */ new RegExp(`^${f3}$`);
function p3(r) {
  const e = "(?:[01]\\d|2[0-3]):[0-5]\\d";
  return typeof r.precision == "number" ? r.precision === -1 ? `${e}` : r.precision === 0 ? `${e}:[0-5]\\d` : `${e}:[0-5]\\d\\.\\d{${r.precision}}` : `${e}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function EZ(r) {
  return new RegExp(`^${p3(r)}$`);
}
function xZ(r) {
  const e = p3({ precision: r.precision }), t = ["Z"];
  r.local && t.push(""), r.offset && t.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");
  const n = `${e}(?:${t.join("|")})`;
  return new RegExp(`^${f3}T(?:${n})$`);
}
const AZ = (r) => {
  const e = r ? `[\\s\\S]{${(r == null ? void 0 : r.minimum) ?? 0},${(r == null ? void 0 : r.maximum) ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${e}$`);
}, IZ = /^-?\d+$/, CZ = /^-?\d+(?:\.\d+)?$/, DZ = /^[^A-Z]*$/, TZ = /^[^a-z]*$/, ui = /* @__PURE__ */ oe("$ZodCheck", (r, e) => {
  var t;
  r._zod ?? (r._zod = {}), r._zod.def = e, (t = r._zod).onattach ?? (t.onattach = []);
}), g3 = {
  number: "number",
  bigint: "bigint",
  object: "date"
}, m3 = /* @__PURE__ */ oe("$ZodCheckLessThan", (r, e) => {
  ui.init(r, e);
  const t = g3[typeof e.value];
  r._zod.onattach.push((n) => {
    const i = n._zod.bag, s = (e.inclusive ? i.maximum : i.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    e.value < s && (e.inclusive ? i.maximum = e.value : i.exclusiveMaximum = e.value);
  }), r._zod.check = (n) => {
    (e.inclusive ? n.value <= e.value : n.value < e.value) || n.issues.push({
      origin: t,
      code: "too_big",
      maximum: typeof e.value == "object" ? e.value.getTime() : e.value,
      input: n.value,
      inclusive: e.inclusive,
      inst: r,
      continue: !e.abort
    });
  };
}), y3 = /* @__PURE__ */ oe("$ZodCheckGreaterThan", (r, e) => {
  ui.init(r, e);
  const t = g3[typeof e.value];
  r._zod.onattach.push((n) => {
    const i = n._zod.bag, s = (e.inclusive ? i.minimum : i.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    e.value > s && (e.inclusive ? i.minimum = e.value : i.exclusiveMinimum = e.value);
  }), r._zod.check = (n) => {
    (e.inclusive ? n.value >= e.value : n.value > e.value) || n.issues.push({
      origin: t,
      code: "too_small",
      minimum: typeof e.value == "object" ? e.value.getTime() : e.value,
      input: n.value,
      inclusive: e.inclusive,
      inst: r,
      continue: !e.abort
    });
  };
}), kZ = /* @__PURE__ */ oe("$ZodCheckMultipleOf", (r, e) => {
  ui.init(r, e), r._zod.onattach.push((t) => {
    var n;
    (n = t._zod.bag).multipleOf ?? (n.multipleOf = e.value);
  }), r._zod.check = (t) => {
    if (typeof t.value != typeof e.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    (typeof t.value == "bigint" ? t.value % e.value === BigInt(0) : PW(t.value, e.value) === 0) || t.issues.push({
      origin: typeof t.value,
      code: "not_multiple_of",
      divisor: e.value,
      input: t.value,
      inst: r,
      continue: !e.abort
    });
  };
}), OZ = /* @__PURE__ */ oe("$ZodCheckNumberFormat", (r, e) => {
  var o;
  ui.init(r, e), e.format = e.format || "float64";
  const t = (o = e.format) == null ? void 0 : o.includes("int"), n = t ? "int" : "number", [i, s] = FW[e.format];
  r._zod.onattach.push((a) => {
    const c = a._zod.bag;
    c.format = e.format, c.minimum = i, c.maximum = s, t && (c.pattern = IZ);
  }), r._zod.check = (a) => {
    const c = a.value;
    if (t) {
      if (!Number.isInteger(c)) {
        a.issues.push({
          expected: n,
          format: e.format,
          code: "invalid_type",
          continue: !1,
          input: c,
          inst: r
        });
        return;
      }
      if (!Number.isSafeInteger(c)) {
        c > 0 ? a.issues.push({
          input: c,
          code: "too_big",
          maximum: Number.MAX_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: r,
          origin: n,
          inclusive: !0,
          continue: !e.abort
        }) : a.issues.push({
          input: c,
          code: "too_small",
          minimum: Number.MIN_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: r,
          origin: n,
          inclusive: !0,
          continue: !e.abort
        });
        return;
      }
    }
    c < i && a.issues.push({
      origin: "number",
      input: c,
      code: "too_small",
      minimum: i,
      inclusive: !0,
      inst: r,
      continue: !e.abort
    }), c > s && a.issues.push({
      origin: "number",
      input: c,
      code: "too_big",
      maximum: s,
      inclusive: !0,
      inst: r,
      continue: !e.abort
    });
  };
}), $Z = /* @__PURE__ */ oe("$ZodCheckMaxLength", (r, e) => {
  var t;
  ui.init(r, e), (t = r._zod.def).when ?? (t.when = (n) => {
    const i = n.value;
    return !pC(i) && i.length !== void 0;
  }), r._zod.onattach.push((n) => {
    const i = n._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    e.maximum < i && (n._zod.bag.maximum = e.maximum);
  }), r._zod.check = (n) => {
    const i = n.value;
    if (i.length <= e.maximum)
      return;
    const o = mC(i);
    n.issues.push({
      origin: o,
      code: "too_big",
      maximum: e.maximum,
      inclusive: !0,
      input: i,
      inst: r,
      continue: !e.abort
    });
  };
}), RZ = /* @__PURE__ */ oe("$ZodCheckMinLength", (r, e) => {
  var t;
  ui.init(r, e), (t = r._zod.def).when ?? (t.when = (n) => {
    const i = n.value;
    return !pC(i) && i.length !== void 0;
  }), r._zod.onattach.push((n) => {
    const i = n._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    e.minimum > i && (n._zod.bag.minimum = e.minimum);
  }), r._zod.check = (n) => {
    const i = n.value;
    if (i.length >= e.minimum)
      return;
    const o = mC(i);
    n.issues.push({
      origin: o,
      code: "too_small",
      minimum: e.minimum,
      inclusive: !0,
      input: i,
      inst: r,
      continue: !e.abort
    });
  };
}), PZ = /* @__PURE__ */ oe("$ZodCheckLengthEquals", (r, e) => {
  var t;
  ui.init(r, e), (t = r._zod.def).when ?? (t.when = (n) => {
    const i = n.value;
    return !pC(i) && i.length !== void 0;
  }), r._zod.onattach.push((n) => {
    const i = n._zod.bag;
    i.minimum = e.length, i.maximum = e.length, i.length = e.length;
  }), r._zod.check = (n) => {
    const i = n.value, s = i.length;
    if (s === e.length)
      return;
    const o = mC(i), a = s > e.length;
    n.issues.push({
      origin: o,
      ...a ? { code: "too_big", maximum: e.length } : { code: "too_small", minimum: e.length },
      inclusive: !0,
      exact: !0,
      input: n.value,
      inst: r,
      continue: !e.abort
    });
  };
}), u0 = /* @__PURE__ */ oe("$ZodCheckStringFormat", (r, e) => {
  var t, n;
  ui.init(r, e), r._zod.onattach.push((i) => {
    const s = i._zod.bag;
    s.format = e.format, e.pattern && (s.patterns ?? (s.patterns = /* @__PURE__ */ new Set()), s.patterns.add(e.pattern));
  }), e.pattern ? (t = r._zod).check ?? (t.check = (i) => {
    e.pattern.lastIndex = 0, !e.pattern.test(i.value) && i.issues.push({
      origin: "string",
      code: "invalid_format",
      format: e.format,
      input: i.value,
      ...e.pattern ? { pattern: e.pattern.toString() } : {},
      inst: r,
      continue: !e.abort
    });
  }) : (n = r._zod).check ?? (n.check = () => {
  });
}), NZ = /* @__PURE__ */ oe("$ZodCheckRegex", (r, e) => {
  u0.init(r, e), r._zod.check = (t) => {
    e.pattern.lastIndex = 0, !e.pattern.test(t.value) && t.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: t.value,
      pattern: e.pattern.toString(),
      inst: r,
      continue: !e.abort
    });
  };
}), BZ = /* @__PURE__ */ oe("$ZodCheckLowerCase", (r, e) => {
  e.pattern ?? (e.pattern = DZ), u0.init(r, e);
}), LZ = /* @__PURE__ */ oe("$ZodCheckUpperCase", (r, e) => {
  e.pattern ?? (e.pattern = TZ), u0.init(r, e);
}), UZ = /* @__PURE__ */ oe("$ZodCheckIncludes", (r, e) => {
  ui.init(r, e);
  const t = jh(e.includes), n = new RegExp(typeof e.position == "number" ? `^.{${e.position}}${t}` : t);
  e.pattern = n, r._zod.onattach.push((i) => {
    const s = i._zod.bag;
    s.patterns ?? (s.patterns = /* @__PURE__ */ new Set()), s.patterns.add(n);
  }), r._zod.check = (i) => {
    i.value.includes(e.includes, e.position) || i.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: e.includes,
      input: i.value,
      inst: r,
      continue: !e.abort
    });
  };
}), FZ = /* @__PURE__ */ oe("$ZodCheckStartsWith", (r, e) => {
  ui.init(r, e);
  const t = new RegExp(`^${jh(e.prefix)}.*`);
  e.pattern ?? (e.pattern = t), r._zod.onattach.push((n) => {
    const i = n._zod.bag;
    i.patterns ?? (i.patterns = /* @__PURE__ */ new Set()), i.patterns.add(t);
  }), r._zod.check = (n) => {
    n.value.startsWith(e.prefix) || n.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: e.prefix,
      input: n.value,
      inst: r,
      continue: !e.abort
    });
  };
}), MZ = /* @__PURE__ */ oe("$ZodCheckEndsWith", (r, e) => {
  ui.init(r, e);
  const t = new RegExp(`.*${jh(e.suffix)}$`);
  e.pattern ?? (e.pattern = t), r._zod.onattach.push((n) => {
    const i = n._zod.bag;
    i.patterns ?? (i.patterns = /* @__PURE__ */ new Set()), i.patterns.add(t);
  }), r._zod.check = (n) => {
    n.value.endsWith(e.suffix) || n.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: e.suffix,
      input: n.value,
      inst: r,
      continue: !e.abort
    });
  };
}), VZ = /* @__PURE__ */ oe("$ZodCheckOverwrite", (r, e) => {
  ui.init(r, e), r._zod.check = (t) => {
    t.value = e.tx(t.value);
  };
});
class zZ {
  constructor(e = []) {
    this.content = [], this.indent = 0, this && (this.args = e);
  }
  indented(e) {
    this.indent += 1, e(this), this.indent -= 1;
  }
  write(e) {
    if (typeof e == "function") {
      e(this, { execution: "sync" }), e(this, { execution: "async" });
      return;
    }
    const n = e.split(`
`).filter((o) => o), i = Math.min(...n.map((o) => o.length - o.trimStart().length)), s = n.map((o) => o.slice(i)).map((o) => " ".repeat(this.indent * 2) + o);
    for (const o of s)
      this.content.push(o);
  }
  compile() {
    const e = Function, t = this == null ? void 0 : this.args, i = [...((this == null ? void 0 : this.content) ?? [""]).map((s) => `  ${s}`)];
    return new e(...t, i.join(`
`));
  }
}
const jZ = {
  major: 4,
  minor: 3,
  patch: 6
}, mr = /* @__PURE__ */ oe("$ZodType", (r, e) => {
  var i;
  var t;
  r ?? (r = {}), r._zod.def = e, r._zod.bag = r._zod.bag || {}, r._zod.version = jZ;
  const n = [...r._zod.def.checks ?? []];
  r._zod.traits.has("$ZodCheck") && n.unshift(r);
  for (const s of n)
    for (const o of s._zod.onattach)
      o(r);
  if (n.length === 0)
    (t = r._zod).deferred ?? (t.deferred = []), (i = r._zod.deferred) == null || i.push(() => {
      r._zod.run = r._zod.parse;
    });
  else {
    const s = (a, c, u) => {
      let l = rd(a), d;
      for (const f of c) {
        if (f._zod.def.when) {
          if (!f._zod.def.when(a))
            continue;
        } else if (l)
          continue;
        const p = a.issues.length, y = f._zod.check(a);
        if (y instanceof Promise && (u == null ? void 0 : u.async) === !1)
          throw new md();
        if (d || y instanceof Promise)
          d = (d ?? Promise.resolve()).then(async () => {
            await y, a.issues.length !== p && (l || (l = rd(a, p)));
          });
        else {
          if (a.issues.length === p)
            continue;
          l || (l = rd(a, p));
        }
      }
      return d ? d.then(() => a) : a;
    }, o = (a, c, u) => {
      if (rd(a))
        return a.aborted = !0, a;
      const l = s(c, n, u);
      if (l instanceof Promise) {
        if (u.async === !1)
          throw new md();
        return l.then((d) => r._zod.parse(d, u));
      }
      return r._zod.parse(l, u);
    };
    r._zod.run = (a, c) => {
      if (c.skipChecks)
        return r._zod.parse(a, c);
      if (c.direction === "backward") {
        const l = r._zod.parse({ value: a.value, issues: [] }, { ...c, skipChecks: !0 });
        return l instanceof Promise ? l.then((d) => o(d, a, c)) : o(l, a, c);
      }
      const u = r._zod.parse(a, c);
      if (u instanceof Promise) {
        if (c.async === !1)
          throw new md();
        return u.then((l) => s(l, n, c));
      }
      return s(u, n, c);
    };
  }
  At(r, "~standard", () => ({
    validate: (s) => {
      var o;
      try {
        const a = ZW(r, s);
        return a.success ? { value: a.data } : { issues: (o = a.error) == null ? void 0 : o.issues };
      } catch {
        return JW(r, s).then((c) => {
          var u;
          return c.success ? { value: c.data } : { issues: (u = c.error) == null ? void 0 : u.issues };
        });
      }
    },
    vendor: "zod",
    version: 1
  }));
}), bC = /* @__PURE__ */ oe("$ZodString", (r, e) => {
  var t;
  mr.init(r, e), r._zod.pattern = [...((t = r == null ? void 0 : r._zod.bag) == null ? void 0 : t.patterns) ?? []].pop() ?? AZ(r._zod.bag), r._zod.parse = (n, i) => {
    if (e.coerce)
      try {
        n.value = String(n.value);
      } catch {
      }
    return typeof n.value == "string" || n.issues.push({
      expected: "string",
      code: "invalid_type",
      input: n.value,
      inst: r
    }), n;
  };
}), er = /* @__PURE__ */ oe("$ZodStringFormat", (r, e) => {
  u0.init(r, e), bC.init(r, e);
}), HZ = /* @__PURE__ */ oe("$ZodGUID", (r, e) => {
  e.pattern ?? (e.pattern = hZ), er.init(r, e);
}), GZ = /* @__PURE__ */ oe("$ZodUUID", (r, e) => {
  if (e.version) {
    const n = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    }[e.version];
    if (n === void 0)
      throw new Error(`Invalid UUID version: "${e.version}"`);
    e.pattern ?? (e.pattern = BO(n));
  } else
    e.pattern ?? (e.pattern = BO());
  er.init(r, e);
}), KZ = /* @__PURE__ */ oe("$ZodEmail", (r, e) => {
  e.pattern ?? (e.pattern = fZ), er.init(r, e);
}), qZ = /* @__PURE__ */ oe("$ZodURL", (r, e) => {
  er.init(r, e), r._zod.check = (t) => {
    try {
      const n = t.value.trim(), i = new URL(n);
      e.hostname && (e.hostname.lastIndex = 0, e.hostname.test(i.hostname) || t.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid hostname",
        pattern: e.hostname.source,
        input: t.value,
        inst: r,
        continue: !e.abort
      })), e.protocol && (e.protocol.lastIndex = 0, e.protocol.test(i.protocol.endsWith(":") ? i.protocol.slice(0, -1) : i.protocol) || t.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid protocol",
        pattern: e.protocol.source,
        input: t.value,
        inst: r,
        continue: !e.abort
      })), e.normalize ? t.value = i.href : t.value = n;
      return;
    } catch {
      t.issues.push({
        code: "invalid_format",
        format: "url",
        input: t.value,
        inst: r,
        continue: !e.abort
      });
    }
  };
}), WZ = /* @__PURE__ */ oe("$ZodEmoji", (r, e) => {
  e.pattern ?? (e.pattern = gZ()), er.init(r, e);
}), ZZ = /* @__PURE__ */ oe("$ZodNanoID", (r, e) => {
  e.pattern ?? (e.pattern = lZ), er.init(r, e);
}), JZ = /* @__PURE__ */ oe("$ZodCUID", (r, e) => {
  e.pattern ?? (e.pattern = sZ), er.init(r, e);
}), XZ = /* @__PURE__ */ oe("$ZodCUID2", (r, e) => {
  e.pattern ?? (e.pattern = oZ), er.init(r, e);
}), YZ = /* @__PURE__ */ oe("$ZodULID", (r, e) => {
  e.pattern ?? (e.pattern = aZ), er.init(r, e);
}), QZ = /* @__PURE__ */ oe("$ZodXID", (r, e) => {
  e.pattern ?? (e.pattern = cZ), er.init(r, e);
}), eJ = /* @__PURE__ */ oe("$ZodKSUID", (r, e) => {
  e.pattern ?? (e.pattern = uZ), er.init(r, e);
}), tJ = /* @__PURE__ */ oe("$ZodISODateTime", (r, e) => {
  e.pattern ?? (e.pattern = xZ(e)), er.init(r, e);
}), rJ = /* @__PURE__ */ oe("$ZodISODate", (r, e) => {
  e.pattern ?? (e.pattern = SZ), er.init(r, e);
}), nJ = /* @__PURE__ */ oe("$ZodISOTime", (r, e) => {
  e.pattern ?? (e.pattern = EZ(e)), er.init(r, e);
}), iJ = /* @__PURE__ */ oe("$ZodISODuration", (r, e) => {
  e.pattern ?? (e.pattern = dZ), er.init(r, e);
}), sJ = /* @__PURE__ */ oe("$ZodIPv4", (r, e) => {
  e.pattern ?? (e.pattern = mZ), er.init(r, e), r._zod.bag.format = "ipv4";
}), oJ = /* @__PURE__ */ oe("$ZodIPv6", (r, e) => {
  e.pattern ?? (e.pattern = yZ), er.init(r, e), r._zod.bag.format = "ipv6", r._zod.check = (t) => {
    try {
      new URL(`http://[${t.value}]`);
    } catch {
      t.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: t.value,
        inst: r,
        continue: !e.abort
      });
    }
  };
}), aJ = /* @__PURE__ */ oe("$ZodCIDRv4", (r, e) => {
  e.pattern ?? (e.pattern = vZ), er.init(r, e);
}), cJ = /* @__PURE__ */ oe("$ZodCIDRv6", (r, e) => {
  e.pattern ?? (e.pattern = bZ), er.init(r, e), r._zod.check = (t) => {
    const n = t.value.split("/");
    try {
      if (n.length !== 2)
        throw new Error();
      const [i, s] = n;
      if (!s)
        throw new Error();
      const o = Number(s);
      if (`${o}` !== s)
        throw new Error();
      if (o < 0 || o > 128)
        throw new Error();
      new URL(`http://[${i}]`);
    } catch {
      t.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: t.value,
        inst: r,
        continue: !e.abort
      });
    }
  };
});
function v3(r) {
  if (r === "")
    return !0;
  if (r.length % 4 !== 0)
    return !1;
  try {
    return atob(r), !0;
  } catch {
    return !1;
  }
}
const uJ = /* @__PURE__ */ oe("$ZodBase64", (r, e) => {
  e.pattern ?? (e.pattern = wZ), er.init(r, e), r._zod.bag.contentEncoding = "base64", r._zod.check = (t) => {
    v3(t.value) || t.issues.push({
      code: "invalid_format",
      format: "base64",
      input: t.value,
      inst: r,
      continue: !e.abort
    });
  };
});
function lJ(r) {
  if (!h3.test(r))
    return !1;
  const e = r.replace(/[-_]/g, (n) => n === "-" ? "+" : "/"), t = e.padEnd(Math.ceil(e.length / 4) * 4, "=");
  return v3(t);
}
const dJ = /* @__PURE__ */ oe("$ZodBase64URL", (r, e) => {
  e.pattern ?? (e.pattern = h3), er.init(r, e), r._zod.bag.contentEncoding = "base64url", r._zod.check = (t) => {
    lJ(t.value) || t.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: t.value,
      inst: r,
      continue: !e.abort
    });
  };
}), hJ = /* @__PURE__ */ oe("$ZodE164", (r, e) => {
  e.pattern ?? (e.pattern = _Z), er.init(r, e);
});
function fJ(r, e = null) {
  try {
    const t = r.split(".");
    if (t.length !== 3)
      return !1;
    const [n] = t;
    if (!n)
      return !1;
    const i = JSON.parse(atob(n));
    return !("typ" in i && (i == null ? void 0 : i.typ) !== "JWT" || !i.alg || e && (!("alg" in i) || i.alg !== e));
  } catch {
    return !1;
  }
}
const pJ = /* @__PURE__ */ oe("$ZodJWT", (r, e) => {
  er.init(r, e), r._zod.check = (t) => {
    fJ(t.value, e.alg) || t.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: t.value,
      inst: r,
      continue: !e.abort
    });
  };
}), b3 = /* @__PURE__ */ oe("$ZodNumber", (r, e) => {
  mr.init(r, e), r._zod.pattern = r._zod.bag.pattern ?? CZ, r._zod.parse = (t, n) => {
    if (e.coerce)
      try {
        t.value = Number(t.value);
      } catch {
      }
    const i = t.value;
    if (typeof i == "number" && !Number.isNaN(i) && Number.isFinite(i))
      return t;
    const s = typeof i == "number" ? Number.isNaN(i) ? "NaN" : Number.isFinite(i) ? void 0 : "Infinity" : void 0;
    return t.issues.push({
      expected: "number",
      code: "invalid_type",
      input: i,
      inst: r,
      ...s ? { received: s } : {}
    }), t;
  };
}), gJ = /* @__PURE__ */ oe("$ZodNumberFormat", (r, e) => {
  OZ.init(r, e), b3.init(r, e);
}), mJ = /* @__PURE__ */ oe("$ZodUnknown", (r, e) => {
  mr.init(r, e), r._zod.parse = (t) => t;
}), yJ = /* @__PURE__ */ oe("$ZodNever", (r, e) => {
  mr.init(r, e), r._zod.parse = (t, n) => (t.issues.push({
    expected: "never",
    code: "invalid_type",
    input: t.value,
    inst: r
  }), t);
});
function LO(r, e, t) {
  r.issues.length && e.issues.push(...c3(t, r.issues)), e.value[t] = r.value;
}
const vJ = /* @__PURE__ */ oe("$ZodArray", (r, e) => {
  mr.init(r, e), r._zod.parse = (t, n) => {
    const i = t.value;
    if (!Array.isArray(i))
      return t.issues.push({
        expected: "array",
        code: "invalid_type",
        input: i,
        inst: r
      }), t;
    t.value = Array(i.length);
    const s = [];
    for (let o = 0; o < i.length; o++) {
      const a = i[o], c = e.element._zod.run({
        value: a,
        issues: []
      }, n);
      c instanceof Promise ? s.push(c.then((u) => LO(u, t, o))) : LO(c, t, o);
    }
    return s.length ? Promise.all(s).then(() => t) : t;
  };
});
function zy(r, e, t, n, i) {
  if (r.issues.length) {
    if (i && !(t in n))
      return;
    e.issues.push(...c3(t, r.issues));
  }
  r.value === void 0 ? t in n && (e.value[t] = void 0) : e.value[t] = r.value;
}
function w3(r) {
  var n, i, s, o;
  const e = Object.keys(r.shape);
  for (const a of e)
    if (!((o = (s = (i = (n = r.shape) == null ? void 0 : n[a]) == null ? void 0 : i._zod) == null ? void 0 : s.traits) != null && o.has("$ZodType")))
      throw new Error(`Invalid element at key "${a}": expected a Zod schema`);
  const t = UW(r.shape);
  return {
    ...r,
    keys: e,
    keySet: new Set(e),
    numKeys: e.length,
    optionalKeys: new Set(t)
  };
}
function _3(r, e, t, n, i, s) {
  const o = [], a = i.keySet, c = i.catchall._zod, u = c.def.type, l = c.optout === "optional";
  for (const d in e) {
    if (a.has(d))
      continue;
    if (u === "never") {
      o.push(d);
      continue;
    }
    const f = c.run({ value: e[d], issues: [] }, n);
    f instanceof Promise ? r.push(f.then((p) => zy(p, t, d, e, l))) : zy(f, t, d, e, l);
  }
  return o.length && t.issues.push({
    code: "unrecognized_keys",
    keys: o,
    input: e,
    inst: s
  }), r.length ? Promise.all(r).then(() => t) : t;
}
const bJ = /* @__PURE__ */ oe("$ZodObject", (r, e) => {
  mr.init(r, e);
  const t = Object.getOwnPropertyDescriptor(e, "shape");
  if (!(t != null && t.get)) {
    const a = e.shape;
    Object.defineProperty(e, "shape", {
      get: () => {
        const c = { ...a };
        return Object.defineProperty(e, "shape", {
          value: c
        }), c;
      }
    });
  }
  const n = o0(() => w3(e));
  At(r._zod, "propValues", () => {
    const a = e.shape, c = {};
    for (const u in a) {
      const l = a[u]._zod;
      if (l.values) {
        c[u] ?? (c[u] = /* @__PURE__ */ new Set());
        for (const d of l.values)
          c[u].add(d);
      }
    }
    return c;
  });
  const i = jp, s = e.catchall;
  let o;
  r._zod.parse = (a, c) => {
    o ?? (o = n.value);
    const u = a.value;
    if (!i(u))
      return a.issues.push({
        expected: "object",
        code: "invalid_type",
        input: u,
        inst: r
      }), a;
    a.value = {};
    const l = [], d = o.shape;
    for (const f of o.keys) {
      const p = d[f], y = p._zod.optout === "optional", g = p._zod.run({ value: u[f], issues: [] }, c);
      g instanceof Promise ? l.push(g.then((v) => zy(v, a, f, u, y))) : zy(g, a, f, u, y);
    }
    return s ? _3(l, u, a, c, n.value, r) : l.length ? Promise.all(l).then(() => a) : a;
  };
}), wJ = /* @__PURE__ */ oe("$ZodObjectJIT", (r, e) => {
  bJ.init(r, e);
  const t = r._zod.parse, n = o0(() => w3(e)), i = (f) => {
    var E;
    const p = new zZ(["shape", "payload", "ctx"]), y = n.value, g = (I) => {
      const S = NO(I);
      return `shape[${S}]._zod.run({ value: input[${S}], issues: [] }, ctx)`;
    };
    p.write("const input = payload.value;");
    const v = /* @__PURE__ */ Object.create(null);
    let _ = 0;
    for (const I of y.keys)
      v[I] = `key_${_++}`;
    p.write("const newResult = {};");
    for (const I of y.keys) {
      const S = v[I], T = NO(I), b = f[I], C = ((E = b == null ? void 0 : b._zod) == null ? void 0 : E.optout) === "optional";
      p.write(`const ${S} = ${g(I)};`), C ? p.write(`
        if (${S}.issues.length) {
          if (${T} in input) {
            payload.issues = payload.issues.concat(${S}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${T}, ...iss.path] : [${T}]
            })));
          }
        }
        
        if (${S}.value === undefined) {
          if (${T} in input) {
            newResult[${T}] = undefined;
          }
        } else {
          newResult[${T}] = ${S}.value;
        }
        
      `) : p.write(`
        if (${S}.issues.length) {
          payload.issues = payload.issues.concat(${S}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${T}, ...iss.path] : [${T}]
          })));
        }
        
        if (${S}.value === undefined) {
          if (${T} in input) {
            newResult[${T}] = undefined;
          }
        } else {
          newResult[${T}] = ${S}.value;
        }
        
      `);
    }
    p.write("payload.value = newResult;"), p.write("return payload;");
    const w = p.compile();
    return (I, S) => w(f, I, S);
  };
  let s;
  const o = jp, a = !i3.jitless, u = a && BW.value, l = e.catchall;
  let d;
  r._zod.parse = (f, p) => {
    d ?? (d = n.value);
    const y = f.value;
    return o(y) ? a && u && (p == null ? void 0 : p.async) === !1 && p.jitless !== !0 ? (s || (s = i(e.shape)), f = s(f, p), l ? _3([], y, f, p, d, r) : f) : t(f, p) : (f.issues.push({
      expected: "object",
      code: "invalid_type",
      input: y,
      inst: r
    }), f);
  };
});
function UO(r, e, t, n) {
  for (const s of r)
    if (s.issues.length === 0)
      return e.value = s.value, e;
  const i = r.filter((s) => !rd(s));
  return i.length === 1 ? (e.value = i[0].value, i[0]) : (e.issues.push({
    code: "invalid_union",
    input: e.value,
    inst: t,
    errors: r.map((s) => s.issues.map((o) => el(o, n, Qu())))
  }), e);
}
const S3 = /* @__PURE__ */ oe("$ZodUnion", (r, e) => {
  mr.init(r, e), At(r._zod, "optin", () => e.options.some((i) => i._zod.optin === "optional") ? "optional" : void 0), At(r._zod, "optout", () => e.options.some((i) => i._zod.optout === "optional") ? "optional" : void 0), At(r._zod, "values", () => {
    if (e.options.every((i) => i._zod.values))
      return new Set(e.options.flatMap((i) => Array.from(i._zod.values)));
  }), At(r._zod, "pattern", () => {
    if (e.options.every((i) => i._zod.pattern)) {
      const i = e.options.map((s) => s._zod.pattern);
      return new RegExp(`^(${i.map((s) => gC(s.source)).join("|")})$`);
    }
  });
  const t = e.options.length === 1, n = e.options[0]._zod.run;
  r._zod.parse = (i, s) => {
    if (t)
      return n(i, s);
    let o = !1;
    const a = [];
    for (const c of e.options) {
      const u = c._zod.run({
        value: i.value,
        issues: []
      }, s);
      if (u instanceof Promise)
        a.push(u), o = !0;
      else {
        if (u.issues.length === 0)
          return u;
        a.push(u);
      }
    }
    return o ? Promise.all(a).then((c) => UO(c, i, r, s)) : UO(a, i, r, s);
  };
}), _J = /* @__PURE__ */ oe("$ZodDiscriminatedUnion", (r, e) => {
  e.inclusive = !1, S3.init(r, e);
  const t = r._zod.parse;
  At(r._zod, "propValues", () => {
    const i = {};
    for (const s of e.options) {
      const o = s._zod.propValues;
      if (!o || Object.keys(o).length === 0)
        throw new Error(`Invalid discriminated union option at index "${e.options.indexOf(s)}"`);
      for (const [a, c] of Object.entries(o)) {
        i[a] || (i[a] = /* @__PURE__ */ new Set());
        for (const u of c)
          i[a].add(u);
      }
    }
    return i;
  });
  const n = o0(() => {
    var o;
    const i = e.options, s = /* @__PURE__ */ new Map();
    for (const a of i) {
      const c = (o = a._zod.propValues) == null ? void 0 : o[e.discriminator];
      if (!c || c.size === 0)
        throw new Error(`Invalid discriminated union option at index "${e.options.indexOf(a)}"`);
      for (const u of c) {
        if (s.has(u))
          throw new Error(`Duplicate discriminator value "${String(u)}"`);
        s.set(u, a);
      }
    }
    return s;
  });
  r._zod.parse = (i, s) => {
    const o = i.value;
    if (!jp(o))
      return i.issues.push({
        code: "invalid_type",
        expected: "object",
        input: o,
        inst: r
      }), i;
    const a = n.value.get(o == null ? void 0 : o[e.discriminator]);
    return a ? a._zod.run(i, s) : e.unionFallback ? t(i, s) : (i.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: e.discriminator,
      input: o,
      path: [e.discriminator],
      inst: r
    }), i);
  };
}), SJ = /* @__PURE__ */ oe("$ZodIntersection", (r, e) => {
  mr.init(r, e), r._zod.parse = (t, n) => {
    const i = t.value, s = e.left._zod.run({ value: i, issues: [] }, n), o = e.right._zod.run({ value: i, issues: [] }, n);
    return s instanceof Promise || o instanceof Promise ? Promise.all([s, o]).then(([c, u]) => FO(t, c, u)) : FO(t, s, o);
  };
});
function ux(r, e) {
  if (r === e)
    return { valid: !0, data: r };
  if (r instanceof Date && e instanceof Date && +r == +e)
    return { valid: !0, data: r };
  if (Hp(r) && Hp(e)) {
    const t = Object.keys(e), n = Object.keys(r).filter((s) => t.indexOf(s) !== -1), i = { ...r, ...e };
    for (const s of n) {
      const o = ux(r[s], e[s]);
      if (!o.valid)
        return {
          valid: !1,
          mergeErrorPath: [s, ...o.mergeErrorPath]
        };
      i[s] = o.data;
    }
    return { valid: !0, data: i };
  }
  if (Array.isArray(r) && Array.isArray(e)) {
    if (r.length !== e.length)
      return { valid: !1, mergeErrorPath: [] };
    const t = [];
    for (let n = 0; n < r.length; n++) {
      const i = r[n], s = e[n], o = ux(i, s);
      if (!o.valid)
        return {
          valid: !1,
          mergeErrorPath: [n, ...o.mergeErrorPath]
        };
      t.push(o.data);
    }
    return { valid: !0, data: t };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function FO(r, e, t) {
  const n = /* @__PURE__ */ new Map();
  let i;
  for (const a of e.issues)
    if (a.code === "unrecognized_keys") {
      i ?? (i = a);
      for (const c of a.keys)
        n.has(c) || n.set(c, {}), n.get(c).l = !0;
    } else
      r.issues.push(a);
  for (const a of t.issues)
    if (a.code === "unrecognized_keys")
      for (const c of a.keys)
        n.has(c) || n.set(c, {}), n.get(c).r = !0;
    else
      r.issues.push(a);
  const s = [...n].filter(([, a]) => a.l && a.r).map(([a]) => a);
  if (s.length && i && r.issues.push({ ...i, keys: s }), rd(r))
    return r;
  const o = ux(e.value, t.value);
  if (!o.valid)
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(o.mergeErrorPath)}`);
  return r.value = o.data, r;
}
const EJ = /* @__PURE__ */ oe("$ZodEnum", (r, e) => {
  mr.init(r, e);
  const t = s3(e.entries), n = new Set(t);
  r._zod.values = n, r._zod.pattern = new RegExp(`^(${t.filter((i) => LW.has(typeof i)).map((i) => typeof i == "string" ? jh(i) : i.toString()).join("|")})$`), r._zod.parse = (i, s) => {
    const o = i.value;
    return n.has(o) || i.issues.push({
      code: "invalid_value",
      values: t,
      input: o,
      inst: r
    }), i;
  };
}), xJ = /* @__PURE__ */ oe("$ZodLiteral", (r, e) => {
  if (mr.init(r, e), e.values.length === 0)
    throw new Error("Cannot create literal schema with no valid values");
  const t = new Set(e.values);
  r._zod.values = t, r._zod.pattern = new RegExp(`^(${e.values.map((n) => typeof n == "string" ? jh(n) : n ? jh(n.toString()) : String(n)).join("|")})$`), r._zod.parse = (n, i) => {
    const s = n.value;
    return t.has(s) || n.issues.push({
      code: "invalid_value",
      values: e.values,
      input: s,
      inst: r
    }), n;
  };
}), AJ = /* @__PURE__ */ oe("$ZodTransform", (r, e) => {
  mr.init(r, e), r._zod.parse = (t, n) => {
    if (n.direction === "backward")
      throw new n3(r.constructor.name);
    const i = e.transform(t.value, t);
    if (n.async)
      return (i instanceof Promise ? i : Promise.resolve(i)).then((o) => (t.value = o, t));
    if (i instanceof Promise)
      throw new md();
    return t.value = i, t;
  };
});
function MO(r, e) {
  return r.issues.length && e === void 0 ? { issues: [], value: void 0 } : r;
}
const E3 = /* @__PURE__ */ oe("$ZodOptional", (r, e) => {
  mr.init(r, e), r._zod.optin = "optional", r._zod.optout = "optional", At(r._zod, "values", () => e.innerType._zod.values ? /* @__PURE__ */ new Set([...e.innerType._zod.values, void 0]) : void 0), At(r._zod, "pattern", () => {
    const t = e.innerType._zod.pattern;
    return t ? new RegExp(`^(${gC(t.source)})?$`) : void 0;
  }), r._zod.parse = (t, n) => {
    if (e.innerType._zod.optin === "optional") {
      const i = e.innerType._zod.run(t, n);
      return i instanceof Promise ? i.then((s) => MO(s, t.value)) : MO(i, t.value);
    }
    return t.value === void 0 ? t : e.innerType._zod.run(t, n);
  };
}), IJ = /* @__PURE__ */ oe("$ZodExactOptional", (r, e) => {
  E3.init(r, e), At(r._zod, "values", () => e.innerType._zod.values), At(r._zod, "pattern", () => e.innerType._zod.pattern), r._zod.parse = (t, n) => e.innerType._zod.run(t, n);
}), CJ = /* @__PURE__ */ oe("$ZodNullable", (r, e) => {
  mr.init(r, e), At(r._zod, "optin", () => e.innerType._zod.optin), At(r._zod, "optout", () => e.innerType._zod.optout), At(r._zod, "pattern", () => {
    const t = e.innerType._zod.pattern;
    return t ? new RegExp(`^(${gC(t.source)}|null)$`) : void 0;
  }), At(r._zod, "values", () => e.innerType._zod.values ? /* @__PURE__ */ new Set([...e.innerType._zod.values, null]) : void 0), r._zod.parse = (t, n) => t.value === null ? t : e.innerType._zod.run(t, n);
}), DJ = /* @__PURE__ */ oe("$ZodDefault", (r, e) => {
  mr.init(r, e), r._zod.optin = "optional", At(r._zod, "values", () => e.innerType._zod.values), r._zod.parse = (t, n) => {
    if (n.direction === "backward")
      return e.innerType._zod.run(t, n);
    if (t.value === void 0)
      return t.value = e.defaultValue, t;
    const i = e.innerType._zod.run(t, n);
    return i instanceof Promise ? i.then((s) => VO(s, e)) : VO(i, e);
  };
});
function VO(r, e) {
  return r.value === void 0 && (r.value = e.defaultValue), r;
}
const TJ = /* @__PURE__ */ oe("$ZodPrefault", (r, e) => {
  mr.init(r, e), r._zod.optin = "optional", At(r._zod, "values", () => e.innerType._zod.values), r._zod.parse = (t, n) => (n.direction === "backward" || t.value === void 0 && (t.value = e.defaultValue), e.innerType._zod.run(t, n));
}), kJ = /* @__PURE__ */ oe("$ZodNonOptional", (r, e) => {
  mr.init(r, e), At(r._zod, "values", () => {
    const t = e.innerType._zod.values;
    return t ? new Set([...t].filter((n) => n !== void 0)) : void 0;
  }), r._zod.parse = (t, n) => {
    const i = e.innerType._zod.run(t, n);
    return i instanceof Promise ? i.then((s) => zO(s, r)) : zO(i, r);
  };
});
function zO(r, e) {
  return !r.issues.length && r.value === void 0 && r.issues.push({
    code: "invalid_type",
    expected: "nonoptional",
    input: r.value,
    inst: e
  }), r;
}
const OJ = /* @__PURE__ */ oe("$ZodCatch", (r, e) => {
  mr.init(r, e), At(r._zod, "optin", () => e.innerType._zod.optin), At(r._zod, "optout", () => e.innerType._zod.optout), At(r._zod, "values", () => e.innerType._zod.values), r._zod.parse = (t, n) => {
    if (n.direction === "backward")
      return e.innerType._zod.run(t, n);
    const i = e.innerType._zod.run(t, n);
    return i instanceof Promise ? i.then((s) => (t.value = s.value, s.issues.length && (t.value = e.catchValue({
      ...t,
      error: {
        issues: s.issues.map((o) => el(o, n, Qu()))
      },
      input: t.value
    }), t.issues = []), t)) : (t.value = i.value, i.issues.length && (t.value = e.catchValue({
      ...t,
      error: {
        issues: i.issues.map((s) => el(s, n, Qu()))
      },
      input: t.value
    }), t.issues = []), t);
  };
}), $J = /* @__PURE__ */ oe("$ZodPipe", (r, e) => {
  mr.init(r, e), At(r._zod, "values", () => e.in._zod.values), At(r._zod, "optin", () => e.in._zod.optin), At(r._zod, "optout", () => e.out._zod.optout), At(r._zod, "propValues", () => e.in._zod.propValues), r._zod.parse = (t, n) => {
    if (n.direction === "backward") {
      const s = e.out._zod.run(t, n);
      return s instanceof Promise ? s.then((o) => Cm(o, e.in, n)) : Cm(s, e.in, n);
    }
    const i = e.in._zod.run(t, n);
    return i instanceof Promise ? i.then((s) => Cm(s, e.out, n)) : Cm(i, e.out, n);
  };
});
function Cm(r, e, t) {
  return r.issues.length ? (r.aborted = !0, r) : e._zod.run({ value: r.value, issues: r.issues }, t);
}
const RJ = /* @__PURE__ */ oe("$ZodReadonly", (r, e) => {
  mr.init(r, e), At(r._zod, "propValues", () => e.innerType._zod.propValues), At(r._zod, "values", () => e.innerType._zod.values), At(r._zod, "optin", () => {
    var t, n;
    return (n = (t = e.innerType) == null ? void 0 : t._zod) == null ? void 0 : n.optin;
  }), At(r._zod, "optout", () => {
    var t, n;
    return (n = (t = e.innerType) == null ? void 0 : t._zod) == null ? void 0 : n.optout;
  }), r._zod.parse = (t, n) => {
    if (n.direction === "backward")
      return e.innerType._zod.run(t, n);
    const i = e.innerType._zod.run(t, n);
    return i instanceof Promise ? i.then(jO) : jO(i);
  };
});
function jO(r) {
  return r.value = Object.freeze(r.value), r;
}
const PJ = /* @__PURE__ */ oe("$ZodCustom", (r, e) => {
  ui.init(r, e), mr.init(r, e), r._zod.parse = (t, n) => t, r._zod.check = (t) => {
    const n = t.value, i = e.fn(n);
    if (i instanceof Promise)
      return i.then((s) => HO(s, t, n, r));
    HO(i, t, n, r);
  };
});
function HO(r, e, t, n) {
  if (!r) {
    const i = {
      code: "custom",
      input: t,
      inst: n,
      // incorporates params.error into issue reporting
      path: [...n._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !n._zod.def.abort
      // params: inst._zod.def.params,
    };
    n._zod.def.params && (i.params = n._zod.def.params), e.issues.push(Gp(i));
  }
}
var GO;
class NJ {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(e, ...t) {
    const n = t[0];
    return this._map.set(e, n), n && typeof n == "object" && "id" in n && this._idmap.set(n.id, e), this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map(), this;
  }
  remove(e) {
    const t = this._map.get(e);
    return t && typeof t == "object" && "id" in t && this._idmap.delete(t.id), this._map.delete(e), this;
  }
  get(e) {
    const t = e._zod.parent;
    if (t) {
      const n = { ...this.get(t) ?? {} };
      delete n.id;
      const i = { ...n, ...this._map.get(e) };
      return Object.keys(i).length ? i : void 0;
    }
    return this._map.get(e);
  }
  has(e) {
    return this._map.has(e);
  }
}
function BJ() {
  return new NJ();
}
(GO = globalThis).__zod_globalRegistry ?? (GO.__zod_globalRegistry = BJ());
const up = globalThis.__zod_globalRegistry;
// @__NO_SIDE_EFFECTS__
function LJ(r, e) {
  return new r({
    type: "string",
    ...Fe(e)
  });
}
// @__NO_SIDE_EFFECTS__
function UJ(r, e) {
  return new r({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...Fe(e)
  });
}
// @__NO_SIDE_EFFECTS__
function KO(r, e) {
  return new r({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...Fe(e)
  });
}
// @__NO_SIDE_EFFECTS__
function FJ(r, e) {
  return new r({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...Fe(e)
  });
}
// @__NO_SIDE_EFFECTS__
function MJ(r, e) {
  return new r({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...Fe(e)
  });
}
// @__NO_SIDE_EFFECTS__
function VJ(r, e) {
  return new r({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...Fe(e)
  });
}
// @__NO_SIDE_EFFECTS__
function zJ(r, e) {
  return new r({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...Fe(e)
  });
}
// @__NO_SIDE_EFFECTS__
function jJ(r, e) {
  return new r({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...Fe(e)
  });
}
// @__NO_SIDE_EFFECTS__
function HJ(r, e) {
  return new r({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...Fe(e)
  });
}
// @__NO_SIDE_EFFECTS__
function GJ(r, e) {
  return new r({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...Fe(e)
  });
}
// @__NO_SIDE_EFFECTS__
function KJ(r, e) {
  return new r({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...Fe(e)
  });
}
// @__NO_SIDE_EFFECTS__
function qJ(r, e) {
  return new r({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...Fe(e)
  });
}
// @__NO_SIDE_EFFECTS__
function WJ(r, e) {
  return new r({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...Fe(e)
  });
}
// @__NO_SIDE_EFFECTS__
function ZJ(r, e) {
  return new r({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...Fe(e)
  });
}
// @__NO_SIDE_EFFECTS__
function JJ(r, e) {
  return new r({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...Fe(e)
  });
}
// @__NO_SIDE_EFFECTS__
function XJ(r, e) {
  return new r({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...Fe(e)
  });
}
// @__NO_SIDE_EFFECTS__
function YJ(r, e) {
  return new r({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...Fe(e)
  });
}
// @__NO_SIDE_EFFECTS__
function QJ(r, e) {
  return new r({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...Fe(e)
  });
}
// @__NO_SIDE_EFFECTS__
function eX(r, e) {
  return new r({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...Fe(e)
  });
}
// @__NO_SIDE_EFFECTS__
function tX(r, e) {
  return new r({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...Fe(e)
  });
}
// @__NO_SIDE_EFFECTS__
function rX(r, e) {
  return new r({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...Fe(e)
  });
}
// @__NO_SIDE_EFFECTS__
function nX(r, e) {
  return new r({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...Fe(e)
  });
}
// @__NO_SIDE_EFFECTS__
function iX(r, e) {
  return new r({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...Fe(e)
  });
}
// @__NO_SIDE_EFFECTS__
function sX(r, e) {
  return new r({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...Fe(e)
  });
}
// @__NO_SIDE_EFFECTS__
function oX(r, e) {
  return new r({
    type: "string",
    format: "date",
    check: "string_format",
    ...Fe(e)
  });
}
// @__NO_SIDE_EFFECTS__
function aX(r, e) {
  return new r({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...Fe(e)
  });
}
// @__NO_SIDE_EFFECTS__
function cX(r, e) {
  return new r({
    type: "string",
    format: "duration",
    check: "string_format",
    ...Fe(e)
  });
}
// @__NO_SIDE_EFFECTS__
function uX(r, e) {
  return new r({
    type: "number",
    checks: [],
    ...Fe(e)
  });
}
// @__NO_SIDE_EFFECTS__
function lX(r, e) {
  return new r({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "safeint",
    ...Fe(e)
  });
}
// @__NO_SIDE_EFFECTS__
function dX(r) {
  return new r({
    type: "unknown"
  });
}
// @__NO_SIDE_EFFECTS__
function hX(r, e) {
  return new r({
    type: "never",
    ...Fe(e)
  });
}
// @__NO_SIDE_EFFECTS__
function qO(r, e) {
  return new m3({
    check: "less_than",
    ...Fe(e),
    value: r,
    inclusive: !1
  });
}
// @__NO_SIDE_EFFECTS__
function a_(r, e) {
  return new m3({
    check: "less_than",
    ...Fe(e),
    value: r,
    inclusive: !0
  });
}
// @__NO_SIDE_EFFECTS__
function WO(r, e) {
  return new y3({
    check: "greater_than",
    ...Fe(e),
    value: r,
    inclusive: !1
  });
}
// @__NO_SIDE_EFFECTS__
function c_(r, e) {
  return new y3({
    check: "greater_than",
    ...Fe(e),
    value: r,
    inclusive: !0
  });
}
// @__NO_SIDE_EFFECTS__
function ZO(r, e) {
  return new kZ({
    check: "multiple_of",
    ...Fe(e),
    value: r
  });
}
// @__NO_SIDE_EFFECTS__
function x3(r, e) {
  return new $Z({
    check: "max_length",
    ...Fe(e),
    maximum: r
  });
}
// @__NO_SIDE_EFFECTS__
function jy(r, e) {
  return new RZ({
    check: "min_length",
    ...Fe(e),
    minimum: r
  });
}
// @__NO_SIDE_EFFECTS__
function A3(r, e) {
  return new PZ({
    check: "length_equals",
    ...Fe(e),
    length: r
  });
}
// @__NO_SIDE_EFFECTS__
function fX(r, e) {
  return new NZ({
    check: "string_format",
    format: "regex",
    ...Fe(e),
    pattern: r
  });
}
// @__NO_SIDE_EFFECTS__
function pX(r) {
  return new BZ({
    check: "string_format",
    format: "lowercase",
    ...Fe(r)
  });
}
// @__NO_SIDE_EFFECTS__
function gX(r) {
  return new LZ({
    check: "string_format",
    format: "uppercase",
    ...Fe(r)
  });
}
// @__NO_SIDE_EFFECTS__
function mX(r, e) {
  return new UZ({
    check: "string_format",
    format: "includes",
    ...Fe(e),
    includes: r
  });
}
// @__NO_SIDE_EFFECTS__
function yX(r, e) {
  return new FZ({
    check: "string_format",
    format: "starts_with",
    ...Fe(e),
    prefix: r
  });
}
// @__NO_SIDE_EFFECTS__
function vX(r, e) {
  return new MZ({
    check: "string_format",
    format: "ends_with",
    ...Fe(e),
    suffix: r
  });
}
// @__NO_SIDE_EFFECTS__
function pf(r) {
  return new VZ({
    check: "overwrite",
    tx: r
  });
}
// @__NO_SIDE_EFFECTS__
function bX(r) {
  return /* @__PURE__ */ pf((e) => e.normalize(r));
}
// @__NO_SIDE_EFFECTS__
function wX() {
  return /* @__PURE__ */ pf((r) => r.trim());
}
// @__NO_SIDE_EFFECTS__
function _X() {
  return /* @__PURE__ */ pf((r) => r.toLowerCase());
}
// @__NO_SIDE_EFFECTS__
function SX() {
  return /* @__PURE__ */ pf((r) => r.toUpperCase());
}
// @__NO_SIDE_EFFECTS__
function EX() {
  return /* @__PURE__ */ pf((r) => NW(r));
}
// @__NO_SIDE_EFFECTS__
function xX(r, e, t) {
  return new r({
    type: "array",
    element: e,
    // get element() {
    //   return element;
    // },
    ...Fe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function AX(r, e, t) {
  return new r({
    type: "custom",
    check: "custom",
    fn: e,
    ...Fe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function IX(r) {
  const e = /* @__PURE__ */ CX((t) => (t.addIssue = (n) => {
    if (typeof n == "string")
      t.issues.push(Gp(n, t.value, e._zod.def));
    else {
      const i = n;
      i.fatal && (i.continue = !1), i.code ?? (i.code = "custom"), i.input ?? (i.input = t.value), i.inst ?? (i.inst = e), i.continue ?? (i.continue = !e._zod.def.abort), t.issues.push(Gp(i));
    }
  }, r(t.value, t)));
  return e;
}
// @__NO_SIDE_EFFECTS__
function CX(r, e) {
  const t = new ui({
    check: "custom",
    ...Fe(e)
  });
  return t._zod.check = r, t;
}
function I3(r) {
  let e = (r == null ? void 0 : r.target) ?? "draft-2020-12";
  return e === "draft-4" && (e = "draft-04"), e === "draft-7" && (e = "draft-07"), {
    processors: r.processors ?? {},
    metadataRegistry: (r == null ? void 0 : r.metadata) ?? up,
    target: e,
    unrepresentable: (r == null ? void 0 : r.unrepresentable) ?? "throw",
    override: (r == null ? void 0 : r.override) ?? (() => {
    }),
    io: (r == null ? void 0 : r.io) ?? "output",
    counter: 0,
    seen: /* @__PURE__ */ new Map(),
    cycles: (r == null ? void 0 : r.cycles) ?? "ref",
    reused: (r == null ? void 0 : r.reused) ?? "inline",
    external: (r == null ? void 0 : r.external) ?? void 0
  };
}
function nn(r, e, t = { path: [], schemaPath: [] }) {
  var l, d;
  var n;
  const i = r._zod.def, s = e.seen.get(r);
  if (s)
    return s.count++, t.schemaPath.includes(r) && (s.cycle = t.path), s.schema;
  const o = { schema: {}, count: 1, cycle: void 0, path: t.path };
  e.seen.set(r, o);
  const a = (d = (l = r._zod).toJSONSchema) == null ? void 0 : d.call(l);
  if (a)
    o.schema = a;
  else {
    const f = {
      ...t,
      schemaPath: [...t.schemaPath, r],
      path: t.path
    };
    if (r._zod.processJSONSchema)
      r._zod.processJSONSchema(e, o.schema, f);
    else {
      const y = o.schema, g = e.processors[i.type];
      if (!g)
        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${i.type}`);
      g(r, e, y, f);
    }
    const p = r._zod.parent;
    p && (o.ref || (o.ref = p), nn(p, e, f), e.seen.get(p).isParent = !0);
  }
  const c = e.metadataRegistry.get(r);
  return c && Object.assign(o.schema, c), e.io === "input" && _n(r) && (delete o.schema.examples, delete o.schema.default), e.io === "input" && o.schema._prefault && ((n = o.schema).default ?? (n.default = o.schema._prefault)), delete o.schema._prefault, e.seen.get(r).schema;
}
function C3(r, e) {
  var o, a, c, u;
  const t = r.seen.get(e);
  if (!t)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const n = /* @__PURE__ */ new Map();
  for (const l of r.seen.entries()) {
    const d = (o = r.metadataRegistry.get(l[0])) == null ? void 0 : o.id;
    if (d) {
      const f = n.get(d);
      if (f && f !== l[0])
        throw new Error(`Duplicate schema id "${d}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      n.set(d, l[0]);
    }
  }
  const i = (l) => {
    var g;
    const d = r.target === "draft-2020-12" ? "$defs" : "definitions";
    if (r.external) {
      const v = (g = r.external.registry.get(l[0])) == null ? void 0 : g.id, _ = r.external.uri ?? ((E) => E);
      if (v)
        return { ref: _(v) };
      const w = l[1].defId ?? l[1].schema.id ?? `schema${r.counter++}`;
      return l[1].defId = w, { defId: w, ref: `${_("__shared")}#/${d}/${w}` };
    }
    if (l[1] === t)
      return { ref: "#" };
    const p = `#/${d}/`, y = l[1].schema.id ?? `__schema${r.counter++}`;
    return { defId: y, ref: p + y };
  }, s = (l) => {
    if (l[1].schema.$ref)
      return;
    const d = l[1], { ref: f, defId: p } = i(l);
    d.def = { ...d.schema }, p && (d.defId = p);
    const y = d.schema;
    for (const g in y)
      delete y[g];
    y.$ref = f;
  };
  if (r.cycles === "throw")
    for (const l of r.seen.entries()) {
      const d = l[1];
      if (d.cycle)
        throw new Error(`Cycle detected: #/${(a = d.cycle) == null ? void 0 : a.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
    }
  for (const l of r.seen.entries()) {
    const d = l[1];
    if (e === l[0]) {
      s(l);
      continue;
    }
    if (r.external) {
      const p = (c = r.external.registry.get(l[0])) == null ? void 0 : c.id;
      if (e !== l[0] && p) {
        s(l);
        continue;
      }
    }
    if ((u = r.metadataRegistry.get(l[0])) == null ? void 0 : u.id) {
      s(l);
      continue;
    }
    if (d.cycle) {
      s(l);
      continue;
    }
    if (d.count > 1 && r.reused === "ref") {
      s(l);
      continue;
    }
  }
}
function D3(r, e) {
  var o, a, c;
  const t = r.seen.get(e);
  if (!t)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const n = (u) => {
    const l = r.seen.get(u);
    if (l.ref === null)
      return;
    const d = l.def ?? l.schema, f = { ...d }, p = l.ref;
    if (l.ref = null, p) {
      n(p);
      const g = r.seen.get(p), v = g.schema;
      if (v.$ref && (r.target === "draft-07" || r.target === "draft-04" || r.target === "openapi-3.0") ? (d.allOf = d.allOf ?? [], d.allOf.push(v)) : Object.assign(d, v), Object.assign(d, f), u._zod.parent === p)
        for (const w in d)
          w === "$ref" || w === "allOf" || w in f || delete d[w];
      if (v.$ref && g.def)
        for (const w in d)
          w === "$ref" || w === "allOf" || w in g.def && JSON.stringify(d[w]) === JSON.stringify(g.def[w]) && delete d[w];
    }
    const y = u._zod.parent;
    if (y && y !== p) {
      n(y);
      const g = r.seen.get(y);
      if (g != null && g.schema.$ref && (d.$ref = g.schema.$ref, g.def))
        for (const v in d)
          v === "$ref" || v === "allOf" || v in g.def && JSON.stringify(d[v]) === JSON.stringify(g.def[v]) && delete d[v];
    }
    r.override({
      zodSchema: u,
      jsonSchema: d,
      path: l.path ?? []
    });
  };
  for (const u of [...r.seen.entries()].reverse())
    n(u[0]);
  const i = {};
  if (r.target === "draft-2020-12" ? i.$schema = "https://json-schema.org/draft/2020-12/schema" : r.target === "draft-07" ? i.$schema = "http://json-schema.org/draft-07/schema#" : r.target === "draft-04" ? i.$schema = "http://json-schema.org/draft-04/schema#" : r.target, (o = r.external) != null && o.uri) {
    const u = (a = r.external.registry.get(e)) == null ? void 0 : a.id;
    if (!u)
      throw new Error("Schema is missing an `id` property");
    i.$id = r.external.uri(u);
  }
  Object.assign(i, t.def ?? t.schema);
  const s = ((c = r.external) == null ? void 0 : c.defs) ?? {};
  for (const u of r.seen.entries()) {
    const l = u[1];
    l.def && l.defId && (s[l.defId] = l.def);
  }
  r.external || Object.keys(s).length > 0 && (r.target === "draft-2020-12" ? i.$defs = s : i.definitions = s);
  try {
    const u = JSON.parse(JSON.stringify(i));
    return Object.defineProperty(u, "~standard", {
      value: {
        ...e["~standard"],
        jsonSchema: {
          input: Hy(e, "input", r.processors),
          output: Hy(e, "output", r.processors)
        }
      },
      enumerable: !1,
      writable: !1
    }), u;
  } catch {
    throw new Error("Error converting schema to JSON.");
  }
}
function _n(r, e) {
  const t = e ?? { seen: /* @__PURE__ */ new Set() };
  if (t.seen.has(r))
    return !1;
  t.seen.add(r);
  const n = r._zod.def;
  if (n.type === "transform")
    return !0;
  if (n.type === "array")
    return _n(n.element, t);
  if (n.type === "set")
    return _n(n.valueType, t);
  if (n.type === "lazy")
    return _n(n.getter(), t);
  if (n.type === "promise" || n.type === "optional" || n.type === "nonoptional" || n.type === "nullable" || n.type === "readonly" || n.type === "default" || n.type === "prefault")
    return _n(n.innerType, t);
  if (n.type === "intersection")
    return _n(n.left, t) || _n(n.right, t);
  if (n.type === "record" || n.type === "map")
    return _n(n.keyType, t) || _n(n.valueType, t);
  if (n.type === "pipe")
    return _n(n.in, t) || _n(n.out, t);
  if (n.type === "object") {
    for (const i in n.shape)
      if (_n(n.shape[i], t))
        return !0;
    return !1;
  }
  if (n.type === "union") {
    for (const i of n.options)
      if (_n(i, t))
        return !0;
    return !1;
  }
  if (n.type === "tuple") {
    for (const i of n.items)
      if (_n(i, t))
        return !0;
    return !!(n.rest && _n(n.rest, t));
  }
  return !1;
}
const DX = (r, e = {}) => (t) => {
  const n = I3({ ...t, processors: e });
  return nn(r, n), C3(n, r), D3(n, r);
}, Hy = (r, e, t = {}) => (n) => {
  const { libraryOptions: i, target: s } = n ?? {}, o = I3({ ...i ?? {}, target: s, io: e, processors: t });
  return nn(r, o), C3(o, r), D3(o, r);
}, TX = {
  guid: "uuid",
  url: "uri",
  datetime: "date-time",
  json_string: "json-string",
  regex: ""
  // do not set
}, kX = (r, e, t, n) => {
  const i = t;
  i.type = "string";
  const { minimum: s, maximum: o, format: a, patterns: c, contentEncoding: u } = r._zod.bag;
  if (typeof s == "number" && (i.minLength = s), typeof o == "number" && (i.maxLength = o), a && (i.format = TX[a] ?? a, i.format === "" && delete i.format, a === "time" && delete i.format), u && (i.contentEncoding = u), c && c.size > 0) {
    const l = [...c];
    l.length === 1 ? i.pattern = l[0].source : l.length > 1 && (i.allOf = [
      ...l.map((d) => ({
        ...e.target === "draft-07" || e.target === "draft-04" || e.target === "openapi-3.0" ? { type: "string" } : {},
        pattern: d.source
      }))
    ]);
  }
}, OX = (r, e, t, n) => {
  const i = t, { minimum: s, maximum: o, format: a, multipleOf: c, exclusiveMaximum: u, exclusiveMinimum: l } = r._zod.bag;
  typeof a == "string" && a.includes("int") ? i.type = "integer" : i.type = "number", typeof l == "number" && (e.target === "draft-04" || e.target === "openapi-3.0" ? (i.minimum = l, i.exclusiveMinimum = !0) : i.exclusiveMinimum = l), typeof s == "number" && (i.minimum = s, typeof l == "number" && e.target !== "draft-04" && (l >= s ? delete i.minimum : delete i.exclusiveMinimum)), typeof u == "number" && (e.target === "draft-04" || e.target === "openapi-3.0" ? (i.maximum = u, i.exclusiveMaximum = !0) : i.exclusiveMaximum = u), typeof o == "number" && (i.maximum = o, typeof u == "number" && e.target !== "draft-04" && (u <= o ? delete i.maximum : delete i.exclusiveMaximum)), typeof c == "number" && (i.multipleOf = c);
}, $X = (r, e, t, n) => {
  t.not = {};
}, RX = (r, e, t, n) => {
}, PX = (r, e, t, n) => {
  const i = r._zod.def, s = s3(i.entries);
  s.every((o) => typeof o == "number") && (t.type = "number"), s.every((o) => typeof o == "string") && (t.type = "string"), t.enum = s;
}, NX = (r, e, t, n) => {
  const i = r._zod.def, s = [];
  for (const o of i.values)
    if (o === void 0) {
      if (e.unrepresentable === "throw")
        throw new Error("Literal `undefined` cannot be represented in JSON Schema");
    } else if (typeof o == "bigint") {
      if (e.unrepresentable === "throw")
        throw new Error("BigInt literals cannot be represented in JSON Schema");
      s.push(Number(o));
    } else
      s.push(o);
  if (s.length !== 0) if (s.length === 1) {
    const o = s[0];
    t.type = o === null ? "null" : typeof o, e.target === "draft-04" || e.target === "openapi-3.0" ? t.enum = [o] : t.const = o;
  } else
    s.every((o) => typeof o == "number") && (t.type = "number"), s.every((o) => typeof o == "string") && (t.type = "string"), s.every((o) => typeof o == "boolean") && (t.type = "boolean"), s.every((o) => o === null) && (t.type = "null"), t.enum = s;
}, BX = (r, e, t, n) => {
  if (e.unrepresentable === "throw")
    throw new Error("Custom types cannot be represented in JSON Schema");
}, LX = (r, e, t, n) => {
  if (e.unrepresentable === "throw")
    throw new Error("Transforms cannot be represented in JSON Schema");
}, UX = (r, e, t, n) => {
  const i = t, s = r._zod.def, { minimum: o, maximum: a } = r._zod.bag;
  typeof o == "number" && (i.minItems = o), typeof a == "number" && (i.maxItems = a), i.type = "array", i.items = nn(s.element, e, { ...n, path: [...n.path, "items"] });
}, FX = (r, e, t, n) => {
  var u;
  const i = t, s = r._zod.def;
  i.type = "object", i.properties = {};
  const o = s.shape;
  for (const l in o)
    i.properties[l] = nn(o[l], e, {
      ...n,
      path: [...n.path, "properties", l]
    });
  const a = new Set(Object.keys(o)), c = new Set([...a].filter((l) => {
    const d = s.shape[l]._zod;
    return e.io === "input" ? d.optin === void 0 : d.optout === void 0;
  }));
  c.size > 0 && (i.required = Array.from(c)), ((u = s.catchall) == null ? void 0 : u._zod.def.type) === "never" ? i.additionalProperties = !1 : s.catchall ? s.catchall && (i.additionalProperties = nn(s.catchall, e, {
    ...n,
    path: [...n.path, "additionalProperties"]
  })) : e.io === "output" && (i.additionalProperties = !1);
}, MX = (r, e, t, n) => {
  const i = r._zod.def, s = i.inclusive === !1, o = i.options.map((a, c) => nn(a, e, {
    ...n,
    path: [...n.path, s ? "oneOf" : "anyOf", c]
  }));
  s ? t.oneOf = o : t.anyOf = o;
}, VX = (r, e, t, n) => {
  const i = r._zod.def, s = nn(i.left, e, {
    ...n,
    path: [...n.path, "allOf", 0]
  }), o = nn(i.right, e, {
    ...n,
    path: [...n.path, "allOf", 1]
  }), a = (u) => "allOf" in u && Object.keys(u).length === 1, c = [
    ...a(s) ? s.allOf : [s],
    ...a(o) ? o.allOf : [o]
  ];
  t.allOf = c;
}, zX = (r, e, t, n) => {
  const i = r._zod.def, s = nn(i.innerType, e, n), o = e.seen.get(r);
  e.target === "openapi-3.0" ? (o.ref = i.innerType, t.nullable = !0) : t.anyOf = [s, { type: "null" }];
}, jX = (r, e, t, n) => {
  const i = r._zod.def;
  nn(i.innerType, e, n);
  const s = e.seen.get(r);
  s.ref = i.innerType;
}, HX = (r, e, t, n) => {
  const i = r._zod.def;
  nn(i.innerType, e, n);
  const s = e.seen.get(r);
  s.ref = i.innerType, t.default = JSON.parse(JSON.stringify(i.defaultValue));
}, GX = (r, e, t, n) => {
  const i = r._zod.def;
  nn(i.innerType, e, n);
  const s = e.seen.get(r);
  s.ref = i.innerType, e.io === "input" && (t._prefault = JSON.parse(JSON.stringify(i.defaultValue)));
}, KX = (r, e, t, n) => {
  const i = r._zod.def;
  nn(i.innerType, e, n);
  const s = e.seen.get(r);
  s.ref = i.innerType;
  let o;
  try {
    o = i.catchValue(void 0);
  } catch {
    throw new Error("Dynamic catch values are not supported in JSON Schema");
  }
  t.default = o;
}, qX = (r, e, t, n) => {
  const i = r._zod.def, s = e.io === "input" ? i.in._zod.def.type === "transform" ? i.out : i.in : i.out;
  nn(s, e, n);
  const o = e.seen.get(r);
  o.ref = s;
}, WX = (r, e, t, n) => {
  const i = r._zod.def;
  nn(i.innerType, e, n);
  const s = e.seen.get(r);
  s.ref = i.innerType, t.readOnly = !0;
}, T3 = (r, e, t, n) => {
  const i = r._zod.def;
  nn(i.innerType, e, n);
  const s = e.seen.get(r);
  s.ref = i.innerType;
}, ZX = /* @__PURE__ */ oe("ZodISODateTime", (r, e) => {
  tJ.init(r, e), sr.init(r, e);
});
function JX(r) {
  return /* @__PURE__ */ sX(ZX, r);
}
const XX = /* @__PURE__ */ oe("ZodISODate", (r, e) => {
  rJ.init(r, e), sr.init(r, e);
});
function YX(r) {
  return /* @__PURE__ */ oX(XX, r);
}
const QX = /* @__PURE__ */ oe("ZodISOTime", (r, e) => {
  nJ.init(r, e), sr.init(r, e);
});
function eY(r) {
  return /* @__PURE__ */ aX(QX, r);
}
const tY = /* @__PURE__ */ oe("ZodISODuration", (r, e) => {
  iJ.init(r, e), sr.init(r, e);
});
function rY(r) {
  return /* @__PURE__ */ cX(tY, r);
}
const nY = (r, e) => {
  l3.init(r, e), r.name = "ZodError", Object.defineProperties(r, {
    format: {
      value: (t) => WW(r, t)
      // enumerable: false,
    },
    flatten: {
      value: (t) => qW(r, t)
      // enumerable: false,
    },
    addIssue: {
      value: (t) => {
        r.issues.push(t), r.message = JSON.stringify(r.issues, cx, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (t) => {
        r.issues.push(...t), r.message = JSON.stringify(r.issues, cx, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return r.issues.length === 0;
      }
      // enumerable: false,
    }
  });
}, es = oe("ZodError", nY, {
  Parent: Error
}), iY = /* @__PURE__ */ yC(es), sY = /* @__PURE__ */ vC(es), oY = /* @__PURE__ */ a0(es), aY = /* @__PURE__ */ c0(es), cY = /* @__PURE__ */ XW(es), uY = /* @__PURE__ */ YW(es), lY = /* @__PURE__ */ QW(es), dY = /* @__PURE__ */ eZ(es), hY = /* @__PURE__ */ tZ(es), fY = /* @__PURE__ */ rZ(es), pY = /* @__PURE__ */ nZ(es), gY = /* @__PURE__ */ iZ(es), yr = /* @__PURE__ */ oe("ZodType", (r, e) => (mr.init(r, e), Object.assign(r["~standard"], {
  jsonSchema: {
    input: Hy(r, "input"),
    output: Hy(r, "output")
  }
}), r.toJSONSchema = DX(r, {}), r.def = e, r.type = e.type, Object.defineProperty(r, "_def", { value: e }), r.check = (...t) => r.clone(Ac(e, {
  checks: [
    ...e.checks ?? [],
    ...t.map((n) => typeof n == "function" ? { _zod: { check: n, def: { check: "custom" }, onattach: [] } } : n)
  ]
}), {
  parent: !0
}), r.with = r.check, r.clone = (t, n) => Ic(r, t, n), r.brand = () => r, r.register = ((t, n) => (t.add(r, n), r)), r.parse = (t, n) => iY(r, t, n, { callee: r.parse }), r.safeParse = (t, n) => oY(r, t, n), r.parseAsync = async (t, n) => sY(r, t, n, { callee: r.parseAsync }), r.safeParseAsync = async (t, n) => aY(r, t, n), r.spa = r.safeParseAsync, r.encode = (t, n) => cY(r, t, n), r.decode = (t, n) => uY(r, t, n), r.encodeAsync = async (t, n) => lY(r, t, n), r.decodeAsync = async (t, n) => dY(r, t, n), r.safeEncode = (t, n) => hY(r, t, n), r.safeDecode = (t, n) => fY(r, t, n), r.safeEncodeAsync = async (t, n) => pY(r, t, n), r.safeDecodeAsync = async (t, n) => gY(r, t, n), r.refine = (t, n) => r.check(uQ(t, n)), r.superRefine = (t) => r.check(lQ(t)), r.overwrite = (t) => r.check(/* @__PURE__ */ pf(t)), r.optional = () => QO(r), r.exactOptional = () => JY(r), r.nullable = () => e$(r), r.nullish = () => QO(e$(r)), r.nonoptional = (t) => rQ(r, t), r.array = () => gy(r), r.or = (t) => VY([r, t]), r.and = (t) => GY(r, t), r.transform = (t) => t$(r, WY(t)), r.default = (t) => QY(r, t), r.prefault = (t) => tQ(r, t), r.catch = (t) => iQ(r, t), r.pipe = (t) => t$(r, t), r.readonly = () => aQ(r), r.describe = (t) => {
  const n = r.clone();
  return up.add(n, { description: t }), n;
}, Object.defineProperty(r, "description", {
  get() {
    var t;
    return (t = up.get(r)) == null ? void 0 : t.description;
  },
  configurable: !0
}), r.meta = (...t) => {
  if (t.length === 0)
    return up.get(r);
  const n = r.clone();
  return up.add(n, t[0]), n;
}, r.isOptional = () => r.safeParse(void 0).success, r.isNullable = () => r.safeParse(null).success, r.apply = (t) => t(r), r)), k3 = /* @__PURE__ */ oe("_ZodString", (r, e) => {
  bC.init(r, e), yr.init(r, e), r._zod.processJSONSchema = (n, i, s) => kX(r, n, i);
  const t = r._zod.bag;
  r.format = t.format ?? null, r.minLength = t.minimum ?? null, r.maxLength = t.maximum ?? null, r.regex = (...n) => r.check(/* @__PURE__ */ fX(...n)), r.includes = (...n) => r.check(/* @__PURE__ */ mX(...n)), r.startsWith = (...n) => r.check(/* @__PURE__ */ yX(...n)), r.endsWith = (...n) => r.check(/* @__PURE__ */ vX(...n)), r.min = (...n) => r.check(/* @__PURE__ */ jy(...n)), r.max = (...n) => r.check(/* @__PURE__ */ x3(...n)), r.length = (...n) => r.check(/* @__PURE__ */ A3(...n)), r.nonempty = (...n) => r.check(/* @__PURE__ */ jy(1, ...n)), r.lowercase = (n) => r.check(/* @__PURE__ */ pX(n)), r.uppercase = (n) => r.check(/* @__PURE__ */ gX(n)), r.trim = () => r.check(/* @__PURE__ */ wX()), r.normalize = (...n) => r.check(/* @__PURE__ */ bX(...n)), r.toLowerCase = () => r.check(/* @__PURE__ */ _X()), r.toUpperCase = () => r.check(/* @__PURE__ */ SX()), r.slugify = () => r.check(/* @__PURE__ */ EX());
}), mY = /* @__PURE__ */ oe("ZodString", (r, e) => {
  bC.init(r, e), k3.init(r, e), r.email = (t) => r.check(/* @__PURE__ */ UJ(yY, t)), r.url = (t) => r.check(/* @__PURE__ */ jJ(vY, t)), r.jwt = (t) => r.check(/* @__PURE__ */ iX(RY, t)), r.emoji = (t) => r.check(/* @__PURE__ */ HJ(bY, t)), r.guid = (t) => r.check(/* @__PURE__ */ KO(JO, t)), r.uuid = (t) => r.check(/* @__PURE__ */ FJ(Dm, t)), r.uuidv4 = (t) => r.check(/* @__PURE__ */ MJ(Dm, t)), r.uuidv6 = (t) => r.check(/* @__PURE__ */ VJ(Dm, t)), r.uuidv7 = (t) => r.check(/* @__PURE__ */ zJ(Dm, t)), r.nanoid = (t) => r.check(/* @__PURE__ */ GJ(wY, t)), r.guid = (t) => r.check(/* @__PURE__ */ KO(JO, t)), r.cuid = (t) => r.check(/* @__PURE__ */ KJ(_Y, t)), r.cuid2 = (t) => r.check(/* @__PURE__ */ qJ(SY, t)), r.ulid = (t) => r.check(/* @__PURE__ */ WJ(EY, t)), r.base64 = (t) => r.check(/* @__PURE__ */ tX(kY, t)), r.base64url = (t) => r.check(/* @__PURE__ */ rX(OY, t)), r.xid = (t) => r.check(/* @__PURE__ */ ZJ(xY, t)), r.ksuid = (t) => r.check(/* @__PURE__ */ JJ(AY, t)), r.ipv4 = (t) => r.check(/* @__PURE__ */ XJ(IY, t)), r.ipv6 = (t) => r.check(/* @__PURE__ */ YJ(CY, t)), r.cidrv4 = (t) => r.check(/* @__PURE__ */ QJ(DY, t)), r.cidrv6 = (t) => r.check(/* @__PURE__ */ eX(TY, t)), r.e164 = (t) => r.check(/* @__PURE__ */ nX($Y, t)), r.datetime = (t) => r.check(JX(t)), r.date = (t) => r.check(YX(t)), r.time = (t) => r.check(eY(t)), r.duration = (t) => r.check(rY(t));
});
function ut(r) {
  return /* @__PURE__ */ LJ(mY, r);
}
const sr = /* @__PURE__ */ oe("ZodStringFormat", (r, e) => {
  er.init(r, e), k3.init(r, e);
}), yY = /* @__PURE__ */ oe("ZodEmail", (r, e) => {
  KZ.init(r, e), sr.init(r, e);
}), JO = /* @__PURE__ */ oe("ZodGUID", (r, e) => {
  HZ.init(r, e), sr.init(r, e);
}), Dm = /* @__PURE__ */ oe("ZodUUID", (r, e) => {
  GZ.init(r, e), sr.init(r, e);
}), vY = /* @__PURE__ */ oe("ZodURL", (r, e) => {
  qZ.init(r, e), sr.init(r, e);
}), bY = /* @__PURE__ */ oe("ZodEmoji", (r, e) => {
  WZ.init(r, e), sr.init(r, e);
}), wY = /* @__PURE__ */ oe("ZodNanoID", (r, e) => {
  ZZ.init(r, e), sr.init(r, e);
}), _Y = /* @__PURE__ */ oe("ZodCUID", (r, e) => {
  JZ.init(r, e), sr.init(r, e);
}), SY = /* @__PURE__ */ oe("ZodCUID2", (r, e) => {
  XZ.init(r, e), sr.init(r, e);
}), EY = /* @__PURE__ */ oe("ZodULID", (r, e) => {
  YZ.init(r, e), sr.init(r, e);
}), xY = /* @__PURE__ */ oe("ZodXID", (r, e) => {
  QZ.init(r, e), sr.init(r, e);
}), AY = /* @__PURE__ */ oe("ZodKSUID", (r, e) => {
  eJ.init(r, e), sr.init(r, e);
}), IY = /* @__PURE__ */ oe("ZodIPv4", (r, e) => {
  sJ.init(r, e), sr.init(r, e);
}), CY = /* @__PURE__ */ oe("ZodIPv6", (r, e) => {
  oJ.init(r, e), sr.init(r, e);
}), DY = /* @__PURE__ */ oe("ZodCIDRv4", (r, e) => {
  aJ.init(r, e), sr.init(r, e);
}), TY = /* @__PURE__ */ oe("ZodCIDRv6", (r, e) => {
  cJ.init(r, e), sr.init(r, e);
}), kY = /* @__PURE__ */ oe("ZodBase64", (r, e) => {
  uJ.init(r, e), sr.init(r, e);
}), OY = /* @__PURE__ */ oe("ZodBase64URL", (r, e) => {
  dJ.init(r, e), sr.init(r, e);
}), $Y = /* @__PURE__ */ oe("ZodE164", (r, e) => {
  hJ.init(r, e), sr.init(r, e);
}), RY = /* @__PURE__ */ oe("ZodJWT", (r, e) => {
  pJ.init(r, e), sr.init(r, e);
}), O3 = /* @__PURE__ */ oe("ZodNumber", (r, e) => {
  b3.init(r, e), yr.init(r, e), r._zod.processJSONSchema = (n, i, s) => OX(r, n, i), r.gt = (n, i) => r.check(/* @__PURE__ */ WO(n, i)), r.gte = (n, i) => r.check(/* @__PURE__ */ c_(n, i)), r.min = (n, i) => r.check(/* @__PURE__ */ c_(n, i)), r.lt = (n, i) => r.check(/* @__PURE__ */ qO(n, i)), r.lte = (n, i) => r.check(/* @__PURE__ */ a_(n, i)), r.max = (n, i) => r.check(/* @__PURE__ */ a_(n, i)), r.int = (n) => r.check(XO(n)), r.safe = (n) => r.check(XO(n)), r.positive = (n) => r.check(/* @__PURE__ */ WO(0, n)), r.nonnegative = (n) => r.check(/* @__PURE__ */ c_(0, n)), r.negative = (n) => r.check(/* @__PURE__ */ qO(0, n)), r.nonpositive = (n) => r.check(/* @__PURE__ */ a_(0, n)), r.multipleOf = (n, i) => r.check(/* @__PURE__ */ ZO(n, i)), r.step = (n, i) => r.check(/* @__PURE__ */ ZO(n, i)), r.finite = () => r;
  const t = r._zod.bag;
  r.minValue = Math.max(t.minimum ?? Number.NEGATIVE_INFINITY, t.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, r.maxValue = Math.min(t.maximum ?? Number.POSITIVE_INFINITY, t.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, r.isInt = (t.format ?? "").includes("int") || Number.isSafeInteger(t.multipleOf ?? 0.5), r.isFinite = !0, r.format = t.format ?? null;
});
function PY(r) {
  return /* @__PURE__ */ uX(O3, r);
}
const NY = /* @__PURE__ */ oe("ZodNumberFormat", (r, e) => {
  gJ.init(r, e), O3.init(r, e);
});
function XO(r) {
  return /* @__PURE__ */ lX(NY, r);
}
const BY = /* @__PURE__ */ oe("ZodUnknown", (r, e) => {
  mJ.init(r, e), yr.init(r, e), r._zod.processJSONSchema = (t, n, i) => RX();
});
function YO() {
  return /* @__PURE__ */ dX(BY);
}
const LY = /* @__PURE__ */ oe("ZodNever", (r, e) => {
  yJ.init(r, e), yr.init(r, e), r._zod.processJSONSchema = (t, n, i) => $X(r, t, n);
});
function UY(r) {
  return /* @__PURE__ */ hX(LY, r);
}
const FY = /* @__PURE__ */ oe("ZodArray", (r, e) => {
  vJ.init(r, e), yr.init(r, e), r._zod.processJSONSchema = (t, n, i) => UX(r, t, n, i), r.element = e.element, r.min = (t, n) => r.check(/* @__PURE__ */ jy(t, n)), r.nonempty = (t) => r.check(/* @__PURE__ */ jy(1, t)), r.max = (t, n) => r.check(/* @__PURE__ */ x3(t, n)), r.length = (t, n) => r.check(/* @__PURE__ */ A3(t, n)), r.unwrap = () => r.element;
});
function gy(r, e) {
  return /* @__PURE__ */ xX(FY, r, e);
}
const MY = /* @__PURE__ */ oe("ZodObject", (r, e) => {
  wJ.init(r, e), yr.init(r, e), r._zod.processJSONSchema = (t, n, i) => FX(r, t, n, i), At(r, "shape", () => e.shape), r.keyof = () => gf(Object.keys(r._zod.def.shape)), r.catchall = (t) => r.clone({ ...r._zod.def, catchall: t }), r.passthrough = () => r.clone({ ...r._zod.def, catchall: YO() }), r.loose = () => r.clone({ ...r._zod.def, catchall: YO() }), r.strict = () => r.clone({ ...r._zod.def, catchall: UY() }), r.strip = () => r.clone({ ...r._zod.def, catchall: void 0 }), r.extend = (t) => zW(r, t), r.safeExtend = (t) => jW(r, t), r.merge = (t) => HW(r, t), r.pick = (t) => MW(r, t), r.omit = (t) => VW(r, t), r.partial = (...t) => GW(R3, r, t[0]), r.required = (...t) => KW(P3, r, t[0]);
});
function my(r, e) {
  const t = {
    type: "object",
    shape: r ?? {},
    ...Fe(e)
  };
  return new MY(t);
}
const $3 = /* @__PURE__ */ oe("ZodUnion", (r, e) => {
  S3.init(r, e), yr.init(r, e), r._zod.processJSONSchema = (t, n, i) => MX(r, t, n, i), r.options = e.options;
});
function VY(r, e) {
  return new $3({
    type: "union",
    options: r,
    ...Fe(e)
  });
}
const zY = /* @__PURE__ */ oe("ZodDiscriminatedUnion", (r, e) => {
  $3.init(r, e), _J.init(r, e);
});
function jY(r, e, t) {
  return new zY({
    type: "union",
    options: e,
    discriminator: r,
    ...Fe(t)
  });
}
const HY = /* @__PURE__ */ oe("ZodIntersection", (r, e) => {
  SJ.init(r, e), yr.init(r, e), r._zod.processJSONSchema = (t, n, i) => VX(r, t, n, i);
});
function GY(r, e) {
  return new HY({
    type: "intersection",
    left: r,
    right: e
  });
}
const lx = /* @__PURE__ */ oe("ZodEnum", (r, e) => {
  EJ.init(r, e), yr.init(r, e), r._zod.processJSONSchema = (n, i, s) => PX(r, n, i), r.enum = e.entries, r.options = Object.values(e.entries);
  const t = new Set(Object.keys(e.entries));
  r.extract = (n, i) => {
    const s = {};
    for (const o of n)
      if (t.has(o))
        s[o] = e.entries[o];
      else
        throw new Error(`Key ${o} not found in enum`);
    return new lx({
      ...e,
      checks: [],
      ...Fe(i),
      entries: s
    });
  }, r.exclude = (n, i) => {
    const s = { ...e.entries };
    for (const o of n)
      if (t.has(o))
        delete s[o];
      else
        throw new Error(`Key ${o} not found in enum`);
    return new lx({
      ...e,
      checks: [],
      ...Fe(i),
      entries: s
    });
  };
});
function gf(r, e) {
  const t = Array.isArray(r) ? Object.fromEntries(r.map((n) => [n, n])) : r;
  return new lx({
    type: "enum",
    entries: t,
    ...Fe(e)
  });
}
const KY = /* @__PURE__ */ oe("ZodLiteral", (r, e) => {
  xJ.init(r, e), yr.init(r, e), r._zod.processJSONSchema = (t, n, i) => NX(r, t, n), r.values = new Set(e.values), Object.defineProperty(r, "value", {
    get() {
      if (e.values.length > 1)
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      return e.values[0];
    }
  });
});
function Ts(r, e) {
  return new KY({
    type: "literal",
    values: Array.isArray(r) ? r : [r],
    ...Fe(e)
  });
}
const qY = /* @__PURE__ */ oe("ZodTransform", (r, e) => {
  AJ.init(r, e), yr.init(r, e), r._zod.processJSONSchema = (t, n, i) => LX(r, t), r._zod.parse = (t, n) => {
    if (n.direction === "backward")
      throw new n3(r.constructor.name);
    t.addIssue = (s) => {
      if (typeof s == "string")
        t.issues.push(Gp(s, t.value, e));
      else {
        const o = s;
        o.fatal && (o.continue = !1), o.code ?? (o.code = "custom"), o.input ?? (o.input = t.value), o.inst ?? (o.inst = r), t.issues.push(Gp(o));
      }
    };
    const i = e.transform(t.value, t);
    return i instanceof Promise ? i.then((s) => (t.value = s, t)) : (t.value = i, t);
  };
});
function WY(r) {
  return new qY({
    type: "transform",
    transform: r
  });
}
const R3 = /* @__PURE__ */ oe("ZodOptional", (r, e) => {
  E3.init(r, e), yr.init(r, e), r._zod.processJSONSchema = (t, n, i) => T3(r, t, n, i), r.unwrap = () => r._zod.def.innerType;
});
function QO(r) {
  return new R3({
    type: "optional",
    innerType: r
  });
}
const ZY = /* @__PURE__ */ oe("ZodExactOptional", (r, e) => {
  IJ.init(r, e), yr.init(r, e), r._zod.processJSONSchema = (t, n, i) => T3(r, t, n, i), r.unwrap = () => r._zod.def.innerType;
});
function JY(r) {
  return new ZY({
    type: "optional",
    innerType: r
  });
}
const XY = /* @__PURE__ */ oe("ZodNullable", (r, e) => {
  CJ.init(r, e), yr.init(r, e), r._zod.processJSONSchema = (t, n, i) => zX(r, t, n, i), r.unwrap = () => r._zod.def.innerType;
});
function e$(r) {
  return new XY({
    type: "nullable",
    innerType: r
  });
}
const YY = /* @__PURE__ */ oe("ZodDefault", (r, e) => {
  DJ.init(r, e), yr.init(r, e), r._zod.processJSONSchema = (t, n, i) => HX(r, t, n, i), r.unwrap = () => r._zod.def.innerType, r.removeDefault = r.unwrap;
});
function QY(r, e) {
  return new YY({
    type: "default",
    innerType: r,
    get defaultValue() {
      return typeof e == "function" ? e() : a3(e);
    }
  });
}
const eQ = /* @__PURE__ */ oe("ZodPrefault", (r, e) => {
  TJ.init(r, e), yr.init(r, e), r._zod.processJSONSchema = (t, n, i) => GX(r, t, n, i), r.unwrap = () => r._zod.def.innerType;
});
function tQ(r, e) {
  return new eQ({
    type: "prefault",
    innerType: r,
    get defaultValue() {
      return typeof e == "function" ? e() : a3(e);
    }
  });
}
const P3 = /* @__PURE__ */ oe("ZodNonOptional", (r, e) => {
  kJ.init(r, e), yr.init(r, e), r._zod.processJSONSchema = (t, n, i) => jX(r, t, n, i), r.unwrap = () => r._zod.def.innerType;
});
function rQ(r, e) {
  return new P3({
    type: "nonoptional",
    innerType: r,
    ...Fe(e)
  });
}
const nQ = /* @__PURE__ */ oe("ZodCatch", (r, e) => {
  OJ.init(r, e), yr.init(r, e), r._zod.processJSONSchema = (t, n, i) => KX(r, t, n, i), r.unwrap = () => r._zod.def.innerType, r.removeCatch = r.unwrap;
});
function iQ(r, e) {
  return new nQ({
    type: "catch",
    innerType: r,
    catchValue: typeof e == "function" ? e : () => e
  });
}
const sQ = /* @__PURE__ */ oe("ZodPipe", (r, e) => {
  $J.init(r, e), yr.init(r, e), r._zod.processJSONSchema = (t, n, i) => qX(r, t, n, i), r.in = e.in, r.out = e.out;
});
function t$(r, e) {
  return new sQ({
    type: "pipe",
    in: r,
    out: e
    // ...util.normalizeParams(params),
  });
}
const oQ = /* @__PURE__ */ oe("ZodReadonly", (r, e) => {
  RJ.init(r, e), yr.init(r, e), r._zod.processJSONSchema = (t, n, i) => WX(r, t, n, i), r.unwrap = () => r._zod.def.innerType;
});
function aQ(r) {
  return new oQ({
    type: "readonly",
    innerType: r
  });
}
const cQ = /* @__PURE__ */ oe("ZodCustom", (r, e) => {
  PJ.init(r, e), yr.init(r, e), r._zod.processJSONSchema = (t, n, i) => BX(r, t);
});
function uQ(r, e = {}) {
  return /* @__PURE__ */ AX(cQ, r, e);
}
function lQ(r) {
  return /* @__PURE__ */ IX(r);
}
const dQ = my({
  supportedBlockchains: gy(
    my({
      id: ut(),
      currency_id: ut(),
      currency_name: ut(),
      currency_ticker: ut()
    })
  ),
  referralUrl: ut(),
  domainUrl: ut(),
  appDependencies: gy(
    my({
      blockchain: ut(),
      appName: ut(),
      dependencies: gy(ut())
    })
  )
});
function wC(r) {
  return "jsonrpc" in r && "id" in r && ("result" in r || "error" in r);
}
function nd(r) {
  return "jsonrpc" in r && "id" in r && "result" in r;
}
var hQ = Object.getOwnPropertyDescriptor, fQ = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? hQ(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, r$ = (r, e) => (t, n) => e(t, n, r);
let dx = class {
  constructor(r, e) {
    this.networkService = r, this.config = e;
  }
  async broadcast(r, e) {
    var c;
    const t = ((c = r.blockchain) == null ? void 0 : c.name) === "ethereum" ? this.config.getRpcUrl(r.blockchain.chainId) : void 0;
    if (t)
      try {
        const u = await fetch(t, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify(r.rpc)
        });
        if (!u.ok)
          return N(
            new lm(
              `Broadcast failed: custom RPC error (status ${u.status})`,
              {
                error: new Error(
                  `Custom RPC request failed (status ${u.status})`
                )
              }
            )
          );
        const l = await u.json();
        return wC(l) && !nd(l) ? N(
          new lm(
            "Broadcast failed: custom RPC returned JSON-RPC error",
            {
              error: new Error(
                `Custom RPC JSON-RPC error: ${JSON.stringify(l.error)}`
              )
            }
          )
        ) : te(l);
      } catch (u) {
        const l = u instanceof Error ? u : new Error(String(u));
        return N(
          new lm("Broadcast failed: custom RPC error", {
            error: l
          })
        );
      }
    const n = `${this.config.getBackendUrl()}/broadcast`, i = e || this.config.dAppIdentifier || "ledger-button-domain", o = {
      headers: {
        "Content-Type": "application/json",
        "X-Ledger-client-origin": this.config.originToken,
        "X-Ledger-Domain": i
      }
    };
    return (await this.networkService.post(
      n,
      JSON.stringify(r),
      o
    )).mapLeft((u) => new lm(
      `Broadcast failed: ${u.message}`,
      {
        error: u
      }
    ));
  }
  async getConfig(r) {
    const e = `${this.config.getBackendUrl()}/config?dAppIdentifier=${encodeURIComponent(
      r.dAppIdentifier
    )}`, n = {
      headers: {
        "X-Ledger-Domain": this.config.dAppIdentifier,
        //TODO verify if this is correct
        "X-Ledger-client-origin": this.config.originToken
      }
    };
    return (await this.networkService.get(e, n)).mapLeft(
      (s) => new Error(`Get config failed: ${s.message}`)
    ).map((s) => dQ.safeParse(s)).chain(
      (s) => s.success ? te(s.data) : N(s.error)
    );
  }
  async event(r, e = "ledger-button-domain") {
    const t = `${this.config.getBackendUrl()}/event`, i = {
      headers: {
        "Content-Type": "application/json",
        "X-Ledger-Domain": e
      }
    };
    return (await this.networkService.post(
      t,
      JSON.stringify(r),
      i
    )).mapLeft(
      (o) => new Error(`Event tracking failed: ${o.message}`)
    );
  }
};
dx = fQ([
  ke(),
  r$(0, H(gl.NetworkService)),
  r$(1, H(Dt.Config))
], dx);
function pQ({ stub: r }) {
  return new $r(({ bind: e }) => {
    e(xc.BackendService).to(dx);
  });
}
class gQ extends it {
  constructor(e, t) {
    super(e, "AlpacaNetworkError", t);
  }
}
class mQ extends it {
  constructor(e, t) {
    super(
      `Invalid address format: ${e}`,
      "AlpacaInvalidAddressError",
      { address: e, ...t }
    );
  }
}
class yQ extends it {
  constructor(e, t) {
    super(
      `Unsupported chain: ${e}`,
      "AlpacaUnsupportedChainError",
      { currencyId: e, ...t }
    );
  }
}
class vQ extends it {
  constructor(e, t) {
    super(e, "AlpacaApiError", t);
  }
}
class bQ extends it {
  constructor(e, t, n) {
    super(
      `Failed to fetch balance for address ${e} on ${t}`,
      "AlpacaBalanceFetchError",
      { address: e, currencyId: t, ...n }
    );
  }
}
class wQ extends it {
  constructor(e, t, n) {
    super(
      `Failed to fetch token balances for address ${e} on ${t}`,
      "AlpacaTokenFetchError",
      { address: e, currencyId: t, ...n }
    );
  }
}
class _Q extends it {
  constructor(e, t) {
    super(e, "AlpacaUnknownError", t);
  }
}
class SQ extends it {
  constructor(e, t) {
    super(
      `Failed to estimate transaction fee for ${e}`,
      "AlpacaFeeEstimationError",
      { network: e, ...t }
    );
  }
}
const EQ = {
  networkError: (r, e) => new gQ(r, { originalError: e }),
  invalidAddress: (r) => new mQ(r),
  unsupportedChain: (r) => new yQ(r),
  apiError: (r, e) => new vQ(r, { originalError: e }),
  balanceFetchError: (r, e, t) => new bQ(r, e, { originalError: t }),
  tokenFetchError: (r, e, t) => new wQ(r, e, { originalError: t }),
  feeEstimationError: (r, e) => new SQ(r, { originalError: e }),
  unknownError: (r, e) => new _Q(r, { originalError: e })
};
var xQ = Object.getOwnPropertyDescriptor, AQ = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? xQ(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, n$ = (r, e) => (t, n) => e(t, n, r);
let hx = class {
  constructor(r, e) {
    this.networkService = r, this.config = e;
  }
  async getBalanceForAddressAndCurrencyId(r, e) {
    const t = `${this.config.getAlpacaUrl()}/v1/${e}/account/${r}/balance`, n = await this.networkService.get(t);
    if (!n.isRight())
      return N(new Error("Failed to fetch balance from Alpaca"));
    const i = n.extract();
    if (!Array.isArray(i))
      return N(new Error("Failed to fetch balance from Alpaca"));
    const s = i.map((o) => ({
      value: o.value,
      type: o.asset.type,
      reference: o.asset.assetReference
    }));
    return te(s);
  }
  async estimateTransactionFee(r, e) {
    const t = `${this.config.getAlpacaUrl()}/v1/${r}/transaction/estimate`, n = { intent: e };
    return (await this.networkService.post(t, JSON.stringify(n))).mapLeft(
      (s) => EQ.feeEstimationError(r, s)
    );
  }
};
hx = AQ([
  ke(),
  n$(0, H(gl.NetworkService)),
  n$(1, H(Dt.Config))
], hx);
var IQ = Object.getOwnPropertyDescriptor, CQ = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? IQ(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, i$ = (r, e) => (t, n) => e(t, n, r);
let fx = class {
  constructor(r, e) {
    this.networkService = r, this.config = e;
  }
  async getTokenInformation(r, e) {
    const t = qg(e), n = `${this.config.getCalUrl()}/v1/tokens?contract_address=${r}&chain_id=${t}&output=id,name,decimals,ticker`, i = await this.networkService.get(n);
    if (i.isLeft())
      return N(new Error("Failed to fetch token information from Cal"));
    const s = i.extract();
    return !Array.isArray(s) || s.length === 0 ? N(new Error("No token information found in Cal")) : te(s[0]);
  }
};
fx = CQ([
  ke(),
  i$(0, H(gl.NetworkService)),
  i$(1, H(Dt.Config))
], fx);
var DQ = Object.getOwnPropertyDescriptor, TQ = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? DQ(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, s$ = (r, e) => (t, n) => e(t, n, r);
let px = class {
  constructor(r, e) {
    this.networkService = r, this.config = e;
  }
  async getCounterValues(r, e) {
    if (r.length === 0)
      return te([]);
    const t = r.join(","), n = `${this.config.getCounterValueUrl()}/v3/spot/simple?froms=${encodeURIComponent(t)}&to=${e}`, i = await this.networkService.get(n);
    if (i.isLeft())
      return N(new Error("Failed to fetch counter values"));
    const s = i.extract(), o = r.map((a) => ({
      ledgerId: a,
      rate: s[a] ?? 0
    }));
    return te(o);
  }
};
px = TQ([
  ke(),
  s$(0, H(gl.NetworkService)),
  s$(1, H(Dt.Config))
], px);
class kQ {
  constructor(e, t, n, i, s) {
    h(this, "ledgerId");
    h(this, "decimals");
    h(this, "balance");
    h(this, "name");
    h(this, "ticker");
    this.ledgerId = e, this.decimals = t, this.balance = n, this.name = i, this.ticker = s;
  }
  get balanceFormatted() {
    const e = BigInt(10 ** this.decimals), t = this.balance / e, n = this.balance % e;
    if (n === BigInt(0))
      return t.toString();
    const s = n.toString().padStart(this.decimals, "0").replace(/0+$/, "");
    return s === "" ? t.toString() : `${t}.${s}`;
  }
}
var OQ = Object.getOwnPropertyDescriptor, $Q = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? OQ(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, u_ = (r, e) => (t, n) => e(t, n, r);
let gx = class {
  constructor(r, e, t) {
    h(this, "logger");
    this.loggerFactory = r, this.alpacaDataSource = e, this.calDataSource = t, this.logger = this.loggerFactory("[Alpaca Service]");
  }
  async getBalanceForAccount(r, e) {
    this.logger.debug("Getting balance for address", {
      address: r.freshAddress,
      currencyId: r.currencyId,
      withTokens: e
    });
    const t = await this.alpacaDataSource.getBalanceForAddressAndCurrencyId(
      r.freshAddress,
      r.currencyId
    );
    if (t.isRight()) {
      const n = t.extract(), i = n.find(
        (s) => s.type === "native"
      );
      if (!i)
        return N(new Error("No native balance found"));
      if (e) {
        const o = (await Promise.all(
          n.filter((a) => a.type !== "native").map(async (a) => {
            if (!a.reference)
              return;
            const c = await this.calDataSource.getTokenInformation(
              a.reference,
              r.currencyId
            );
            if (c.isRight()) {
              const u = c.extract();
              return new kQ(
                u.id,
                u.decimals,
                BigInt(a.value),
                u.name,
                u.ticker
              );
            } else
              return;
          })
        )).filter(
          (a) => a !== void 0 && a.balance > 0
        );
        return te({
          nativeBalance: {
            balance: BigInt(i.value)
          },
          tokenBalances: o
        });
      } else
        return te({
          nativeBalance: {
            balance: BigInt(i.value)
          },
          tokenBalances: []
        });
    } else
      return N(new Error("Failed to fetch balance from Alpaca"));
  }
};
gx = $Q([
  ke(),
  u_(0, H(Me.LoggerPublisher)),
  u_(1, H(Ss.AlpacaDataSource)),
  u_(2, H(Ss.CalDataSource))
], gx);
const RQ = {
  1: "ethereum",
  61: "ethereum_classic",
  17e3: "ethereum_holesky",
  11155111: "ethereum_sepolia",
  42161: "arbitrum",
  421614: "arbitrum_sepolia",
  592: "astar",
  43114: "avalanche_c_chain",
  8453: "base",
  84532: "base_sepolia",
  80094: "berachain",
  199: "bittorrent",
  81457: "blast",
  168587773: "blast_sepolia",
  288: "boba",
  56: "bsc",
  25: "cronos",
  246: "energy_web",
  128123: "etherlink",
  250: "fantom",
  14: "flare",
  295: "hedera",
  296: "hedera-testnet",
  998: "hyperevm",
  8217: "klaytn",
  59144: "linea",
  59141: "linea_sepolia",
  42: "lukso",
  1088: "metis",
  1284: "moonbeam",
  1285: "moonriver",
  245022934: "neon_evm",
  10: "optimism",
  11155420: "optimism_sepolia",
  137: "polygon",
  1101: "polygon_zk_evm",
  2442: "polygon_zk_evm_testnet",
  30: "rsk",
  534352: "scroll",
  534351: "scroll_sepolia",
  1329: "sei_network_evm",
  19: "songbird",
  146: "sonic",
  57054: "syscoin",
  40: "telos_evm",
  106: "velas_evm",
  324: "zksync",
  300: "zksync_sepolia"
};
function PQ(r) {
  return RQ[r];
}
var NQ = Object.getOwnPropertyDescriptor, BQ = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? NQ(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, Tm = (r, e) => (t, n) => e(t, n, r);
let mx = class {
  constructor(r, e, t, n) {
    h(this, "logger");
    this.loggerFactory = r, this.backendService = e, this.alpacaDataSource = t, this.config = n, this.logger = this.loggerFactory("[DefaultGasFeeEstimationService]");
  }
  //TODO: Move to a different service
  async getNonceForTx(r) {
    const e = await this.getNonce(r);
    if (!e)
      throw new Error("Failed to get nonce");
    return e;
  }
  async getFeesForTransaction(r) {
    if (this.config.getRpcUrl(r.chainId))
      return this.logger.debug("Custom RPC configured, using RPC fee estimation", {
        chainId: r.chainId
      }), this.getFeesFromRpc(r);
    const e = PQ(r.chainId);
    if (!e)
      return this.logger.debug(
        "Network not supported by Alpaca, using fallback RPC method",
        { chainId: r.chainId }
      ), this.getFeesFromRpc(r);
    this.logger.debug("Attempting to get gas fee estimation from Alpaca", {
      network: e
    });
    const t = await this.getFeesFromAlpaca(r, e);
    return t ? (this.logger.debug("Successfully got gas fee estimation from Alpaca", {
      alpacaResult: t
    }), t) : (this.logger.debug(
      "Alpaca gas fee estimation failed, falling back to RPC method"
    ), this.getFeesFromRpc(r));
  }
  async getFeesFromAlpaca(r, e) {
    const t = (() => {
      try {
        return r.value.startsWith("0x"), BigInt(r.value).toString(10);
      } catch {
        return r.value;
      }
    })(), n = r.data !== void 0 && r.data !== "" && r.data !== "0x", i = typeof r.data == "string" && (r.data.startsWith("0xa9059cbb") || r.data.startsWith("0x23b872dd")), s = n ? {
      // Contract call (incl ERC-20 transfer)
      type: "contract_call",
      sender: r.from,
      recipient: r.to,
      amount: t,
      asset: i ? { type: "erc20", assetReference: r.to } : { type: "native" },
      feesStrategy: "medium",
      data: r.data
    } : {
      // Native send
      type: "send",
      sender: r.from,
      recipient: r.to,
      amount: t,
      asset: { type: "native" },
      feesStrategy: "medium"
    };
    return (await me(async () => (await this.alpacaDataSource.estimateTransactionFee(e, s)).caseOf({
      Left: (c) => {
        throw c;
      },
      Right: (c) => c
    })).map((a) => ({
      gasLimit: a.parameters.gasLimit,
      maxFeePerGas: a.parameters.maxFeePerGas,
      maxPriorityFeePerGas: a.parameters.maxPriorityFeePerGas
    })).ifLeft((a) => {
      this.logger.debug("Alpaca gas fee estimation failed", { error: a });
    })).toMaybe().extract();
  }
  async getFeesFromRpc(r) {
    const e = await this.estimateGas(r), t = await this.getBaseFeePerGas(r), n = await this.getMaxPriorityFeePerGas(r);
    this.logger.debug("Estimated gas", { estimateGas: e }), this.logger.debug("Estimated base fee per gas", { baseFeePerGasResult: t }), this.logger.debug("Estimated base priority fee per gas", {
      maxPriorityFeePerGasResult: n
    });
    const i = Number((e * 1.2).toFixed(0)), s = t * 2 + n;
    return {
      gasLimit: `0x${i.toString(16)}`,
      maxFeePerGas: `0x${s.toString(16)}`,
      maxPriorityFeePerGas: `0x${n.toString(16)}`
    };
  }
  async getMaxPriorityFeePerGas(r) {
    const e = Number(r.chainId), t = await this.backendService.broadcast({
      blockchain: { name: "ethereum", chainId: e.toString() },
      rpc: {
        method: "eth_maxPriorityFeePerGas",
        params: [],
        id: 1,
        jsonrpc: "2.0"
      }
    });
    if (t.isLeft())
      return 2e4;
    if (t.isRight() && nd(t.extract())) {
      const i = t.extract().result;
      return Number(i);
    }
    throw new Error("Failed to estimate base priority fee per gas");
  }
  async getBaseFeePerGas(r) {
    const e = Number(r.chainId), t = await this.backendService.broadcast({
      blockchain: { name: "ethereum", chainId: e.toString() },
      rpc: {
        method: "eth_getBlockByNumber",
        params: ["latest", !1],
        id: 1,
        jsonrpc: "2.0"
      }
    });
    if (t.isLeft())
      return 2e6;
    if (t.isRight() && nd(t.extract())) {
      const s = t.extract().result.baseFeePerGas;
      return Number(s);
    }
    throw new Error("Failed to estimate base fee per gas");
  }
  async estimateGas(r) {
    const e = {
      from: r.from,
      to: r.to,
      value: r.value,
      input: r.data
    };
    this.logger.debug("Estimating gas: request sent", { estimateRequest: e });
    const t = Number(r.chainId), n = await this.backendService.broadcast({
      blockchain: { name: "ethereum", chainId: t.toString() },
      rpc: {
        method: "eth_estimateGas",
        params: [e, "latest"],
        id: 1,
        jsonrpc: "2.0"
      }
    });
    if (n.isLeft())
      return 9e4;
    if (n.isRight() && nd(n.extract())) {
      const s = n.extract().result;
      return Number(s);
    }
    throw new Error("Failed to estimate gas");
  }
  async getNonce(r) {
    const e = Number(r.chainId);
    return (await this.backendService.broadcast({
      blockchain: { name: "ethereum", chainId: e.toString() },
      rpc: {
        method: "eth_getTransactionCount",
        params: [r.from, "latest"],
        id: 1,
        jsonrpc: "2.0"
      }
    })).caseOf({
      Left: () => {
      },
      Right: (n) => {
        if (nd(n) && typeof n.result == "string")
          return n.result;
      }
    });
  }
};
mx = BQ([
  ke(),
  Tm(0, H(Me.LoggerPublisher)),
  Tm(1, H(xc.BackendService)),
  Tm(2, H(Ss.AlpacaDataSource)),
  Tm(3, H(Dt.Config))
], mx);
function LQ({ stub: r }) {
  return new $r(({ bind: e }) => {
    e(Ss.BalanceService).to(gx).inSingletonScope(), e(Ss.GasFeeEstimationService).to(mx).inSingletonScope(), e(Ss.AlpacaDataSource).to(hx).inSingletonScope(), e(Ss.CalDataSource).to(fx).inSingletonScope(), e(Ss.CounterValueDataSource).to(px).inSingletonScope();
  });
}
var UQ = Object.getOwnPropertyDescriptor, FQ = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? UQ(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, l_ = (r, e) => (t, n) => e(t, n, r);
let yx = class {
  constructor(r, e, t) {
    h(this, "logger");
    this.networkService = e, this.config = t, this.logger = r("[Cloud Sync Service]");
  }
  async fetchEncryptedAccounts(r) {
    const e = new URLSearchParams({
      path: r.applicationPath,
      id: r.trustChainId,
      version: "0"
    });
    return (await this.networkService.get(
      `${this.config.lkrp.cloudSyncUrl}/atomic/v1/live?${e.toString()}`,
      {
        headers: {
          Authorization: `Bearer ${r.jwt.access_token}`,
          "x-ledger-client-version": "ll-web-tools/0.0.0"
        }
      }
    )).caseOf({
      Right: (n) => {
        if (n.status === "no-data")
          throw new j8("No data found");
        return n;
      },
      Left: (n) => {
        throw this.logger.error("Failed to fetch encrypted accounts", { error: n }), new H8(
          "Failed to fetch encrypted accounts"
        );
      }
    });
  }
};
yx = FQ([
  ke(),
  l_(0, H(Me.LoggerPublisher)),
  l_(1, H(gl.NetworkService)),
  l_(2, H(Dt.Config))
], yx);
function MQ({ stub: r }) {
  return new $r(({ bind: e }) => {
    e(SM.CloudSyncService).to(yx).inSingletonScope();
  });
}
const Cr = {
  fatal: 0,
  error: 1,
  warn: 2,
  info: 3,
  debug: 4
};
var VQ = Object.getOwnPropertyDescriptor, zQ = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? VQ(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
};
let vx = class {
  constructor({
    originToken: e,
    dAppIdentifier: t,
    logLevel: n = "info",
    environment: i = "production",
    rpcUrls: s = {}
  }) {
    h(this, "originToken");
    h(this, "dAppIdentifier");
    h(this, "logLevel");
    h(this, "environment");
    h(this, "lkrp");
    h(this, "rpcUrls");
    this.originToken = e, this.dAppIdentifier = t, this.logLevel = Cr[n], this.environment = i, this.rpcUrls = s, this.lkrp = {
      cloudSyncUrl: this.getCloudSyncUrl()
    };
  }
  getCloudSyncUrl() {
    return this.environment === "production" ? "https://cloud-sync-backend.api.aws.prd.ldg-tech.com" : "https://cloud-sync-backend.api.aws.stg.ldg-tech.com";
  }
  setLogLevel(e) {
    this.logLevel = Cr[e];
  }
  getAlpacaUrl() {
    return "https://alpaca.api.ledger.com";
  }
  getCalUrl() {
    return this.environment === "production" ? "https://crypto-assets-service.api.ledger.com" : "https://crypto-assets-service.api.ledger-test.com";
  }
  getBackendUrl() {
    return this.environment === "production" ? "https://ledgerb.aws.prd.ldg-tech.com" : "https://ledgerb.aws.stg.ldg-tech.com";
  }
  getRpcUrl(e) {
    const t = String(e);
    return this.rpcUrls[t] || void 0;
  }
  getCounterValueUrl() {
    return "https://countervalues.live.ledger.com";
  }
  getExplorerUrl() {
    return "https://explorers.api.live.ledger.com";
  }
  setEnvironment(e) {
    this.environment = e, this.lkrp = {
      cloudSyncUrl: this.getCloudSyncUrl()
    };
  }
};
vx = zQ([
  ke()
], vx);
const jQ = "1e55ba3959f4543af24809d9066a2120bd2ac9246e626e26a1ff77eb109ca0e5";
function HQ({
  loggerLevel: r,
  apiKey: e,
  dAppIdentifier: t,
  environment: n,
  rpcUrls: i
}) {
  return new $r(({ bind: s }) => {
    s(Dt.Config).toResolvedValue(() => new vx({
      logLevel: r,
      originToken: e || jQ,
      dAppIdentifier: t || "",
      environment: n,
      rpcUrls: i
    }));
  });
}
var ze = /* @__PURE__ */ ((r) => (r.ConsentGiven = "consent_given", r.ErrorOccurred = "error_occurred", r.FloatingButtonClick = "floating_button_clicked", r.InvoicingTransactionSigned = "invoicing_transaction_signed", r.LedgerSyncActivated = "ledger_sync_activated", r.Onboarding = "onboarding", r.OpenLedgerSync = "open_ledger_sync", r.OpenSession = "open_session", r.SessionAuthentication = "session_authentication", r.TransactionFlowCompletion = "transaction_flow_completion", r.TransactionFlowInitialization = "transaction_flow_initialization", r.TypedMessageFlowCompletion = "typed_message_flow_completion", r.TypedMessageFlowInitialization = "typed_message_flow_initialization", r.WalletActionClicked = "wallet_action_clicked", r.WalletRedirectConfirmed = "wallet_redirect_confirmed", r.WalletRedirectCancelled = "wallet_redirect_cancelled", r))(ze || {});
const rt = {
  EventTrackingService: Symbol.for("EventTrackingService"),
  TrackFloatingButtonClick: Symbol.for("TrackFloatingButtonClick"),
  TrackOpenSession: Symbol.for("TrackOpenSession"),
  TrackLedgerSyncOpened: Symbol.for("TrackLedgerSyncOpened"),
  TrackLedgerSyncActivated: Symbol.for("TrackLedgerSyncActivated"),
  TrackOnboarding: Symbol.for("TrackOnboarding"),
  TrackTransactionStarted: Symbol.for("TrackTransactionStarted"),
  TrackTransactionCompleted: Symbol.for("TrackTransactionCompleted"),
  TrackTypedMessageStarted: Symbol.for("TrackTypedMessageStarted"),
  TrackTypedMessageCompleted: Symbol.for("TrackTypedMessageCompleted"),
  TrackWalletAction: Symbol.for("TrackWalletAction")
};
var GQ = Object.getOwnPropertyDescriptor, KQ = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? GQ(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, o$ = (r, e) => (t, n) => e(t, n, r);
let bx = class {
  constructor(r, e) {
    this.storageService = r, this.eventTrackingService = e;
  }
  async hasConsent() {
    return (await this.storageService.getUserConsent()).map((e) => e.consentGiven).orDefault(!1);
  }
  async hasRespondedToConsent() {
    return (await this.storageService.getUserConsent()).isJust();
  }
  async giveConsent() {
    const r = {
      consentGiven: !0,
      consentDate: (/* @__PURE__ */ new Date()).toISOString()
    };
    await this.storageService.saveUserConsent(r), await this.eventTrackingService.trackEvent({
      name: "Consent Given",
      type: ze.ConsentGiven,
      data: {
        event_type: "consent_given",
        event_id: crypto.randomUUID(),
        transaction_dapp_id: "",
        timestamp_ms: Date.now()
      }
    });
  }
  async refuseConsent() {
    const r = {
      consentGiven: !1,
      consentDate: (/* @__PURE__ */ new Date()).toISOString()
    };
    await this.storageService.saveUserConsent(r);
  }
  async removeConsent() {
    await this.storageService.removeUserConsent();
  }
  async getConsentDetails() {
    const r = await this.storageService.getUserConsent();
    return r.isJust() ? r.extract() : void 0;
  }
};
bx = KQ([
  ke(),
  o$(0, H(zt.StorageService)),
  o$(1, H(rt.EventTrackingService))
], bx);
function qQ() {
  return new $r(({ bind: r }) => {
    r(zl.ConsentService).to(bx).inSingletonScope();
  });
}
var WQ = Object.getOwnPropertyDescriptor, ZQ = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? WQ(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, JQ = (r, e) => (t, n) => e(t, n, r);
let wx = class {
  constructor(r) {
    h(this, "context", {
      connectedDevice: void 0,
      selectedAccount: void 0,
      trustChainId: void 0,
      applicationPath: void 0,
      chainId: 1,
      welcomeScreenCompleted: !1,
      hasTrackingConsent: void 0
    });
    h(this, "logger");
    h(this, "contextSubject", new fa(this.context));
    this.loggerFactory = r, this.logger = this.loggerFactory("[Context Service]");
  }
  observeContext() {
    return this.contextSubject.asObservable();
  }
  getContext() {
    return this.context;
  }
  onEvent(r) {
    var e;
    switch (this.logger.debug("onEvent", { event: r }), r.type) {
      case "initialize_context":
        this.context = r.context;
        break;
      case "chain_changed":
        this.context.chainId = r.chainId, this.context.selectedAccount && (this.context.selectedAccount = {
          ...this.context.selectedAccount,
          currencyId: gF(r.chainId) ?? ((e = this.context.selectedAccount) == null ? void 0 : e.currencyId)
        });
        break;
      case "account_changed":
        this.context.selectedAccount = r.account, this.context.chainId = qg(
          r.account.currencyId
        );
        break;
      case "device_connected":
        this.context.connectedDevice = r.device;
        break;
      case "device_disconnected":
        this.context.connectedDevice = void 0, this.context.selectedAccount = void 0;
        break;
      case "trustchain_connected":
        this.context.trustChainId = r.trustChainId, this.context.applicationPath = r.applicationPath;
        break;
      case "wallet_disconnected":
        this.context.selectedAccount = void 0, this.context.trustChainId = void 0, this.context.connectedDevice = void 0, this.context.applicationPath = void 0;
        break;
      case "welcome_screen_completed":
        this.context.welcomeScreenCompleted = !0;
        break;
      case "tracking_consent_given":
        this.context.hasTrackingConsent = !0;
        break;
      case "tracking_consent_refused":
        this.context.hasTrackingConsent = !1;
        break;
    }
    this.contextSubject.next(this.context);
  }
};
wx = ZQ([
  ke(),
  JQ(0, H(Me.LoggerPublisher))
], wx);
function XQ() {
  return new $r(({ bind: r }) => {
    r(ci.ContextService).to(wx).inSingletonScope();
  });
}
var YQ = Object.getOwnPropertyDescriptor, QQ = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? YQ(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, eee = (r, e) => (t, n) => e(t, n, r);
let _x = class {
  constructor(r) {
    h(this, "logger");
    this.loggerFactory = r, this.logger = this.loggerFactory("[Decrypt KeyPair Use Case]");
  }
  async execute(r, e) {
    this.logger.info("Decrypting keyPair with decryption key", {
      encryptedKeyPair: It(r)
    });
    const t = r.slice(0, 12), n = r.slice(12), i = await window.crypto.subtle.decrypt(
      {
        name: "AES-GCM",
        iv: t
      },
      e,
      n
    );
    return new Uint8Array(i);
  }
};
_x = QQ([
  ke(),
  eee(0, H(Me.LoggerPublisher))
], _x);
var tee = Object.getOwnPropertyDescriptor, ree = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? tee(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, nee = (r, e) => (t, n) => e(t, n, r);
let Sx = class {
  constructor(r) {
    h(this, "logger");
    this.loggerFactory = r, this.logger = this.loggerFactory("[Encrypt KeyPair Use Case]");
  }
  async execute(r, e) {
    if (!window || !window.crypto || !window.crypto.subtle)
      throw this.logger.error("Web Crypto API is not available in the environment"), new Error("Web Crypto API is not available");
    this.logger.info("Encrypting keyPair with pub key", {
      keyPair: r.getPublicKeyToHex()
    });
    const t = r.id, n = _r(t);
    if (n === null)
      throw this.logger.error("Private key bytes are null"), new Error("Can't encrypt keyPair");
    const i = window.crypto.getRandomValues(new Uint8Array(12)), s = await window.crypto.subtle.encrypt(
      {
        name: "AES-GCM",
        iv: i
      },
      e,
      new Uint8Array(n)
    ), o = new Uint8Array(i.length + s.byteLength);
    return o.set(i, 0), o.set(new Uint8Array(s), i.length), this.logger.info("KeyPair encrypted", {
      encryptedKeyPair: It(o)
    }), o;
  }
};
Sx = ree([
  ke(),
  nee(0, H(Me.LoggerPublisher))
], Sx);
var N3 = ((r) => (r.Authenticate = "lkrp-authenticate", r))(N3 || {}), rc = ((r) => (r.OpenApp = "lkrp.steps.openApp", r.Authenticate = "lkrp.steps.authenticate", r.GetTrustchain = "lkrp.steps.getTrustchain", r.ExtractEncryptionKey = "lkrp.steps.extractEncryptionKey", r))(rc || {}), Eo = ((r) => (r[r.K256 = 0] = "K256", r[r.P256 = 1] = "P256", r))(Eo || {}), lo = ((r) => (r[r.AES256_GCM = 0] = "AES256_GCM", r))(lo || {}), Hh = ((r) => (r[r.SHA256 = 0] = "SHA256", r))(Hh || {});
const iee = 32, Gy = 16;
var Ky = ((r) => (r[r.COMPACT = 0] = "COMPACT", r[r.DER = 1] = "DER", r))(Ky || {});
const Cl = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */
function B3(r) {
  return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array";
}
function Wn(r, ...e) {
  if (!B3(r))
    throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(r.length))
    throw new Error("Uint8Array expected of length " + e + ", got length=" + r.length);
}
function qy(r, e = !0) {
  if (r.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && r.finished)
    throw new Error("Hash#digest() has already been called");
}
function L3(r, e) {
  Wn(r);
  const t = e.outputLen;
  if (r.length < t)
    throw new Error("digestInto() expects output buffer of length at least " + t);
}
function see(r) {
  return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
}
function aa(r) {
  return new Uint32Array(r.buffer, r.byteOffset, Math.floor(r.byteLength / 4));
}
function ua(...r) {
  for (let e = 0; e < r.length; e++)
    r[e].fill(0);
}
function l0(r) {
  return new DataView(r.buffer, r.byteOffset, r.byteLength);
}
const oee = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function aee(r) {
  if (typeof r != "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(r));
}
function Kp(r) {
  if (typeof r == "string")
    r = aee(r);
  else if (B3(r))
    r = qp(r);
  else
    throw new Error("Uint8Array expected, got " + typeof r);
  return r;
}
function cee(r, e) {
  if (r.length !== e.length)
    return !1;
  let t = 0;
  for (let n = 0; n < r.length; n++)
    t |= r[n] ^ e[n];
  return t === 0;
}
const uee = /* @__NO_SIDE_EFFECTS__ */ (r, e) => {
  function t(n, ...i) {
    if (Wn(n), !oee)
      throw new Error("Non little-endian hardware is not yet supported");
    if (r.nonceLength !== void 0) {
      const l = i[0];
      if (!l)
        throw new Error("nonce / iv required");
      r.varSizeNonce ? Wn(l) : Wn(l, r.nonceLength);
    }
    const s = r.tagLength;
    s && i[1] !== void 0 && Wn(i[1]);
    const o = e(n, ...i), a = (l, d) => {
      if (d !== void 0) {
        if (l !== 2)
          throw new Error("cipher output not supported");
        Wn(d);
      }
    };
    let c = !1;
    return {
      encrypt(l, d) {
        if (c)
          throw new Error("cannot encrypt() twice with same key + nonce");
        return c = !0, Wn(l), a(o.encrypt.length, d), o.encrypt(l, d);
      },
      decrypt(l, d) {
        if (Wn(l), s && l.length < s)
          throw new Error("invalid ciphertext length: smaller than tagLength=" + s);
        return a(o.decrypt.length, d), o.decrypt(l, d);
      }
    };
  }
  return Object.assign(t, r), t;
};
function lee(r, e, t = !0) {
  if (e === void 0)
    return new Uint8Array(r);
  if (e.length !== r)
    throw new Error("invalid output length, expected " + r + ", got: " + e.length);
  if (t && !Wy(e))
    throw new Error("invalid output, must be aligned");
  return e;
}
function Ex(r, e, t, n) {
  if (typeof r.setBigUint64 == "function")
    return r.setBigUint64(e, t, n);
  const i = BigInt(32), s = BigInt(4294967295), o = Number(t >> i & s), a = Number(t & s), c = 0, u = 4;
  r.setUint32(e + c, o, n), r.setUint32(e + u, a, n);
}
function dee(r, e, t) {
  const n = new Uint8Array(16), i = l0(n);
  return Ex(i, 0, BigInt(e), t), Ex(i, 8, BigInt(r), t), n;
}
function Wy(r) {
  return r.byteOffset % 4 === 0;
}
function qp(r) {
  return Uint8Array.from(r);
}
function U3(r = 32) {
  if (Cl && typeof Cl.getRandomValues == "function")
    return Cl.getRandomValues(new Uint8Array(r));
  if (Cl && typeof Cl.randomBytes == "function")
    return Uint8Array.from(Cl.randomBytes(r));
  throw new Error("crypto.getRandomValues must be defined");
}
const Dl = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function d0(r) {
  return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array";
}
function xx(r) {
  if (!Number.isSafeInteger(r) || r < 0)
    throw new Error("positive integer expected, got " + r);
}
function yl(r, ...e) {
  if (!d0(r))
    throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(r.length))
    throw new Error("Uint8Array expected of length " + e + ", got length=" + r.length);
}
function F3(r) {
  if (typeof r != "function" || typeof r.create != "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  xx(r.outputLen), xx(r.blockLen);
}
function Zy(r, e = !0) {
  if (r.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && r.finished)
    throw new Error("Hash#digest() has already been called");
}
function hee(r, e) {
  yl(r);
  const t = e.outputLen;
  if (r.length < t)
    throw new Error("digestInto() expects output buffer of length at least " + t);
}
function Gh(...r) {
  for (let e = 0; e < r.length; e++)
    r[e].fill(0);
}
function d_(r) {
  return new DataView(r.buffer, r.byteOffset, r.byteLength);
}
function Vs(r, e) {
  return r << 32 - e | r >>> e;
}
const M3 = /* @ts-ignore */ typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", fee = /* @__PURE__ */ Array.from({ length: 256 }, (r, e) => e.toString(16).padStart(2, "0"));
function yd(r) {
  if (yl(r), M3)
    return r.toHex();
  let e = "";
  for (let t = 0; t < r.length; t++)
    e += fee[r[t]];
  return e;
}
const ko = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function a$(r) {
  if (r >= ko._0 && r <= ko._9)
    return r - ko._0;
  if (r >= ko.A && r <= ko.F)
    return r - (ko.A - 10);
  if (r >= ko.a && r <= ko.f)
    return r - (ko.a - 10);
}
function Jy(r) {
  if (typeof r != "string")
    throw new Error("hex string expected, got " + typeof r);
  if (M3)
    return Uint8Array.fromHex(r);
  const e = r.length, t = e / 2;
  if (e % 2)
    throw new Error("hex string expected, got unpadded hex of length " + e);
  const n = new Uint8Array(t);
  for (let i = 0, s = 0; i < t; i++, s += 2) {
    const o = a$(r.charCodeAt(s)), a = a$(r.charCodeAt(s + 1));
    if (o === void 0 || a === void 0) {
      const c = r[s] + r[s + 1];
      throw new Error('hex string expected, got non-hex character "' + c + '" at index ' + s);
    }
    n[i] = o * 16 + a;
  }
  return n;
}
function pee(r) {
  if (typeof r != "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(r));
}
function _C(r) {
  return typeof r == "string" && (r = pee(r)), yl(r), r;
}
function Pa(...r) {
  let e = 0;
  for (let n = 0; n < r.length; n++) {
    const i = r[n];
    yl(i), e += i.length;
  }
  const t = new Uint8Array(e);
  for (let n = 0, i = 0; n < r.length; n++) {
    const s = r[n];
    t.set(s, i), i += s.length;
  }
  return t;
}
class V3 {
}
function SC(r) {
  const e = (n) => r().update(_C(n)).digest(), t = r();
  return e.outputLen = t.outputLen, e.blockLen = t.blockLen, e.create = () => r(), e;
}
function z3(r = 32) {
  if (Dl && typeof Dl.getRandomValues == "function")
    return Dl.getRandomValues(new Uint8Array(r));
  if (Dl && typeof Dl.randomBytes == "function")
    return Uint8Array.from(Dl.randomBytes(r));
  throw new Error("crypto.getRandomValues must be defined");
}
class j3 extends V3 {
  constructor(e, t) {
    super(), this.finished = !1, this.destroyed = !1, F3(e);
    const n = _C(t);
    if (this.iHash = e.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const i = this.blockLen, s = new Uint8Array(i);
    s.set(n.length > i ? e.create().update(n).digest() : n);
    for (let o = 0; o < s.length; o++)
      s[o] ^= 54;
    this.iHash.update(s), this.oHash = e.create();
    for (let o = 0; o < s.length; o++)
      s[o] ^= 106;
    this.oHash.update(s), Gh(s);
  }
  update(e) {
    return Zy(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    Zy(this), yl(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: t, iHash: n, finished: i, destroyed: s, blockLen: o, outputLen: a } = this;
    return e = e, e.finished = i, e.destroyed = s, e.blockLen = o, e.outputLen = a, e.oHash = t._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const EC = (r, e, t) => new j3(r, e).update(t).digest();
EC.create = (r, e) => new j3(r, e);
function gee(r, e, t, n) {
  if (typeof r.setBigUint64 == "function")
    return r.setBigUint64(e, t, n);
  const i = BigInt(32), s = BigInt(4294967295), o = Number(t >> i & s), a = Number(t & s), c = n ? 4 : 0, u = n ? 0 : 4;
  r.setUint32(e + c, o, n), r.setUint32(e + u, a, n);
}
function mee(r, e, t) {
  return r & e ^ ~r & t;
}
function yee(r, e, t) {
  return r & e ^ r & t ^ e & t;
}
class H3 extends V3 {
  constructor(e, t, n, i) {
    super(), this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.blockLen = e, this.outputLen = t, this.padOffset = n, this.isLE = i, this.buffer = new Uint8Array(e), this.view = d_(this.buffer);
  }
  update(e) {
    Zy(this), e = _C(e), yl(e);
    const { view: t, buffer: n, blockLen: i } = this, s = e.length;
    for (let o = 0; o < s; ) {
      const a = Math.min(i - this.pos, s - o);
      if (a === i) {
        const c = d_(e);
        for (; i <= s - o; o += i)
          this.process(c, o);
        continue;
      }
      n.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === i && (this.process(t, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Zy(this), hee(e, this), this.finished = !0;
    const { buffer: t, view: n, blockLen: i, isLE: s } = this;
    let { pos: o } = this;
    t[o++] = 128, Gh(this.buffer.subarray(o)), this.padOffset > i - o && (this.process(n, 0), o = 0);
    for (let d = o; d < i; d++)
      t[d] = 0;
    gee(n, i - 8, BigInt(this.length * 8), s), this.process(n, 0);
    const a = d_(e), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4, l = this.get();
    if (u > l.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let d = 0; d < u; d++)
      a.setUint32(4 * d, l[d], s);
  }
  digest() {
    const { buffer: e, outputLen: t } = this;
    this.digestInto(e);
    const n = e.slice(0, t);
    return this.destroy(), n;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: t, buffer: n, length: i, finished: s, destroyed: o, pos: a } = this;
    return e.destroyed = o, e.finished = s, e.length = i, e.pos = a, i % t && e.buffer.set(n), e;
  }
  clone() {
    return this._cloneInto();
  }
}
const Sa = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), un = /* @__PURE__ */ Uint32Array.from([
  3418070365,
  3238371032,
  1654270250,
  914150663,
  2438529370,
  812702999,
  355462360,
  4144912697,
  1731405415,
  4290775857,
  2394180231,
  1750603025,
  3675008525,
  1694076839,
  1203062813,
  3204075428
]), ln = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  4089235720,
  3144134277,
  2227873595,
  1013904242,
  4271175723,
  2773480762,
  1595750129,
  1359893119,
  2917565137,
  2600822924,
  725511199,
  528734635,
  4215389547,
  1541459225,
  327033209
]), km = /* @__PURE__ */ BigInt(2 ** 32 - 1), c$ = /* @__PURE__ */ BigInt(32);
function vee(r, e = !1) {
  return e ? { h: Number(r & km), l: Number(r >> c$ & km) } : { h: Number(r >> c$ & km) | 0, l: Number(r & km) | 0 };
}
function bee(r, e = !1) {
  const t = r.length;
  let n = new Uint32Array(t), i = new Uint32Array(t);
  for (let s = 0; s < t; s++) {
    const { h: o, l: a } = vee(r[s], e);
    [n[s], i[s]] = [o, a];
  }
  return [n, i];
}
const u$ = (r, e, t) => r >>> t, l$ = (r, e, t) => r << 32 - t | e >>> t, Tl = (r, e, t) => r >>> t | e << 32 - t, kl = (r, e, t) => r << 32 - t | e >>> t, Om = (r, e, t) => r << 64 - t | e >>> t - 32, $m = (r, e, t) => r >>> t - 32 | e << 64 - t;
function Oo(r, e, t, n) {
  const i = (e >>> 0) + (n >>> 0);
  return { h: r + t + (i / 2 ** 32 | 0) | 0, l: i | 0 };
}
const wee = (r, e, t) => (r >>> 0) + (e >>> 0) + (t >>> 0), _ee = (r, e, t, n) => e + t + n + (r / 2 ** 32 | 0) | 0, See = (r, e, t, n) => (r >>> 0) + (e >>> 0) + (t >>> 0) + (n >>> 0), Eee = (r, e, t, n, i) => e + t + n + i + (r / 2 ** 32 | 0) | 0, xee = (r, e, t, n, i) => (r >>> 0) + (e >>> 0) + (t >>> 0) + (n >>> 0) + (i >>> 0), Aee = (r, e, t, n, i, s) => e + t + n + i + s + (r / 2 ** 32 | 0) | 0, Iee = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), Ea = /* @__PURE__ */ new Uint32Array(64);
class Cee extends H3 {
  constructor(e = 32) {
    super(64, e, 8, !1), this.A = Sa[0] | 0, this.B = Sa[1] | 0, this.C = Sa[2] | 0, this.D = Sa[3] | 0, this.E = Sa[4] | 0, this.F = Sa[5] | 0, this.G = Sa[6] | 0, this.H = Sa[7] | 0;
  }
  get() {
    const { A: e, B: t, C: n, D: i, E: s, F: o, G: a, H: c } = this;
    return [e, t, n, i, s, o, a, c];
  }
  // prettier-ignore
  set(e, t, n, i, s, o, a, c) {
    this.A = e | 0, this.B = t | 0, this.C = n | 0, this.D = i | 0, this.E = s | 0, this.F = o | 0, this.G = a | 0, this.H = c | 0;
  }
  process(e, t) {
    for (let d = 0; d < 16; d++, t += 4)
      Ea[d] = e.getUint32(t, !1);
    for (let d = 16; d < 64; d++) {
      const f = Ea[d - 15], p = Ea[d - 2], y = Vs(f, 7) ^ Vs(f, 18) ^ f >>> 3, g = Vs(p, 17) ^ Vs(p, 19) ^ p >>> 10;
      Ea[d] = g + Ea[d - 7] + y + Ea[d - 16] | 0;
    }
    let { A: n, B: i, C: s, D: o, E: a, F: c, G: u, H: l } = this;
    for (let d = 0; d < 64; d++) {
      const f = Vs(a, 6) ^ Vs(a, 11) ^ Vs(a, 25), p = l + f + mee(a, c, u) + Iee[d] + Ea[d] | 0, g = (Vs(n, 2) ^ Vs(n, 13) ^ Vs(n, 22)) + yee(n, i, s) | 0;
      l = u, u = c, c = a, a = o + p | 0, o = s, s = i, i = n, n = p + g | 0;
    }
    n = n + this.A | 0, i = i + this.B | 0, s = s + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, u = u + this.G | 0, l = l + this.H | 0, this.set(n, i, s, o, a, c, u, l);
  }
  roundClean() {
    Gh(Ea);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), Gh(this.buffer);
  }
}
const G3 = bee([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((r) => BigInt(r))), Dee = G3[0], Tee = G3[1], xa = /* @__PURE__ */ new Uint32Array(80), Aa = /* @__PURE__ */ new Uint32Array(80);
class K3 extends H3 {
  constructor(e = 64) {
    super(128, e, 16, !1), this.Ah = ln[0] | 0, this.Al = ln[1] | 0, this.Bh = ln[2] | 0, this.Bl = ln[3] | 0, this.Ch = ln[4] | 0, this.Cl = ln[5] | 0, this.Dh = ln[6] | 0, this.Dl = ln[7] | 0, this.Eh = ln[8] | 0, this.El = ln[9] | 0, this.Fh = ln[10] | 0, this.Fl = ln[11] | 0, this.Gh = ln[12] | 0, this.Gl = ln[13] | 0, this.Hh = ln[14] | 0, this.Hl = ln[15] | 0;
  }
  // prettier-ignore
  get() {
    const { Ah: e, Al: t, Bh: n, Bl: i, Ch: s, Cl: o, Dh: a, Dl: c, Eh: u, El: l, Fh: d, Fl: f, Gh: p, Gl: y, Hh: g, Hl: v } = this;
    return [e, t, n, i, s, o, a, c, u, l, d, f, p, y, g, v];
  }
  // prettier-ignore
  set(e, t, n, i, s, o, a, c, u, l, d, f, p, y, g, v) {
    this.Ah = e | 0, this.Al = t | 0, this.Bh = n | 0, this.Bl = i | 0, this.Ch = s | 0, this.Cl = o | 0, this.Dh = a | 0, this.Dl = c | 0, this.Eh = u | 0, this.El = l | 0, this.Fh = d | 0, this.Fl = f | 0, this.Gh = p | 0, this.Gl = y | 0, this.Hh = g | 0, this.Hl = v | 0;
  }
  process(e, t) {
    for (let E = 0; E < 16; E++, t += 4)
      xa[E] = e.getUint32(t), Aa[E] = e.getUint32(t += 4);
    for (let E = 16; E < 80; E++) {
      const I = xa[E - 15] | 0, S = Aa[E - 15] | 0, T = Tl(I, S, 1) ^ Tl(I, S, 8) ^ u$(I, S, 7), b = kl(I, S, 1) ^ kl(I, S, 8) ^ l$(I, S, 7), C = xa[E - 2] | 0, P = Aa[E - 2] | 0, Z = Tl(C, P, 19) ^ Om(C, P, 61) ^ u$(C, P, 6), Y = kl(C, P, 19) ^ $m(C, P, 61) ^ l$(C, P, 6), q = See(b, Y, Aa[E - 7], Aa[E - 16]), J = Eee(q, T, Z, xa[E - 7], xa[E - 16]);
      xa[E] = J | 0, Aa[E] = q | 0;
    }
    let { Ah: n, Al: i, Bh: s, Bl: o, Ch: a, Cl: c, Dh: u, Dl: l, Eh: d, El: f, Fh: p, Fl: y, Gh: g, Gl: v, Hh: _, Hl: w } = this;
    for (let E = 0; E < 80; E++) {
      const I = Tl(d, f, 14) ^ Tl(d, f, 18) ^ Om(d, f, 41), S = kl(d, f, 14) ^ kl(d, f, 18) ^ $m(d, f, 41), T = d & p ^ ~d & g, b = f & y ^ ~f & v, C = xee(w, S, b, Tee[E], Aa[E]), P = Aee(C, _, I, T, Dee[E], xa[E]), Z = C | 0, Y = Tl(n, i, 28) ^ Om(n, i, 34) ^ Om(n, i, 39), q = kl(n, i, 28) ^ $m(n, i, 34) ^ $m(n, i, 39), J = n & s ^ n & a ^ s & a, O = i & o ^ i & c ^ o & c;
      _ = g | 0, w = v | 0, g = p | 0, v = y | 0, p = d | 0, y = f | 0, { h: d, l: f } = Oo(u | 0, l | 0, P | 0, Z | 0), u = a | 0, l = c | 0, a = s | 0, c = o | 0, s = n | 0, o = i | 0;
      const x = wee(Z, q, O);
      n = _ee(x, P, Y, J), i = x | 0;
    }
    ({ h: n, l: i } = Oo(this.Ah | 0, this.Al | 0, n | 0, i | 0)), { h: s, l: o } = Oo(this.Bh | 0, this.Bl | 0, s | 0, o | 0), { h: a, l: c } = Oo(this.Ch | 0, this.Cl | 0, a | 0, c | 0), { h: u, l } = Oo(this.Dh | 0, this.Dl | 0, u | 0, l | 0), { h: d, l: f } = Oo(this.Eh | 0, this.El | 0, d | 0, f | 0), { h: p, l: y } = Oo(this.Fh | 0, this.Fl | 0, p | 0, y | 0), { h: g, l: v } = Oo(this.Gh | 0, this.Gl | 0, g | 0, v | 0), { h: _, l: w } = Oo(this.Hh | 0, this.Hl | 0, _ | 0, w | 0), this.set(n, i, s, o, a, c, u, l, d, f, p, y, g, v, _, w);
  }
  roundClean() {
    Gh(xa, Aa);
  }
  destroy() {
    Gh(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
class kee extends K3 {
  constructor() {
    super(48), this.Ah = un[0] | 0, this.Al = un[1] | 0, this.Bh = un[2] | 0, this.Bl = un[3] | 0, this.Ch = un[4] | 0, this.Cl = un[5] | 0, this.Dh = un[6] | 0, this.Dl = un[7] | 0, this.Eh = un[8] | 0, this.El = un[9] | 0, this.Fh = un[10] | 0, this.Fl = un[11] | 0, this.Gh = un[12] | 0, this.Gl = un[13] | 0, this.Hh = un[14] | 0, this.Hl = un[15] | 0;
  }
}
const xC = /* @__PURE__ */ SC(() => new Cee()), Oee = /* @__PURE__ */ SC(() => new K3()), $ee = /* @__PURE__ */ SC(() => new kee()), Ax = xC, Fo = 16, AC = /* @__PURE__ */ new Uint8Array(16), no = aa(AC), Ree = 225, Pee = (r, e, t, n) => {
  const i = n & 1;
  return {
    s3: t << 31 | n >>> 1,
    s2: e << 31 | t >>> 1,
    s1: r << 31 | e >>> 1,
    s0: r >>> 1 ^ Ree << 24 & -(i & 1)
    // reduce % poly
  };
}, zi = (r) => (r >>> 0 & 255) << 24 | (r >>> 8 & 255) << 16 | (r >>> 16 & 255) << 8 | r >>> 24 & 255 | 0;
function Nee(r) {
  r.reverse();
  const e = r[15] & 1;
  let t = 0;
  for (let n = 0; n < r.length; n++) {
    const i = r[n];
    r[n] = i >>> 1 | t, t = (i & 1) << 7;
  }
  return r[0] ^= -e & 225, r;
}
const Bee = (r) => r > 64 * 1024 ? 8 : r > 1024 ? 4 : 2;
class q3 {
  // We select bits per window adaptively based on expectedLength
  constructor(e, t) {
    this.blockLen = Fo, this.outputLen = Fo, this.s0 = 0, this.s1 = 0, this.s2 = 0, this.s3 = 0, this.finished = !1, e = Kp(e), Wn(e, 16);
    const n = l0(e);
    let i = n.getUint32(0, !1), s = n.getUint32(4, !1), o = n.getUint32(8, !1), a = n.getUint32(12, !1);
    const c = [];
    for (let y = 0; y < 128; y++)
      c.push({ s0: zi(i), s1: zi(s), s2: zi(o), s3: zi(a) }), { s0: i, s1: s, s2: o, s3: a } = Pee(i, s, o, a);
    const u = Bee(t || 1024);
    if (![1, 2, 4, 8].includes(u))
      throw new Error("ghash: invalid window size, expected 2, 4 or 8");
    this.W = u;
    const d = 128 / u, f = this.windowSize = 2 ** u, p = [];
    for (let y = 0; y < d; y++)
      for (let g = 0; g < f; g++) {
        let v = 0, _ = 0, w = 0, E = 0;
        for (let I = 0; I < u; I++) {
          if (!(g >>> u - I - 1 & 1))
            continue;
          const { s0: T, s1: b, s2: C, s3: P } = c[u * y + I];
          v ^= T, _ ^= b, w ^= C, E ^= P;
        }
        p.push({ s0: v, s1: _, s2: w, s3: E });
      }
    this.t = p;
  }
  _updateBlock(e, t, n, i) {
    e ^= this.s0, t ^= this.s1, n ^= this.s2, i ^= this.s3;
    const { W: s, t: o, windowSize: a } = this;
    let c = 0, u = 0, l = 0, d = 0;
    const f = (1 << s) - 1;
    let p = 0;
    for (const y of [e, t, n, i])
      for (let g = 0; g < 4; g++) {
        const v = y >>> 8 * g & 255;
        for (let _ = 8 / s - 1; _ >= 0; _--) {
          const w = v >>> s * _ & f, { s0: E, s1: I, s2: S, s3: T } = o[p * a + w];
          c ^= E, u ^= I, l ^= S, d ^= T, p += 1;
        }
      }
    this.s0 = c, this.s1 = u, this.s2 = l, this.s3 = d;
  }
  update(e) {
    qy(this), e = Kp(e), Wn(e);
    const t = aa(e), n = Math.floor(e.length / Fo), i = e.length % Fo;
    for (let s = 0; s < n; s++)
      this._updateBlock(t[s * 4 + 0], t[s * 4 + 1], t[s * 4 + 2], t[s * 4 + 3]);
    return i && (AC.set(e.subarray(n * Fo)), this._updateBlock(no[0], no[1], no[2], no[3]), ua(no)), this;
  }
  destroy() {
    const { t: e } = this;
    for (const t of e)
      t.s0 = 0, t.s1 = 0, t.s2 = 0, t.s3 = 0;
  }
  digestInto(e) {
    qy(this), L3(e, this), this.finished = !0;
    const { s0: t, s1: n, s2: i, s3: s } = this, o = aa(e);
    return o[0] = t, o[1] = n, o[2] = i, o[3] = s, e;
  }
  digest() {
    const e = new Uint8Array(Fo);
    return this.digestInto(e), this.destroy(), e;
  }
}
class Lee extends q3 {
  constructor(e, t) {
    e = Kp(e), Wn(e);
    const n = Nee(qp(e));
    super(n, t), ua(n);
  }
  update(e) {
    e = Kp(e), qy(this);
    const t = aa(e), n = e.length % Fo, i = Math.floor(e.length / Fo);
    for (let s = 0; s < i; s++)
      this._updateBlock(zi(t[s * 4 + 3]), zi(t[s * 4 + 2]), zi(t[s * 4 + 1]), zi(t[s * 4 + 0]));
    return n && (AC.set(e.subarray(i * Fo)), this._updateBlock(zi(no[3]), zi(no[2]), zi(no[1]), zi(no[0])), ua(no)), this;
  }
  digestInto(e) {
    qy(this), L3(e, this), this.finished = !0;
    const { s0: t, s1: n, s2: i, s3: s } = this, o = aa(e);
    return o[0] = t, o[1] = n, o[2] = i, o[3] = s, e.reverse();
  }
}
function W3(r) {
  const e = (n, i) => r(i, n.length).update(Kp(n)).digest(), t = r(new Uint8Array(16), 0);
  return e.outputLen = t.outputLen, e.blockLen = t.blockLen, e.create = (n, i) => r(n, i), e;
}
const d$ = W3((r, e) => new q3(r, e));
W3((r, e) => new Lee(r, e));
const Ix = 16, Uee = 4, Rm = /* @__PURE__ */ new Uint8Array(Ix), Fee = 283;
function IC(r) {
  return r << 1 ^ Fee & -(r >> 7);
}
function h$(r, e) {
  let t = 0;
  for (; e > 0; e >>= 1)
    t ^= r & -(e & 1), r = IC(r);
  return t;
}
const Mee = /* @__PURE__ */ (() => {
  const r = new Uint8Array(256);
  for (let t = 0, n = 1; t < 256; t++, n ^= IC(n))
    r[t] = n;
  const e = new Uint8Array(256);
  e[0] = 99;
  for (let t = 0; t < 255; t++) {
    let n = r[255 - t];
    n |= n << 8, e[r[t]] = (n ^ n >> 4 ^ n >> 5 ^ n >> 6 ^ n >> 7 ^ 99) & 255;
  }
  return ua(r), e;
})(), Vee = (r) => r << 24 | r >>> 8, h_ = (r) => r << 8 | r >>> 24;
function zee(r, e) {
  if (r.length !== 256)
    throw new Error("Wrong sbox length");
  const t = new Uint32Array(256).map((u, l) => e(r[l])), n = t.map(h_), i = n.map(h_), s = i.map(h_), o = new Uint32Array(256 * 256), a = new Uint32Array(256 * 256), c = new Uint16Array(256 * 256);
  for (let u = 0; u < 256; u++)
    for (let l = 0; l < 256; l++) {
      const d = u * 256 + l;
      o[d] = t[u] ^ n[l], a[d] = i[u] ^ s[l], c[d] = r[u] << 8 | r[l];
    }
  return { sbox: r, sbox2: c, T0: t, T1: n, T2: i, T3: s, T01: o, T23: a };
}
const Z3 = /* @__PURE__ */ zee(Mee, (r) => h$(r, 3) << 24 | r << 16 | r << 8 | h$(r, 2)), jee = /* @__PURE__ */ (() => {
  const r = new Uint8Array(16);
  for (let e = 0, t = 1; e < 16; e++, t = IC(t))
    r[e] = t;
  return r;
})();
function Hee(r) {
  Wn(r);
  const e = r.length;
  if (![16, 24, 32].includes(e))
    throw new Error("aes: invalid key size, should be 16, 24 or 32, got " + e);
  const { sbox2: t } = Z3, n = [];
  Wy(r) || n.push(r = qp(r));
  const i = aa(r), s = i.length, o = (c) => lp(t, c, c, c, c), a = new Uint32Array(e + 28);
  a.set(i);
  for (let c = s; c < a.length; c++) {
    let u = a[c - 1];
    c % s === 0 ? u = o(Vee(u)) ^ jee[c / s - 1] : s > 6 && c % s === 4 && (u = o(u)), a[c] = a[c - s] ^ u;
  }
  return ua(...n), a;
}
function Pm(r, e, t, n, i, s) {
  return r[t << 8 & 65280 | n >>> 8 & 255] ^ e[i >>> 8 & 65280 | s >>> 24 & 255];
}
function lp(r, e, t, n, i) {
  return r[e & 255 | t & 65280] | r[n >>> 16 & 255 | i >>> 16 & 65280] << 16;
}
function f$(r, e, t, n, i) {
  const { sbox2: s, T01: o, T23: a } = Z3;
  let c = 0;
  e ^= r[c++], t ^= r[c++], n ^= r[c++], i ^= r[c++];
  const u = r.length / 4 - 2;
  for (let y = 0; y < u; y++) {
    const g = r[c++] ^ Pm(o, a, e, t, n, i), v = r[c++] ^ Pm(o, a, t, n, i, e), _ = r[c++] ^ Pm(o, a, n, i, e, t), w = r[c++] ^ Pm(o, a, i, e, t, n);
    e = g, t = v, n = _, i = w;
  }
  const l = r[c++] ^ lp(s, e, t, n, i), d = r[c++] ^ lp(s, t, n, i, e), f = r[c++] ^ lp(s, n, i, e, t), p = r[c++] ^ lp(s, i, e, t, n);
  return { s0: l, s1: d, s2: f, s3: p };
}
function Nm(r, e, t, n, i) {
  Wn(t, Ix), Wn(n), i = lee(n.length, i);
  const s = t, o = aa(s), a = l0(s), c = aa(n), u = aa(i), l = e ? 0 : 12, d = n.length;
  let f = a.getUint32(l, e), { s0: p, s1: y, s2: g, s3: v } = f$(r, o[0], o[1], o[2], o[3]);
  for (let w = 0; w + 4 <= c.length; w += 4)
    u[w + 0] = c[w + 0] ^ p, u[w + 1] = c[w + 1] ^ y, u[w + 2] = c[w + 2] ^ g, u[w + 3] = c[w + 3] ^ v, f = f + 1 >>> 0, a.setUint32(l, f, e), { s0: p, s1: y, s2: g, s3: v } = f$(r, o[0], o[1], o[2], o[3]);
  const _ = Ix * Math.floor(c.length / Uee);
  if (_ < d) {
    const w = new Uint32Array([p, y, g, v]), E = see(w);
    for (let I = _, S = 0; I < d; I++, S++)
      i[I] = n[I] ^ E[S];
    ua(w);
  }
  return i;
}
function Gee(r, e, t, n, i) {
  const s = i ? i.length : 0, o = r.create(t, n.length + s);
  i && o.update(i);
  const a = dee(8 * n.length, 8 * s, e);
  o.update(n), o.update(a);
  const c = o.digest();
  return ua(a), c;
}
const p$ = /* @__PURE__ */ uee({ blockSize: 16, nonceLength: 12, tagLength: 16, varSizeNonce: !0 }, function(e, t, n) {
  if (t.length < 8)
    throw new Error("aes/gcm: invalid nonce length");
  const i = 16;
  function s(a, c, u) {
    const l = Gee(d$, !1, a, u, n);
    for (let d = 0; d < c.length; d++)
      l[d] ^= c[d];
    return l;
  }
  function o() {
    const a = Hee(e), c = Rm.slice(), u = Rm.slice();
    if (Nm(a, !1, u, u, c), t.length === 12)
      u.set(t);
    else {
      const d = Rm.slice(), f = l0(d);
      Ex(f, 8, BigInt(t.length * 8), !1);
      const p = d$.create(c).update(t).update(d);
      p.digestInto(u), p.destroy();
    }
    const l = Nm(a, !1, u, Rm);
    return { xk: a, authKey: c, counter: u, tagMask: l };
  }
  return {
    encrypt(a) {
      const { xk: c, authKey: u, counter: l, tagMask: d } = o(), f = new Uint8Array(a.length + i), p = [c, u, l, d];
      Wy(a) || p.push(a = qp(a)), Nm(c, !1, l, a, f.subarray(0, a.length));
      const y = s(u, d, f.subarray(0, f.length - i));
      return p.push(y), f.set(y, a.length), ua(...p), f;
    },
    decrypt(a) {
      const { xk: c, authKey: u, counter: l, tagMask: d } = o(), f = [c, u, d, l];
      Wy(a) || f.push(a = qp(a));
      const p = a.subarray(0, -i), y = a.subarray(-i), g = s(u, d, p);
      if (f.push(g), !cee(g, y))
        throw new Error("aes/gcm: invalid ghash tag");
      const v = Nm(c, !1, l, p);
      return ua(...f), v;
    }
  };
});
let g$ = class Cx {
  constructor(e) {
    this.key = e;
  }
  static async generate(e = lo.AES256_GCM) {
    if (e !== lo.AES256_GCM) throw new Error(`Unsupported encryption algorithm ${e}`);
    return new Cx(U3(iee));
  }
  static from(e, t = lo.AES256_GCM) {
    if (t !== lo.AES256_GCM) throw new Error(`Unsupported encryption algorithm ${t}`);
    return new Cx(e);
  }
  async encrypt(e, t) {
    return p$(this.key, e.slice(0, Gy)).encrypt(t);
  }
  async decrypt(e, t) {
    return p$(this.key, e.slice(0, Gy)).decrypt(t);
  }
}, Kee = class {
  constructor(e, t, n, i, s) {
    h(this, "cla");
    h(this, "ins");
    h(this, "p1");
    h(this, "p2");
    h(this, "data");
    this.cla = e, this.ins = t, this.p1 = n, this.p2 = i, this.data = s ?? new Uint8Array();
  }
  getRawApdu() {
    const e = Uint8Array.from([this.cla, this.ins, this.p1, this.p2, this.data.length]), t = new Uint8Array(e.length + this.data.length);
    return t.set(e, 0), this.data.length > 0 && t.set(this.data, e.length), t;
  }
};
function wc(r) {
  var t;
  if (r.startsWith("0x") && (r = r.slice(2)), r.length === 0) return new Uint8Array();
  if (r.length % 2 !== 0 && (r = "0" + r), /^[0-9a-fA-F]*$/.test(r) === !1) return null;
  const e = (t = r.match(/.{1,2}/g)) == null ? void 0 : t.map((n) => parseInt(n, 16));
  return !e || e.some(isNaN) ? null : new Uint8Array(e);
}
function ar(r, e = !0) {
  return `${e ? "0x" : ""}${Array.from(r, (t) => t.toString(16).padStart(2, "0")).join("")}`;
}
let f_ = class {
  constructor(e, t = J3) {
    h(this, "_tag", "ValueOverflow");
    h(this, "originalError");
    h(this, "message");
    this.message = `Value overflow for ${e}, max is ${t}`;
  }
}, Bm = class {
  constructor(e, t = 0) {
    h(this, "_tag", "DataOverflow");
    h(this, "message");
    h(this, "originalError");
    this.message = t === 0 ? `this.data is already full (value: ${e})` : `this.data will overflow with "${e}", remaining bytes: ${t}`;
  }
}, m$ = class {
  constructor(e) {
    h(this, "_tag", "HexaString");
    h(this, "message");
    h(this, "originalError");
    this.message = `Invalid encoded hexa string or length is null: ${e}`;
  }
};
const qee = 4294967295;
let nc = class {
  constructor(e = qee) {
    h(this, "data", new Uint8Array());
    h(this, "errors", []);
    h(this, "build", () => this.data);
    h(this, "tryBuild", () => this.hasErrors() ? void 0 : this.data);
    h(this, "add8BitUIntToData", (e) => this.addNumberToData(e, 8n, !1, !1));
    h(this, "add16BitUIntToData", (e, t = !0) => this.addNumberToData(e, 16n, !1, t));
    h(this, "add32BitUIntToData", (e, t = !0) => this.addNumberToData(e, 32n, !1, t));
    h(this, "add64BitUIntToData", (e, t = !0) => this.addNumberToData(e, 64n, !1, t));
    h(this, "add128BitUIntToData", (e, t = !0) => this.addNumberToData(e, 128n, !1, t));
    h(this, "add256BitUIntToData", (e, t = !0) => this.addNumberToData(e, 256n, !1, t));
    h(this, "add16BitIntToData", (e, t = !0) => this.addNumberToData(e, 16n, !0, t));
    h(this, "add32BitIntToData", (e, t = !0) => this.addNumberToData(e, 32n, !0, t));
    h(this, "add64BitIntToData", (e, t = !0) => this.addNumberToData(e, 64n, !0, t));
    h(this, "add128BitIntToData", (e, t = !0) => this.addNumberToData(e, 128n, !0, t));
    h(this, "add256BitIntToData", (e, t = !0) => this.addNumberToData(e, 256n, !0, t));
    h(this, "addBufferToData", (e) => this.hasEnoughLengthRemaining(e) ? (this.data = Uint8Array.from([...this.data, ...e]), this) : (this.errors.push(new Bm(e.toString())), this));
    h(this, "addHexaStringToData", (e) => {
      const t = wc(e);
      return t === null || t.length === 0 ? (this.errors.push(new m$(e)), this) : (this.addBufferToData(t), this);
    });
    h(this, "addAsciiStringToData", (e) => {
      const t = new TextEncoder().encode(e);
      return this.addBufferToData(t), this;
    });
    h(this, "encodeInLVFromHexa", (e) => {
      const t = wc(e);
      return t === null || t.length === 0 ? (this.errors.push(new m$(e)), this) : this.hasEnoughLengthRemaining(t, !0) ? (this.add8BitUIntToData(t.length), this.addBufferToData(t), this) : (this.errors.push(new Bm(e)), this);
    });
    h(this, "encodeInLVFromBuffer", (e) => this.hasEnoughLengthRemaining(e, !0) ? (this.add8BitUIntToData(e.length), this.addBufferToData(e), this) : (this.errors.push(new Bm(e.toString())), this));
    h(this, "encodeInLVFromAscii", (e) => this.hasEnoughLengthRemaining(e, !0) ? (this.add8BitUIntToData(e.length), this.addAsciiStringToData(e), this) : (this.errors.push(new Bm(e)), this));
    h(this, "encodeInTLVFromAscii", (e, t) => (this.add8BitUIntToData(e), this.encodeInLVFromAscii(t)));
    h(this, "encodeInTLVFromHexa", (e, t) => (this.add8BitUIntToData(e), this.encodeInLVFromHexa(t)));
    h(this, "encodeInTLVFromBuffer", (e, t) => (this.add8BitUIntToData(e), this.encodeInLVFromBuffer(t)));
    h(this, "encodeInTLVFromUInt8", (e, t) => (this.add8BitUIntToData(e), this.add8BitUIntToData(1), this.add8BitUIntToData(t)));
    h(this, "encodeInTLVFromUInt16", (e, t, n = !0) => (this.add8BitUIntToData(e), this.add8BitUIntToData(2), this.add16BitUIntToData(t, n)));
    h(this, "encodeInTLVFromUInt32", (e, t, n = !0) => (this.add8BitUIntToData(e), this.add8BitUIntToData(4), this.add32BitUIntToData(t, n)));
    h(this, "encodeInTLVFromUInt64", (e, t, n = !0) => (this.add8BitUIntToData(e), this.add8BitUIntToData(8), this.add64BitUIntToData(t, n)));
    h(this, "getAvailablePayloadLength", () => this.maxPayloadSize - this.data.length);
    h(this, "getErrors", () => this.errors);
    h(this, "hasErrors", () => this.errors.length !== 0);
    h(this, "hasEnoughLengthRemaining", (e, t = !1) => this.data.length + e.length + (t ? 1 : 0) <= this.maxPayloadSize);
    this.maxPayloadSize = e;
  }
  addNumberToData(e, t, n, i) {
    let s = this.checkBoundsAndConvert(e, t, n);
    if (s === void 0) return this;
    const o = Number(t) / 8, a = new Uint8Array(o);
    if (i) for (let c = o - 1; c >= 0; c--) a[c] = Number(s & 0xffn), s >>= 8n;
    else for (let c = 0; c < o; c++) a[c] = Number(s & 0xffn), s >>= 8n;
    return this.addBufferToData(a);
  }
  checkBoundsAndConvert(e, t, n) {
    if (typeof e == "number") {
      if (!Number.isInteger(e) || e > Number.MAX_SAFE_INTEGER) {
        this.errors.push(new f_(e.toString()));
        return;
      }
      e = BigInt(e);
    }
    if (n) {
      const i = 1n << t - 1n;
      if (e >= i || e < -i) {
        this.errors.push(new f_(e.toString(), i - 1n));
        return;
      }
      if (e < 0n) {
        const s = (1n << t) - 1n;
        e = -e, e = (~e & s) + 1n;
      }
    } else {
      const i = 1n << t;
      if (e < 0 || e >= i) {
        this.errors.push(new f_(e.toString(), i - 1n));
        return;
      }
    }
    return e;
  }
};
const J3 = 255;
let li = class {
  constructor({ ins: e, cla: t, p1: n, p2: i }) {
    h(this, "_ins");
    h(this, "_cla");
    h(this, "_p1");
    h(this, "p2");
    h(this, "data", new nc(J3));
    h(this, "build", () => new Kee(this._cla, this._ins, this._p1, this.p2, this.data.build()));
    h(this, "add8BitUIntToData", (e) => (this.data.add8BitUIntToData(e), this));
    h(this, "add16BitUIntToData", (e) => (this.data.add16BitUIntToData(e), this));
    h(this, "add32BitUIntToData", (e) => (this.data.add32BitUIntToData(e), this));
    h(this, "addBufferToData", (e) => (this.data.addBufferToData(e), this));
    h(this, "addHexaStringToData", (e) => (this.data.addHexaStringToData(e), this));
    h(this, "addAsciiStringToData", (e) => (this.data.addAsciiStringToData(e), this));
    h(this, "encodeInLVFromHexa", (e) => (this.data.encodeInLVFromHexa(e), this));
    h(this, "encodeInLVFromBuffer", (e) => (this.data.encodeInLVFromBuffer(e), this));
    h(this, "encodeInLVFromAscii", (e) => (this.data.encodeInLVFromAscii(e), this));
    h(this, "getAvailablePayloadLength", () => this.data.getAvailablePayloadLength());
    h(this, "getErrors", () => this.data.getErrors());
    this._cla = t & 255, this._ins = e & 255, this._p1 = n & 255, this.p2 = i & 255;
  }
}, h0 = class {
  constructor(e) {
    h(this, "index", 0);
    this.buffer = e;
  }
  testMinimalLength(e) {
    return e <= this.buffer.length - this.index;
  }
  extract8BitUInt() {
    if (!this.outOfRange(1)) return this.buffer[this.index++];
  }
  extract16BitUInt(e = !0) {
    const t = this.extractNumber(16n, !1, e);
    return t === void 0 ? void 0 : Number(t);
  }
  extract16BitInt(e = !0) {
    const t = this.extractNumber(16n, !0, e);
    return t === void 0 ? void 0 : Number(t);
  }
  extract32BitUInt(e = !0) {
    const t = this.extractNumber(32n, !1, e);
    return t === void 0 ? void 0 : Number(t);
  }
  extract32BitInt(e = !0) {
    const t = this.extractNumber(32n, !0, e);
    return t === void 0 ? void 0 : Number(t);
  }
  extract64BitUInt(e = !0) {
    return this.extractNumber(64n, !1, e);
  }
  extract64BitInt(e = !0) {
    return this.extractNumber(64n, !0, e);
  }
  extract128BitUInt(e = !0) {
    return this.extractNumber(128n, !1, e);
  }
  extract128BitInt(e = !0) {
    return this.extractNumber(128n, !0, e);
  }
  extract256BitUInt(e = !0) {
    return this.extractNumber(256n, !1, e);
  }
  extract256BitInt(e = !0) {
    return this.extractNumber(256n, !0, e);
  }
  extractFieldByLength(e) {
    if (this.outOfRange(e)) return;
    if (e === 0) return new Uint8Array();
    const t = this.buffer.slice(this.index, this.index + e);
    return this.index += e, t;
  }
  extractFieldLVEncoded() {
    const e = this.extract8BitUInt();
    if (e === void 0) return;
    if (e === 0) return new Uint8Array();
    const t = this.extractFieldByLength(e);
    return t === void 0 && this.index--, t;
  }
  extractFieldTLVEncoded() {
    if (this.outOfRange(2)) return;
    const e = this.index, t = this.extract8BitUInt(), n = this.extractFieldLVEncoded();
    if (t === void 0 || n === void 0) {
      this.index--;
      return;
    }
    const i = this.index;
    return { tag: t, value: n, tlv: this.buffer.slice(e, i) };
  }
  encodeToHexaString(e, t = !1) {
    if (e === void 0 || e.length === 0) return "";
    const n = ar(e);
    return t ? n : n.slice(2);
  }
  encodeToString(e) {
    let t = "", n = 0;
    if (!e) return t;
    for (; n <= e.length; ) {
      const i = e[n];
      i && (t += String.fromCharCode(i)), n++;
    }
    return t;
  }
  getCurrentIndex() {
    return this.index;
  }
  resetIndex() {
    this.index = 0;
  }
  getUnparsedRemainingLength() {
    return this.buffer.length - this.index;
  }
  outOfRange(e) {
    return this.index + e > this.buffer.length;
  }
  extractNumber(e, t, n) {
    const i = Number(e) / 8;
    if (this.outOfRange(i)) return;
    let s = 0n;
    if (n) for (let o = 0; o < i; o++) s = s << 8n | BigInt(this.buffer[o + this.index]);
    else for (let o = i - 1; o >= 0; o--) s = s << 8n | BigInt(this.buffer[o + this.index]);
    if (t) {
      const o = 1n << e - 1n;
      s & o && (s -= o << 1n);
    }
    return this.index += i, s;
  }
}, Bn = class {
  constructor(e) {
    h(this, "parser");
    h(this, "testMinimalLength", (e) => this.parser.testMinimalLength(e));
    h(this, "extract8BitUInt", () => this.parser.extract8BitUInt());
    h(this, "extract16BitUInt", () => this.parser.extract16BitUInt());
    h(this, "extract32BitUInt", () => this.parser.extract32BitUInt());
    h(this, "extractFieldByLength", (e) => this.parser.extractFieldByLength(e));
    h(this, "extractFieldLVEncoded", () => this.parser.extractFieldLVEncoded());
    h(this, "extractFieldTLVEncoded", () => this.parser.extractFieldTLVEncoded());
    h(this, "encodeToString", (e) => this.parser.encodeToString(e));
    h(this, "getUnparsedRemainingLength", () => this.parser.getUnparsedRemainingLength());
    this.parser = new h0(e.data);
  }
  encodeToHexaString(e, t = !1) {
    return t ? this.parser.encodeToHexaString(e, !0) : this.parser.encodeToHexaString(e, !1);
  }
}, Yn = class {
  constructor(e) {
    h(this, "_tag", "InvalidStatusWordError");
    h(this, "originalError");
    this.originalError = new Error(e ?? "Invalid status word.");
  }
}, Wee = class {
  constructor(e) {
    h(this, "_tag", "InvalidResponseFormatError");
    h(this, "originalError");
    this.originalError = new Error(e ?? "Invalid response format.");
  }
};
var ho = ((r) => (r.Error = "ERROR", r.Success = "SUCCESS", r))(ho || {});
function nt({ data: r, error: e }) {
  return e ? { status: "ERROR", error: e } : { status: "SUCCESS", data: r };
}
function Kh(r) {
  return r.status === "SUCCESS";
}
let mf = class Hl {
  static isValidStatusCode(e) {
    return e.length === 2;
  }
  static isSuccessResponse({ statusCode: e }) {
    return Hl.isValidStatusCode(e) ? e[0] === 144 && e[1] === 0 : !1;
  }
  static isLockedDeviceResponse({ statusCode: e }) {
    return Hl.isValidStatusCode(e) ? e[0] === 85 && e[1] === 21 || e[0] === 105 && e[1] === 130 || e[0] === 83 && e[1] === 3 : !1;
  }
  static isRefusedByUser({ statusCode: e }) {
    return Hl.isValidStatusCode(e) ? e[0] === 85 && e[1] === 1 || e[0] === 105 && e[1] === 133 : !1;
  }
  static isAppAlreadyInstalled({ statusCode: e }) {
    return Hl.isValidStatusCode(e) ? e[0] === 106 && e[1] === 128 || e[0] === 106 && e[1] === 129 || e[0] === 106 && e[1] === 142 || e[0] === 106 && e[1] === 143 : !1;
  }
  static isOutOfMemory({ statusCode: e }) {
    return Hl.isValidStatusCode(e) ? e[0] === 106 && e[1] === 132 || e[0] === 106 && e[1] === 133 || e[0] === 81 && e[1] === 2 || e[0] === 81 && e[1] === 3 : !1;
  }
  static isApduThatTriggersDisconnection(e) {
    const t = /* @__PURE__ */ new Map();
    return t.set("openApp", new Uint8Array([224, 216, 0, 0])), t.set("closeApp", new Uint8Array([176, 167, 0, 0])), Array.from(t.values()).some((n) => {
      for (let i = 0; i < 4; i++) if (n[i] !== e[i]) return !1;
      return !0;
    });
  }
}, CC = class {
  constructor({ tag: e, errorCode: t, originalError: n, message: i }) {
    h(this, "_tag");
    h(this, "originalError");
    h(this, "errorCode");
    h(this, "message");
    this._tag = e, this.originalError = n, this.errorCode = t, this.message = i ?? "An error occured during device exchange.";
  }
}, Zee = class {
  constructor(e) {
    h(this, "_tag", "UnknownDeviceExchangeError");
    h(this, "originalError");
    h(this, "message");
    this.originalError = e, this.message = "Unexpected device exchange error happened.";
  }
};
const DC = (r, e) => Object.keys(e).includes(r);
let Jee = class extends CC {
  constructor(e) {
    super({ tag: "GlobalCommandError", ...e });
  }
};
const y$ = { 5515: { message: "Device is locked.", tag: "DeviceLockedError" }, 5501: { message: "Action refused on device.", tag: "ActionRefusedError" }, 5502: { message: "Pin is not set", tag: "PinNotSetError" }, 5223: { message: "Device internal error", tag: "DeviceInternalError" }, "6e00": { message: "CLA not supported", tag: "DeviceInternalError" }, "6d00": { message: "INS not supported", tag: "DeviceInternalError" } };
let Xg = class {
  static handle(e) {
    const t = new Bn(e).encodeToHexaString(e.statusCode);
    return DC(t, y$) ? new Jee({ ...y$[t], errorCode: t }) : new Zee({ message: "UnknownError", errorCode: t });
  }
}, Xee = class {
  constructor() {
    h(this, "args");
    h(this, "triggersDisconnection", !0);
  }
  getApdu() {
    const e = { cla: 176, ins: 167, p1: 0, p2: 0 };
    return new li(e).build();
  }
  parseResponse(e) {
    return mf.isSuccessResponse(e) ? nt({ data: void 0 }) : nt({ error: Xg.handle(e) });
  }
}, Xy = class {
  constructor() {
    h(this, "args");
  }
  getApdu() {
    const e = { cla: 176, ins: 1, p1: 0, p2: 0 };
    return new li(e).build();
  }
  parseResponse(e) {
    if (!mf.isSuccessResponse(e)) return nt({ error: Xg.handle(e) });
    const t = new Bn(e);
    if (t.extract8BitUInt() !== 1) return nt({ error: new Wee("getAppAndVersion: format not supported") });
    const n = t.encodeToString(t.extractFieldLVEncoded()), i = t.encodeToString(t.extractFieldLVEncoded());
    if (t.getUnparsedRemainingLength() === 0) return nt({ data: { name: n, version: i } });
    const s = t.extractFieldLVEncoded();
    return nt({ data: { name: n, version: i, flags: s } });
  }
};
var Yee = ((r) => (r[r.BATTERY_PERCENTAGE = 0] = "BATTERY_PERCENTAGE", r[r.BATTERY_VOLTAGE = 1] = "BATTERY_VOLTAGE", r[r.BATTERY_TEMPERATURE = 2] = "BATTERY_TEMPERATURE", r[r.BATTERY_CURRENT = 3] = "BATTERY_CURRENT", r[r.BATTERY_FLAGS = 4] = "BATTERY_FLAGS", r))(Yee || {}), Qee = ((r) => (r[r.NONE = 0] = "NONE", r[r.USB = 1] = "USB", r[r.QI = 2] = "QI", r))(Qee || {}), wt = ((r) => (r.NANO_S = "nanoS", r.NANO_SP = "nanoSP", r.NANO_X = "nanoX", r.STAX = "stax", r.FLEX = "flex", r.APEX = "apexp", r))(wt || {});
let X3 = class {
  constructor({ id: e, model: t, name: n }) {
    h(this, "id");
    h(this, "model");
    h(this, "name");
    this.id = e, this.model = t, this.name = n;
  }
}, ete = class {
  constructor(e) {
    if (this.seFlags = e, this.seFlags.length !== 4) throw new Error("Invalid secure element flags length");
  }
  generalDeviceState() {
    const e = this.seFlags[0] ?? 0;
    return { isPinValidated: this._checkNthBitInByte(e, 1), hasMcuSerialNumber: this._checkNthBitInByte(e, 2), hasValidCertificate: this._checkNthBitInByte(e, 3), isCustomAuthorityConnectionAllowed: this._checkNthBitInByte(e, 4), isSecureConnectionAllowed: this._checkNthBitInByte(e, 5), isOnboarded: this._checkNthBitInByte(e, 6), isMcuCodeSigned: this._checkNthBitInByte(e, 7), isInRecoveryMode: this._checkNthBitInByte(e, 8) };
  }
  endorsementInformation() {
    throw new Error("Not implemented");
  }
  wordsInformation() {
    throw new Error("Not implemented");
  }
  onboardingStatus() {
    throw new Error("Not implemented");
  }
  _checkNthBitInByte(e, t) {
    return (e >> 8 - t & 1) === 1;
  }
}, tte = class {
  constructor() {
    h(this, "args");
  }
  getApdu() {
    const e = { cla: 224, ins: 1, p1: 0, p2: 0 };
    return new li(e).build();
  }
  parseResponse(e, t) {
    if (!mf.isSuccessResponse(e)) return nt({ error: Xg.handle(e) });
    const n = new Bn(e), i = n.extract32BitUInt();
    if (i === void 0) return nt({ error: new Yn("Missing target ID in OS version") });
    let s = n.encodeToString(n.extractFieldLVEncoded()), o = n.extractFieldLVEncoded() ?? new Uint8Array(0);
    const a = { ...new ete(o).generalDeviceState() };
    s || (s = "0.0.0", o = new Uint8Array());
    const c = (i & 4026531840) !== 805306368, u = s.includes("-osu");
    let l = "", d = "", f = "", p = "", y, g, v, _;
    if (c) {
      f = s, y = i;
      const w = n.extractFieldLVEncoded();
      w && (w.length >= 5 ? (l = n.encodeToString(w), g = parseInt(n.encodeToHexaString(n.extractFieldLVEncoded()), 16)) : g = parseInt(n.encodeToHexaString(w), 16));
    } else {
      if (l = s, g = i, d = n.encodeToString(n.extractFieldLVEncoded()), this.isBootloaderVersionSupported(l, t) && (f = n.encodeToString(n.extractFieldLVEncoded())), this.isHardwareVersionSupported(l, t) ? p = n.encodeToHexaString(n.extractFieldLVEncoded()) : p = "00", this.isLocalizationSupported(l, t)) {
        const w = n.extractFieldLVEncoded();
        w !== void 0 && (v = parseInt(n.encodeToHexaString(w), 16));
      }
      if (this.isRecoverSupported(l, t)) {
        const w = n.extractFieldLVEncoded();
        w !== void 0 && (_ = parseInt(n.encodeToHexaString(w), 16));
      }
    }
    return nt({ data: { isBootloader: c, isOsu: u, targetId: i, seTargetId: g, mcuTargetId: y, seVersion: l, seFlags: o, mcuSephVersion: d, mcuBootloaderVersion: f, hwVersion: p, langId: v, recoverState: _, secureElementFlags: a } });
  }
  isBootloaderVersionSupported(e, t) {
    const n = Et.coerce(e) ?? "";
    switch (t) {
      case wt.NANO_S:
      case wt.NANO_X:
        return Et.gte(n, "2.0.0");
      default:
        return !0;
    }
  }
  isHardwareVersionSupported(e, t) {
    const n = Et.coerce(e) ?? "";
    switch (t) {
      case wt.NANO_X:
        return Et.gte(n, "2.0.0");
      default:
        return !1;
    }
  }
  isLocalizationSupported(e, t) {
    const n = Et.coerce(e) ?? "";
    switch (t) {
      case wt.NANO_S:
        return !1;
      case wt.NANO_SP:
        return Et.gte(n, "1.1.0");
      case wt.NANO_X:
        return Et.gte(n, "2.1.0");
      default:
        return !0;
    }
  }
  isRecoverSupported(e, t) {
    const n = Et.coerce(e) ?? "";
    switch (t) {
      case wt.NANO_S:
        return !1;
      case wt.NANO_SP:
        return Et.gte(n, "1.1.2");
      case wt.NANO_X:
        return Et.gte(n, "2.2.3");
      case wt.STAX:
        return Et.gte(n, "1.4.0");
      case wt.FLEX:
        return Et.gte(n, "1.0.1");
      default:
        return !0;
    }
  }
};
const v$ = { "670a": { message: "No app name provided" }, 6807: { message: "Unknown application name" } };
let rte = class extends CC {
  constructor({ message: e, errorCode: t }) {
    super({ tag: "OpenAppCommandError", message: e, errorCode: t });
  }
}, nte = class {
  constructor(e) {
    h(this, "args");
    h(this, "triggersDisconnection", !0);
    this.args = e;
  }
  getApdu() {
    const e = { cla: 224, ins: 216, p1: 0, p2: 0 };
    return new li(e).addAsciiStringToData(this.args.appName).build();
  }
  parseResponse(e) {
    if (mf.isSuccessResponse(e)) return nt({ data: void 0 });
    const t = new Bn(e).encodeToHexaString(e.statusCode);
    return DC(t, v$) ? nt({ error: new rte({ ...v$[t], errorCode: t }) }) : nt({ error: Xg.handle(e) });
  }
};
var ic = ((r) => (r.LOCKED = "LOCKED", r.BUSY = "BUSY", r.CONNECTED = "CONNECTED", r.NOT_CONNECTED = "NOT CONNECTED", r))(ic || {}), id = ((r) => (r.NotStarted = "not-started", r.Pending = "pending", r.Stopped = "stopped", r.Completed = "completed", r.Error = "error", r))(id || {}), pr = ((r) => (r.None = "none", r.UnlockDevice = "unlock-device", r.AllowSecureConnection = "allow-secure-connection", r.ConfirmOpenApp = "confirm-open-app", r.SignTransaction = "sign-transaction", r.SignTypedData = "sign-typed-data", r.AllowListApps = "allow-list-apps", r.VerifyAddress = "verify-address", r.SignPersonalMessage = "sign-personal-message", r.SignDelegationAuthorization = "sign-delegation-authorization", r.Web3ChecksOptIn = "web3-checks-opt-in", r))(pr || {});
let Y3 = class {
  constructor(e) {
    h(this, "_tag", "DeviceNotOnboardedError");
    h(this, "originalError");
    this.originalError = new Error(e ?? "Device not onboarded.");
  }
}, ite = class {
  constructor(e) {
    h(this, "_tag", "DeviceLockedError");
    h(this, "originalError");
    this.originalError = new Error(e ?? "Device locked.");
  }
}, ste = class {
  constructor(e) {
    h(this, "_tag", "UnknownDAError");
    h(this, "originalError");
    this.originalError = new Error(e ?? "Unknown error.");
  }
};
const Q3 = 6e4;
let yf = class {
  constructor(e) {
    h(this, "input");
    h(this, "inspect", !1);
    this.input = e.input, this.inspect = !!e.inspect;
  }
  _execute(e) {
    const t = this.makeStateMachine(e);
    return this._subscribeToStateMachine(t);
  }
  _subscribeToStateMachine(e) {
    const t = Gu(e, { input: this.input }), n = new $v(), i = (a) => {
      const { context: c, status: u, output: l, error: d } = a;
      switch (u) {
        case "active":
          n.next({ status: id.Pending, intermediateValue: c.intermediateValue });
          break;
        case "done":
          l.caseOf({ Left: (f) => {
            n.next({ status: id.Error, error: f });
          }, Right: (f) => {
            n.next({ status: id.Completed, output: f });
          } }), n.complete();
          break;
        case "error":
          n.error(d), n.complete();
          break;
        case "stopped":
          n.next({ status: id.Stopped }), n.complete();
          break;
        default:
          this._exhaustiveMatchingGuard(u);
      }
    }, s = new mn((a) => {
      const c = n.subscribe(a);
      return () => {
        o.unsubscribe(), c.unsubscribe(), t.stop();
      };
    }), o = t.subscribe(i);
    return t.start(), { observable: s.pipe(GL()), cancel: () => {
      t.stop(), o.unsubscribe(), i(t.getSnapshot());
    } };
  }
  _exhaustiveMatchingGuard(e) {
    throw console.log("_exhaustiveMatchingGuard status", e), new Error(`Unhandled status: ${e}`);
  }
};
var mo = ((r) => (r[r.Connected = 0] = "Connected", r[r.ReadyWithoutSecureChannel = 1] = "ReadyWithoutSecureChannel", r[r.ReadyWithSecureChannel = 2] = "ReadyWithSecureChannel", r))(mo || {});
class ote extends yf {
  makeStateMachine(e) {
    const { getAppAndVersion: t, getDeviceSessionState: n, setDeviceSessionState: i, waitForDeviceUnlock: s, isDeviceOnboarded: o } = this.extractDependencies(e), a = this.input.unlockTimeout ?? Q3;
    return Or({ actors: { getAppAndVersion: tt(t), waitForDeviceUnlock: kv(s) }, guards: { isDeviceOnboarded: () => o(), isDeviceLocked: ({ context: c }) => c._internalState.locked, hasError: ({ context: c }) => c._internalState.error !== null }, actions: { assignErrorDeviceNotOnboarded: Q({ _internalState: (c) => ({ ...c.context._internalState, error: new Y3() }) }), assignErrorDeviceLocked: Q({ _internalState: (c) => ({ ...c.context._internalState, error: new ite() }), intermediateValue: { requiredUserInteraction: pr.UnlockDevice } }), assignErrorFromEvent: Q({ _internalState: (c) => ({ ...c.context._internalState, error: c.event.error }) }), assignNoUserActionNeeded: Q({ intermediateValue: (c) => ({ ...c.context.intermediateValue, requiredUserInteraction: pr.None }) }), assignUserActionUnlockNeeded: Q({ intermediateValue: (c) => ({ ...c.context.intermediateValue, requiredUserInteraction: pr.UnlockDevice }) }) } }).createMachine({ id: "GetDeviceStatusDeviceAction", initial: "DeviceReady", context: (c) => {
      const u = n(), { sessionStateType: l } = u;
      return { input: { unlockTimeout: c.input.unlockTimeout }, intermediateValue: { requiredUserInteraction: pr.None }, _internalState: { onboarded: !1, locked: !1, currentApp: l === mo.ReadyWithoutSecureChannel ? u.currentApp.name : null, currentAppVersion: null, error: null } };
    }, states: { DeviceReady: { always: { target: "OnboardingCheck" } }, OnboardingCheck: { always: [{ guard: { type: "isDeviceOnboarded" }, target: "AppAndVersionCheck", actions: Q({ _internalState: (c) => ({ ...c.context._internalState, onboarded: !0 }) }) }, { target: "Error", actions: "assignErrorDeviceNotOnboarded" }] }, UserActionUnlockDevice: { entry: "assignUserActionUnlockNeeded", exit: "assignNoUserActionNeeded", invoke: { id: "UserActionUnlockDevice", src: "waitForDeviceUnlock", input: (c) => ({ unlockTimeout: a }), onDone: { target: "AppAndVersionCheck", actions: Q({ _internalState: (c) => ({ ...c.context._internalState, locked: !1 }) }) }, onError: { target: "Error", actions: "assignErrorDeviceLocked" } } }, AppAndVersionCheck: { invoke: { src: "getAppAndVersion", onDone: { target: "ApplicationAvailableResultCheck", actions: Q({ _internalState: (c) => {
      if (Kh(c.event.output)) {
        const u = n();
        return u.sessionStateType !== mo.Connected ? i({ ...u, currentApp: c.event.output.data }) : i({ deviceModelId: u.deviceModelId, sessionStateType: mo.ReadyWithoutSecureChannel, deviceStatus: ic.CONNECTED, currentApp: c.event.output.data, installedApps: [], isSecureConnectionAllowed: !1 }), { ...c.context._internalState, locked: !1, currentApp: c.event.output.data.name, currentAppVersion: c.event.output.data.version };
      }
      if ("errorCode" in c.event.output.error) {
        if (c.event.output.error.errorCode === "5515") return { ...c.context._internalState, locked: !0 };
        if (c.event.output.error.errorCode === "6e00") return { ...c.context._internalState, locked: !1, currentApp: "BOLOS", currentAppVersion: "0.0.0" };
      }
      return { ...c.context._internalState, error: c.event.output.error };
    } }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, ApplicationAvailableResultCheck: { always: [{ guard: "hasError", target: "Error" }, { target: "UserActionUnlockDevice", guard: "isDeviceLocked" }, { target: "Success" }] }, Success: { type: "final" }, Error: { type: "final" } }, output: (c) => {
      const { context: u } = c, { error: l, currentApp: d, currentAppVersion: f } = u._internalState;
      return l ? N(l) : te({ currentApp: d, currentAppVersion: f });
    } });
  }
  extractDependencies(e) {
    return { getAppAndVersion: () => e.sendCommand(new Xy()), waitForDeviceUnlock: ({ input: t }) => zL(1e3).pipe(Qr(() => rn(e.sendCommand(new Xy()))), cf((n) => !Kh(n) && "errorCode" in n.error && n.error.errorCode === "5515" ? Rv : Ji(void 0)), HL(1), ML(t.unlockTimeout)), getDeviceSessionState: () => e.getDeviceSessionState(), setDeviceSessionState: (t) => e.setDeviceSessionState(t), isDeviceOnboarded: () => !0 };
  }
}
let ts = class {
  constructor(e) {
    h(this, "_tag", "GeneralDmkError");
    h(this, "originalError");
    e instanceof Error ? this.originalError = e : e !== void 0 && (this.originalError = new Error(String(e)));
  }
}, TC = class extends ts {
  constructor(t) {
    super(t);
    h(this, "_tag", "TransportNotSupportedError");
    this.err = t;
  }
}, ate = class extends ts {
  constructor(t) {
    super(t);
    h(this, "_tag", "TransportAlreadyExistsError");
    this.err = t;
  }
}, cte = class extends ts {
  constructor(t) {
    super(t);
    h(this, "_tag", "DeviceDisconnectedWhileSendingError");
    this.err = t;
  }
}, ute = class extends ts {
  constructor(t) {
    super(t);
    h(this, "_tag", "NoTransportProvidedError");
    this.err = t;
  }
};
const lte = ["BOLOS", "OLOS", "OLOS\0"], dte = (r) => lte.includes(r);
class e6 extends yf {
  makeStateMachine(e) {
    const { closeApp: t, openApp: n, getDeviceSessionState: i, isDeviceOnboarded: s, setDeviceSessionState: o } = this.extractDependencies(e), a = this.input.unlockTimeout ?? Q3, c = new ote({ input: { unlockTimeout: a } }).makeStateMachine(e);
    return Or({ actors: { closeApp: tt(t), openApp: tt(n), getDeviceStatus: c }, guards: { isDeviceOnboarded: () => s(), isRequestedAppOpen: ({ context: u }) => u._internalState.currentlyRunningApp === null ? !1 : u._internalState.currentlyRunningApp === u.input.appName, isDashboardOpen: ({ context: u }) => {
      if (u._internalState.currentlyRunningApp === null) throw new Error("context.currentlyRunningApp === null");
      return dte(u._internalState.currentlyRunningApp);
    }, hasDisconnectedWhileSending: ({ context: u }) => u._internalState.error !== null && u._internalState.error instanceof cte, hasError: ({ context: u }) => u._internalState.error !== null }, actions: { assignErrorDeviceNotOnboarded: Q({ _internalState: (u) => ({ ...u.context._internalState, error: new Y3() }) }), assignUserActionNeededOpenApp: Q({ intermediateValue: (u) => ({ ...u.context.intermediateValue, requiredUserInteraction: pr.ConfirmOpenApp }) }), assignNoUserActionNeeded: Q({ intermediateValue: (u) => ({ ...u.context.intermediateValue, requiredUserInteraction: pr.None }) }), assignErrorFromEvent: Q({ _internalState: (u) => ({ ...u.context._internalState, error: u.event.error }) }), assignNoError: Q({ _internalState: (u) => ({ ...u.context._internalState, error: null }) }) } }).createMachine({ id: "OpenAppDeviceAction", initial: "DeviceReady", context: ({ input: u }) => {
      const l = i(), { sessionStateType: d } = l;
      return { input: u, intermediateValue: { requiredUserInteraction: pr.None }, _internalState: { error: null, currentlyRunningApp: d === mo.ReadyWithoutSecureChannel ? l.currentApp.name : null } };
    }, states: { DeviceReady: { always: { target: "OnboardingCheck" } }, OnboardingCheck: { always: [{ target: "GetDeviceStatus", guard: { type: "isDeviceOnboarded" } }, { target: "Error", actions: "assignErrorDeviceNotOnboarded" }] }, GetDeviceStatus: { invoke: { id: "deviceStatus", src: "getDeviceStatus", input: (u) => ({ unlockTimeout: u.context.input.unlockTimeout }), onSnapshot: { actions: Q({ intermediateValue: (u) => u.event.snapshot.context.intermediateValue }) }, onDone: { target: "CheckDeviceStatus", actions: Q({ _internalState: (u) => u.event.output.caseOf({ Right: (l) => {
      const d = i();
      return d.sessionStateType !== mo.Connected && o({ ...d, currentApp: { name: l.currentApp, version: l.currentAppVersion } }), { ...u.context._internalState, currentlyRunningApp: l.currentApp };
    }, Left: (l) => ({ ...u.context._internalState, currentlyRunningApp: null, error: l }) }) }) }, onError: { target: "Error", actions: [Q({ _internalState: (u) => ({ ...u.context._internalState, currentlyRunningApp: null }) }), "assignErrorFromEvent"] } } }, CheckDeviceStatus: { always: [{ target: "ApplicationReady", guard: "isRequestedAppOpen", actions: "assignNoError" }, { target: "Error", guard: "hasError" }, { target: "DashboardCheck" }] }, DashboardCheck: { always: [{ target: "OpenApplication", guard: "isDashboardOpen" }, "CloseApplication"] }, OpenApplication: { entry: "assignUserActionNeededOpenApp", exit: "assignNoUserActionNeeded", invoke: { src: "openApp", input: ({ context: u }) => ({ appName: u.input.appName }), onDone: { target: "OpenApplicationResultCheck", actions: Q({ _internalState: (u) => Kh(u.event.output) ? { ...u.context._internalState, currentlyRunningApp: u.context.input.appName } : { ...u.context._internalState, error: u.event.output.error } }) }, onError: { target: "OpenApplicationResultCheck", actions: "assignErrorFromEvent" } } }, OpenApplicationResultCheck: { always: [{ target: "GetDeviceStatus", guard: "hasDisconnectedWhileSending" }, { target: "Error", guard: "hasError" }, { target: "GetDeviceStatus" }] }, CloseApplication: { invoke: { src: "closeApp", onDone: { target: "CloseApplicationResultCheck", actions: Q({ _internalState: (u) => Kh(u.event.output) ? { ...u.context._internalState, currentlyRunningApp: "BOLOS" } : { ...u.context._internalState, error: u.event.output.error } }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, CloseApplicationResultCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "OpenApplication" }] }, ApplicationReady: { always: "Success" }, Success: { type: "final", actions: "assignNoError" }, Error: { type: "final" } }, output: ({ context: u }) => u._internalState.error ? N(u._internalState.error) : te(void 0) });
  }
  extractDependencies(e) {
    return { closeApp: async () => e.sendCommand(new Xee()), openApp: async (t) => e.sendCommand(new nte({ appName: t.input.appName })), getDeviceSessionState: () => e.getDeviceSessionState(), setDeviceSessionState: (t) => e.setDeviceSessionState(t), isDeviceOnboarded: () => !0 };
  }
}
var hte = ((r) => (r.GenuineCheck = "GenuineCheck", r.ListInstalledApps = "ListInstalledApps", r.UpdateMcu = "UpdateMcu", r.UpdateFirmware = "UpdateFirmware", r.InstallApp = "InstallApp", r.UninstallApp = "UninstallApp", r))(hte || {}), fte = ((r) => (r.EXCHANGE = "exchange", r.BULK = "bulk", r.ERROR = "error", r.WARNING = "warning", r.SUCCESS = "success", r))(fte || {}), pte = ((r) => (r.SUCCESS = "success", r.ERROR = "error", r))(pte || {}), gte = ((r) => (r.Opened = "opened", r.Closed = "closed", r.PermissionRequested = "permission-requested", r.PermissionGranted = "permission-granted", r.PreExchange = "pre-exchange", r.Exchange = "exchange", r.Progress = "progress", r.Warning = "warning", r.Error = "error", r.Result = "result", r))(gte || {}), mte = ((r) => (r[r.AppAlreadyInstalled = 0] = "AppAlreadyInstalled", r[r.DeviceLocked = 1] = "DeviceLocked", r[r.OutOfMemory = 2] = "OutOfMemory", r[r.RefusedByUser = 3] = "RefusedByUser", r[r.Unknown = 4] = "Unknown", r))(mte || {});
let yte = class {
  constructor(e) {
    h(this, "_tag", "WebSocketConnectionError");
    h(this, "originalError");
    this.error = e, this.originalError = e;
  }
}, vte = class extends yf {
  makeStateMachine(e) {
    const { sendCommand: t } = this.extractDependencies(e);
    return Or({ actors: { sendCommand: tt(t), openAppStateMachine: new e6({ input: { appName: this.input.appName } }).makeStateMachine(e) }, guards: { skipOpenApp: () => this.input.skipOpenApp, noInternalError: ({ context: n }) => n._internalState.error === null }, actions: { assignErrorFromEvent: Q({ _internalState: (n) => ({ ...n.context._internalState, error: n.event.error }) }) } }).createMachine({ id: "SendCommandInAppDeviceAction", initial: "InitialState", context: ({ input: n }) => ({ input: n, intermediateValue: { requiredUserInteraction: pr.None }, _internalState: { commandResponse: null, error: null } }), states: { InitialState: { always: [{ target: "SendCommand", guard: "skipOpenApp" }, "OpenAppDeviceAction"] }, OpenAppDeviceAction: { invoke: { id: "openAppStateMachine", input: { appName: this.input.appName }, src: "openAppStateMachine", onSnapshot: { actions: Q({ intermediateValue: (n) => n.event.snapshot.context.intermediateValue }) }, onDone: { actions: Q({ _internalState: (n) => n.event.output.caseOf({ Right: () => n.context._internalState, Left: (i) => ({ ...n.context._internalState, error: i }) }) }), target: "CheckOpenAppDeviceActionResult" } } }, CheckOpenAppDeviceActionResult: { always: [{ target: "SendCommand", guard: "noInternalError" }, "Error"] }, SendCommand: { entry: Q({ intermediateValue: { requiredUserInteraction: this.input.requiredUserInteraction } }), exit: Q({ intermediateValue: { requiredUserInteraction: pr.None } }), invoke: { id: "sendCommand", src: "sendCommand", input: ({ context: n }) => n.input.command, onDone: { target: "SendCommandResultCheck", actions: [Q({ _internalState: ({ event: n, context: i }) => Kh(n.output) ? { ...i._internalState, commandResponse: n.output.data } : { ...i._internalState, error: n.output.error } })] }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, SendCommandResultCheck: { always: [{ target: "Success", guard: "noInternalError" }, "Error"] }, Success: { type: "final" }, Error: { type: "final" } }, output: ({ context: n }) => n._internalState.commandResponse ? te(n._internalState.commandResponse) : N(n._internalState.error || new ste("No error in final state")) });
  }
  extractDependencies(e) {
    return { sendCommand: (t) => e.sendCommand(t.input) };
  }
}, bte = class {
  constructor(e, t, n, i, s) {
    this.deviceModel = e, this.serviceUuid = t, this.writeUuid = n, this.writeCmdUuid = i, this.notifyUuid = s;
  }
}, Ol = class {
  constructor(e) {
    h(this, "id");
    h(this, "productName");
    h(this, "usbProductId");
    h(this, "bootloaderUsbProductId");
    h(this, "usbOnly");
    h(this, "memorySize");
    h(this, "blockSize");
    h(this, "masks");
    h(this, "bluetoothSpec");
    this.id = e.id, this.productName = e.productName, this.usbProductId = e.usbProductId, this.bootloaderUsbProductId = e.bootloaderUsbProductId, this.usbOnly = e.usbOnly, this.memorySize = e.memorySize, this.blockSize = e.blockSize, this.masks = e.masks, this.bluetoothSpec = e.bluetoothSpec;
  }
  getBlockSize(e) {
    switch (this.id) {
      case wt.NANO_S:
        return ky.lt(ky.coerce(e) ?? "", "2.0.0") ? 4 * 1024 : 2 * 1024;
      case wt.NANO_X:
        return 4 * 1024;
      case wt.NANO_SP:
      case wt.STAX:
      case wt.FLEX:
      case wt.APEX:
        return 32;
    }
  }
};
var wte = Object.defineProperty, _te = (r, e, t) => e in r ? wte(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Ste = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Ete = (r, e, t) => _te(r, e + "", t);
let Yc = class {
  getAllDeviceModels() {
    return Object.values(Yc.deviceModelByIds);
  }
  getDeviceModel(e) {
    return Yc.deviceModelByIds[e.id];
  }
  filterDeviceModels(e) {
    return this.getAllDeviceModels().filter((t) => Object.entries(e).every(([n, i]) => t[n] === i));
  }
  getBluetoothServicesInfos() {
    return Object.values(Yc.deviceModelByIds).reduce((e, t) => {
      const { bluetoothSpec: n } = t;
      return n ? { ...e, ...n.reduce((i, s) => ({ ...i, [s.serviceUuid]: new bte(t, s.serviceUuid, s.writeUuid, s.writeCmdUuid, s.notifyUuid) }), {}) } : e;
    }, {});
  }
  getBluetoothServices() {
    return Object.values(Yc.deviceModelByIds).map((e) => (e.bluetoothSpec || []).map((t) => t.serviceUuid)).flat().filter((e) => !!e);
  }
};
Ete(Yc, "deviceModelByIds", { [wt.NANO_S]: new Ol({ id: wt.NANO_S, productName: "Ledger Nano S", usbProductId: 16, bootloaderUsbProductId: 1, usbOnly: !0, memorySize: 320 * 1024, blockSize: 4 * 1024, masks: [823132160] }), [wt.NANO_SP]: new Ol({ id: wt.NANO_SP, productName: "Ledger Nano S Plus", usbProductId: 80, bootloaderUsbProductId: 5, usbOnly: !0, memorySize: 1533 * 1024, blockSize: 32, masks: [856686592] }), [wt.NANO_X]: new Ol({ id: wt.NANO_X, productName: "Ledger Nano X", usbProductId: 64, bootloaderUsbProductId: 4, usbOnly: !1, memorySize: 2 * 1024 * 1024, blockSize: 4 * 1024, masks: [855638016], bluetoothSpec: [{ serviceUuid: "13d63400-2c97-0004-0000-4c6564676572", notifyUuid: "13d63400-2c97-0004-0001-4c6564676572", writeUuid: "13d63400-2c97-0004-0002-4c6564676572", writeCmdUuid: "13d63400-2c97-0004-0003-4c6564676572" }] }), [wt.STAX]: new Ol({ id: wt.STAX, productName: "Ledger Stax", usbProductId: 96, bootloaderUsbProductId: 6, usbOnly: !1, memorySize: 1533 * 1024, blockSize: 32, masks: [857735168], bluetoothSpec: [{ serviceUuid: "13d63400-2c97-6004-0000-4c6564676572", notifyUuid: "13d63400-2c97-6004-0001-4c6564676572", writeUuid: "13d63400-2c97-6004-0002-4c6564676572", writeCmdUuid: "13d63400-2c97-6004-0003-4c6564676572" }] }), [wt.FLEX]: new Ol({ id: wt.FLEX, productName: "Ledger Flex", usbProductId: 112, bootloaderUsbProductId: 7, usbOnly: !1, memorySize: 1533 * 1024, blockSize: 32, masks: [858783744], bluetoothSpec: [{ serviceUuid: "13d63400-2c97-3004-0000-4c6564676572", notifyUuid: "13d63400-2c97-3004-0001-4c6564676572", writeUuid: "13d63400-2c97-3004-0002-4c6564676572", writeCmdUuid: "13d63400-2c97-3004-0003-4c6564676572" }] }), [wt.APEX]: new Ol({ id: wt.APEX, productName: "Ledger Apex", usbProductId: 128, bootloaderUsbProductId: 8, usbOnly: !1, memorySize: 1533 * 1024, blockSize: 32, masks: [859832320], bluetoothSpec: [{ serviceUuid: "13d63400-2c97-8004-0000-4c6564676572", notifyUuid: "13d63400-2c97-8004-0001-4c6564676572", writeUuid: "13d63400-2c97-8004-0002-4c6564676572", writeCmdUuid: "13d63400-2c97-8004-0003-4c6564676572" }] }) }), Yc = Ste([le()], Yc);
let xte = class {
  constructor({ statusCode: e, data: t }) {
    h(this, "statusCode");
    h(this, "data");
    this.statusCode = e, this.data = t;
  }
};
const Ate = 5, Vc = 1, Dx = 2, sd = 2, Tx = 2, Ru = { getLastBytesFrom(r, e) {
  return r.slice(-e);
}, getFirstBytesFrom(r, e) {
  return r.slice(0, e);
}, bytesToNumber(r) {
  return r.reduce((e, t, n) => e + t * Math.pow(256, r.length - 1 - n), 0);
}, numberToByteArray(r, e) {
  return new Uint8Array(e).map((t, n) => r >> 8 * (e - 1 - n) & 255);
} }, b$ = 2, p_ = 800;
let w$ = class {
  constructor() {
    h(this, "_tag", "FramerOverflowError");
    h(this, "originalError");
    this.originalError = new Error("Frame header length is greater than frame size");
  }
}, Ite = class {
  constructor() {
    h(this, "_tag", "FramerApduError");
    h(this, "originalError");
    this.originalError = new Error("Frame offset is greater than apdu length");
  }
}, _$ = class {
  constructor(e) {
    h(this, "_tag", "ReceiverApduError");
    h(this, "originalError");
    this.originalError = new Error(e ?? "Unable to parse apdu");
  }
}, S$ = class {
  constructor(e) {
    h(this, "_tag", "DeviceSessionNotFound");
    h(this, "originalError");
    this.originalError = e ?? new Error("Device session not found");
  }
}, t6 = class {
  constructor({ header: e, data: t }) {
    h(this, "_header");
    h(this, "_data");
    this._header = e, this._data = t;
  }
  toString() {
    return JSON.stringify({ header: this._header.toString(), data: ar(this._data) }, null, 2);
  }
  getRawData() {
    const e = this._header.getRawData(), t = new Uint8Array(e.length + this._data.length);
    return t.set(e, 0), t.set(this._data, e.length), t;
  }
  getHeader() {
    return this._header;
  }
  getData() {
    return this._data;
  }
}, r6 = class {
  constructor({ uuid: e, dataSize: t, index: n, headTag: i, length: s, channel: o }) {
    h(this, "_uuid");
    h(this, "_channel");
    h(this, "_headTag");
    h(this, "_index");
    h(this, "_length");
    h(this, "_dataLength");
    this._uuid = e, this._dataLength = t, this._index = n, this._headTag = i, this._length = s, this._channel = o;
  }
  getDataLength() {
    return this._dataLength.map((e) => Ru.bytesToNumber(e));
  }
  setDataSize(e) {
    return this._dataLength = e, this;
  }
  getLength() {
    return this._length;
  }
  toString() {
    var e, t;
    return JSON.stringify({ uuid: this._uuid.toString(), dataSize: (e = this._dataLength.extract()) == null ? void 0 : e.toString(), index: this._index.toString(), headTag: this._headTag.toString(), length: this._length.toString(), channel: (t = this._channel.extract()) == null ? void 0 : t.toString() });
  }
  getRawData() {
    return new Uint8Array([...this._channel.caseOf({ Just: (e) => [...e], Nothing: () => [] }), ...this._headTag, ...this._index, ...this._dataLength.caseOf({ Just: (e) => [...e], Nothing: () => [] })]);
  }
};
const sn = { LoggerPublisherServiceFactory: Symbol.for("LoggerPublisherServiceFactory") };
var Cte = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Dte = (r, e) => (t, n) => e(t, n, r);
let E$ = class {
  constructor({ channel: e = pe.zero() }, t) {
    h(this, "_channel");
    h(this, "_logger");
    h(this, "_pendingFrames");
    this._channel = e, this._logger = t("ApduReceiverService"), this._pendingFrames = [];
  }
  handleFrame(e) {
    return this.getFrameFromBytes(e).map((t) => {
      if (this._pendingFrames.push(t), !this._pendingFrames[0]) return ve;
      const n = this._pendingFrames[0].getHeader().getDataLength();
      return this.getCompleteFrame(n);
    });
  }
  getCompleteFrame(e) {
    return e.chain((t) => {
      if (!this.isComplete(t)) return this._logger.debug("frame is not complete, waiting for more"), ve;
      const n = Ru.getFirstBytesFrom(this.concatFrames(this._pendingFrames), t), i = Ru.getFirstBytesFrom(n, n.length - b$), s = Ru.getLastBytesFrom(n, b$);
      return this._pendingFrames = [], Le(new xte({ data: i, statusCode: s }));
    });
  }
  getFrameFromBytes(e) {
    const t = this._channel.caseOf({ Just: () => Dx, Nothing: () => 0 }), n = e.slice(t, t + Vc), i = e.slice(t + Vc, t + Vc + sd), s = i.reduce((f, p) => f + p, 0) === 0;
    if (!s && this._pendingFrames.length === 0) return N(new _$());
    const o = t + Vc + sd, a = s ? Tx : 0;
    if (e.length < t + Vc + sd + a) return N(new _$("Unable to parse header from apdu"));
    const c = s ? Le(e.slice(o, o + a)) : ve, u = o + a, l = e.slice(u), d = new t6({ header: new r6({ uuid: pa(), channel: this._channel, dataSize: c, headTag: n, index: i, length: t + Vc + sd + a }), data: l });
    return te(d);
  }
  isComplete(e) {
    return this._pendingFrames.reduce((t, n) => t + n.getData().length, 0) >= e;
  }
  concatFrames(e) {
    return e.reduce((t, n) => Uint8Array.from([...t, ...n.getData()]), new Uint8Array(0));
  }
};
E$ = Cte([le(), Dte(1, X(sn.LoggerPublisherServiceFactory))], E$);
var Tte = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, kte = (r, e) => (t, n) => e(t, n, r);
let x$ = class {
  constructor({ frameSize: e, channel: t = pe.zero(), padding: n = !1 }, i) {
    h(this, "_frameSize");
    h(this, "_channel");
    h(this, "_padding");
    h(this, "_logger");
    this._frameSize = e, this._channel = t, this._padding = n, this._logger = i("DefaultApduSenderService");
  }
  getFrames(e) {
    const t = [];
    let n = 0, i = this.getFrameAtIndex(e, n);
    for (; i.isRight(); ) t.push(i.extract()), n += 1, i = this.getFrameAtIndex(e, n).mapLeft((s) => (s instanceof w$ || this._logger.error("Error while parsing frame", { data: { error: s } }), s));
    return t;
  }
  getFrameAtIndex(e, t) {
    const n = this.getFrameHeaderFrom(t, e.length), i = t === 0 ? 0 : t * this._frameSize - this.getHeaderSizeSumFrom(t);
    if (i >= e.length) return N(new w$());
    if (n.getLength() > this._frameSize) return N(new Ite());
    const s = this._frameSize - n.getLength(), o = e.slice(i, i + this._frameSize - n.getLength()), a = this._padding ? new Uint8Array(s).fill(0) : new Uint8Array(o.length < s ? o.length : s);
    a.set(o, 0);
    const c = new t6({ header: n, data: a });
    return te(c);
  }
  getFrameHeaderFrom(e, t) {
    const n = new r6({ uuid: pa(), channel: this._channel.map((i) => Ru.getLastBytesFrom(i, Dx)), headTag: new Uint8Array([Ate]), index: Ru.numberToByteArray(e, sd), length: this.getFrameHeaderSizeFromIndex(e), dataSize: pe.zero() });
    return e === 0 && n.setDataSize(pe.of(Ru.numberToByteArray(t, Tx))), n;
  }
  getHeaderSizeSumFrom(e) {
    let t = this.getFrameHeaderSizeFromIndex(0), n = 1;
    for (; n < e; ) t += this.getFrameHeaderSizeFromIndex(n), n += 1;
    return t;
  }
  getFrameHeaderSizeFromIndex(e) {
    return this._channel.caseOf({ Just: () => Dx, Nothing: () => 0 }) + sd + Vc + (e === 0 ? Tx : 0);
  }
};
x$ = Tte([le(), kte(1, X(sn.LoggerPublisherServiceFactory))], x$);
const kx = { LocalConfigDataSource: Symbol.for("LocalConfigDataSource"), RemoteConfigDataSource: Symbol.for("RemoteConfigDataSource"), ConfigService: Symbol.for("ConfigService") }, oi = { ApduSenderServiceFactory: Symbol.for("ApduSenderServiceFactory"), ApduReceiverServiceFactory: Symbol.for("ApduReceiverServiceFactory"), DeviceSessionService: Symbol.for("DeviceSessionService") }, f0 = { ManagerApiService: Symbol.for("ManagerApiService"), ManagerApiDataSource: Symbol.for("ManagerApiDataSource"), DmkConfig: Symbol.for("ManagerApiDmkConfig") }, _c = { DmkConfig: Symbol.for("TransportDmkConfig"), TransportService: Symbol.for("TransportService"), TransportsInput: Symbol.for("TransportsInput") };
var Ote = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, A$ = (r, e) => (t, n) => e(t, n, r);
let I$ = class {
  constructor(e, t) {
    h(this, "_sessionService");
    h(this, "_logger");
    this._sessionService = e, this._logger = t("SendCommandUseCase");
  }
  async execute({ sessionId: e, command: t, abortTimeout: n }) {
    return this._sessionService.getDeviceSessionById(e).caseOf({ Right: async (i) => await i.sendCommand(t, n), Left: (i) => {
      throw this._logger.error("Error getting session", { data: { error: i } }), i;
    } });
  }
};
I$ = Ote([le(), A$(0, X(oi.DeviceSessionService)), A$(1, X(sn.LoggerPublisherServiceFactory))], I$);
var $te = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
};
let C$ = class {
  constructor() {
    h(this, "execute", vi.fn(() => "stub"));
  }
};
C$ = $te([le()], C$);
var Rte = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, D$ = (r, e) => (t, n) => e(t, n, r);
let T$ = class {
  constructor(e, t) {
    h(this, "_sessionService");
    h(this, "_logger");
    this._sessionService = e, this._logger = t("ExecuteDeviceActionUseCase");
  }
  execute({ sessionId: e, deviceAction: t }) {
    return this._sessionService.getDeviceSessionById(e).caseOf({ Right: (n) => n.executeDeviceAction(t), Left: (n) => {
      throw this._logger.error("Error getting session", { data: { error: n } }), n;
    } });
  }
};
T$ = Rte([le(), D$(0, X(oi.DeviceSessionService)), D$(1, X(sn.LoggerPublisherServiceFactory))], T$);
function Pte(r) {
  return typeof r == "object" && r !== null && "version" in r && "name" in r && typeof r.version == "string" && typeof r.name == "string";
}
let k$ = class {
  constructor(e) {
    h(this, "_tag", "ApiCallError");
    h(this, "originalError");
    this.err = e, this.originalError = e;
  }
}, Nte = class {
  constructor(e) {
    h(this, "_tag", "ParseResponseError");
    h(this, "originalError");
    this.err = e, this.originalError = e;
  }
}, n6 = class {
  constructor(e) {
    h(this, "_tag", "JSONParseError");
    h(this, "originalError");
    this.err = e, this.originalError = e;
  }
}, Bte = class {
  constructor(e) {
    h(this, "_tag", "ReadFileError");
    h(this, "originalError");
    this.err = e, this.originalError = e;
  }
};
const Lte = "@ledgerhq/device-management-kit", Ute = "0.9.1", O$ = {
  name: Lte,
  version: Ute
};
var Fte = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
};
const Mte = { name: O$.name, version: O$.version }, Vte = () => JSON.stringify(Mte);
let $$ = class {
  getConfig() {
    return Pt.encase(() => Vte()).mapLeft((e) => new Bte(e)).chain((e) => Pt.encase(() => {
      const t = JSON.parse(e);
      if (Pte(t)) return t;
      throw new Error("Invalid config file");
    }).mapLeft((t) => new n6(t)));
  }
};
$$ = Fte([le()], $$);
var zte = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
};
let R$ = class {
  getConfig() {
    return Pt.of({ name: "DeviceSDK", version: "0.0.0-stub.1" });
  }
};
R$ = zte([le()], R$);
var jte = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
};
let P$ = class {
  async getConfig() {
    const e = await this._callApi();
    if (e.isLeft()) return N(new k$(e.extract()));
    if (!e.extract().ok) return N(new k$(new Error("response not ok")));
    const t = await e.extract().json();
    return t.isLeft() ? N(new n6()) : t.chain((n) => this._parseResponse(n)).map((n) => n);
  }
  _parseResponse(e) {
    const { name: t, version: n } = e;
    return !t || !n ? N(new Nte()) : Pt.of({ name: t, version: n });
  }
  _callApi() {
    return new Promise((e) => {
      e(Pt.of({ ok: !0, json: async () => new Promise((t) => {
        t(Pt.of({ name: "DeviceSDK", version: "0.0.0-fake.1", yolo: "yolo" }));
      }) }));
    });
  }
};
P$ = jte([le()], P$);
var Hte = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
};
let N$ = class {
  async getConfig() {
    return new Promise((e) => e(Pt.of({ name: "DeviceSDK", version: "0.0.0-fake.2" })));
  }
};
N$ = Hte([le()], N$);
var Gte = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, g_ = (r, e) => (t, n) => e(t, n, r);
let B$ = class {
  constructor(e, t, n) {
    h(this, "_local");
    h(this, "_remote");
    h(this, "_logger");
    this._local = e, this._remote = t, this._logger = n("config");
  }
  async getDmkConfig() {
    const e = this._local.getConfig().ifLeft((t) => {
      this._logger.error("Local config not available", { data: { error: t } });
    });
    if (e.isRight()) {
      const t = e.extract();
      return this._logger.info("Local config available", { data: { config: t } }), t;
    }
    return this._remote.getConfig().then((t) => t.mapLeft((n) => (this._logger.error("Local config available", { data: { error: n } }), { name: "DeadDmk", version: "0.0.0-dead.1" })).extract());
  }
};
B$ = Gte([le(), g_(0, X(kx.LocalConfigDataSource)), g_(1, X(kx.RemoteConfigDataSource)), g_(2, X(sn.LoggerPublisherServiceFactory))], B$);
var Kte = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, qte = (r, e) => (t, n) => e(t, n, r);
let L$ = class {
  constructor(e) {
    h(this, "_configService");
    this._configService = e;
  }
  async getDmkVersion() {
    return (await this._configService.getDmkConfig()).version;
  }
};
L$ = Kte([le(), qte(0, X(kx.ConfigService))], L$);
const Wte = { DeviceModelDataSource: Symbol.for("DeviceModelDataSource") };
var Zte = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, U$ = (r, e) => (t, n) => e(t, n, r);
let F$ = class {
  constructor(e, t) {
    h(this, "_logger");
    this._sessionService = e, this._logger = t("DisableDeviceSessionRefresherUseCase");
  }
  execute({ sessionId: e, blockerId: t }) {
    return this._sessionService.getDeviceSessionById(e).caseOf({ Left: (n) => {
      throw this._logger.error("Error getting device session", { data: { error: n } }), n;
    }, Right: (n) => n.disableRefresher(t) });
  }
};
F$ = Zte([le(), U$(0, X(oi.DeviceSessionService)), U$(1, X(sn.LoggerPublisherServiceFactory))], F$);
var Jte = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Xte = (r, e) => (t, n) => e(t, n, r);
let M$ = class {
  constructor(e) {
    h(this, "_sessions");
    h(this, "_logger");
    h(this, "_sessionsSubject");
    this._sessions = [], this._sessionsSubject = new $v(), this._logger = e("DeviceSessionService");
  }
  get sessionsObs() {
    return this._sessionsSubject.asObservable();
  }
  addDeviceSession(e) {
    return this._sessions.find((t) => t.id === e.id) ? (this._logger.warn("DeviceSession already exists", { data: { deviceSession: e } }), this) : (this._sessions.push(e), this._sessionsSubject.next(e), this._logger.info("DeviceSession added", { data: { deviceSession: e } }), this);
  }
  removeDeviceSession(e) {
    const t = this._sessions.find((n) => n.id === e);
    return t ? (t.close(), this._sessions = this._sessions.filter((n) => n.id !== e), this._logger.info("DeviceSession removed", { data: { sessionId: e } }), this) : (this._logger.warn("DeviceSession not found", { data: { sessionId: e } }), this);
  }
  getDeviceSessionById(e) {
    return pe.fromNullable(this._sessions.find((t) => t.id === e)).toEither(new S$());
  }
  getDeviceSessionByDeviceId(e) {
    return pe.fromNullable(this._sessions.find((t) => t.connectedDevice.id === e)).toEither(new S$());
  }
  getDeviceSessions() {
    return this._sessions;
  }
};
M$ = Jte([le(), Xte(0, X(sn.LoggerPublisherServiceFactory))], M$);
var Yte = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, V$ = (r, e) => (t, n) => e(t, n, r);
let z$ = class {
  constructor(e, t) {
    h(this, "_sessionService");
    h(this, "_transportService");
    this._sessionService = e, this._transportService = t;
  }
  execute() {
    const e = this._sessionService.getDeviceSessions();
    for (const t of e) this._transportService.closeConnection(t.connectedDevice), this._sessionService.removeDeviceSession(t.id);
  }
};
z$ = Yte([le(), V$(0, X(oi.DeviceSessionService)), V$(1, X(_c.TransportService))], z$);
var Qte = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, j$ = (r, e) => (t, n) => e(t, n, r);
let H$ = class {
  constructor(e, t) {
    h(this, "_sessionService");
    h(this, "_logger");
    this._sessionService = e, this._logger = t("GetDeviceSessionStateUseCase");
  }
  execute({ sessionId: e }) {
    return this._sessionService.getDeviceSessionById(e).caseOf({ Left: (t) => {
      throw this._logger.error("Error getting session device", { data: { error: t } }), t;
    }, Right: (t) => t.state });
  }
};
H$ = Qte([le(), j$(0, X(oi.DeviceSessionService)), j$(1, X(sn.LoggerPublisherServiceFactory))], H$);
const Ox = 1e3, m_ = 1e3, ere = { isRefresherDisabled: !1, pollingInterval: 1e3 };
let tre = class {
  constructor() {
    h(this, "_queue", []);
    h(this, "_locked", !1);
  }
  async lock() {
    return new Promise((e) => {
      const t = () => {
        if (this._locked = !1, this._queue.length > 0) {
          const n = this._queue.shift();
          this._locked = !0, n();
        }
      };
      this._locked ? this._queue.push(() => e(t)) : (this._locked = !0, e(t));
    });
  }
}, rre = class {
  constructor(e, t) {
    h(this, "_refresherBlockers", /* @__PURE__ */ new Set());
    h(this, "_logger");
    this._refresher = t, this._logger = e("refresher-service");
  }
  disableRefresher(e) {
    const t = `${e}-${pa()}`;
    this.addRefresherBlocker(t), this._logger.debug("Refresher disabled", { data: { blockerId: t, blockers: Array.from(this._refresherBlockers) } });
    let n = !1;
    return () => {
      n || (n = !0, this.removeRefresherBlocker(t), this._logger.debug("Refresher re-enabled", { data: { blockerId: t, blockers: Array.from(this._refresherBlockers) } }));
    };
  }
  addRefresherBlocker(e) {
    const t = this._refresherBlockers.size;
    this._refresherBlockers.add(e), t === 0 && this._refresher.stop();
  }
  removeRefresherBlocker(e) {
    const t = this._refresherBlockers.size;
    this._refresherBlockers.delete(e), t > 0 && this._refresherBlockers.size === 0 && this._refresher.start();
  }
};
var Qn = ((r) => (r.NEW_STATE = "NEW_STATE", r.REFRESH_NEEDED = "REFRESH_NEEDED", r.COMMAND_SUCCEEDED = "COMMAND_SUCCEEDED", r.DEVICE_STATE_UPDATE_BUSY = "DEVICE_STATE_UPDATE_BUSY", r.DEVICE_STATE_UPDATE_LOCKED = "DEVICE_STATE_UPDATE_LOCKED", r.DEVICE_STATE_UPDATE_CONNECTED = "DEVICE_STATE_UPDATE_CONNECTED", r))(Qn || {});
let nre = class {
  constructor() {
    h(this, "_eventEmitter", new af());
  }
  listen() {
    return this._eventEmitter.asObservable();
  }
  dispatch(e) {
    this._eventEmitter.next(e);
  }
}, ire = class {
  constructor(e, t, n, i) {
    h(this, "_sendCommandFunction");
    h(this, "_subscription");
    h(this, "_logger");
    h(this, "mapEventAction", async (e) => {
      switch (e.eventName) {
        case Qn.REFRESH_NEEDED:
          return await this.ping();
        default:
          return null;
      }
    });
    this.connectedDevice = t, this._sessionEventDispatcher = n, this._sendCommandFunction = i, this._logger = e("device-pinger"), this._subscription = this._sessionEventDispatcher.listen().subscribe(async (s) => await this.mapEventAction(s));
  }
  async ping() {
    try {
      return await this.mapDevicePingAction(this.connectedDevice.deviceModel.id);
    } catch (e) {
      throw this._logger.error("Error while pinging device", { data: { error: e } }), e;
    }
  }
  async mapDevicePingAction(e) {
    switch (e) {
      case wt.NANO_S: {
        const t = async () => {
          const s = await this._sendCommandFunction(new Xy(), p_);
          return this._sendCommandFunction(new tte(), p_), s;
        }, n = new Promise((s) => {
          setTimeout(() => s(null), Ox * 2 + 100);
        }), i = await Promise.race([t(), n]);
        return i ? this._sessionEventDispatcher.dispatch({ eventName: Qn.COMMAND_SUCCEEDED, eventData: i }) : this._sessionEventDispatcher.dispatch({ eventName: Qn.DEVICE_STATE_UPDATE_LOCKED }), i;
      }
      default: {
        const t = await this._sendCommandFunction(new Xy(), p_);
        return this._sessionEventDispatcher.dispatch({ eventName: Qn.COMMAND_SUCCEEDED, eventData: t }), t;
      }
    }
  }
  unsubscribe() {
    this._subscription.unsubscribe();
  }
}, sre = class {
  constructor(e, t, n, i) {
    h(this, "_refresherSubscription");
    h(this, "_refresherOptions");
    h(this, "_logger");
    h(this, "_connectedDeviceID");
    h(this, "getValidPollingInterval", (e, t) => {
      const { pollingInterval: n } = e;
      switch (this._connectedDeviceID) {
        case wt.NANO_S: {
          const i = Ox * 2;
          return n !== void 0 && n < i ? (t.warn(`Polling interval of ${n} is too low, setting to minimum as ${i}`), i) : n ?? i;
        }
        default:
          return n !== void 0 && n < m_ ? (t.warn(`Polling interval of ${n} is too low, setting to minimum as ${m_}`), m_) : n ?? Ox;
      }
    });
    this._sessionEventDispatcher = n, this._refresherOptions = t, this._logger = e("device-session-refresher"), this._connectedDeviceID = i.deviceModel.id;
  }
  startRefresher() {
    if (this._refresherOptions.isRefresherDisabled) return;
    const e = this.getValidPollingInterval(this._refresherOptions, this._logger) * 2;
    this._refresherSubscription = E1(0, e).subscribe(() => {
      this._sessionEventDispatcher.dispatch({ eventName: Qn.REFRESH_NEEDED });
    });
  }
  stopRefresher() {
    this._refresherSubscription && (this._refresherSubscription.unsubscribe(), this._refresherSubscription = void 0, this._logger.info("Refresher stopped."));
  }
  restartRefresher() {
    this.stopRefresher(), this.startRefresher(), this._logger.info("Refresher restarted.");
  }
  destroy() {
    this.stopRefresher();
  }
}, ore = class {
  constructor(e, t, n, i, s) {
    h(this, "_subscription");
    h(this, "_logger");
    h(this, "mapEventAction", (e) => {
      switch (e.eventName) {
        case Qn.COMMAND_SUCCEEDED:
          return this._updateDeviceState(e.eventData);
        case Qn.DEVICE_STATE_UPDATE_BUSY:
          return this.setDeviceSessionState({ ...this._deviceState.getValue(), deviceStatus: ic.BUSY });
        case Qn.DEVICE_STATE_UPDATE_LOCKED:
          return this.setDeviceSessionState({ ...this._deviceState.getValue(), deviceStatus: ic.LOCKED });
        case Qn.DEVICE_STATE_UPDATE_CONNECTED:
          return this.setDeviceSessionState({ ...this._deviceState.getValue(), deviceStatus: ic.CONNECTED });
        default:
          return null;
      }
    });
    this._sessionEventDispatcher = t, this._connectedDevice = n, this._deviceState = i, this.setDeviceSessionState = s, this._subscription = this._sessionEventDispatcher.listen().subscribe((o) => this.mapEventAction(o)), this._logger = e("device-session-state-handler");
  }
  _updateDeviceState(e) {
    const t = this._parseDeviceStatus(e);
    if (t) {
      const { sessionStateType: n, deviceStatus: i, currentApp: s } = t, o = this._deviceState.getValue();
      o.sessionStateType === mo.Connected ? this.setDeviceSessionState({ sessionStateType: n, deviceStatus: i, deviceModelId: this._connectedDevice.deviceModel.id, currentApp: s, installedApps: [], isSecureConnectionAllowed: !1 }) : this.setDeviceSessionState({ ...o, sessionStateType: n, deviceStatus: i, deviceModelId: this._connectedDevice.deviceModel.id, currentApp: s });
    }
  }
  _parseDeviceStatus(e) {
    return Kh(e) ? { sessionStateType: mo.ReadyWithoutSecureChannel, deviceStatus: ic.CONNECTED, currentApp: { name: e.data.name, version: e.data.version } } : (this._logger.debug("Error while parsing APDU response", { data: { parsedResponse: e } }), null);
  }
  unsubscribe() {
    this._subscription.unsubscribe();
  }
};
class are {
  constructor({ connectedDevice: e, id: t = pa() }, n, i, s, o) {
    h(this, "_id");
    h(this, "_connectedDevice");
    h(this, "_deviceState");
    h(this, "_managerApiService");
    h(this, "_secureChannelService");
    h(this, "_logger");
    h(this, "_refresherOptions");
    h(this, "_pinger");
    h(this, "_deviceSessionRefresher");
    h(this, "_refresherService");
    h(this, "_commandMutex", new tre());
    h(this, "_sessionEventDispatcher", new nre());
    this._id = t, this._connectedDevice = e, this._logger = n("device-session"), this._managerApiService = i, this._secureChannelService = s, this._refresherOptions = { ...ere, ...o }, this._deviceState = new fa({ sessionStateType: mo.Connected, deviceStatus: ic.CONNECTED, deviceModelId: this._connectedDevice.deviceModel.id }), this._pinger = new ire(n, e, this._sessionEventDispatcher, (a, c) => this.sendCommand(a, c)), this._deviceSessionRefresher = new sre(n, this._refresherOptions, this._sessionEventDispatcher, this._connectedDevice), new ore(n, this._sessionEventDispatcher, this._connectedDevice, this._deviceState, (a) => this.setDeviceSessionState(a)), this._refresherService = new rre(n, { start: () => this._deviceSessionRefresher.restartRefresher(), stop: () => this._deviceSessionRefresher.stopRefresher() });
  }
  async initialiseSession() {
    try {
      await this._pinger.ping();
    } catch (e) {
      throw this._logger.error("Error while initialising session", { data: { error: e } }), e;
    } finally {
      this._refresherOptions.isRefresherDisabled || this._deviceSessionRefresher.startRefresher();
    }
  }
  get id() {
    return this._id;
  }
  get connectedDevice() {
    return this._connectedDevice;
  }
  get state() {
    return this._deviceState.asObservable();
  }
  getDeviceSessionState() {
    return this._deviceState.getValue();
  }
  setDeviceSessionState(e) {
    this._deviceState.next(e);
  }
  async sendApdu(e, t = { isPolling: !1, triggersDisconnection: !1, abortTimeout: void 0 }) {
    const n = await this._commandMutex.lock();
    try {
      this._sessionEventDispatcher.dispatch({ eventName: Qn.DEVICE_STATE_UPDATE_BUSY });
      const i = await this._connectedDevice.sendApdu(e, t.triggersDisconnection, t.abortTimeout);
      return i.ifRight((s) => {
        mf.isLockedDeviceResponse(s) ? this._sessionEventDispatcher.dispatch({ eventName: Qn.DEVICE_STATE_UPDATE_LOCKED }) : this._sessionEventDispatcher.dispatch({ eventName: Qn.DEVICE_STATE_UPDATE_CONNECTED });
      }).ifLeft(() => {
        this._sessionEventDispatcher.dispatch({ eventName: Qn.DEVICE_STATE_UPDATE_CONNECTED });
      }), i;
    } finally {
      n();
    }
  }
  async sendCommand(e, t) {
    const n = e.getApdu();
    return (await this.sendApdu(n.getRawApdu(), { isPolling: !1, triggersDisconnection: e.triggersDisconnection ?? !1, abortTimeout: t })).caseOf({ Left: (i) => {
      throw i;
    }, Right: (i) => e.parseResponse(i, this._connectedDevice.deviceModel.id) });
  }
  executeDeviceAction(e) {
    const { observable: t, cancel: n } = e._execute({ sendApdu: async (i) => this.sendApdu(i), sendCommand: async (i, s) => this.sendCommand(i, s), getDeviceModel: () => this._connectedDevice.deviceModel, getDeviceSessionState: () => this._deviceState.getValue(), getDeviceSessionStateObservable: () => this.state, setDeviceSessionState: (i) => (this.setDeviceSessionState(i), this._deviceState.getValue()), disableRefresher: (i) => this._refresherService.disableRefresher(i), getManagerApiService: () => this._managerApiService, getSecureChannelService: () => this._secureChannelService });
    return { observable: t, cancel: n };
  }
  close() {
    this._updateDeviceStatus(ic.NOT_CONNECTED), this._deviceState.complete(), this._deviceSessionRefresher.stopRefresher();
  }
  disableRefresher(e) {
    return this._refresherService.disableRefresher(e);
  }
  _updateDeviceStatus(e) {
    const t = this._deviceState.getValue();
    this._deviceState.next({ ...t, deviceStatus: e });
  }
}
const kC = { SecureChannelService: Symbol.for("SecureChannelService"), SecureChannelDataSource: Symbol.for("SecureChannelDataSource"), DmkConfig: Symbol.for("SecureChannelDmkConfig") };
var cre = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Ff = (r, e) => (t, n) => e(t, n, r);
let G$ = class {
  constructor(e, t, n, i, s) {
    h(this, "_transportService");
    h(this, "_sessionService");
    h(this, "_loggerFactory");
    h(this, "_managerApi");
    h(this, "_secureChannel");
    h(this, "_logger");
    this._sessionService = t, this._transportService = e, this._loggerFactory = n, this._logger = n("ConnectUseCase"), this._managerApi = i, this._secureChannel = s;
  }
  handleDeviceDisconnect(e) {
    this._sessionService.getDeviceSessionByDeviceId(e).map((t) => {
      this._sessionService.removeDeviceSession(t.id);
    });
  }
  async execute({ device: e, sessionRefresherOptions: t }) {
    const n = this._transportService.getTransport(e.transport);
    return me.liftEither(n.toEither(new TC(new Error("Unknown transport")))).chain(async (i) => i.connect({ deviceId: e.id, onDisconnect: (s) => this.handleDeviceDisconnect(s) })).ifLeft((i) => {
      this._logger.error("Error connecting to device", { data: { deviceId: e.id, error: i } });
    }).map(async (i) => {
      const s = new are({ connectedDevice: i }, this._loggerFactory, this._managerApi, this._secureChannel, t);
      return this._sessionService.addDeviceSession(s), await s.initialiseSession(), s.id;
    }).caseOf({ Left: (i) => {
      throw i;
    }, Right: (i) => i });
  }
};
G$ = cre([le(), Ff(0, X(_c.TransportService)), Ff(1, X(oi.DeviceSessionService)), Ff(2, X(sn.LoggerPublisherServiceFactory)), Ff(3, X(f0.ManagerApiService)), Ff(4, X(kC.SecureChannelService))], G$);
var ure = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, y_ = (r, e) => (t, n) => e(t, n, r);
let K$ = class {
  constructor(e, t, n) {
    h(this, "_transportService");
    h(this, "_sessionService");
    h(this, "_logger");
    this._sessionService = t, this._transportService = e, this._logger = n("DisconnectUseCase");
  }
  async execute({ sessionId: e }) {
    return me(async ({ liftEither: t }) => {
      const n = await t(this._sessionService.getDeviceSessionById(e).ifLeft((o) => {
        this._logger.error("Device session not found", { data: { sessionId: e, error: o } });
      })), i = n.connectedDevice.transport, s = await t(this._transportService.getTransport(i).toEither(new TC(new Error("Unknown transport"))));
      n.close(), this._sessionService.removeDeviceSession(e), await s.disconnect({ connectedDevice: n.connectedDevice });
    }).caseOf({ Left: (t) => {
      throw this._logger.error("Error disconnecting from device", { data: { error: t } }), t;
    }, Right: () => {
    } });
  }
};
K$ = ure([le(), y_(0, X(_c.TransportService)), y_(1, X(oi.DeviceSessionService)), y_(2, X(sn.LoggerPublisherServiceFactory))], K$);
let OC = class {
  constructor({ transportConnectedDevice: { id: e, deviceModel: { id: t, productName: n }, type: i }, sessionId: s }) {
    h(this, "id");
    h(this, "sessionId");
    h(this, "modelId");
    h(this, "name");
    h(this, "type");
    this.id = e, this.sessionId = s, this.modelId = t, this.name = n, this.type = i;
  }
};
var lre = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, q$ = (r, e) => (t, n) => e(t, n, r);
let W$ = class {
  constructor(e, t) {
    h(this, "_sessionService");
    h(this, "_logger");
    this._sessionService = e, this._logger = t("GetConnectedDeviceUseCase");
  }
  execute({ sessionId: e }) {
    return this._sessionService.getDeviceSessionById(e).caseOf({ Right: (t) => new OC({ sessionId: t.id, transportConnectedDevice: t.connectedDevice }), Left: (t) => {
      throw this._logger.error("Error getting session", { data: { error: t } }), t;
    } });
  }
};
W$ = lre([le(), q$(0, X(oi.DeviceSessionService)), q$(1, X(sn.LoggerPublisherServiceFactory))], W$);
var dre = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Z$ = (r, e) => (t, n) => e(t, n, r);
let J$ = class {
  constructor(e, t) {
    h(this, "_sessionService");
    h(this, "_logger");
    this._sessionService = e, this._logger = t("ListConnectedDeviceUseCase");
  }
  execute() {
    return this._logger.info("Listing connected devices"), this._sessionService.getDeviceSessions().map((e) => new OC({ transportConnectedDevice: e.connectedDevice, sessionId: e.id }));
  }
};
J$ = dre([le(), Z$(0, X(oi.DeviceSessionService)), Z$(1, X(sn.LoggerPublisherServiceFactory))], J$);
var hre = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, X$ = (r, e) => (t, n) => e(t, n, r);
let Y$ = class {
  constructor(e, t) {
    h(this, "_transports");
    h(this, "_transportService");
    h(this, "_logger");
    this._transports = e.getAllTransports(), this._transportService = e, this._logger = t("ListenToAvailableDevicesUseCase");
  }
  mapTransportDiscoveredDeviceToDiscoveredDevice(e) {
    const t = new X3({ id: e.id, model: e.deviceModel.id, name: e.deviceModel.productName });
    return { id: e.id, deviceModel: t, transport: e.transport, name: e.name || t.name, rssi: e.rssi };
  }
  execute({ transport: e } = {}) {
    if (this._logger.info("Listening to available devices"), this._transports.length === 0) return this._logger.warn("No transports available"), rn([[]]);
    if (!e) {
      this._logger.info("Discovering all available transports");
      const t = this._transports.map((n, i) => n.listenToAvailableDevices().pipe(cr((s) => ({ index: i, arr: s }))));
      return x1(...t).pipe(A1((n, { index: i, arr: s }) => (n[i] = s, n), {}), cr((n) => Object.values(n).flat().map(this.mapTransportDiscoveredDeviceToDiscoveredDevice)));
    }
    return this._logger.info(`Discovering devices on transport ${e}`), this._transportService.getTransport(e).caseOf({ Nothing: () => (this._logger.error(`Transport ${e} not found`), Ji([])), Just: (t) => t.listenToAvailableDevices().pipe(cr((n) => n.map(this.mapTransportDiscoveredDeviceToDiscoveredDevice))) });
  }
};
Y$ = hre([le(), X$(0, X(_c.TransportService)), X$(1, X(sn.LoggerPublisherServiceFactory))], Y$);
var fre = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Q$ = (r, e) => (t, n) => e(t, n, r);
let eR = class {
  constructor(e, t) {
    h(this, "_logger");
    this._sessionService = e, this._logger = t("ListenToConnectedDeviceUseCase");
  }
  execute() {
    return this._logger.info("Observe connected devices"), this._sessionService.sessionsObs.pipe(cr((e) => new OC({ transportConnectedDevice: e.connectedDevice, sessionId: e.id })));
  }
};
eR = fre([le(), Q$(0, X(oi.DeviceSessionService)), Q$(1, X(sn.LoggerPublisherServiceFactory))], eR);
var pre = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, gre = (r, e) => (t, n) => e(t, n, r);
let tR = class {
  constructor(e) {
    this._transportService = e;
  }
  mapDiscoveredDevice(e) {
    const t = new X3({ id: e.id, model: e.deviceModel.id, name: e.deviceModel.productName });
    return { id: e.id, deviceModel: t, transport: e.transport, name: e.name || t.name, rssi: e.rssi };
  }
  execute({ transport: e } = {}) {
    if (!e) {
      const t = this._transportService.getAllTransports();
      return Ji(...t).pipe(cf((n) => n.startDiscovering().pipe(cr((i) => this.mapDiscoveredDevice(i)))));
    }
    return this._transportService.getTransport(e).caseOf({ Just: (t) => t.startDiscovering().pipe(cr((n) => this.mapDiscoveredDevice(n))), Nothing: () => {
      throw new TC(new Error("Unknown transport"));
    } });
  }
};
tR = pre([le(), gre(0, X(_c.TransportService))], tR);
var mre = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, rR = (r, e) => (t, n) => e(t, n, r);
let nR = class {
  constructor(e, t) {
    h(this, "_logger");
    this.transportService = e, this._logger = t("StopDiscoveringUseCase");
  }
  async execute() {
    this._logger.debug("Stopping discovering devices");
    for (const e of this.transportService.getAllTransports()) await e.stopDiscovering();
  }
};
nR = mre([le(), rR(0, X(_c.TransportService)), rR(1, X(sn.LoggerPublisherServiceFactory))], nR);
var dp = ((r) => (r[r.Fatal = 0] = "Fatal", r[r.Error = 1] = "Error", r[r.Warning = 2] = "Warning", r[r.Info = 3] = "Info", r[r.Debug = 4] = "Debug", r))(dp || {}), yre = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
};
let iR = class {
  constructor(e, t) {
    h(this, "subscribers");
    h(this, "tag");
    this.subscribers = e, this.tag = t;
  }
  _log(e, t, n) {
    this.subscribers.forEach((i) => {
      const s = { timestamp: Date.now(), tag: this.tag, ...n };
      i.log(e, t, s);
    });
  }
  info(e, t) {
    this._log(dp.Info, e, t);
  }
  warn(e, t) {
    this._log(dp.Warning, e, t);
  }
  debug(e, t) {
    this._log(dp.Debug, e, t);
  }
  error(e, t) {
    this._log(dp.Error, e, t);
  }
};
iR = yre([le()], iR);
var hp = ((r) => (r.currency = "currency", r.plugin = "plugin", r.tool = "tool", r.swap = "swap", r))(hp || {});
const vre = 1, bre = "0";
let ss = class {
  constructor(e) {
    h(this, "_tag", "FetchError");
    h(this, "originalError");
    this.error = e, this.originalError = e;
  }
};
var fp = ((r) => (r.currency = "currency", r.plugin = "plugin", r.tool = "tool", r.swap = "swap", r))(fp || {}), wre = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, _re = (r, e) => (t, n) => e(t, n, r);
let sR = class {
  constructor({ managerApiUrl: e, provider: t, firmwareDistributionSalt: n }) {
    h(this, "_managerApiBaseUrl");
    h(this, "_provider", vre);
    h(this, "_firmwareDistributionSalt", bre);
    this._managerApiBaseUrl = e, this._provider = t, this._firmwareDistributionSalt = n;
  }
  setProvider(e) {
    this._provider === e || e < 1 || (this._provider = e);
  }
  getProvider() {
    return this._provider;
  }
  getAppList(e) {
    const { targetId: t, firmwareVersionName: n } = e;
    return me(() => He.get(`${this._managerApiBaseUrl}/v2/apps/by-target`, { params: { target_id: t, provider: this._provider, firmware_version_name: n } })).map((i) => i.data).chain((i) => this.mapApplicationDtoToApplication(i)).mapLeft((i) => new ss(i));
  }
  getMcuList() {
    return me(() => He.get(`${this._managerApiBaseUrl}/mcu_versions`, {})).map((e) => e.data).chain((e) => this.mapMcuDtoToMcu(e)).mapLeft((e) => new ss(e));
  }
  getDeviceVersion(e) {
    const { targetId: t } = e;
    return me(() => He.get(`${this._managerApiBaseUrl}/get_device_version`, { params: { target_id: t, provider: this._provider } })).map((n) => n.data).chain((n) => this.mapDeviceVersionDto(n)).mapLeft((n) => new ss(n));
  }
  getFirmwareVersion(e) {
    const { deviceId: t, version: n } = e;
    return me(() => He.get(`${this._managerApiBaseUrl}/get_firmware_version`, { params: { device_version: t, version_name: n, provider: this._provider } })).map((i) => i.data).chain((i) => this.mapFinalFirmwareDto(i)).mapLeft((i) => new ss(i));
  }
  getFirmwareVersionById(e) {
    return me(() => He.get(`${this._managerApiBaseUrl}/firmware_final_versions/${e}`, {})).map((t) => t.data).chain((t) => this.mapFinalFirmwareDto(t)).mapLeft((t) => new ss(t));
  }
  getOsuFirmwareVersion(e) {
    const { deviceId: t, version: n } = e;
    return me(() => He.get(`${this._managerApiBaseUrl}/get_osu_version`, { params: { device_version: t, version_name: n, provider: this._provider } })).map((i) => i.data).chain((i) => this.mapOsuFirmwareDto(i)).mapLeft((i) => new ss(i));
  }
  getLatestFirmwareVersion(e) {
    const t = "34.27.0", { currentFinalFirmwareId: n, deviceId: i } = e;
    return me(() => He.get(`${this._managerApiBaseUrl}/get_latest_firmware`, { params: { current_se_firmware_final_version: n, device_version: i, provider: this._provider, salt: this._firmwareDistributionSalt, livecommonversion: t } })).map((s) => s.data).chain((s) => this.mapLatestFirmwareDto(s)).mapLeft((s) => new ss(s));
  }
  getAppsByHash(e) {
    const { hashes: t } = e;
    return me(() => He.post(`${this._managerApiBaseUrl}/v2/apps/hash`, t)).map((n) => n.data).chain((n) => this.mapNullableApplicationDtoToApplication(n)).mapLeft((n) => new ss(n));
  }
  getLanguagePackages(e) {
    const { deviceId: t, currentFinalFirmwareId: n } = e;
    return me(() => He.get(`${this._managerApiBaseUrl}/language-packages`, { params: { device_version: t, current_se_firmware_final_version: n } })).map((i) => i.data).chain((i) => this.mapLanguagesDtoToLanguages(i)).mapLeft((i) => new ss(i));
  }
  mapAppTypeDtoToAppType(e) {
    if (e === null) return null;
    switch (e) {
      case fp.currency:
        return hp.currency;
      case fp.plugin:
        return hp.plugin;
      case fp.tool:
        return hp.tool;
      case fp.swap:
        return hp.swap;
    }
  }
  mapApplicationDtoToApplication(e) {
    return me(() => Promise.resolve(e.map((t) => this.mapApplicationDto(t))));
  }
  mapNullableApplicationDtoToApplication(e) {
    return me(() => Promise.resolve(e.map((t) => t === null ? null : this.mapApplicationDto(t))));
  }
  mapApplicationDto(e) {
    if (typeof e != "object" || typeof e.versionId != "number" || typeof e.versionName != "string" || e.versionDisplayName !== null && typeof e.versionDisplayName != "string" || typeof e.version != "string" || e.currencyId !== null && typeof e.currencyId != "string" || e.description !== null && typeof e.description != "string" || e.applicationType !== null && typeof e.applicationType != "string" || typeof e.dateModified != "string" || e.icon !== null && typeof e.icon != "string" || e.authorName !== null && typeof e.authorName != "string" || e.supportURL !== null && typeof e.supportURL != "string" || e.contactURL !== null && typeof e.contactURL != "string" || e.sourceURL !== null && typeof e.sourceURL != "string" || e.compatibleWallets !== null && typeof e.compatibleWallets != "string" || typeof e.hash != "string" || typeof e.perso != "string" || typeof e.firmware != "string" || typeof e.firmwareKey != "string" || typeof e.delete != "string" || typeof e.deleteKey != "string" || e.bytes !== null && typeof e.bytes != "number" || e.warning !== null && typeof e.warning != "string" || typeof e.isDevTools != "boolean" || e.category !== null && typeof e.category != "number" || e.parent !== null && typeof e.parent != "number" || e.parentName !== null && typeof e.parentName != "string") throw new Error(`Incomplete application: ${JSON.stringify(e)}`);
    const { applicationType: t, hash: n, perso: i, firmware: s, firmwareKey: o, delete: a, deleteKey: c, ...u } = e;
    return { ...u, hash: n, perso: i, firmware: s, firmwareKey: o, delete: a, deleteKey: c, applicationType: this.mapAppTypeDtoToAppType(t) };
  }
  mapMcuDtoToMcu(e) {
    return me(() => Promise.resolve(e.map((t) => {
      if (typeof t != "object" || typeof t.id != "number" || typeof t.name != "string") throw new Error(`Incomplete MCU version: ${JSON.stringify(t)}`);
      return { id: t.id, name: t.name };
    })));
  }
  mapDeviceVersionDto(e) {
    return me(() => {
      if (typeof e != "object" || typeof e.id != "number") throw new Error(`Incomplete device version: ${JSON.stringify(e)}`);
      const t = { id: e.id };
      return Promise.resolve(t);
    });
  }
  mapFinalFirmwareDto(e) {
    return me(() => {
      if (typeof e != "object" || typeof e.id != "number" || typeof e.version != "string" || typeof e.perso != "string" || e.firmware !== null && typeof e.firmware != "string" || e.firmware_key !== null && typeof e.firmware_key != "string" || e.hash !== null && typeof e.hash != "string" || e.bytes !== null && typeof e.bytes != "number" || !Array.isArray(e.mcu_versions)) throw new Error(`Incomplete final firmware: ${JSON.stringify(e)}`);
      const t = { id: e.id, version: e.version, perso: e.perso, firmware: e.firmware, firmwareKey: e.firmware_key, hash: e.hash, bytes: e.bytes, mcuVersions: e.mcu_versions };
      return Promise.resolve(t);
    });
  }
  mapLatestFirmwareDto(e) {
    return me(() => {
      if (e.result !== "success" || !e.se_firmware_osu_version) throw new Error(`Latest firmware could not be retrieved: ${e.result}`);
      const t = e.se_firmware_osu_version;
      return Promise.resolve(t);
    }).chain((t) => this.mapOsuFirmwareDto(t));
  }
  mapOsuFirmwareDto(e) {
    return me(() => {
      if (typeof e != "object" || typeof e.id != "number" || typeof e.perso != "string" || typeof e.firmware != "string" || typeof e.firmware_key != "string" || e.hash !== null && typeof e.hash != "string" || typeof e.next_se_firmware_final_version != "number") throw new Error(`Incomplete latest firmware: ${JSON.stringify(e)}`);
      const t = { id: e.id, perso: e.perso, firmware: e.firmware, firmwareKey: e.firmware_key, hash: e.hash, nextFinalFirmware: e.next_se_firmware_final_version };
      return Promise.resolve(t);
    });
  }
  mapLanguagesDtoToLanguages(e) {
    return me(() => Promise.resolve(e.map((t) => this.mapLanguageDto(t))));
  }
  mapLanguageDto(e) {
    if (typeof e != "object" || typeof e.language != "string" || typeof e.languagePackageVersionId != "number" || typeof e.version != "string" || typeof e.language_package_id != "number" || typeof e.apdu_install_url != "string" || typeof e.apdu_uninstall_url != "string" || typeof e.bytes != "number" || typeof e.date_creation != "string" || typeof e.date_last_modified != "string") throw new Error(`Incomplete language version: ${JSON.stringify(e)}`);
    return { language: e.language, languagePackageVersionId: e.languagePackageVersionId, version: e.version, languagePackageId: e.language_package_id, apduInstallUrl: e.apdu_install_url, apduUninstallUrl: e.apdu_uninstall_url, bytes: e.bytes, dateCreation: e.date_creation, dateLastModified: e.date_last_modified };
  }
};
sR = wre([le(), _re(0, X(f0.DmkConfig))], sR);
var Sre = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Ere = (r, e) => (t, n) => e(t, n, r);
let oR = class {
  constructor(e) {
    this.dataSource = e;
  }
  getAppList(e) {
    const t = { targetId: e.targetId.toString(), firmwareVersionName: e.seVersion };
    return this.dataSource.getAppList(t);
  }
  getDeviceVersion(e) {
    const t = { targetId: e.targetId.toString() };
    return this.dataSource.getDeviceVersion(t);
  }
  getFirmwareVersion(e, t) {
    const n = { version: e.seVersion, deviceId: t.id };
    return this.dataSource.getFirmwareVersion(n);
  }
  getOsuFirmwareVersion(e, t) {
    const n = { version: e.seVersion, deviceId: t.id };
    return this.dataSource.getOsuFirmwareVersion(n);
  }
  getLatestFirmwareVersion(e, t) {
    const n = { currentFinalFirmwareId: e.id, deviceId: t.id };
    return this.dataSource.getLatestFirmwareVersion(n);
  }
  getNextFirmwareVersion(e) {
    return this.dataSource.getFirmwareVersionById(e.nextFinalFirmware);
  }
  getLanguagePackages(e, t) {
    const n = { deviceId: e.id, currentFinalFirmwareId: t.id };
    return this.dataSource.getLanguagePackages(n);
  }
  getMcuList() {
    return this.dataSource.getMcuList();
  }
  getAppsByHash(e) {
    const t = { hashes: e };
    return me(async ({ fromPromise: n, throwE: i }) => {
      if (t.hashes.length === 0) return [];
      try {
        return await n(this.dataSource.getAppsByHash(t));
      } catch (s) {
        return s instanceof ss ? i(s) : i(new ss(s));
      }
    });
  }
};
oR = Sre([le(), Ere(0, X(f0.ManagerApiDataSource))], oR);
var xre = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, aR = (r, e) => (t, n) => e(t, n, r);
let cR = class {
  constructor(e, t) {
    this.sessionService = e, this.managerApiDataSource = t;
  }
  execute(e) {
    for (const t of this.sessionService.getDeviceSessions()) {
      const n = t.getDeviceSessionState();
      n.sessionStateType !== mo.Connected && t.setDeviceSessionState({ ...n, firmwareUpdateContext: void 0, installedApps: [], appsUpdates: void 0, catalog: void 0 });
    }
    this.managerApiDataSource.setProvider(e);
  }
};
cR = xre([le(), aR(0, X(oi.DeviceSessionService)), aR(1, X(f0.ManagerApiDataSource))], cR);
var Are = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Ire = (r, e) => (t, n) => e(t, n, r);
let uR = class {
  constructor({ webSocketUrl: e }) {
    h(this, "webSocketBaseUrl");
    this.webSocketBaseUrl = e;
  }
  genuineCheck(e) {
    const t = ji.format({ pathname: `${this.webSocketBaseUrl}/genuine`, query: e });
    return this._connectWebSocket(t);
  }
  installApp(e) {
    const t = ji.format({ pathname: `${this.webSocketBaseUrl}/install`, query: e });
    return this._connectWebSocket(t);
  }
  listInstalledApps(e) {
    const t = ji.format({ pathname: `${this.webSocketBaseUrl}/apps/list`, query: e });
    return this._connectWebSocket(t);
  }
  uninstallApp(e) {
    const t = ji.format({ pathname: `${this.webSocketBaseUrl}/install`, query: e });
    return this._connectWebSocket(t);
  }
  updateFirmware(e) {
    const t = ji.format({ pathname: `${this.webSocketBaseUrl}/install`, query: e });
    return this._connectWebSocket(t);
  }
  updateMcu(e) {
    const t = ji.format({ pathname: `${this.webSocketBaseUrl}/mcu`, query: e });
    return this._connectWebSocket(t);
  }
  _connectWebSocket(e) {
    try {
      return te(new D1(e));
    } catch (t) {
      return N(new yte(t));
    }
  }
};
uR = Are([le(), Ire(0, X(kC.DmkConfig))], uR);
var Cre = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Dre = (r, e) => (t, n) => e(t, n, r);
let lR = class {
  constructor(e) {
    this.dataSource = e;
  }
  genuineCheck(e, t) {
    const n = { targetId: e.targetId.toString(), perso: t.perso };
    return this.dataSource.genuineCheck(n);
  }
  installApp(e, t) {
    const { perso: n, firmware: i, firmwareKey: s, hash: o } = t, a = { targetId: e.targetId.toString(), perso: n, firmware: i, firmwareKey: s, hash: o };
    return this.dataSource.installApp(a);
  }
  listInstalledApps(e, t) {
    const n = { targetId: e.targetId.toString(), perso: t.perso };
    return this.dataSource.listInstalledApps(n);
  }
  uninstallApp(e, t) {
    const { perso: n, delete: i, deleteKey: s, hash: o } = t, a = { targetId: e.targetId.toString(), perso: n, firmware: i, firmwareKey: s, hash: o };
    return this.dataSource.uninstallApp(a);
  }
  updateFirmware(e, t) {
    const n = { targetId: e.targetId.toString(), perso: t.perso, firmware: t.firmware, firmwareKey: t.firmwareKey };
    return this.dataSource.updateFirmware(n);
  }
  updateMcu(e, t) {
    const n = { targetId: e.targetId.toString(), version: t.version };
    return this.dataSource.updateMcu(n);
  }
};
lR = Cre([le(), Dre(0, X(kC.SecureChannelDataSource))], lR);
var Tre = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, dR = (r, e) => (t, n) => e(t, n, r);
let hR = class {
  constructor(e, t) {
    h(this, "_sessionService");
    h(this, "_logger");
    this._sessionService = e, this._logger = t("SendApduUseCase");
  }
  async execute({ sessionId: e, apdu: t, abortTimeout: n, triggersDisconnection: i }) {
    return this._sessionService.getDeviceSessionById(e).caseOf({ Right: async (s) => (await s.sendApdu(t, { abortTimeout: n, triggersDisconnection: i })).caseOf({ Right: (o) => o, Left: (o) => {
      throw this._logger.error("Error sending APDU", { data: { sessionId: e, apdu: t, error: o } }), o;
    } }), Left: (s) => {
      throw this._logger.error("Error getting deviceSession", { data: { error: s } }), s;
    } });
  }
};
hR = Tre([le(), dR(0, X(oi.DeviceSessionService)), dR(1, X(sn.LoggerPublisherServiceFactory))], hR);
var kre = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, $l = (r, e) => (t, n) => e(t, n, r);
let fR = class {
  constructor(e, t, n, i, s, o) {
    h(this, "_transports", /* @__PURE__ */ new Map());
    h(this, "_logger");
    if (this._config = t, this._loggerModuleFactory = n, this._deviceModelDataSource = i, this._apduSenderServiceFactory = s, this._apduReceiverServiceFactory = o, this._logger = n("TransportService"), e.length === 0) throw this._logger.warn("No transports provided, please check your configuration"), new ute("No transports provided, please check your configuration");
    for (const a of e) {
      const c = this.addTransport(a);
      if (c.isLeft()) throw c.extract();
    }
  }
  addTransport(e) {
    const t = e({ deviceModelDataSource: this._deviceModelDataSource, loggerServiceFactory: this._loggerModuleFactory, config: this._config, apduSenderServiceFactory: this._apduSenderServiceFactory, apduReceiverServiceFactory: this._apduReceiverServiceFactory });
    return this.addTransportInternal(t);
  }
  addTransportInternal(e) {
    return this.getTransport(e.getIdentifier()).isJust() ? (this._logger.warn(`Transport ${e.getIdentifier()} already exists, please check your configuration`), N(new ate(`Transport ${e.getIdentifier()} already exists, please check your configuration`))) : (this._transports.set(e.getIdentifier(), e), te(void 0));
  }
  getTransport(e) {
    return pe.fromNullable(this._transports.get(e));
  }
  getAllTransports() {
    return Array.from(this._transports.values());
  }
  closeConnection(e) {
    this.getTransport(e.transport).map((t) => t.disconnect({ connectedDevice: e }));
  }
};
fR = kre([le(), $l(0, X(_c.TransportsInput)), $l(1, X(_c.DmkConfig)), $l(2, X(sn.LoggerPublisherServiceFactory)), $l(3, X(Wte.DeviceModelDataSource)), $l(4, X(oi.ApduSenderServiceFactory)), $l(5, X(oi.ApduReceiverServiceFactory))], fR);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const $C = /* @__PURE__ */ BigInt(0), $x = /* @__PURE__ */ BigInt(1);
function Yy(r, e = "") {
  if (typeof r != "boolean") {
    const t = e && `"${e}"`;
    throw new Error(t + "expected boolean, got type=" + typeof r);
  }
  return r;
}
function Qc(r, e, t = "") {
  const n = d0(r), i = r == null ? void 0 : r.length, s = e !== void 0;
  if (!n || s && i !== e) {
    const o = t && `"${t}" `, a = s ? ` of length ${e}` : "", c = n ? `length=${i}` : `type=${typeof r}`;
    throw new Error(o + "expected Uint8Array" + a + ", got " + c);
  }
  return r;
}
function Lm(r) {
  const e = r.toString(16);
  return e.length & 1 ? "0" + e : e;
}
function i6(r) {
  if (typeof r != "string")
    throw new Error("hex string expected, got " + typeof r);
  return r === "" ? $C : BigInt("0x" + r);
}
function p0(r) {
  return i6(yd(r));
}
function s6(r) {
  return yl(r), i6(yd(Uint8Array.from(r).reverse()));
}
function RC(r, e) {
  return Jy(r.toString(16).padStart(e * 2, "0"));
}
function o6(r, e) {
  return RC(r, e).reverse();
}
function Kn(r, e, t) {
  let n;
  if (typeof e == "string")
    try {
      n = Jy(e);
    } catch (i) {
      throw new Error(r + " must be hex string or Uint8Array, cause: " + i);
    }
  else if (d0(e))
    n = Uint8Array.from(e);
  else
    throw new Error(r + " must be hex string or Uint8Array");
  return n.length, n;
}
const v_ = (r) => typeof r == "bigint" && $C <= r;
function Ore(r, e, t) {
  return v_(r) && v_(e) && v_(t) && e <= r && r < t;
}
function $re(r, e, t, n) {
  if (!Ore(e, t, n))
    throw new Error("expected valid " + r + ": " + t + " <= n < " + n + ", got " + e);
}
function a6(r) {
  let e;
  for (e = 0; r > $C; r >>= $x, e += 1)
    ;
  return e;
}
const Yg = (r) => ($x << BigInt(r)) - $x;
function Rre(r, e, t) {
  if (typeof r != "number" || r < 2)
    throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2)
    throw new Error("qByteLen must be a number");
  if (typeof t != "function")
    throw new Error("hmacFn must be a function");
  const n = (p) => new Uint8Array(p), i = (p) => Uint8Array.of(p);
  let s = n(r), o = n(r), a = 0;
  const c = () => {
    s.fill(1), o.fill(0), a = 0;
  }, u = (...p) => t(o, s, ...p), l = (p = n(0)) => {
    o = u(i(0), p), s = u(), p.length !== 0 && (o = u(i(1), p), s = u());
  }, d = () => {
    if (a++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let p = 0;
    const y = [];
    for (; p < e; ) {
      s = u();
      const g = s.slice();
      y.push(g), p += s.length;
    }
    return Pa(...y);
  };
  return (p, y) => {
    c(), l(p);
    let g;
    for (; !(g = y(d())); )
      l();
    return c(), g;
  };
}
function PC(r, e, t = {}) {
  if (!r || typeof r != "object")
    throw new Error("expected valid options object");
  function n(i, s, o) {
    const a = r[i];
    if (o && a === void 0)
      return;
    const c = typeof a;
    if (c !== s || a === null)
      throw new Error(`param "${i}" is invalid: expected ${s}, got ${c}`);
  }
  Object.entries(e).forEach(([i, s]) => n(i, s, !1)), Object.entries(t).forEach(([i, s]) => n(i, s, !0));
}
function pR(r) {
  const e = /* @__PURE__ */ new WeakMap();
  return (t, ...n) => {
    const i = e.get(t);
    if (i !== void 0)
      return i;
    const s = r(t, ...n);
    return e.set(t, s), s;
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ei = BigInt(0), On = BigInt(1), eu = /* @__PURE__ */ BigInt(2), c6 = /* @__PURE__ */ BigInt(3), u6 = /* @__PURE__ */ BigInt(4), l6 = /* @__PURE__ */ BigInt(5), Pre = /* @__PURE__ */ BigInt(7), d6 = /* @__PURE__ */ BigInt(8), Nre = /* @__PURE__ */ BigInt(9), h6 = /* @__PURE__ */ BigInt(16);
function cs(r, e) {
  const t = r % e;
  return t >= ei ? t : e + t;
}
function Ni(r, e, t) {
  let n = r;
  for (; e-- > ei; )
    n *= n, n %= t;
  return n;
}
function gR(r, e) {
  if (r === ei)
    throw new Error("invert: expected non-zero number");
  if (e <= ei)
    throw new Error("invert: expected positive modulus, got " + e);
  let t = cs(r, e), n = e, i = ei, s = On;
  for (; t !== ei; ) {
    const a = n / t, c = n % t, u = i - s * a;
    n = t, t = c, i = s, s = u;
  }
  if (n !== On)
    throw new Error("invert: does not exist");
  return cs(i, e);
}
function NC(r, e, t) {
  if (!r.eql(r.sqr(e), t))
    throw new Error("Cannot find square root");
}
function f6(r, e) {
  const t = (r.ORDER + On) / u6, n = r.pow(e, t);
  return NC(r, n, e), n;
}
function Bre(r, e) {
  const t = (r.ORDER - l6) / d6, n = r.mul(e, eu), i = r.pow(n, t), s = r.mul(e, i), o = r.mul(r.mul(s, eu), i), a = r.mul(s, r.sub(o, r.ONE));
  return NC(r, a, e), a;
}
function Lre(r) {
  const e = Cc(r), t = p6(r), n = t(e, e.neg(e.ONE)), i = t(e, n), s = t(e, e.neg(n)), o = (r + Pre) / h6;
  return (a, c) => {
    let u = a.pow(c, o), l = a.mul(u, n);
    const d = a.mul(u, i), f = a.mul(u, s), p = a.eql(a.sqr(l), c), y = a.eql(a.sqr(d), c);
    u = a.cmov(u, l, p), l = a.cmov(f, d, y);
    const g = a.eql(a.sqr(l), c), v = a.cmov(u, l, g);
    return NC(a, v, c), v;
  };
}
function p6(r) {
  if (r < c6)
    throw new Error("sqrt is not defined for small field");
  let e = r - On, t = 0;
  for (; e % eu === ei; )
    e /= eu, t++;
  let n = eu;
  const i = Cc(r);
  for (; mR(i, n) === 1; )
    if (n++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  if (t === 1)
    return f6;
  let s = i.pow(n, e);
  const o = (e + On) / eu;
  return function(c, u) {
    if (c.is0(u))
      return u;
    if (mR(c, u) !== 1)
      throw new Error("Cannot find square root");
    let l = t, d = c.mul(c.ONE, s), f = c.pow(u, e), p = c.pow(u, o);
    for (; !c.eql(f, c.ONE); ) {
      if (c.is0(f))
        return c.ZERO;
      let y = 1, g = c.sqr(f);
      for (; !c.eql(g, c.ONE); )
        if (y++, g = c.sqr(g), y === l)
          throw new Error("Cannot find square root");
      const v = On << BigInt(l - y - 1), _ = c.pow(d, v);
      l = y, d = c.sqr(_), f = c.mul(f, d), p = c.mul(p, _);
    }
    return p;
  };
}
function Ure(r) {
  return r % u6 === c6 ? f6 : r % d6 === l6 ? Bre : r % h6 === Nre ? Lre(r) : p6(r);
}
const Fre = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function Mre(r) {
  const e = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "number",
    BITS: "number"
  }, t = Fre.reduce((n, i) => (n[i] = "function", n), e);
  return PC(r, t), r;
}
function Vre(r, e, t) {
  if (t < ei)
    throw new Error("invalid exponent, negatives unsupported");
  if (t === ei)
    return r.ONE;
  if (t === On)
    return e;
  let n = r.ONE, i = e;
  for (; t > ei; )
    t & On && (n = r.mul(n, i)), i = r.sqr(i), t >>= On;
  return n;
}
function g6(r, e, t = !1) {
  const n = new Array(e.length).fill(t ? r.ZERO : void 0), i = e.reduce((o, a, c) => r.is0(a) ? o : (n[c] = o, r.mul(o, a)), r.ONE), s = r.inv(i);
  return e.reduceRight((o, a, c) => r.is0(a) ? o : (n[c] = r.mul(o, n[c]), r.mul(o, a)), s), n;
}
function mR(r, e) {
  const t = (r.ORDER - On) / eu, n = r.pow(e, t), i = r.eql(n, r.ONE), s = r.eql(n, r.ZERO), o = r.eql(n, r.neg(r.ONE));
  if (!i && !s && !o)
    throw new Error("invalid Legendre symbol result");
  return i ? 1 : s ? 0 : -1;
}
function m6(r, e) {
  e !== void 0 && xx(e);
  const t = e !== void 0 ? e : r.toString(2).length, n = Math.ceil(t / 8);
  return { nBitLength: t, nByteLength: n };
}
function Cc(r, e, t = !1, n = {}) {
  if (r <= ei)
    throw new Error("invalid field: expected ORDER > 0, got " + r);
  let i, s, o = !1, a;
  if (typeof e == "object" && e != null) {
    if (n.sqrt || t)
      throw new Error("cannot specify opts in two arguments");
    const f = e;
    f.BITS && (i = f.BITS), f.sqrt && (s = f.sqrt), typeof f.isLE == "boolean" && (t = f.isLE), typeof f.modFromBytes == "boolean" && (o = f.modFromBytes), a = f.allowedLengths;
  } else
    typeof e == "number" && (i = e), n.sqrt && (s = n.sqrt);
  const { nBitLength: c, nByteLength: u } = m6(r, i);
  if (u > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let l;
  const d = Object.freeze({
    ORDER: r,
    isLE: t,
    BITS: c,
    BYTES: u,
    MASK: Yg(c),
    ZERO: ei,
    ONE: On,
    allowedLengths: a,
    create: (f) => cs(f, r),
    isValid: (f) => {
      if (typeof f != "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof f);
      return ei <= f && f < r;
    },
    is0: (f) => f === ei,
    // is valid and invertible
    isValidNot0: (f) => !d.is0(f) && d.isValid(f),
    isOdd: (f) => (f & On) === On,
    neg: (f) => cs(-f, r),
    eql: (f, p) => f === p,
    sqr: (f) => cs(f * f, r),
    add: (f, p) => cs(f + p, r),
    sub: (f, p) => cs(f - p, r),
    mul: (f, p) => cs(f * p, r),
    pow: (f, p) => Vre(d, f, p),
    div: (f, p) => cs(f * gR(p, r), r),
    // Same as above, but doesn't normalize
    sqrN: (f) => f * f,
    addN: (f, p) => f + p,
    subN: (f, p) => f - p,
    mulN: (f, p) => f * p,
    inv: (f) => gR(f, r),
    sqrt: s || ((f) => (l || (l = Ure(r)), l(d, f))),
    toBytes: (f) => t ? o6(f, u) : RC(f, u),
    fromBytes: (f, p = !0) => {
      if (a) {
        if (!a.includes(f.length) || f.length > u)
          throw new Error("Field.fromBytes: expected " + a + " bytes, got " + f.length);
        const g = new Uint8Array(u);
        g.set(f, t ? 0 : g.length - f.length), f = g;
      }
      if (f.length !== u)
        throw new Error("Field.fromBytes: expected " + u + " bytes, got " + f.length);
      let y = t ? s6(f) : p0(f);
      if (o && (y = cs(y, r)), !p && !d.isValid(y))
        throw new Error("invalid field element: outside of range 0..ORDER");
      return y;
    },
    // TODO: we don't need it here, move out to separate fn
    invertBatch: (f) => g6(d, f),
    // We can't move this out because Fp6, Fp12 implement it
    // and it's unclear what to return in there.
    cmov: (f, p, y) => y ? p : f
  });
  return Object.freeze(d);
}
function y6(r) {
  if (typeof r != "bigint")
    throw new Error("field order must be bigint");
  const e = r.toString(2).length;
  return Math.ceil(e / 8);
}
function v6(r) {
  const e = y6(r);
  return e + Math.ceil(e / 2);
}
function zre(r, e, t = !1) {
  const n = r.length, i = y6(e), s = v6(e);
  if (n < 16 || n < s || n > 1024)
    throw new Error("expected " + s + "-1024 bytes of input, got " + n);
  const o = t ? s6(r) : p0(r), a = cs(o, e - On) + On;
  return t ? o6(a, i) : RC(a, i);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const qh = BigInt(0), tu = BigInt(1);
function Qy(r, e) {
  const t = e.negate();
  return r ? t : e;
}
function b_(r, e) {
  const t = g6(r.Fp, e.map((n) => n.Z));
  return e.map((n, i) => r.fromAffine(n.toAffine(t[i])));
}
function b6(r, e) {
  if (!Number.isSafeInteger(r) || r <= 0 || r > e)
    throw new Error("invalid window size, expected [1.." + e + "], got W=" + r);
}
function w_(r, e) {
  b6(r, e);
  const t = Math.ceil(e / r) + 1, n = 2 ** (r - 1), i = 2 ** r, s = Yg(r), o = BigInt(r);
  return { windows: t, windowSize: n, mask: s, maxNumber: i, shiftBy: o };
}
function yR(r, e, t) {
  const { windowSize: n, mask: i, maxNumber: s, shiftBy: o } = t;
  let a = Number(r & i), c = r >> o;
  a > n && (a -= s, c += tu);
  const u = e * n, l = u + Math.abs(a) - 1, d = a === 0, f = a < 0, p = e % 2 !== 0;
  return { nextN: c, offset: l, isZero: d, isNeg: f, isNegF: p, offsetF: u };
}
function jre(r, e) {
  if (!Array.isArray(r))
    throw new Error("array expected");
  r.forEach((t, n) => {
    if (!(t instanceof e))
      throw new Error("invalid point at index " + n);
  });
}
function Hre(r, e) {
  if (!Array.isArray(r))
    throw new Error("array of scalars expected");
  r.forEach((t, n) => {
    if (!e.isValid(t))
      throw new Error("invalid scalar at index " + n);
  });
}
const __ = /* @__PURE__ */ new WeakMap(), w6 = /* @__PURE__ */ new WeakMap();
function S_(r) {
  return w6.get(r) || 1;
}
function vR(r) {
  if (r !== qh)
    throw new Error("invalid wNAF");
}
class Gre {
  // Parametrized with a given Point class (not individual point)
  constructor(e, t) {
    this.BASE = e.BASE, this.ZERO = e.ZERO, this.Fn = e.Fn, this.bits = t;
  }
  // non-const time multiplication ladder
  _unsafeLadder(e, t, n = this.ZERO) {
    let i = e;
    for (; t > qh; )
      t & tu && (n = n.add(i)), i = i.double(), t >>= tu;
    return n;
  }
  /**
   * Creates a wNAF precomputation window. Used for caching.
   * Default window size is set by `utils.precompute()` and is equal to 8.
   * Number of precomputed points depends on the curve size:
   * 2^(1) * (Math.ceil( / ) + 1), where:
   * -  is the window size
   * -  is the bitlength of the curve order.
   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
   * @param point Point instance
   * @param W window size
   * @returns precomputed point tables flattened to a single array
   */
  precomputeWindow(e, t) {
    const { windows: n, windowSize: i } = w_(t, this.bits), s = [];
    let o = e, a = o;
    for (let c = 0; c < n; c++) {
      a = o, s.push(a);
      for (let u = 1; u < i; u++)
        a = a.add(o), s.push(a);
      o = a.double();
    }
    return s;
  }
  /**
   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
   * More compact implementation:
   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
   * @returns real and fake (for const-time) points
   */
  wNAF(e, t, n) {
    if (!this.Fn.isValid(n))
      throw new Error("invalid scalar");
    let i = this.ZERO, s = this.BASE;
    const o = w_(e, this.bits);
    for (let a = 0; a < o.windows; a++) {
      const { nextN: c, offset: u, isZero: l, isNeg: d, isNegF: f, offsetF: p } = yR(n, a, o);
      n = c, l ? s = s.add(Qy(f, t[p])) : i = i.add(Qy(d, t[u]));
    }
    return vR(n), { p: i, f: s };
  }
  /**
   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
   * @param acc accumulator point to add result of multiplication
   * @returns point
   */
  wNAFUnsafe(e, t, n, i = this.ZERO) {
    const s = w_(e, this.bits);
    for (let o = 0; o < s.windows && n !== qh; o++) {
      const { nextN: a, offset: c, isZero: u, isNeg: l } = yR(n, o, s);
      if (n = a, !u) {
        const d = t[c];
        i = i.add(l ? d.negate() : d);
      }
    }
    return vR(n), i;
  }
  getPrecomputes(e, t, n) {
    let i = __.get(t);
    return i || (i = this.precomputeWindow(t, e), e !== 1 && (typeof n == "function" && (i = n(i)), __.set(t, i))), i;
  }
  cached(e, t, n) {
    const i = S_(e);
    return this.wNAF(i, this.getPrecomputes(i, e, n), t);
  }
  unsafe(e, t, n, i) {
    const s = S_(e);
    return s === 1 ? this._unsafeLadder(e, t, i) : this.wNAFUnsafe(s, this.getPrecomputes(s, e, n), t, i);
  }
  // We calculate precomputes for elliptic curve point multiplication
  // using windowed method. This specifies window size and
  // stores precomputed values. Usually only base point would be precomputed.
  createCache(e, t) {
    b6(t, this.bits), w6.set(e, t), __.delete(e);
  }
  hasCache(e) {
    return S_(e) !== 1;
  }
}
function Kre(r, e, t, n) {
  let i = e, s = r.ZERO, o = r.ZERO;
  for (; t > qh || n > qh; )
    t & tu && (s = s.add(i)), n & tu && (o = o.add(i)), i = i.double(), t >>= tu, n >>= tu;
  return { p1: s, p2: o };
}
function qre(r, e, t, n) {
  jre(t, r), Hre(n, e);
  const i = t.length, s = n.length;
  if (i !== s)
    throw new Error("arrays of points and scalars must have equal length");
  const o = r.ZERO, a = a6(BigInt(i));
  let c = 1;
  a > 12 ? c = a - 3 : a > 4 ? c = a - 2 : a > 0 && (c = 2);
  const u = Yg(c), l = new Array(Number(u) + 1).fill(o), d = Math.floor((e.BITS - 1) / c) * c;
  let f = o;
  for (let p = d; p >= 0; p -= c) {
    l.fill(o);
    for (let g = 0; g < s; g++) {
      const v = n[g], _ = Number(v >> BigInt(p) & u);
      l[_] = l[_].add(t[g]);
    }
    let y = o;
    for (let g = l.length - 1, v = o; g > 0; g--)
      v = v.add(l[g]), y = y.add(v);
    if (f = f.add(y), p !== 0)
      for (let g = 0; g < c; g++)
        f = f.double();
  }
  return f;
}
function bR(r, e, t) {
  if (e) {
    if (e.ORDER !== r)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return Mre(e), e;
  } else
    return Cc(r, { isLE: t });
}
function Wre(r, e, t = {}, n) {
  if (n === void 0 && (n = r === "edwards"), !e || typeof e != "object")
    throw new Error(`expected valid ${r} CURVE object`);
  for (const c of ["p", "n", "h"]) {
    const u = e[c];
    if (!(typeof u == "bigint" && u > qh))
      throw new Error(`CURVE.${c} must be positive bigint`);
  }
  const i = bR(e.p, t.Fp, n), s = bR(e.n, t.Fn, n), a = ["Gx", "Gy", "a", "b"];
  for (const c of a)
    if (!i.isValid(e[c]))
      throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);
  return e = Object.freeze(Object.assign({}, e)), { CURVE: e, Fp: i, Fn: s };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const wR = (r, e) => (r + (r >= 0 ? e : -e) / _6) / e;
function Zre(r, e, t) {
  const [[n, i], [s, o]] = e, a = wR(o * r, t), c = wR(-i * r, t);
  let u = r - a * n - c * s, l = -a * i - c * o;
  const d = u < ia, f = l < ia;
  d && (u = -u), f && (l = -l);
  const p = Yg(Math.ceil(a6(t) / 2)) + vd;
  if (u < ia || u >= p || l < ia || l >= p)
    throw new Error("splitScalar (endomorphism): failed, k=" + r);
  return { k1neg: d, k1: u, k2neg: f, k2: l };
}
function Rx(r) {
  if (!["compact", "recovered", "der"].includes(r))
    throw new Error('Signature format must be "compact", "recovered", or "der"');
  return r;
}
function E_(r, e) {
  const t = {};
  for (let n of Object.keys(e))
    t[n] = r[n] === void 0 ? e[n] : r[n];
  return Yy(t.lowS, "lowS"), Yy(t.prehash, "prehash"), t.format !== void 0 && Rx(t.format), t;
}
class Jre extends Error {
  constructor(e = "") {
    super(e);
  }
}
const Mo = {
  // asn.1 DER encoding utils
  Err: Jre,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (r, e) => {
      const { Err: t } = Mo;
      if (r < 0 || r > 256)
        throw new t("tlv.encode: wrong tag");
      if (e.length & 1)
        throw new t("tlv.encode: unpadded data");
      const n = e.length / 2, i = Lm(n);
      if (i.length / 2 & 128)
        throw new t("tlv.encode: long form length too big");
      const s = n > 127 ? Lm(i.length / 2 | 128) : "";
      return Lm(r) + s + i + e;
    },
    // v - value, l - left bytes (unparsed)
    decode(r, e) {
      const { Err: t } = Mo;
      let n = 0;
      if (r < 0 || r > 256)
        throw new t("tlv.encode: wrong tag");
      if (e.length < 2 || e[n++] !== r)
        throw new t("tlv.decode: wrong tlv");
      const i = e[n++], s = !!(i & 128);
      let o = 0;
      if (!s)
        o = i;
      else {
        const c = i & 127;
        if (!c)
          throw new t("tlv.decode(long): indefinite length not supported");
        if (c > 4)
          throw new t("tlv.decode(long): byte length is too big");
        const u = e.subarray(n, n + c);
        if (u.length !== c)
          throw new t("tlv.decode: length bytes not complete");
        if (u[0] === 0)
          throw new t("tlv.decode(long): zero leftmost byte");
        for (const l of u)
          o = o << 8 | l;
        if (n += c, o < 128)
          throw new t("tlv.decode(long): not minimal encoding");
      }
      const a = e.subarray(n, n + o);
      if (a.length !== o)
        throw new t("tlv.decode: wrong value length");
      return { v: a, l: e.subarray(n + o) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(r) {
      const { Err: e } = Mo;
      if (r < ia)
        throw new e("integer: negative integers are not allowed");
      let t = Lm(r);
      if (Number.parseInt(t[0], 16) & 8 && (t = "00" + t), t.length & 1)
        throw new e("unexpected DER parsing assertion: unpadded hex");
      return t;
    },
    decode(r) {
      const { Err: e } = Mo;
      if (r[0] & 128)
        throw new e("invalid signature integer: negative");
      if (r[0] === 0 && !(r[1] & 128))
        throw new e("invalid signature integer: unnecessary leading zero");
      return p0(r);
    }
  },
  toSig(r) {
    const { Err: e, _int: t, _tlv: n } = Mo, i = Kn("signature", r), { v: s, l: o } = n.decode(48, i);
    if (o.length)
      throw new e("invalid signature: left bytes after parsing");
    const { v: a, l: c } = n.decode(2, s), { v: u, l } = n.decode(2, c);
    if (l.length)
      throw new e("invalid signature: left bytes after parsing");
    return { r: t.decode(a), s: t.decode(u) };
  },
  hexFromSig(r) {
    const { _tlv: e, _int: t } = Mo, n = e.encode(2, t.encode(r.r)), i = e.encode(2, t.encode(r.s)), s = n + i;
    return e.encode(48, s);
  }
}, ia = BigInt(0), vd = BigInt(1), _6 = BigInt(2), Um = BigInt(3), Xre = BigInt(4);
function od(r, e) {
  const { BYTES: t } = r;
  let n;
  if (typeof e == "bigint")
    n = e;
  else {
    let i = Kn("private key", e);
    try {
      n = r.fromBytes(i);
    } catch {
      throw new Error(`invalid private key: expected ui8a of size ${t}, got ${typeof e}`);
    }
  }
  if (!r.isValidNot0(n))
    throw new Error("invalid private key: out of range [1..N-1]");
  return n;
}
function Yre(r, e = {}) {
  const t = Wre("weierstrass", r, e), { Fp: n, Fn: i } = t;
  let s = t.CURVE;
  const { h: o, n: a } = s;
  PC(e, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object",
    wrapPrivateKey: "boolean"
  });
  const { endo: c } = e;
  if (c && (!n.is0(s.a) || typeof c.beta != "bigint" || !Array.isArray(c.basises)))
    throw new Error('invalid endo: expected "beta": bigint and "basises": array');
  const u = E6(n, i);
  function l() {
    if (!n.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function d(q, J, O) {
    const { x, y: k } = J.toAffine(), B = n.toBytes(x);
    if (Yy(O, "isCompressed"), O) {
      l();
      const A = !n.isOdd(k);
      return Pa(S6(A), B);
    } else
      return Pa(Uint8Array.of(4), B, n.toBytes(k));
  }
  function f(q) {
    Qc(q, void 0, "Point");
    const { publicKey: J, publicKeyUncompressed: O } = u, x = q.length, k = q[0], B = q.subarray(1);
    if (x === J && (k === 2 || k === 3)) {
      const A = n.fromBytes(B);
      if (!n.isValid(A))
        throw new Error("bad point: is not on curve, wrong x");
      const K = g(A);
      let F;
      try {
        F = n.sqrt(K);
      } catch (z) {
        const ce = z instanceof Error ? ": " + z.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + ce);
      }
      l();
      const j = n.isOdd(F);
      return (k & 1) === 1 !== j && (F = n.neg(F)), { x: A, y: F };
    } else if (x === O && k === 4) {
      const A = n.BYTES, K = n.fromBytes(B.subarray(0, A)), F = n.fromBytes(B.subarray(A, A * 2));
      if (!v(K, F))
        throw new Error("bad point: is not on curve");
      return { x: K, y: F };
    } else
      throw new Error(`bad point: got length ${x}, expected compressed=${J} or uncompressed=${O}`);
  }
  const p = e.toBytes || d, y = e.fromBytes || f;
  function g(q) {
    const J = n.sqr(q), O = n.mul(J, q);
    return n.add(n.add(O, n.mul(q, s.a)), s.b);
  }
  function v(q, J) {
    const O = n.sqr(J), x = g(q);
    return n.eql(O, x);
  }
  if (!v(s.Gx, s.Gy))
    throw new Error("bad curve params: generator point");
  const _ = n.mul(n.pow(s.a, Um), Xre), w = n.mul(n.sqr(s.b), BigInt(27));
  if (n.is0(n.add(_, w)))
    throw new Error("bad curve params: a or b");
  function E(q, J, O = !1) {
    if (!n.isValid(J) || O && n.is0(J))
      throw new Error(`bad point coordinate ${q}`);
    return J;
  }
  function I(q) {
    if (!(q instanceof P))
      throw new Error("ProjectivePoint expected");
  }
  function S(q) {
    if (!c || !c.basises)
      throw new Error("no endo");
    return Zre(q, c.basises, i.ORDER);
  }
  const T = pR((q, J) => {
    const { X: O, Y: x, Z: k } = q;
    if (n.eql(k, n.ONE))
      return { x: O, y: x };
    const B = q.is0();
    J == null && (J = B ? n.ONE : n.inv(k));
    const A = n.mul(O, J), K = n.mul(x, J), F = n.mul(k, J);
    if (B)
      return { x: n.ZERO, y: n.ZERO };
    if (!n.eql(F, n.ONE))
      throw new Error("invZ was invalid");
    return { x: A, y: K };
  }), b = pR((q) => {
    if (q.is0()) {
      if (e.allowInfinityPoint && !n.is0(q.Y))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: J, y: O } = q.toAffine();
    if (!n.isValid(J) || !n.isValid(O))
      throw new Error("bad point: x or y not field elements");
    if (!v(J, O))
      throw new Error("bad point: equation left != right");
    if (!q.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return !0;
  });
  function C(q, J, O, x, k) {
    return O = new P(n.mul(O.X, q), O.Y, O.Z), J = Qy(x, J), O = Qy(k, O), J.add(O);
  }
  class P {
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(J, O, x) {
      this.X = E("x", J), this.Y = E("y", O, !0), this.Z = E("z", x), Object.freeze(this);
    }
    static CURVE() {
      return s;
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(J) {
      const { x: O, y: x } = J || {};
      if (!J || !n.isValid(O) || !n.isValid(x))
        throw new Error("invalid affine point");
      if (J instanceof P)
        throw new Error("projective point not allowed");
      return n.is0(O) && n.is0(x) ? P.ZERO : new P(O, x, n.ONE);
    }
    static fromBytes(J) {
      const O = P.fromAffine(y(Qc(J, void 0, "point")));
      return O.assertValidity(), O;
    }
    static fromHex(J) {
      return P.fromBytes(Kn("pointHex", J));
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(J = 8, O = !0) {
      return Y.createCache(this, J), O || this.multiply(Um), this;
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      b(this);
    }
    hasEvenY() {
      const { y: J } = this.toAffine();
      if (!n.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !n.isOdd(J);
    }
    /** Compare one point to another. */
    equals(J) {
      I(J);
      const { X: O, Y: x, Z: k } = this, { X: B, Y: A, Z: K } = J, F = n.eql(n.mul(O, K), n.mul(B, k)), j = n.eql(n.mul(x, K), n.mul(A, k));
      return F && j;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new P(this.X, n.neg(this.Y), this.Z);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: J, b: O } = s, x = n.mul(O, Um), { X: k, Y: B, Z: A } = this;
      let K = n.ZERO, F = n.ZERO, j = n.ZERO, re = n.mul(k, k), z = n.mul(B, B), ce = n.mul(A, A), he = n.mul(k, B);
      return he = n.add(he, he), j = n.mul(k, A), j = n.add(j, j), K = n.mul(J, j), F = n.mul(x, ce), F = n.add(K, F), K = n.sub(z, F), F = n.add(z, F), F = n.mul(K, F), K = n.mul(he, K), j = n.mul(x, j), ce = n.mul(J, ce), he = n.sub(re, ce), he = n.mul(J, he), he = n.add(he, j), j = n.add(re, re), re = n.add(j, re), re = n.add(re, ce), re = n.mul(re, he), F = n.add(F, re), ce = n.mul(B, A), ce = n.add(ce, ce), re = n.mul(ce, he), K = n.sub(K, re), j = n.mul(ce, z), j = n.add(j, j), j = n.add(j, j), new P(K, F, j);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(J) {
      I(J);
      const { X: O, Y: x, Z: k } = this, { X: B, Y: A, Z: K } = J;
      let F = n.ZERO, j = n.ZERO, re = n.ZERO;
      const z = s.a, ce = n.mul(s.b, Um);
      let he = n.mul(O, B), de = n.mul(x, A), xe = n.mul(k, K), Ze = n.add(O, x), Se = n.add(B, A);
      Ze = n.mul(Ze, Se), Se = n.add(he, de), Ze = n.sub(Ze, Se), Se = n.add(O, k);
      let be = n.add(B, K);
      return Se = n.mul(Se, be), be = n.add(he, xe), Se = n.sub(Se, be), be = n.add(x, k), F = n.add(A, K), be = n.mul(be, F), F = n.add(de, xe), be = n.sub(be, F), re = n.mul(z, Se), F = n.mul(ce, xe), re = n.add(F, re), F = n.sub(de, re), re = n.add(de, re), j = n.mul(F, re), de = n.add(he, he), de = n.add(de, he), xe = n.mul(z, xe), Se = n.mul(ce, Se), de = n.add(de, xe), xe = n.sub(he, xe), xe = n.mul(z, xe), Se = n.add(Se, xe), he = n.mul(de, Se), j = n.add(j, he), he = n.mul(be, Se), F = n.mul(Ze, F), F = n.sub(F, he), he = n.mul(Ze, de), re = n.mul(be, re), re = n.add(re, he), new P(F, j, re);
    }
    subtract(J) {
      return this.add(J.negate());
    }
    is0() {
      return this.equals(P.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(J) {
      const { endo: O } = e;
      if (!i.isValidNot0(J))
        throw new Error("invalid scalar: out of range");
      let x, k;
      const B = (A) => Y.cached(this, A, (K) => b_(P, K));
      if (O) {
        const { k1neg: A, k1: K, k2neg: F, k2: j } = S(J), { p: re, f: z } = B(K), { p: ce, f: he } = B(j);
        k = z.add(he), x = C(O.beta, re, ce, A, F);
      } else {
        const { p: A, f: K } = B(J);
        x = A, k = K;
      }
      return b_(P, [x, k])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed secret key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(J) {
      const { endo: O } = e, x = this;
      if (!i.isValid(J))
        throw new Error("invalid scalar: out of range");
      if (J === ia || x.is0())
        return P.ZERO;
      if (J === vd)
        return x;
      if (Y.hasCache(this))
        return this.multiply(J);
      if (O) {
        const { k1neg: k, k1: B, k2neg: A, k2: K } = S(J), { p1: F, p2: j } = Kre(P, x, B, K);
        return C(O.beta, F, j, k, A);
      } else
        return Y.unsafe(x, J);
    }
    multiplyAndAddUnsafe(J, O, x) {
      const k = this.multiplyUnsafe(O).add(J.multiplyUnsafe(x));
      return k.is0() ? void 0 : k;
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(J) {
      return T(this, J);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree: J } = e;
      return o === vd ? !0 : J ? J(P, this) : Y.unsafe(this, a).is0();
    }
    clearCofactor() {
      const { clearCofactor: J } = e;
      return o === vd ? this : J ? J(P, this) : this.multiplyUnsafe(o);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(o).is0();
    }
    toBytes(J = !0) {
      return Yy(J, "isCompressed"), this.assertValidity(), p(P, this, J);
    }
    toHex(J = !0) {
      return yd(this.toBytes(J));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
    // TODO: remove
    get px() {
      return this.X;
    }
    get py() {
      return this.X;
    }
    get pz() {
      return this.Z;
    }
    toRawBytes(J = !0) {
      return this.toBytes(J);
    }
    _setWindowSize(J) {
      this.precompute(J);
    }
    static normalizeZ(J) {
      return b_(P, J);
    }
    static msm(J, O) {
      return qre(P, i, J, O);
    }
    static fromPrivateKey(J) {
      return P.BASE.multiply(od(i, J));
    }
  }
  P.BASE = new P(s.Gx, s.Gy, n.ONE), P.ZERO = new P(n.ZERO, n.ONE, n.ZERO), P.Fp = n, P.Fn = i;
  const Z = i.BITS, Y = new Gre(P, e.endo ? Math.ceil(Z / 2) : Z);
  return P.BASE.precompute(8), P;
}
function S6(r) {
  return Uint8Array.of(r ? 2 : 3);
}
function E6(r, e) {
  return {
    secretKey: e.BYTES,
    publicKey: 1 + r.BYTES,
    publicKeyUncompressed: 1 + 2 * r.BYTES,
    publicKeyHasPrefix: !0,
    signature: 2 * e.BYTES
  };
}
function Qre(r, e = {}) {
  const { Fn: t } = r, n = e.randomBytes || z3, i = Object.assign(E6(r.Fp, t), { seed: v6(t.ORDER) });
  function s(p) {
    try {
      return !!od(t, p);
    } catch {
      return !1;
    }
  }
  function o(p, y) {
    const { publicKey: g, publicKeyUncompressed: v } = i;
    try {
      const _ = p.length;
      return y === !0 && _ !== g || y === !1 && _ !== v ? !1 : !!r.fromBytes(p);
    } catch {
      return !1;
    }
  }
  function a(p = n(i.seed)) {
    return zre(Qc(p, i.seed, "seed"), t.ORDER);
  }
  function c(p, y = !0) {
    return r.BASE.multiply(od(t, p)).toBytes(y);
  }
  function u(p) {
    const y = a(p);
    return { secretKey: y, publicKey: c(y) };
  }
  function l(p) {
    if (typeof p == "bigint")
      return !1;
    if (p instanceof r)
      return !0;
    const { secretKey: y, publicKey: g, publicKeyUncompressed: v } = i;
    if (t.allowedLengths || y === g)
      return;
    const _ = Kn("key", p).length;
    return _ === g || _ === v;
  }
  function d(p, y, g = !0) {
    if (l(p) === !0)
      throw new Error("first arg must be private key");
    if (l(y) === !1)
      throw new Error("second arg must be public key");
    const v = od(t, p);
    return r.fromHex(y).multiply(v).toBytes(g);
  }
  return Object.freeze({ getPublicKey: c, getSharedSecret: d, keygen: u, Point: r, utils: {
    isValidSecretKey: s,
    isValidPublicKey: o,
    randomSecretKey: a,
    // TODO: remove
    isValidPrivateKey: s,
    randomPrivateKey: a,
    normPrivateKeyToScalar: (p) => od(t, p),
    precompute(p = 8, y = r.BASE) {
      return y.precompute(p, !1);
    }
  }, lengths: i });
}
function ene(r, e, t = {}) {
  F3(e), PC(t, {}, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  });
  const n = t.randomBytes || z3, i = t.hmac || ((O, ...x) => EC(e, O, Pa(...x))), { Fp: s, Fn: o } = r, { ORDER: a, BITS: c } = o, { keygen: u, getPublicKey: l, getSharedSecret: d, utils: f, lengths: p } = Qre(r, t), y = {
    prehash: !1,
    lowS: typeof t.lowS == "boolean" ? t.lowS : !1,
    format: void 0,
    //'compact' as ECDSASigFormat,
    extraEntropy: !1
  }, g = "compact";
  function v(O) {
    const x = a >> vd;
    return O > x;
  }
  function _(O, x) {
    if (!o.isValidNot0(x))
      throw new Error(`invalid signature ${O}: out of range 1..Point.Fn.ORDER`);
    return x;
  }
  function w(O, x) {
    Rx(x);
    const k = p.signature, B = x === "compact" ? k : x === "recovered" ? k + 1 : void 0;
    return Qc(O, B, `${x} signature`);
  }
  class E {
    constructor(x, k, B) {
      this.r = _("r", x), this.s = _("s", k), B != null && (this.recovery = B), Object.freeze(this);
    }
    static fromBytes(x, k = g) {
      w(x, k);
      let B;
      if (k === "der") {
        const { r: j, s: re } = Mo.toSig(Qc(x));
        return new E(j, re);
      }
      k === "recovered" && (B = x[0], k = "compact", x = x.subarray(1));
      const A = o.BYTES, K = x.subarray(0, A), F = x.subarray(A, A * 2);
      return new E(o.fromBytes(K), o.fromBytes(F), B);
    }
    static fromHex(x, k) {
      return this.fromBytes(Jy(x), k);
    }
    addRecoveryBit(x) {
      return new E(this.r, this.s, x);
    }
    recoverPublicKey(x) {
      const k = s.ORDER, { r: B, s: A, recovery: K } = this;
      if (K == null || ![0, 1, 2, 3].includes(K))
        throw new Error("recovery id invalid");
      if (a * _6 < k && K > 1)
        throw new Error("recovery id is ambiguous for h>1 curve");
      const j = K === 2 || K === 3 ? B + a : B;
      if (!s.isValid(j))
        throw new Error("recovery id 2 or 3 invalid");
      const re = s.toBytes(j), z = r.fromBytes(Pa(S6((K & 1) === 0), re)), ce = o.inv(j), he = S(Kn("msgHash", x)), de = o.create(-he * ce), xe = o.create(A * ce), Ze = r.BASE.multiplyUnsafe(de).add(z.multiplyUnsafe(xe));
      if (Ze.is0())
        throw new Error("point at infinify");
      return Ze.assertValidity(), Ze;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return v(this.s);
    }
    toBytes(x = g) {
      if (Rx(x), x === "der")
        return Jy(Mo.hexFromSig(this));
      const k = o.toBytes(this.r), B = o.toBytes(this.s);
      if (x === "recovered") {
        if (this.recovery == null)
          throw new Error("recovery bit must be present");
        return Pa(Uint8Array.of(this.recovery), k, B);
      }
      return Pa(k, B);
    }
    toHex(x) {
      return yd(this.toBytes(x));
    }
    // TODO: remove
    assertValidity() {
    }
    static fromCompact(x) {
      return E.fromBytes(Kn("sig", x), "compact");
    }
    static fromDER(x) {
      return E.fromBytes(Kn("sig", x), "der");
    }
    normalizeS() {
      return this.hasHighS() ? new E(this.r, o.neg(this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return yd(this.toBytes("der"));
    }
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return yd(this.toBytes("compact"));
    }
  }
  const I = t.bits2int || function(x) {
    if (x.length > 8192)
      throw new Error("input is too large");
    const k = p0(x), B = x.length * 8 - c;
    return B > 0 ? k >> BigInt(B) : k;
  }, S = t.bits2int_modN || function(x) {
    return o.create(I(x));
  }, T = Yg(c);
  function b(O) {
    return $re("num < 2^" + c, O, ia, T), o.toBytes(O);
  }
  function C(O, x) {
    return Qc(O, void 0, "message"), x ? Qc(e(O), void 0, "prehashed message") : O;
  }
  function P(O, x, k) {
    if (["recovered", "canonical"].some((de) => de in k))
      throw new Error("sign() legacy options not supported");
    const { lowS: B, prehash: A, extraEntropy: K } = E_(k, y);
    O = C(O, A);
    const F = S(O), j = od(o, x), re = [b(j), b(F)];
    if (K != null && K !== !1) {
      const de = K === !0 ? n(p.secretKey) : K;
      re.push(Kn("extraEntropy", de));
    }
    const z = Pa(...re), ce = F;
    function he(de) {
      const xe = I(de);
      if (!o.isValidNot0(xe))
        return;
      const Ze = o.inv(xe), Se = r.BASE.multiply(xe).toAffine(), be = o.create(Se.x);
      if (be === ia)
        return;
      const Ie = o.create(Ze * o.create(ce + be * j));
      if (Ie === ia)
        return;
      let Re = (Se.x === be ? 0 : 2) | Number(Se.y & vd), Ue = Ie;
      return B && v(Ie) && (Ue = o.neg(Ie), Re ^= 1), new E(be, Ue, Re);
    }
    return { seed: z, k2sig: he };
  }
  function Z(O, x, k = {}) {
    O = Kn("message", O);
    const { seed: B, k2sig: A } = P(O, x, k);
    return Rre(e.outputLen, o.BYTES, i)(B, A);
  }
  function Y(O) {
    let x;
    const k = typeof O == "string" || d0(O), B = !k && O !== null && typeof O == "object" && typeof O.r == "bigint" && typeof O.s == "bigint";
    if (!k && !B)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    if (B)
      x = new E(O.r, O.s);
    else if (k) {
      try {
        x = E.fromBytes(Kn("sig", O), "der");
      } catch (A) {
        if (!(A instanceof Mo.Err))
          throw A;
      }
      if (!x)
        try {
          x = E.fromBytes(Kn("sig", O), "compact");
        } catch {
          return !1;
        }
    }
    return x || !1;
  }
  function q(O, x, k, B = {}) {
    const { lowS: A, prehash: K, format: F } = E_(B, y);
    if (k = Kn("publicKey", k), x = C(Kn("message", x), K), "strict" in B)
      throw new Error("options.strict was renamed to lowS");
    const j = F === void 0 ? Y(O) : E.fromBytes(Kn("sig", O), F);
    if (j === !1)
      return !1;
    try {
      const re = r.fromBytes(k);
      if (A && j.hasHighS())
        return !1;
      const { r: z, s: ce } = j, he = S(x), de = o.inv(ce), xe = o.create(he * de), Ze = o.create(z * de), Se = r.BASE.multiplyUnsafe(xe).add(re.multiplyUnsafe(Ze));
      return Se.is0() ? !1 : o.create(Se.x) === z;
    } catch {
      return !1;
    }
  }
  function J(O, x, k = {}) {
    const { prehash: B } = E_(k, y);
    return x = C(x, B), E.fromBytes(O, "recovered").recoverPublicKey(x).toBytes();
  }
  return Object.freeze({
    keygen: u,
    getPublicKey: l,
    getSharedSecret: d,
    utils: f,
    lengths: p,
    Point: r,
    sign: Z,
    verify: q,
    recoverPublicKey: J,
    Signature: E,
    hash: e
  });
}
function tne(r) {
  const e = {
    a: r.a,
    b: r.b,
    p: r.Fp.ORDER,
    n: r.n,
    h: r.h,
    Gx: r.Gx,
    Gy: r.Gy
  }, t = r.Fp;
  let n = r.allowedPrivateKeyLengths ? Array.from(new Set(r.allowedPrivateKeyLengths.map((o) => Math.ceil(o / 2)))) : void 0;
  const i = Cc(e.n, {
    BITS: r.nBitLength,
    allowedLengths: n,
    modFromBytes: r.wrapPrivateKey
  }), s = {
    Fp: t,
    Fn: i,
    allowInfinityPoint: r.allowInfinityPoint,
    endo: r.endo,
    isTorsionFree: r.isTorsionFree,
    clearCofactor: r.clearCofactor,
    fromBytes: r.fromBytes,
    toBytes: r.toBytes
  };
  return { CURVE: e, curveOpts: s };
}
function rne(r) {
  const { CURVE: e, curveOpts: t } = tne(r), n = {
    hmac: r.hmac,
    randomBytes: r.randomBytes,
    lowS: r.lowS,
    bits2int: r.bits2int,
    bits2int_modN: r.bits2int_modN
  };
  return { CURVE: e, curveOpts: t, hash: r.hash, ecdsaOpts: n };
}
function nne(r, e) {
  const t = e.Point;
  return Object.assign({}, e, {
    ProjectivePoint: t,
    CURVE: Object.assign({}, r, m6(t.Fn.ORDER, t.Fn.BITS))
  });
}
function ine(r) {
  const { CURVE: e, curveOpts: t, hash: n, ecdsaOpts: i } = rne(r), s = Yre(e, t), o = ene(s, n, i);
  return nne(r, o);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function g0(r, e) {
  const t = (n) => ine({ ...r, hash: n });
  return { ...t(e), create: t };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const x6 = {
  p: BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"),
  n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),
  h: BigInt(1),
  a: BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"),
  b: BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),
  Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),
  Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5")
}, A6 = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"),
  n: BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),
  h: BigInt(1),
  a: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"),
  b: BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),
  Gx: BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),
  Gy: BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f")
}, I6 = {
  p: BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
  n: BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),
  h: BigInt(1),
  a: BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"),
  b: BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"),
  Gx: BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),
  Gy: BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650")
}, sne = Cc(x6.p), one = Cc(A6.p), ane = Cc(I6.p), cne = g0({ ...x6, Fp: sne, lowS: !1 }, xC);
g0({ ...A6, Fp: one, lowS: !1 }, $ee);
g0({ ...I6, Fp: ane, lowS: !1, allowedPrivateKeyLengths: [130, 131, 132] }, Oee);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const BC = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
}, une = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  basises: [
    [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
    [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
  ]
}, _R = /* @__PURE__ */ BigInt(2);
function lne(r) {
  const e = BC.p, t = BigInt(3), n = BigInt(6), i = BigInt(11), s = BigInt(22), o = BigInt(23), a = BigInt(44), c = BigInt(88), u = r * r * r % e, l = u * u * r % e, d = Ni(l, t, e) * l % e, f = Ni(d, t, e) * l % e, p = Ni(f, _R, e) * u % e, y = Ni(p, i, e) * p % e, g = Ni(y, s, e) * y % e, v = Ni(g, a, e) * g % e, _ = Ni(v, c, e) * v % e, w = Ni(_, a, e) * g % e, E = Ni(w, t, e) * l % e, I = Ni(E, o, e) * y % e, S = Ni(I, n, e) * u % e, T = Ni(S, _R, e);
  if (!Px.eql(Px.sqr(T), r))
    throw new Error("Cannot find square root");
  return T;
}
const Px = Cc(BC.p, { sqrt: lne }), dne = g0({ ...BC, Fp: Px, lowS: !0, endo: une }, xC);
let SR = class pp {
  constructor(e, t, n) {
    this.curve = e, this.privateKey = t, this.publicKey = n;
  }
  static async generate(e) {
    const t = pp.getCurve(e), { secretKey: n, publicKey: i } = t.keygen();
    return new pp(t, n, i);
  }
  static from(e, t) {
    const n = pp.getCurve(t), i = n.getPublicKey(e);
    return new pp(n, e, i);
  }
  static getCurve(e) {
    switch (e) {
      case Eo.K256:
        return dne;
      case Eo.P256:
        return cne;
      default:
        throw new Error(`Unsupported curve ${e}`);
    }
  }
  get id() {
    return ar(this.privateKey);
  }
  async sign(e, t) {
    return this.curve.sign(e, this.privateKey).toBytes(t === Ky.DER ? "der" : "compact");
  }
  async verify(e, t, n) {
    return this.curve.verify(t, e, this.publicKey, { format: n === Ky.DER ? "der" : "compact" });
  }
  async deriveSharedSecret(e, t = !0) {
    return this.curve.getSharedSecret(this.privateKey, e, t);
  }
  getPublicKey() {
    return this.publicKey;
  }
  getPublicKeyToHex() {
    return ar(this.publicKey, !1);
  }
}, m0 = class {
  randomBytes(e) {
    return U3(e);
  }
  hash(e, t) {
    switch (t) {
      case Hh.SHA256:
        return Ax(e);
      default:
        throw new Error("Unsupported hash algorithm", t);
    }
  }
  hmac(e, t, n) {
    switch (n) {
      case Hh.SHA256:
        return EC(Ax, e, t);
      default:
        throw new Error("Unsupported hash algorithm", n);
    }
  }
  async createKeyPair(e) {
    return await SR.generate(e);
  }
  importKeyPair(e, t) {
    return SR.from(e, t);
  }
  async createSymmetricKey(e) {
    return await g$.generate(e);
  }
  importSymmetricKey(e, t) {
    return g$.from(e, t);
  }
};
var Wh = ((r) => (r.PROD = "prod", r.STAGING = "staging", r))(Wh || {});
let LC = class extends ts {
  constructor(t) {
    super(t.message);
    h(this, "_tag", "LedgerKeyringProtocolError");
    h(this, "message");
    h(this, "status");
    this.err = t, this.status = t.status, this.message = t.message;
  }
}, hne = class extends ts {
  constructor(t = null, n = `Current keypair is not a member of the trustchain${t ? ` ${t}` : ""}.`) {
    super(n);
    h(this, "_tag", "LedgerKeyringProtocolError");
    this.trustchainId = t, this.message = n;
  }
}, fne = class extends ts {
  constructor(t = "The trustchain is outdated.") {
    super(t);
    h(this, "_tag", "LedgerKeyringProtocolError");
    this.message = t;
  }
}, C6 = class extends ts {
  constructor(t = "Ledger Sync must be initialized from Ledger Live with this device.") {
    super(t);
    h(this, "_tag", "LedgerKeyringProtocolError");
    this.message = t;
  }
}, vr = class extends ts {
  constructor(t) {
    super(t);
    h(this, "_tag", "LedgerKeyringProtocolError");
    this.err = t;
  }
}, Pu = class extends ts {
  constructor(t) {
    super(t);
    h(this, "_tag", "LedgerKeyringProtocolError");
    this.err = t;
  }
}, ER = class extends ts {
  constructor(t) {
    const n = t && typeof t == "object" && "type" in t && typeof t.type == "number" && `0x${t.type.toString(16).padStart(2, "0")}`;
    let i = "Unsupported command";
    n && (i += `: ${n}`);
    super(i);
    h(this, "_tag", "LedgerKeyringProtocolError");
    h(this, "message");
    this.command = t, this.message = i;
  }
}, Gi = class extends ts {
  constructor(t) {
    super(t);
    h(this, "_tag", "LedgerKeyringProtocolError");
    this.message = t;
  }
};
var gp = ((r) => (r[r.OWNER = 4294967295] = "OWNER", r[r.CAN_ENCRYPT = 1] = "CAN_ENCRYPT", r[r.CAN_DERIVE = 2] = "CAN_DERIVE", r[r.CAN_ADD_BLOCK = 4] = "CAN_ADD_BLOCK", r))(gp || {});
const D6 = { AppBinding: Symbol.for("AppBinder") }, lc = { Dmk: Symbol.for("Dmk"), ApplicationId: Symbol.for("ApplicationId"), CryptoService: Symbol.for("CryptoService") }, ev = { LKRPDataSource: Symbol.for("LKRPDataSource"), BaseUrl: Symbol.for("BaseUrl") };
let Ao = class {
  constructor(e, t, n = mf.isSuccessResponse) {
    this._errors = e, this._errorFactory = t, this._isSuccessResponse = n;
  }
  getError(e) {
    const t = new Bn(e).encodeToHexaString(e.statusCode);
    if (DC(t, this._errors)) return nt({ error: this._errorFactory({ ...this._errors[t], errorCode: t }) });
    if (!this._isSuccessResponse(e)) return nt({ error: Xg.handle(e) });
  }
};
const Io = { 6985: { message: "Rejected by user" }, "6a86": { message: "Either P1 or P2 is incorrect" }, "6a87": { message: "Lc or minimum APDU length is incorrect" }, "6d00": { message: "No command exists with INS" }, "6e00": { message: "Bad CLA used for this application" }, b000: { message: "Wrong response length (buffer size problem)" }, b007: { message: "Security issue with bad state" }, b008: { message: "Signature of raw transaction failed" }, b009: { message: "Security issue lead by an invalid Command stream" }, b00a: { message: "Invalid or unsupported command stream format" }, b00b: { message: "Trusted properties buffer can't receive all data" }, b00c: { message: "Attempt to perform an action on a closed stream" } };
let pne = class extends CC {
  constructor(e) {
    super({ tag: "LedgerKeyringProtocolError", ...e });
  }
};
const Co = (r) => new pne(r);
let gne = class {
  constructor() {
    h(this, "errorHelper", new Ao(Io, Co));
  }
  getApdu() {
    const e = { cla: 224, ins: 3, p1: 0, p2: 0 };
    return new li(e).build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefaultLazy(() => {
      const t = new Bn(e).encodeToString(e.data);
      return nt(t ? { data: { version: t } } : { error: new Yn("Version is missing") });
    });
  }
}, T6 = class {
  run(e, t) {
    return e.getChallenge().chain((n) => t.run(n)).chain((n) => e.authenticate(n)).run();
  }
}, k6 = class {
  async run(e, t, n) {
    return (await n.getPublishedKey(e, t)).map((i) => i.privateKey).toEither(new Gi("There is no encryption key for the current member in the application stream."));
  }
};
function or(r) {
  const e = {};
  for (const [t, n] of Object.entries(r)) {
    const i = typeof n == "function" && n.length === 0 && n();
    if (!Pt.isEither(i)) Object.assign(e, { [t]: n });
    else {
      if (i.isLeft()) return i;
      Object.assign(e, { [t]: i.extract() });
    }
  }
  return te(e);
}
function mne(r) {
  return me.sequence(Object.entries(r).map(([e, t]) => t && typeof t == "object" && t.constructor === me ? t.map((n) => [e, n]) : me.liftEither(te([e, t])))).map(Object.fromEntries);
}
let yne = class {
  constructor(e) {
    h(this, "errorHelper", new Ao(Io, Co));
    this.args = e;
  }
  getApdu() {
    const { challengeTLV: e } = this.args, t = { cla: 224, ins: 5, p1: 0, p2: 0 };
    return new li(t).addHexaStringToData(e).build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefaultLazy(() => {
      const t = new Bn(e), n = (i, s) => pe.fromNullable(i).toEither(new Yn(s));
      return or({ credential: () => or({ version: () => n(t.extract8BitUInt(), "Version is missing"), curveId: () => n(t.extract8BitUInt(), "Curve ID is missing"), signAlgorithm: () => n(t.extract8BitUInt(), "Sign algorithm is missing"), publicKey: () => n(t.extract8BitUInt(), "Public key length is missing").chain((i) => n(t.extractFieldByLength(i), "Public key is missing")).map((i) => ar(i, !1)) }), signature: () => n(t.extract8BitUInt(), "Signature length is missing").chain((i) => n(t.extractFieldByLength(i), "Signature is missing")).map((i) => ar(i, !1)), attestation: () => or({ id: () => n(t.extractFieldByLength(1), "Attestation Id is missing"), version: () => n(t.extract8BitUInt(), "Attestation version is missing"), curveId: () => n(t.extract8BitUInt(), "Attestation curve ID is missing"), signAlgorithm: () => n(t.extract8BitUInt(), "Attestation sign algorithm is missing"), publicKey: () => n(t.extract8BitUInt(), "Attestation key length is missing").chain((i) => n(t.extractFieldByLength(i), "Attestation key is missing")), signature: () => n(t.extract8BitUInt(), "Attestation signature length is missing").chain((i) => n(t.extractFieldByLength(i), "Attestation signature is missing")) }).map((i) => ar(Uint8Array.from([...i.id, i.version, i.curveId, i.signAlgorithm, i.publicKey.length, ...i.publicKey, i.signature.length, ...i.signature]), !1)) }).caseOf({ Left: (i) => nt({ error: i }), Right: (i) => nt({ data: i }) });
    });
  }
}, vne = class {
  constructor(e) {
    this.api = e;
  }
  async run(e) {
    const t = await this.api.sendCommand(new yne({ challengeTLV: e.tlv }));
    if (t.status !== ho.Success) return N(t.error);
    const { credential: n, signature: i, attestation: s } = t.data;
    return te({ challenge: e.json, signature: { credential: n, signature: i, attestation: s } });
  }
};
function Bt(r, e) {
  return pe.fromNullable(r).toEither(new Pu(e));
}
function In(r) {
  return LV(({ enqueue: e, ...t }) => {
    r(t).ifLeft((n) => {
      e.assign({ _internalState: N(n) }), e.raise({ type: "error" });
    }).ifRight(({ raise: n, assign: i }) => {
      if (t.context._internalState.isLeft()) return e.raise({ type: "error" });
      i && e.assign({ _internalState: t.context._internalState.map((s) => ({ ...s, ...i })) }), e.raise({ type: n });
    });
  });
}
var Nx = ((r) => (r.AddMember = "lkrp-add-member", r))(Nx || {}), mp = ((r) => (r.Initialize = "lkrp-init-transaction", r.ParseStream = "lkrp-parse-stream", r.AddMember = "lkrp-add-member", r))(mp || {});
let bne = class {
  constructor(e) {
    h(this, "errorHelper", new Ao(Io, Co));
    this.args = e;
  }
  getApdu() {
    const { publicKey: e } = this.args;
    return new li({ cla: 224, ins: 6, p1: 0, p2: 0 }).addBufferToData(e).build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefaultLazy(() => new Bn(e).getUnparsedRemainingLength() !== 0 ? nt({ error: new Yn("Unexpected response data for SetTrustedMemberCommand") }) : nt({ data: void 0 }));
  }
}, wne = class {
  constructor(e, t) {
    this.api = e, this.cryptoService = t;
  }
  async run() {
    const e = await this.cryptoService.createKeyPair(Eo.K256), t = await this.api.sendCommand(new bne({ publicKey: e.getPublicKey() }));
    return t.status !== ho.Success ? N(t.error) : te(e);
  }
}, _ne = class {
  constructor(e) {
    h(this, "errorHelper", new Ao(Io, Co));
    this.args = e;
  }
  getApdu() {
    const { signature: e } = this.args;
    return new li({ cla: 224, ins: 8, p1: 2, p2: 0 }).addBufferToData(e).build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefaultLazy(() => {
      const t = new Bn(e), n = t.getUnparsedRemainingLength(), i = t.extractFieldByLength(n);
      return nt(i ? { data: i } : { error: new Yn("No data returned by ParseBlockSignatureCommand") });
    });
  }
}, Sne = class {
  constructor(e) {
    h(this, "errorHelper", new Ao(Io, Co));
    this.args = e;
  }
  getApdu() {
    const { command: e, outputTrustedParam: t = !0 } = this.args;
    return new li({ cla: 224, ins: 8, p1: 1, p2: t ? 1 : 0 }).addBufferToData(e).build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefaultLazy(() => {
      const t = new Bn(e), n = t.getUnparsedRemainingLength(), i = t.extractFieldByLength(n);
      return nt(i ? { data: i } : { error: new Yn("No data returned by ParseSingleCommand") });
    });
  }
}, Ene = class {
  constructor(e) {
    h(this, "errorHelper", new Ao(Io, Co));
    this.args = e;
  }
  getApdu() {
    const { header: e } = this.args;
    return new li({ cla: 224, ins: 8, p1: 0, p2: 0 }).addBufferToData(e).build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefaultLazy(() => {
      const t = new Bn(e), n = t.getUnparsedRemainingLength(), i = t.extractFieldByLength(n);
      return nt(i ? { data: i } : { error: new Yn("No data returned by parseBlockHeader") });
    });
  }
};
var qe = ((r) => (r[r.Null = 0] = "Null", r[r.Int = 1] = "Int", r[r.Hash = 2] = "Hash", r[r.Signature = 3] = "Signature", r[r.String = 4] = "String", r[r.Bytes = 5] = "Bytes", r[r.PublicKey = 6] = "PublicKey", r))(qe || {}), pt = ((r) => (r[r.Seed = 16] = "Seed", r[r.AddMember = 17] = "AddMember", r[r.PublishKey = 18] = "PublishKey", r[r.CloseStream = 19] = "CloseStream", r[r.EditMember = 20] = "EditMember", r[r.Derive = 21] = "Derive", r))(pt || {});
const x_ = 128;
var $a = ((r) => (r[r.IV = 0] = "IV", r[r.ISSUER = 1 | x_] = "ISSUER", r[r.XPRIV = 2 | x_] = "XPRIV", r[r.EPHEMERAL_PUBLIC_KEY = 3] = "EPHEMERAL_PUBLIC_KEY", r[r.COMMAND_IV = 4] = "COMMAND_IV", r[r.GROUPKEY = 5] = "GROUPKEY", r[r.NEW_MEMBER = 6 | x_] = "NEW_MEMBER", r))($a || {});
let xne = class {
  constructor(e) {
    h(this, "errorHelper", new Ao(Io, Co));
    this.args = e;
  }
  getApdu() {
    const { iv: e, memberTlv: t } = this.args;
    return new li({ cla: 224, ins: 9, p1: 0, p2: 0 }).add8BitUIntToData($a.IV).add8BitUIntToData(e.length).addBufferToData(e).addBufferToData(t).build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefaultLazy(() => new Bn(e).getUnparsedRemainingLength() !== 0 ? nt({ error: new Yn("Unexpected response data for SetTrustedMemberCommand") }) : nt({ data: void 0 }));
  }
}, Bx = class {
  constructor(e) {
    h(this, "parser");
    h(this, "iv", null);
    h(this, "encryptedProps", null);
    this.bytes = e, this.parser = new h0(e);
  }
  getIv() {
    if (!this.iv) {
      const e = this.parser.extractFieldTLVEncoded();
      if (!e || e.tag !== 0) return N(new vr("Invalid trusted property: missing IV"));
      this.iv = e.value;
    }
    return te(this.iv);
  }
  getIssuer() {
    return this.parseEncryptedProps().chain((e) => {
      var t;
      return Bt((t = e.get($a.ISSUER)) == null ? void 0 : t.value, "Missing issuer in trusted properties");
    });
  }
  getXPriv() {
    return this.parseEncryptedProps().chain((e) => {
      var t;
      return Bt((t = e.get($a.XPRIV)) == null ? void 0 : t.value, "Missing xpriv in trusted properties");
    });
  }
  getEphemeralPublicKey() {
    return this.parseEncryptedProps().chain((e) => {
      var t;
      return Bt((t = e.get($a.EPHEMERAL_PUBLIC_KEY)) == null ? void 0 : t.value, "Missing ephemeral public key in trusted properties");
    });
  }
  getCommandIv() {
    return this.parseEncryptedProps().chain((e) => {
      var t;
      return Bt((t = e.get($a.COMMAND_IV)) == null ? void 0 : t.value, "Missing command IV in trusted properties");
    });
  }
  getGroupKey() {
    return this.parseEncryptedProps().chain((e) => {
      var t;
      return Bt((t = e.get($a.GROUPKEY)) == null ? void 0 : t.value, "Missing group key in trusted properties");
    });
  }
  getNewMember() {
    return this.parseEncryptedProps().chain((e) => {
      var t;
      return Bt((t = e.get($a.NEW_MEMBER)) == null ? void 0 : t.tlv, "Missing new member in trusted properties");
    });
  }
  parseEncryptedProps() {
    return this.encryptedProps ? te(this.encryptedProps) : this.getIv().chain(() => Pt.sequence(Array.from(Ane(this.parser)))).map((e) => new Map(e.map((t) => [t.tag, t]))).ifRight((e) => {
      this.encryptedProps = e;
    });
  }
};
function* Ane(r) {
  for (; ; ) {
    const e = r.extractFieldTLVEncoded();
    if (!e) return;
    yield te(e);
  }
}
class Ine {
  constructor(e) {
    h(this, "lastTrustedMember", null);
    h(this, "trustedMembers", /* @__PURE__ */ new Map());
    this.api = e;
  }
  run({ seedBlock: e, applicationStream: t }) {
    return this.parseBlock(e).chain(() => t ? this.parseStream(t) : me.liftEither(te(void 0)));
  }
  parseStream(e) {
    return me.liftEither(e.parse()).chain((t) => me.sequence(t.map((n) => this.parseBlock(n))));
  }
  parseBlock(e) {
    return me.liftEither(e.parse()).chain((t) => this.setTrustedMember(ar(t.issuer, !1)).map(() => t)).chain(async (t) => {
      try {
        const n = await this.api.sendCommand(new Ene(t));
        if (n.status !== ho.Success) return N(n.error);
      } catch (n) {
        return N(new Gi(String(n)));
      }
      return te(t);
    }).chain((t) => me.sequence(t.commands.map((n) => this.parseCommand(n, ar(t.issuer, !1)))).map(() => t)).chain(async (t) => {
      try {
        const n = await this.api.sendCommand(new _ne(t));
        if (n.status !== ho.Success) return N(n.error);
      } catch (n) {
        return N(new Gi(String(n)));
      }
      return te(void 0);
    });
  }
  parseCommand(e, t) {
    const n = e.getPublicKey().orDefault(t);
    return this.setTrustedMember(n).chain(async () => {
      try {
        const i = await this.api.sendCommand(new Sne({ command: e.toU8A() }));
        return i.status !== ho.Success ? N(i.error) : this.recordTrustedMembers(n, i.data);
      } catch (i) {
        return N(new Gi(String(i)));
      }
    });
  }
  setTrustedMember(e) {
    return me.fromPromise(async () => {
      if (e === this.lastTrustedMember) return te(void 0);
      const t = this.trustedMembers.get(e);
      if (!t) return te(void 0);
      try {
        const n = await this.api.sendCommand(new xne(t));
        if (n.status !== ho.Success) return N(n.error);
      } catch (n) {
        return N(new Gi(String(n)));
      }
      return te(void 0);
    });
  }
  recordTrustedMembers(e, t) {
    if (this.lastTrustedMember = e, t.length === 0 || this.trustedMembers.has(e)) return te(void 0);
    const n = new Bx(t);
    return or({ iv: () => n.getIv(), memberTlv: () => n.getNewMember() }).ifRight((i) => this.trustedMembers.set(e, i));
  }
}
const xR = [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], Cne = Uint8Array.from([qe.PublicKey, xR.length, ...xR]);
let Dne = class {
  constructor(e) {
    h(this, "errorHelper", new Ao(Io, Co));
    this.args = e;
  }
  getApdu() {
    const { parent: e, commandCount: t } = this.args, n = Uint8Array.from([qe.Hash, e.length, ...e]);
    return new li({ cla: 224, ins: 7, p1: 0, p2: 0 }).addBufferToData(Uint8Array.from([qe.Int, 1, 1])).addBufferToData(Uint8Array.from(n)).addBufferToData(Cne).addBufferToData(Uint8Array.from([qe.Int, 1, t])).build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefaultLazy(() => {
      const t = new Bn(e), n = t.getUnparsedRemainingLength(), i = t.extractFieldByLength(n);
      return nt(i ? { data: i } : { error: new Yn("No data returned by SignBlockHeaderCommand") });
    });
  }
}, Tne = class {
  constructor() {
    h(this, "errorHelper", new Ao(Io, Co));
  }
  getApdu() {
    return new li({ cla: 224, ins: 7, p1: 2, p2: 0 }).build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefaultLazy(() => {
      const t = new Bn(e), n = t.getUnparsedRemainingLength(), i = t.extractFieldByLength(n);
      if (!i) return nt({ error: new Yn("No data returned by SignBlockSignatureCommand") });
      if (i.length < 2) return nt({ error: new Yn("Invalid response: missing signature length or reserved byte") });
      const s = i[0];
      if (s === void 0) return nt({ error: new Yn("Invalid response: unable to read signature length") });
      const o = s;
      if (i.length < 2 + o) return nt({ error: new Yn("Signature length out of bounds") });
      const a = i.slice(1, 1 + o), c = i.slice(1 + o + 1);
      return nt({ data: { signature: a, deviceSessionKey: c } });
    });
  }
}, kne = class {
  constructor(e) {
    h(this, "errorHelper", new Ao(Io, Co));
    this.args = e;
  }
  getApdu() {
    return new li({ cla: 224, ins: 7, p1: 1, p2: 0 }).addBufferToData(this.args.command).build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefaultLazy(() => {
      const t = new Bn(e), n = t.getUnparsedRemainingLength(), i = t.extractFieldByLength(n);
      return nt(i ? { data: i } : { error: new Yn("No data returned by SignBlockSingleCommand") });
    });
  }
};
function One(r) {
  const e = new DataView(r.buffer);
  return "m/" + Array.from({ length: r.length / 4 }, (t, n) => n * 4).map((t) => e.getUint32(t, !1)).map((t) => t >= 2147483648 ? `${t - 2147483648}'` : String(t)).join("/");
}
function AR(r) {
  return new Uint8Array(r.split("/").slice(1).flatMap((e) => {
    const t = e.endsWith("'") ? Number(e.slice(0, -1)) + 2147483648 : Number(e), n = new Uint8Array(4);
    return new DataView(n.buffer).setUint32(0, t, !1), Array.from(n);
  }));
}
let Gl = class Lx {
  constructor(e, t) {
    h(this, "data");
    this.bytes = e, this.data = t ? Le(te(t)) : ve;
  }
  static fromHex(e) {
    return new Lx(wc(e) ?? new Uint8Array());
  }
  static fromData(e) {
    const t = new nc();
    switch (e.type) {
      case pt.Seed:
        t.encodeInTLVFromBuffer(qe.Bytes, e.topic).encodeInTLVFromUInt16(qe.Int, e.protocolVersion).encodeInTLVFromBuffer(qe.PublicKey, e.groupKey).encodeInTLVFromBuffer(qe.Bytes, e.initializationVector).encodeInTLVFromBuffer(qe.Bytes, e.encryptedXpriv).encodeInTLVFromBuffer(qe.PublicKey, e.ephemeralPublicKey);
        break;
      case pt.AddMember: {
        const i = new ArrayBuffer(4);
        new DataView(i).setUint32(0, e.permissions), t.encodeInTLVFromAscii(qe.String, e.name).encodeInTLVFromBuffer(qe.PublicKey, e.publicKey).encodeInTLVFromBuffer(qe.Int, new Uint8Array(i));
        break;
      }
      case pt.PublishKey:
        t.encodeInTLVFromBuffer(qe.Bytes, e.initializationVector).encodeInTLVFromBuffer(qe.Bytes, e.encryptedXpriv).encodeInTLVFromBuffer(qe.PublicKey, e.recipient).encodeInTLVFromBuffer(qe.PublicKey, e.ephemeralPublicKey);
        break;
      case pt.Derive:
        t.encodeInTLVFromBuffer(qe.Bytes, AR(e.path)).encodeInTLVFromBuffer(qe.PublicKey, e.groupKey).encodeInTLVFromBuffer(qe.Bytes, e.initializationVector).encodeInTLVFromBuffer(qe.Bytes, e.encryptedXpriv).encodeInTLVFromBuffer(qe.PublicKey, e.ephemeralPublicKey);
        break;
    }
    const n = t.build();
    return new Lx(new Uint8Array([e.type, n.length, ...n]), e);
  }
  static bytesFromUnsignedData(e) {
    const t = new nc();
    switch (e.type) {
      case pt.AddMember: {
        const i = new ArrayBuffer(4);
        new DataView(i).setUint32(0, e.permissions), t.encodeInTLVFromAscii(qe.String, e.name).encodeInTLVFromBuffer(qe.PublicKey, e.publicKey).encodeInTLVFromBuffer(qe.Int, new Uint8Array(i));
        break;
      }
      case pt.PublishKey:
        t.encodeInTLVFromBuffer(qe.Bytes, new Uint8Array()).encodeInTLVFromBuffer(qe.Bytes, new Uint8Array()).encodeInTLVFromBuffer(qe.PublicKey, e.recipient).encodeInTLVFromBuffer(qe.PublicKey, new Uint8Array());
        break;
      case pt.Derive:
        t.encodeInTLVFromBuffer(qe.Bytes, AR(e.path));
        break;
    }
    const n = t.build();
    return new Uint8Array([e.type, n.length, ...n]);
  }
  toString() {
    return ar(this.bytes, !1);
  }
  toU8A() {
    return this.bytes;
  }
  parse() {
    return this.data.orDefaultLazy(() => {
      const e = new UC(this.bytes).parseCommandData();
      return this.data = Le(e), e;
    });
  }
  toHuman() {
    return this.parse().map((e) => Object.entries(e).map(([t, n]) => t === "type" ? `${pt[n]}(0x${n == null ? void 0 : n.toString(16).padStart(2, "0")}):` : `  ${t}: ${n instanceof Uint8Array ? ar(n, !1) : n}`).join(`
`));
  }
  getPublicKey() {
    switch (this.bytes[0]) {
      case pt.AddMember:
      case pt.PublishKey:
        return this.parse().toMaybe().chain((e) => {
          switch (e.type) {
            case pt.AddMember:
              return Le(e.publicKey);
            case pt.PublishKey:
              return Le(e.recipient);
            default:
              return ve;
          }
        }).map((e) => ar(e, !1));
      default:
        return ve;
    }
  }
  getEncryptedPublishedKey() {
    switch (this.bytes[0]) {
      case pt.Seed:
      case pt.Derive:
      case pt.PublishKey:
        return this.parse().toMaybe().chain((e) => {
          switch (e.type) {
            case pt.Seed:
            case pt.Derive:
            case pt.PublishKey:
              return pe.of({ ...e });
            default:
              return ve;
          }
        });
      default:
        return ve;
    }
  }
};
const $ne = 3;
let UC = class {
  constructor(e) {
    h(this, "bytes");
    h(this, "parser");
    h(this, "offset", 0);
    this.bytes = e, this.parser = this.parseTLV(e);
  }
  get state() {
    return { offset: this.offset, isDone: this.offset >= this.bytes.length };
  }
  parse() {
    return this.parser.next().value;
  }
  tlvEncoded(e) {
    const t = this.offset;
    return e().map(() => this.bytes.slice(t, this.offset));
  }
  parseNull() {
    return this.parse().chain((e) => e.tag !== qe.Null ? N(new vr("Expected null")) : te(e.value));
  }
  parseInt() {
    return this.parse().chain((e) => e.tag !== qe.Int ? N(new vr("Expected a number")) : te(e.value));
  }
  parseHash() {
    return this.parse().chain((e) => e.tag !== qe.Hash ? N(new vr("Expected a hash")) : te(e.value));
  }
  parseSignature() {
    return this.parse().chain((e) => e.tag !== qe.Signature ? N(new vr("Expected a signature")) : te(e.value));
  }
  parseString() {
    return this.parse().chain((e) => e.tag !== qe.String ? N(new vr("Expected a string")) : te(e.value));
  }
  parseBytes() {
    return this.parse().chain((e) => e.tag !== qe.Bytes ? N(new vr("Expected bytes")) : te(e.value));
  }
  parsePublicKey() {
    return this.parse().chain((e) => e.tag !== qe.PublicKey ? N(new vr("Expected a public key")) : te(e.value));
  }
  parseCommandBytes() {
    return this.parse().chain(({ tag: e, value: t }) => e < 16 || e > 63 || !(t instanceof Uint8Array) ? N(new vr(`Invalid command type: 0x${e.toString(16).padStart(2, "0")}`)) : te(t));
  }
  parseCommandData() {
    const e = this.parseCommandBytes(), t = this.offset;
    return e.chain((n) => {
      const i = n[0];
      switch (this.offset -= n.length - 2, i) {
        case pt.Seed:
          return or({ type: i, topic: () => this.parseBytes(), protocolVersion: () => this.parseInt(), groupKey: () => this.parsePublicKey(), initializationVector: () => this.parseBytes(), encryptedXpriv: () => this.parseBytes(), ephemeralPublicKey: () => this.parsePublicKey() });
        case pt.AddMember:
          return or({ type: i, name: () => this.parseString(), publicKey: () => this.parsePublicKey(), permissions: () => this.parseInt() });
        case pt.PublishKey:
          return or({ type: i, initializationVector: () => this.parseBytes(), encryptedXpriv: () => this.parseBytes(), recipient: () => this.parsePublicKey(), ephemeralPublicKey: () => this.parsePublicKey() });
        case pt.Derive:
          return or({ type: i, path: () => this.parseBytes().map(One), groupKey: () => this.parsePublicKey(), initializationVector: () => this.parseBytes(), encryptedXpriv: () => this.parseBytes(), ephemeralPublicKey: () => this.parsePublicKey() });
        default:
          return N(new vr(`Unsupported command type: 0x${i == null ? void 0 : i.toString(16).padStart(2, "0")}`));
      }
    }).chain((n) => this.offset === t ? te(n) : N(new vr("Command was parsed incorrectly")));
  }
  parseCommands() {
    return this.parse().chain((e) => e.tag !== qe.Int ? N(new vr("Expected a command count")) : te(e.value)).chain((e) => {
      const t = [];
      for (let n = 0; n < e; n++) {
        const i = this.parseCommandBytes();
        if (i.isLeft()) return i;
        i.ifRight((s) => t.push(new Gl(s)));
      }
      return te(t);
    });
  }
  parseBlockData() {
    const e = this.offset;
    return this.parseInt().chain((t) => or({ parent: () => this.parseHash().map((n) => ar(n, !1)), issuer: () => this.parsePublicKey(), header: () => te(this.bytes.slice(e, this.offset + $ne)), commands: () => this.parseCommands(), signature: () => this.tlvEncoded(() => this.parseSignature()) }));
  }
  *parseTLV(e) {
    for (; ; ) {
      const t = e[this.offset];
      if (typeof t > "u") return N(new vr("Unexpected end of TLV"));
      this.offset++;
      const n = e[this.offset];
      if (typeof n > "u") return N(new vr("Invalid end of TLV, expected length"));
      this.offset++;
      const i = this.offset + n, s = e.slice(this.offset, i);
      if (i > e.length) return N(new vr("Invalid end of TLV value"));
      switch (this.offset = i, t) {
        case qe.Null:
          yield n > 0 ? N(new vr("Invalid null length")) : te({ tag: t, value: null });
          break;
        case qe.Int:
          {
            const o = new DataView(s.buffer);
            switch (s.length) {
              case 1:
                yield te({ tag: t, value: o.getUint8(0) });
                break;
              case 2:
                yield te({ tag: t, value: o.getUint16(0, !1) });
                break;
              case 4:
                yield te({ tag: t, value: o.getUint32(0, !1) });
                break;
              default:
                yield N(new vr("Unsupported integer length"));
            }
          }
          break;
        case qe.String:
          yield s.length === 0 ? N(new vr("Empty string value")) : te({ tag: t, value: new TextDecoder().decode(s) });
          break;
        case qe.Hash:
        case qe.Signature:
        case qe.Bytes:
        case qe.PublicKey:
          yield te({ tag: t, value: s });
          break;
        default:
          yield te({ tag: t, value: new Uint8Array([t, n, ...s]) });
          break;
      }
    }
  }
}, Ux = class Fx {
  constructor(e, t) {
    h(this, "hashValue", ve);
    h(this, "data");
    this.bytes = e, this.data = t ? Le(te(t)) : ve;
  }
  static fromHex(e) {
    return new Fx(wc(e) ?? new Uint8Array());
  }
  static fromData(e) {
    const t = new nc().encodeInTLVFromUInt8(qe.Int, 1).encodeInTLVFromHexa(qe.Hash, e.parent).encodeInTLVFromBuffer(qe.PublicKey, e.issuer).encodeInTLVFromUInt8(qe.Int, e.commands.length).build(), n = new nc();
    e.commands.forEach((a) => n.addBufferToData(a.toU8A()));
    const i = n.build(), s = new nc().encodeInTLVFromBuffer(qe.Signature, e.signature).build(), o = new nc().addBufferToData(t).addBufferToData(i).addBufferToData(s).build();
    return new Fx(o, { ...e, header: t, signature: s });
  }
  toString() {
    return ar(this.bytes, !1);
  }
  toU8A() {
    return this.bytes;
  }
  parse() {
    return this.data.orDefaultLazy(() => {
      const e = new UC(this.bytes).parseBlockData();
      return this.data = Le(e), e;
    });
  }
  toHuman() {
    return this.parse().chain((e) => Pt.sequence(e.commands.map((t) => t.toHuman())).map((t) => ({ ...e, commands: t }))).map((e) => [`Parent: ${e.parent}`, `Issuer: ${ar(e.issuer, !1)}`, `Commands:${e.commands.flatMap((t) => t.split(`
`).map((n) => `
  ${n}`)).join("")}`, `Signature: ${ar(e.signature.slice(2), !1)}`].join(`
`));
  }
  hash() {
    return this.hashValue.orDefaultLazy(() => {
      const e = Ax(this.bytes);
      return ar(e, !1);
    });
  }
}, Rne = class {
  constructor(e, t) {
    this.api = e, this.cryptoService = t;
  }
  run({ lkrpDataSource: e, trustchainId: t, path: n, jwt: i, parent: s, blockFlow: o, sessionKeypair: a }) {
    const c = this.signCommands(n, o);
    return mne({ header: this.signBlockHeader(s, c.length), commands: me.sequence(c), signature: this.signBlockSignature(a) }).chain(async (u) => this.decryptBlock(s, u)).chain((u) => {
      switch (o.type) {
        case "derive":
          return e.postDerivation(t, u, i);
        case "addMember":
          return e.putCommands(t, n, u, i);
      }
    }).mapLeft((u) => u instanceof LC && u.status === "BAD_REQUEST" ? new fne() : u);
  }
  signBlockHeader(e, t) {
    return me.fromPromise(async () => {
      try {
        const n = await this.api.sendCommand(new Dne({ parent: e, commandCount: t }));
        if (n.status !== ho.Success) return N(n.error);
        const i = new Bx(n.data);
        return or({ iv: () => i.getIv(), issuer: () => i.getIssuer() });
      } catch (n) {
        return N(new Gi(String(n)));
      }
    });
  }
  signBlockSignature(e) {
    return me.fromPromise(async () => {
      try {
        const t = await this.api.sendCommand(new Tne());
        if (t.status !== ho.Success) return N(t.error);
        const { signature: n, deviceSessionKey: i } = t.data, s = (await e.deriveSharedSecret(i)).slice(1);
        return te({ signature: n, secret: s });
      } catch (t) {
        return N(new Gi(String(t)));
      }
    });
  }
  signCommands(e, t) {
    switch (t.type) {
      case "derive":
        return [this.signDeriveCommand(e), this.signAddMemberCommand(t.data), this.signPublishKeyCommand(t.data)];
      case "addMember":
        return [this.signAddMemberCommand(t.data), this.signPublishKeyCommand(t.data)];
    }
  }
  signSingleCommand(e) {
    return me.fromPromise(async () => {
      try {
        const t = await this.api.sendCommand(new kne({ command: e }));
        return t.status !== ho.Success ? N(t.error) : te(new Bx(t.data));
      } catch (t) {
        return N(new Gi(String(t)));
      }
    });
  }
  signDeriveCommand(e) {
    return this.signSingleCommand(Gl.bytesFromUnsignedData({ type: pt.Derive, path: e })).chain((t) => me.liftEither(or({ type: pt.Derive, path: e, iv: () => t.getIv(), xpriv: () => t.getXPriv(), ephemeralPublicKey: () => t.getEphemeralPublicKey(), commandIv: () => t.getCommandIv(), groupKey: () => t.getGroupKey(), newMember: () => t.getNewMember() })));
  }
  signAddMemberCommand({ name: e, publicKey: t, permissions: n }) {
    return this.signSingleCommand(Gl.bytesFromUnsignedData({ type: pt.AddMember, name: e, publicKey: t, permissions: n })).chain((i) => me.liftEither(or({ type: pt.AddMember, name: e, publicKey: t, permissions: n, iv: () => i.getIv(), newMember: () => i.getNewMember() })));
  }
  signPublishKeyCommand({ publicKey: e }) {
    return this.signSingleCommand(Gl.bytesFromUnsignedData({ type: pt.PublishKey, recipient: e })).chain((t) => me.liftEither(or({ type: pt.PublishKey, recipient: e, iv: () => t.getIv(), xpriv: () => t.getXPriv(), ephemeralPublicKey: () => t.getEphemeralPublicKey(), commandIv: () => t.getCommandIv(), newMember: () => t.getNewMember() })));
  }
  decryptBlock(e, { header: t, commands: n, signature: i }) {
    return me(async ({ throwE: s }) => {
      const o = await this.cryptoService.importSymmetricKey(i.secret, lo.AES256_GCM).decrypt(t.iv, t.issuer);
      return Pt.sequence(await Promise.all(n.map((a) => this.decryptCommand(i.secret, a).run()))).caseOf({ Left: (a) => {
        throw s(a), a;
      }, Right: (a) => Ux.fromData({ parent: ar(e), issuer: o, commands: a, signature: i.signature }) });
    });
  }
  decryptCommand(e, t) {
    return me(async ({ throwE: n }) => {
      switch (t.type) {
        case pt.Derive:
        case pt.PublishKey: {
          const i = await this.cryptoService.importSymmetricKey(e, lo.AES256_GCM).decrypt(t.iv, t.xpriv);
          return Gl.fromData({ ...t, initializationVector: t.commandIv, encryptedXpriv: i });
        }
        case pt.AddMember:
          return Gl.fromData({ ...t });
        default:
          throw n(new ER(t)), new ER(t);
      }
    });
  }
}, Pne = class extends yf {
  makeStateMachine(e) {
    const { initCommand: t, parseStream: n, signBlock: i } = this.extractDependencies(e);
    return Or({ actors: { initCommand: tt(t), parseStream: tt(n), signBlock: tt(i) }, actions: { assignErrorFromEvent: In(({ event: s }) => N(new Gi(String(s.error)))) }, guards: { isTustchainEmpty: ({ context: s }) => s.input.toMaybe().chain((o) => o.trustchain.getAppStream(o.appId)).chain((o) => o.parse().toMaybe()).map((o) => o.length === 0).orDefault(!0) } }).createMachine({ id: "AddToTrustchainDeviceAction", context: ({ input: s }) => ({ input: s, intermediateValue: { requiredUserInteraction: pr.None }, _internalState: te({ sessionKeypair: null }) }), initial: "InitSession", states: { InitSession: { entry: Q({ intermediateValue: { requiredUserInteraction: pr.None, step: mp.Initialize } }), on: { success: "ParseStream", error: "Error" }, invoke: { id: "initCommand", src: "initCommand", input: ({ context: s }) => s.input.map((o) => o.cryptoService), onError: { actions: "assignErrorFromEvent" }, onDone: { actions: In(({ event: s }) => s.output.map((o) => ({ raise: "success", assign: { sessionKeypair: o } }))) } } }, ParseStream: { entry: Q({ intermediateValue: { requiredUserInteraction: pr.None, step: mp.ParseStream } }), on: { success: "CheckApplicationStreamExist", error: "Error" }, invoke: { id: "parseStream", src: "parseStream", input: ({ context: s }) => s.input.chain((o) => or({ seedBlock: () => {
      var a;
      return Bt((a = o.trustchain.getRootStream().chain((c) => c.parse().toMaybe()).extract()) == null ? void 0 : a[0], "Missing seed block to parse");
    }, applicationStream: () => Bt(o.trustchain.getAppStream(o.appId).extract(), "Missing application stream to parse") })), onError: { actions: "assignErrorFromEvent" }, onDone: { actions: In(({ event: s }) => s.output.map(() => ({ raise: "success" }))) } } }, CheckApplicationStreamExist: { always: [{ target: "AddToNewStream", guard: "isTustchainEmpty" }, { target: "AddToExistingStream" }] }, AddToExistingStream: { entry: Q({ intermediateValue: { requiredUserInteraction: Nx.AddMember, step: mp.AddMember } }), on: { success: "Success", error: "Error" }, invoke: { id: "signBlock", src: "signBlock", input: ({ context: s }) => s.input.chain((o) => {
      const a = o.trustchain.getAppStream(o.appId);
      return or({ cryptoService: o.cryptoService, lkrpDataSource: o.lkrpDataSource, trustchainId: o.trustchain.getId(), jwt: o.jwt, clientName: o.clientName, sessionKeypair: () => s._internalState.chain(({ sessionKeypair: c }) => Bt(c, "Missing session keypair")), path: () => Bt(a.chain((c) => c.getPath()).extract(), "Missing application path"), parent: () => Bt(a.chain((c) => c.parse().toMaybe()).chainNullable((c) => {
        var u;
        return (u = c.at(-1)) == null ? void 0 : u.hash();
      }).chainNullable(wc).extract(), "Missing parent block"), blockFlow: { type: "addMember", data: { name: o.clientName, publicKey: o.keypair.getPublicKey(), permissions: o.permissions } } });
    }), onError: { actions: "assignErrorFromEvent" }, onDone: { actions: In(({ event: s }) => s.output.map(() => ({ raise: "success" }))) } } }, AddToNewStream: { entry: Q({ intermediateValue: { requiredUserInteraction: Nx.AddMember, step: mp.AddMember } }), on: { success: "Success", error: "Error" }, invoke: { id: "signBlock", src: "signBlock", input: ({ context: s }) => s.input.chain((o) => or({ lkrpDataSource: o.lkrpDataSource, trustchainId: o.trustchain.getId(), jwt: o.jwt, clientName: o.clientName, sessionKeypair: () => s._internalState.chain(({ sessionKeypair: a }) => Bt(a, "Missing session keypair")), path: `m/0'/${o.appId}'/0'`, parent: () => Bt(o.trustchain.getRootStream().chain((a) => a.parse().toMaybe()).chainNullable((a) => {
      var c;
      return (c = a[0]) == null ? void 0 : c.hash();
    }).chainNullable(wc).extract(), "Missing init block"), blockFlow: { type: "derive", data: { name: o.clientName, publicKey: o.keypair.getPublicKey(), permissions: o.permissions } } }).chain(() => N(new C6()))), onError: { actions: "assignErrorFromEvent" }, onDone: { actions: In(({ event: s }) => s.output.map(() => ({ raise: "success" }))) } } }, Success: { type: "final" }, Error: { type: "final" } }, output: ({ context: s }) => s._internalState.map((o) => {
    }) });
  }
  extractDependencies(e) {
    return { initCommand: async (t) => me.liftEither(t.input).chain((n) => new wne(e, n).run()).run(), parseStream: async (t) => me.liftEither(t.input).chain((n) => new Ine(e).run(n)).run(), signBlock: (t) => me.liftEither(t.input).chain((n) => new Rne(e, n.cryptoService).run(n)).run() };
  }
};
const IR = "Ledger Sync";
let Nne = class extends yf {
  makeStateMachine(e) {
    const { deviceAuth: t, getTrustchain: n, extractEncryptionKey: i } = this.extractDependencies(e);
    return Or({ actors: { openAppStateMachine: new e6({ input: { appName: IR } }).makeStateMachine(e), deviceAuth: tt(t), getTrustchain: tt(n), addToTrustchainStateMachine: new Pne({ input: N(new Pu("Missing input for GetEncryptionKey")) }).makeStateMachine(e), extractEncryptionKey: tt(i) }, actions: { assignErrorFromEvent: In(({ event: s }) => N(new Gi(String(s.error)))) }, guards: { isTrustchainMember: ({ context: s }) => s._internalState.toMaybe().map((o) => {
      var a;
      return o.wasAddedToTrustchain || ((a = o.trustchain) == null ? void 0 : a.getAppStream(s.input.appId).mapOrDefault((c) => c.hasMember(s.input.keypair.getPublicKeyToHex()), !1));
    }).extract() ?? !1 } }).createMachine({ id: "AuthenticateWithDeviceDeviceAction", context: ({ input: s }) => ({ input: s, intermediateValue: { requiredUserInteraction: pr.None }, _internalState: te({ trustchainId: null, jwt: null, trustchain: null, encryptionKey: null, wasAddedToTrustchain: !1 }) }), initial: "OpenApp", states: { OpenApp: { on: { success: "DeviceAuth", error: "Error" }, invoke: { id: "openApp", src: "openAppStateMachine", onSnapshot: { actions: Q({ intermediateValue: ({ event: s }) => ({ step: rc.OpenApp, ...s.snapshot.context.intermediateValue }) }) }, input: { appName: IR }, onError: { actions: "assignErrorFromEvent" }, onDone: { actions: In(({ event: s }) => s.output.map(() => ({ raise: "success" }))) } } }, DeviceAuth: { entry: Q({ intermediateValue: { step: rc.Authenticate, requiredUserInteraction: N3.Authenticate } }), on: { success: "GetTrustchain", error: "Error" }, invoke: { id: "deviceAuth", src: "deviceAuth", input: ({ context: s }) => s.input, onError: { actions: "assignErrorFromEvent" }, onDone: { actions: In(({ event: s }) => s.output.chain((o) => o.trustchainId.caseOf({ Nothing: () => N(new C6()), Just: (a) => te({ raise: "success", assign: { jwt: o.jwt, trustchainId: a } }) }))) } } }, GetTrustchain: { entry: Q({ intermediateValue: { step: rc.GetTrustchain, requiredUserInteraction: pr.None } }), on: { success: "CheckIsMembers", error: "Error" }, invoke: { id: "getTrustchain", src: "getTrustchain", input: ({ context: s }) => s._internalState.chain((o) => or({ lkrpDataSource: s.input.lkrpDataSource, trustchainId: () => Bt(o.trustchainId, "Missing Trustchain ID for GetTrustchain"), jwt: () => Bt(o.jwt, "Missing JWT for GetTrustchain") })), onError: { actions: "assignErrorFromEvent" }, onDone: { actions: In(({ event: s }) => s.output.map((o) => ({ raise: "success", assign: { trustchain: o } }))) } } }, CheckIsMembers: { always: [{ target: "ExtractEncryptionKey", guard: "isTrustchainMember" }, { target: "AddToTrustchain" }] }, AddToTrustchain: { on: { success: "GetTrustchain", error: "Error" }, invoke: { id: "AddToTrustchain", src: "addToTrustchainStateMachine", onSnapshot: { actions: Q({ intermediateValue: ({ event: s }) => s.snapshot.context.intermediateValue }) }, input: ({ context: s }) => s._internalState.mapLeft(() => new Pu("Missing data in the input for AddToTrustchain")).chain((o) => or({ lkrpDataSource: s.input.lkrpDataSource, cryptoService: s.input.cryptoService, keypair: s.input.keypair, clientName: s.input.clientName, permissions: s.input.permissions, jwt: () => Bt(o.jwt, "Missing JWT for AddToTrustchain"), appId: s.input.appId, trustchain: () => Bt(o.trustchain, "Missing Trustchain for AddToTrustchain") })), onError: { actions: "assignErrorFromEvent" }, onDone: { actions: In(({ event: s }) => s.output.map(() => ({ raise: "success", assign: { wasAddedToTrustchain: !0 } }))) } } }, ExtractEncryptionKey: { entry: Q({ intermediateValue: { step: rc.ExtractEncryptionKey, requiredUserInteraction: pr.None } }), on: { success: "Success", error: "Error" }, invoke: { id: "ExtractEncryptionKey", src: "extractEncryptionKey", input: ({ context: s }) => ({ cryptoService: s.input.cryptoService, keypair: s.input.keypair, stream: s._internalState.chain(({ trustchain: o }) => Bt(o == null ? void 0 : o.getAppStream(s.input.appId).extract(), "Missing application stream for ExtractEncryptionKey")) }), onError: { actions: "assignErrorFromEvent" }, onDone: { actions: In(({ event: s }) => s.output.map((o) => ({ raise: "success", assign: { encryptionKey: o } }))) } } }, Success: { type: "final" }, Error: { type: "final" } }, output: ({ context: s }) => s._internalState.chain((o) => or({ trustchainId: () => Bt(o.trustchainId, "Missing Trustchain ID in the output"), jwt: () => Bt(o.jwt, "Missing JWT in the output"), applicationPath: () => {
      var a;
      return Bt((a = o.trustchain) == null ? void 0 : a.getAppStream(s.input.appId).chain((c) => c.getPath()).extract(), "Missing application path in the output");
    }, encryptionKey: () => Bt(o.encryptionKey, "Missing encryption key in the output") })) });
  }
  extractDependencies(e) {
    const t = new T6(), n = new k6();
    return { deviceAuth: ({ input: i }) => t.run(i.lkrpDataSource, new vne(e)), getTrustchain: (i) => me.liftEither(i.input).chain(({ lkrpDataSource: s, trustchainId: o, jwt: a }) => s.getTrustchainById(o, a)).run(), extractEncryptionKey: async ({ input: i }) => me.liftEither(i.stream).chain((s) => n.run(i.cryptoService, i.keypair, s)) };
  }
}, Bne = class {
  constructor(e, t, n) {
    this.cryptoService = e, this.keypair = t, this.trustchainId = n;
  }
  run(e) {
    const t = this.getAttestation(), n = this.getCredential(this.keypair.getPublicKeyToHex());
    return me.liftEither(this.getUnsignedChallengeTLV(e.tlv)).map((i) => this.cryptoService.hash(i, Hh.SHA256)).map((i) => this.keypair.sign(i, Ky.DER)).map((i) => ar(i, !1)).map((i) => ({ challenge: e.json, signature: { attestation: t, credential: n, signature: i } })).mapLeft((i) => i instanceof Pu ? i : new Gi(String(i)));
  }
  getAttestation() {
    const e = new TextEncoder().encode(this.trustchainId), t = Uint8Array.from([2, e.length, ...e]);
    return ar(t, !1);
  }
  getCredential(e) {
    return { version: 0, curveId: 33, signAlgorithm: 1, publicKey: e };
  }
  getUnsignedChallengeTLV(e) {
    const t = new h0(wc(e) ?? new Uint8Array()), n = new Map((function* () {
      for (; ; ) {
        const s = t.extractFieldTLVEncoded();
        if (!s) break;
        yield [s.tag, s.value];
      }
    })());
    if (n.size > 10) return N(new Pu("Challenge TLV contains unexpected data"));
    const i = (s, o) => pe.fromNullable(n.get(s)).toEither(new Pu(`Missing ${o} field`));
    return or({ payloadType: () => i(1, "Payload type"), version: () => i(2, "Version"), challengeExpiry: () => i(22, "Challenge expiry"), host: () => i(32, "Host"), protocolVersion: () => i(96, "Protocol version"), curveId: () => i(50, "Curve ID"), publicKey: () => i(51, "Public key"), challengeData: () => i(18, "Challenge data"), signAlgorithm: () => i(20, "Sign algorithm"), rpSignatureField: () => i(21, "RP signature field") }).map((s) => Uint8Array.from([[1, s.payloadType.length, ...s.payloadType], [2, s.version.length, ...s.version], [18, s.challengeData.length, ...s.challengeData], [22, s.challengeExpiry.length, ...s.challengeExpiry], [32, s.host.length, ...s.host], [96, s.protocolVersion.length, ...s.protocolVersion]].flat()));
  }
};
class Lne extends yf {
  execute() {
    const e = this.makeStateMachine();
    return this._subscribeToStateMachine(e);
  }
  makeStateMachine() {
    const { keypairAuth: e, getTrustchain: t, extractEncryptionKey: n } = this.extractDependencies();
    return Or({ actors: { keypairAuth: tt(e), getTrustchain: tt(t), extractEncryptionKey: tt(n) }, actions: { assignErrorFromEvent: In(({ event: i }) => N(new Gi(String(i.error)))) } }).createMachine({ id: "AuthenticateWithKeypairDeviceAction", context: ({ input: i }) => ({ input: i, intermediateValue: { requiredUserInteraction: pr.None }, _internalState: te({ jwt: null, trustchain: null, encryptionKey: null }) }), initial: "KeypairAuth", states: { KeypairAuth: { entry: Q({ intermediateValue: { requiredUserInteraction: pr.None, step: rc.Authenticate } }), on: { success: "GetTrustchain", error: "Error" }, invoke: { id: "keypairAuth", src: "keypairAuth", input: ({ context: i }) => i.input, onError: { actions: "assignErrorFromEvent" }, onDone: { actions: In(({ context: i, event: s }) => s.output.map(({ jwt: o }) => ({ raise: "success", assign: { jwt: o } })).mapLeft((o) => o instanceof LC && o.status === "UNAUTHORIZED" ? new hne(i.input.trustchainId) : o)) } } }, GetTrustchain: { entry: Q({ intermediateValue: { requiredUserInteraction: pr.None, step: rc.GetTrustchain } }), on: { success: "ExtractEncryptionKey", error: "Error" }, invoke: { id: "getTrustchain", src: "getTrustchain", input: ({ context: i }) => ({ lkrpDataSource: i.input.lkrpDataSource, trustchainId: i.input.trustchainId, jwt: i._internalState.chain(({ jwt: s }) => Bt(s, "Missing JWT for GetTrustchain")) }), onError: { actions: "assignErrorFromEvent" }, onDone: { actions: In(({ event: i }) => i.output.map((s) => ({ raise: "success", assign: { trustchain: s } }))) } } }, ExtractEncryptionKey: { entry: Q({ intermediateValue: { requiredUserInteraction: pr.None, step: rc.ExtractEncryptionKey } }), on: { success: "Success", error: "Error" }, invoke: { id: "ExtractEncryptionKey", src: "extractEncryptionKey", input: ({ context: i }) => ({ cryptoService: i.input.cryptoService, keypair: i.input.keypair, stream: i._internalState.chain(({ trustchain: s }) => Bt(s == null ? void 0 : s.getAppStream(i.input.appId).extract(), "Missing application stream for ExtractEncryptionKey")) }), onError: { actions: "assignErrorFromEvent" }, onDone: { actions: In(({ event: i }) => i.output.map((s) => ({ raise: "success", assign: { encryptionKey: s } }))) } } }, Success: { type: "final" }, Error: { type: "final" } }, output: ({ context: i }) => i._internalState.chain((s) => or({ trustchainId: i.input.trustchainId, jwt: () => Bt(s.jwt, "Missing JWT in the output"), applicationPath: () => {
      var o;
      return Bt((o = s.trustchain) == null ? void 0 : o.getAppStream(i.input.appId).chain((a) => a.getPath()).extract(), "Missing application path in the output");
    }, encryptionKey: () => Bt(s.encryptionKey, "Missing encryption key in the output") })) });
  }
  extractDependencies() {
    const e = new T6(), t = new k6();
    return { keypairAuth: ({ input: n }) => e.run(n.lkrpDataSource, new Bne(n.cryptoService, n.keypair, n.trustchainId)), getTrustchain: ({ input: n }) => me.liftEither(n.jwt).chain((i) => n.lkrpDataSource.getTrustchainById(n.trustchainId, i)).run(), extractEncryptionKey: async ({ input: n }) => me.liftEither(n.stream).chain((i) => t.run(n.cryptoService, n.keypair, i)) };
  }
}
var Une = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Fm = (r, e) => (t, n) => e(t, n, r);
let Mx = class {
  constructor(e, t, n, i) {
    this.dmk = e, this.applicationId = t, this.cryptoService = n, this.lkrpDataSource = i;
  }
  authenticateWithKeypair(e) {
    return new Lne({ input: { lkrpDataSource: this.lkrpDataSource, appId: this.applicationId, cryptoService: this.cryptoService, keypair: e.keypair, trustchainId: e.trustchainId } }).execute();
  }
  authenticateWithDevice(e) {
    return this.dmk.executeDeviceAction({ sessionId: e.sessionId, deviceAction: new Nne({ input: { lkrpDataSource: this.lkrpDataSource, appId: this.applicationId, cryptoService: this.cryptoService, clientName: e.clientName, permissions: e.permissions, keypair: e.keypair } }) });
  }
  getVersion(e) {
    return this.dmk.executeDeviceAction({ sessionId: e.sessionId, deviceAction: new vte({ input: { command: new gne(), appName: "Ledger Sync", requiredUserInteraction: pr.None, skipOpenApp: e.skipOpenApp } }) });
  }
  getAppName() {
    throw new Error("Not implemented");
  }
  getSeedId() {
    throw new Error("Not implemented");
  }
  init() {
    throw new Error("Not implemented");
  }
  parseStream() {
    throw new Error("Not implemented");
  }
  signBlock() {
    throw new Error("Not implemented");
  }
  setTrustedMember() {
    throw new Error("Not implemented");
  }
};
Mx = Une([le(), Fm(0, X(lc.Dmk)), Fm(1, X(lc.ApplicationId)), Fm(2, X(lc.CryptoService)), Fm(3, X(ev.LKRPDataSource))], Mx);
const Fne = () => new mt(({ bind: r }) => {
  r(D6.AppBinding).to(Mx);
});
let Mne = class Vx {
  constructor(e, t) {
    h(this, "validation", ve);
    h(this, "blocks", ve);
    h(this, "path", ve);
    this.bytes = e, this.blocks = t ? Le(te(t)) : ve;
  }
  static fromHex(e) {
    return new Vx(wc(e) ?? new Uint8Array());
  }
  static fromData(e, t) {
    const n = [];
    let i = t ?? ar(crypto.getRandomValues(new Uint8Array(32)), !1);
    for (const o of e) {
      const a = Ux.fromData({ ...o, parent: i });
      i = a.hash(), n.push(a);
    }
    const s = n.reduce((o, a) => new Uint8Array([...o, ...a.toU8A()]), new Uint8Array());
    return new Vx(s, n);
  }
  toU8A() {
    return this.bytes;
  }
  toString() {
    return ar(this.bytes, !1);
  }
  parse() {
    return this.blocks.orDefaultLazy(() => {
      const e = new UC(this.bytes), t = [];
      for (; !e.state.isDone; ) {
        const i = e.state.offset, s = e.parseBlockData().map((o) => {
          const a = e.state.offset;
          return new Ux(this.bytes.slice(i, a), o);
        });
        if (t.push(s), s.isLeft()) break;
      }
      const n = Pt.sequence(t);
      return this.blocks = Le(n), n;
    });
  }
  toHuman() {
    return this.parse().map((e) => e.map((t) => t.toHuman())).chain(Pt.sequence).map((e) => e.join(`

`));
  }
  async validate(e) {
    return this.validation.orDefaultLazy(async () => this.parse().map((t) => t.map((n) => n.parse().map(({ parent: i }) => ({ parent: i, hash: () => n.hash() })))).chain(Pt.sequence).toMaybe().map(async (t) => {
      if (e && t[0] && e !== t[0].parent) return !1;
      for await (const [n, i] of t.entries()) {
        const s = t[n + 1];
        if (s && i.hash() !== s.parent) return !1;
      }
      return !0;
    }).orDefault(Promise.resolve(!1)));
  }
  getPath() {
    return this.path.ifNothing(() => {
      this.path = this.parse().toMaybe().chainNullable((e) => e[0]).chain((e) => e.parse().toMaybe()).chainNullable(({ commands: e }) => e[0]).chain((e) => e.parse().toMaybe()).chain((e) => {
        switch (e.type) {
          case pt.Derive:
            return Le(e.path);
          case pt.Seed:
            return Le("m/0'");
          default:
            return ve;
        }
      });
    }), this.path;
  }
  getMemberBlock(e) {
    return this.parse().toMaybe().chain((t) => {
      for (const n of t) {
        const i = n.parse();
        if (i.isRight()) {
          const s = i.extract();
          for (const o of s.commands) {
            const a = o.getPublicKey();
            if (a.isJust() && a.extract() === e) return pe.of(s);
          }
        }
      }
      return ve;
    });
  }
  hasMember(e) {
    return this.getMemberBlock(e).isJust();
  }
  async getPublishedKey(e, t) {
    return Br.liftMaybe(this.getMemberBlock(t.getPublicKeyToHex()).chain((n) => {
      for (const i of n.commands) {
        const s = i.getEncryptedPublishedKey();
        if (s.isJust()) return s;
      }
      return ve;
    })).map(async (n) => {
      const i = (await t.deriveSharedSecret(n.ephemeralPublicKey)).slice(1), s = await e.importSymmetricKey(i, lo.AES256_GCM).decrypt(n.initializationVector, n.encryptedXpriv);
      return { privateKey: s.slice(0, 32), chainCode: s.slice(32) };
    });
  }
}, Vne = class {
  constructor(e, t) {
    this.id = e, this.serialized = t;
  }
  getId() {
    return this.id;
  }
  getRootStream() {
    return this.getStream("m/");
  }
  getAppStream(e) {
    return this.getStream(`m/${e}'`);
  }
  getStream(e) {
    return pe.fromNullable(this.serialized[e]).map(Mne.fromHex);
  }
};
var zne = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, jne = (r, e) => (t, n) => e(t, n, r);
let zx = class {
  constructor(e) {
    this.baseUrl = e;
  }
  getChallenge() {
    return this.request("/challenge", ve);
  }
  authenticate(e) {
    return this.request("/authenticate", ve, { method: "POST", body: JSON.stringify(e) }).map((t) => ({ jwt: t, trustchainId: pe.fromNullable(Object.keys(t.permissions).find((n) => {
      var i;
      return !!((i = t.permissions[n]) != null && i["m/"]);
    })) }));
  }
  getTrustchainById(e, t) {
    return this.request(`/trustchain/${e}`, Le(t)).map((n) => new Vne(e, n));
  }
  postDerivation(e, t, n) {
    return this.request(`/trustchain/${e}/derivation`, Le(n), { method: "POST", body: JSON.stringify(t.toString()) });
  }
  putCommands(e, t, n, i) {
    return this.request(`/trustchain/${e}/commands`, Le(i), { method: "PUT", body: JSON.stringify({ path: t, blocks: [n.toString()] }) });
  }
  request(e, t, n) {
    const i = this.baseUrl + e, s = { ...n == null ? void 0 : n.headers, "Content-Type": "application/json", ...t.mapOrDefault(({ access_token: o }) => ({ Authorization: `Bearer ${o}` }), {}) };
    return me(() => fetch(i, { ...n, headers: s })).mapLeft((o) => ({ status: "UNKNOWN", message: A_(o) })).chain(async (o) => {
      switch (o.status) {
        case 204:
          return te(void 0);
        default:
          return me(() => o.json()).mapLeft(A_).map((a) => o.ok ? te(a) : N(A_(a))).chain(me.liftEither).mapLeft((a) => ({ status: Hne.get(o.status) ?? "UNKNOWN", message: `[${o.status}] ${a || o.statusText}` }));
      }
    }).mapLeft(({ status: o, message: a }) => new LC({ status: o, message: `${a || "Unknown error"} (from: ${i})` }));
  }
};
zx = zne([le(), jne(0, X(ev.BaseUrl))], zx);
const Hne = /* @__PURE__ */ new Map([[400, "BAD_REQUEST"], [401, "UNAUTHORIZED"]]);
function A_(r) {
  if (r) {
    if (typeof r != "object" || r.toString !== {}.toString) return String(r);
    if ("message" in r) return String(r.message);
  }
}
const Gne = ({ baseUrl: r }) => new mt(({ bind: e }) => {
  e(ev.LKRPDataSource).to(zx), e(ev.BaseUrl).toConstantValue(r);
});
var Kne = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, qne = (r, e) => (t, n) => e(t, n, r);
let jx = class {
  constructor(e) {
    this.appBinder = e;
  }
  execute(e) {
    if (e.trustchainId) return this.appBinder.authenticateWithKeypair(e);
    const t = e.sessionId;
    return t ? this.appBinder.authenticateWithDevice({ ...e, sessionId: t }) : { observable: Ji({ status: id.Error, error: new Pu("Either a trustchainId or a device is required for authentication.") }), cancel: () => {
    } };
  }
};
jx = Kne([le(), qne(0, X(D6.AppBinding))], jx);
var Wne = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Zne = (r, e) => (t, n) => e(t, n, r);
let Hx = class {
  constructor(e) {
    this.cryptoService = e;
  }
  async execute(e, t) {
    const n = new h0(t);
    if (n.extract8BitUInt() !== 0) throw new vr("Unsupported serialization version");
    const i = (s, o) => pe.fromNullable(s).toEither(new vr(`Missing ${o} field`));
    return or({ ephemeralPublicKey: () => i(n.extractFieldByLength(33), "ephemeral public key"), iv: () => i(n.extractFieldByLength(16), "IV"), tag: () => i(n.extractFieldByLength(16), "tag"), encryptedData: () => i(n.extractFieldByLength(n.getUnparsedRemainingLength()), "encrypted data") }).map(async ({ ephemeralPublicKey: s, iv: o, tag: a, encryptedData: c }) => {
      const u = await this.cryptoService.importKeyPair(e, Eo.K256).deriveSharedSecret(s), l = this.cryptoService.hmac(new Uint8Array(), u.slice(1), Hh.SHA256), d = this.cryptoService.importSymmetricKey(l, lo.AES256_GCM), f = new Uint8Array([...c, ...a]);
      return await d.decrypt(o, f);
    }).caseOf({ Left: (s) => {
      throw s;
    }, Right: (s) => s });
  }
};
Hx = Wne([le(), Zne(0, X(lc.CryptoService))], Hx);
var Jne = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Xne = (r, e) => (t, n) => e(t, n, r);
let Gx = class {
  constructor(e) {
    this.cryptoService = e;
  }
  async execute(e, t) {
    const n = this.cryptoService.importKeyPair(e, Eo.K256), i = await this.cryptoService.createKeyPair(Eo.K256), s = await n.deriveSharedSecret(i.getPublicKey()), o = this.cryptoService.hmac(new Uint8Array(), s.slice(1), Hh.SHA256), a = this.cryptoService.randomBytes(16), c = await this.cryptoService.importSymmetricKey(o, lo.AES256_GCM).encrypt(a, t), u = c.subarray(0, -Gy), l = c.subarray(-Gy);
    return new nc().add8BitUIntToData(0).addBufferToData(i.getPublicKey()).addBufferToData(a).addBufferToData(l).addBufferToData(u).build();
  }
};
Gx = Jne([le(), Xne(0, X(lc.CryptoService))], Gx);
const bd = { AuthenticateUseCase: Symbol.for("AuthenticateUseCase"), EncryptDataUseCase: Symbol.for("EncryptDataUseCase"), DecryptDataUseCase: Symbol.for("DecryptDataUseCase") }, Yne = () => new mt(({ bind: r }) => {
  r(bd.AuthenticateUseCase).to(jx), r(bd.EncryptDataUseCase).to(Gx), r(bd.DecryptDataUseCase).to(Hx);
}), Qne = ({ dmk: r, applicationId: e, cryptoService: t, env: n = Wh.PROD, baseUrl: i, stub: s }) => {
  const o = new Uv();
  return o.bind(lc.Dmk).toConstantValue(r), o.bind(lc.ApplicationId).toConstantValue(e), o.bind(lc.CryptoService).toConstantValue(t), o.loadSync(Fne(), Gne({ baseUrl: i ?? eie.get(n) }), Yne()), o;
}, eie = /* @__PURE__ */ new Map([[Wh.PROD, "https://trustchain.api.live.ledger.com/v1"], [Wh.STAGING, "https://trustchain-backend.api.aws.stg.ldg-tech.com/v1"]]);
let tie = class {
  constructor({ dmk: e, applicationId: t, cryptoService: n, env: i, baseUrl: s }) {
    h(this, "name");
    h(this, "_container");
    this.name = "Ledger Keyring Protocol", this._container = Qne({ dmk: e, applicationId: t, cryptoService: n, env: i, baseUrl: s });
  }
  authenticate(e) {
    return this._container.get(bd.AuthenticateUseCase).execute(e);
  }
  encryptData(e, t) {
    return this._container.get(bd.EncryptDataUseCase).execute(e, t);
  }
  decryptData(e, t) {
    return this._container.get(bd.DecryptDataUseCase).execute(e, t);
  }
}, rie = class {
  constructor(e) {
    h(this, "dmk");
    h(this, "applicationId");
    h(this, "env");
    h(this, "baseUrl");
    h(this, "cryptoService", new m0());
    this.dmk = e.dmk, this.applicationId = e.applicationId, this.env = e.env, this.baseUrl = e.baseUrl;
  }
  withCryptoService(e) {
    return this.cryptoService = e, this;
  }
  build() {
    return new tie({ dmk: this.dmk, applicationId: this.applicationId, cryptoService: this.cryptoService, env: this.env, baseUrl: this.baseUrl });
  }
};
var nie = Object.getOwnPropertyDescriptor, iie = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? nie(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, sie = (r, e) => (t, n) => e(t, n, r);
let Kx = class {
  constructor(r) {
    h(this, "logger");
    this.logger = r("GenerateKeyPairUseCase");
  }
  async execute() {
    this.logger.info("Generating new keyPair...");
    const e = await new m0().createKeyPair(Eo.K256);
    if (!e)
      throw new Error("Invalid keyPair");
    return this.logger.info("KeyPair public key", {
      keyPair: e.getPublicKeyToHex()
    }), e;
  }
};
Kx = iie([
  ke(),
  sie(0, H(Me.LoggerPublisher))
], Kx);
var oie = Object.getOwnPropertyDescriptor, aie = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? oie(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, CR = (r, e) => (t, n) => e(t, n, r);
let qx = class {
  constructor(r, e) {
    h(this, "logger");
    this.loggerFactory = r, this.storageService = e, this.logger = this.loggerFactory("[Get Encryption Key Use Case]");
  }
  async execute() {
    const r = await this.storageService.getEncryptionKey();
    if (r.isNothing())
      return this.logger.debug("Encryption key not found, generating new one"), await this.generateAndStoreEncryptionKey();
    const e = r.extract();
    return e || (this.logger.debug("Encryption key is undefined, generating new one"), await this.generateAndStoreEncryptionKey());
  }
  async storeEncryptionKey(r) {
    return new Promise((e, t) => {
      try {
        this.storageService.storeEncryptionKey(r), e();
      } catch (n) {
        this.logger.error("Error storing encryption key", { error: n }), t(n);
      }
    });
  }
  async generateAndStoreEncryptionKey() {
    const r = await window.crypto.subtle.generateKey(
      {
        name: "AES-GCM",
        length: 256
      },
      !1,
      ["encrypt", "decrypt"]
    );
    return await this.storeEncryptionKey(r), r;
  }
};
qx = aie([
  CR(0, H(Me.LoggerPublisher)),
  CR(1, H(zt.StorageService))
], qx);
const Ii = {
  GenerateKeyPairUseCase: Symbol.for("GenerateKeyPairUseCase"),
  EncryptKeyPairUseCase: Symbol.for("EncryptKeyPairUseCase"),
  GetEncryptionKeyUseCase: Symbol.for("GetEncryptionKeyUseCase"),
  GetOrCreateKeyPairUseCase: Symbol.for("GetOrCreateKeyPairUseCase"),
  DecryptKeyPairUseCase: Symbol.for("DecryptKeyPairUseCase")
};
var cie = Object.getOwnPropertyDescriptor, uie = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? cie(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, Rl = (r, e) => (t, n) => e(t, n, r);
let Wx = class {
  constructor(r, e, t, n, i, s) {
    h(this, "logger");
    this.storageService = e, this.generateKeyPairUseCase = t, this.getEncryptionKeyUseCase = n, this.encryptKeyPairUseCase = i, this.decryptKeyPairUseCase = s, this.logger = r("GetOrCreateKeyPairUseCase");
  }
  async execute() {
    this.logger.info("Start Getting/Creating keypair");
    let r;
    const e = await this.storageService.getKeyPair();
    if (e.isRight()) {
      this.logger.info("KeyPair found in storage, decrypting");
      const t = e.extract(), n = await this.getEncryptionKeyUseCase.execute();
      this.logger.debug("Decrypting keypair with pub key", {
        encryptedKeyPair: It(t)
      });
      const i = await this.decryptKeyPairUseCase.execute(
        t,
        n
      );
      this.logger.debug("Decrypted keypair", {
        decryptedKeyPair: It(i)
      }), r = new m0().importKeyPair(i, Eo.K256);
    } else {
      this.logger.info("KeyPair not found in storage, generating new one"), r = await this.generateKeyPairUseCase.execute(), this.logger.info("New keypair generated", {
        keypair: r.getPublicKeyToHex()
      });
      const t = await this.getEncryptionKeyUseCase.execute(), n = await this.encryptKeyPairUseCase.execute(
        r,
        t
      );
      this.logger.info("Storing encrypted keypair in storage", {
        encryptedKeyPair: It(n)
      }), await this.storageService.storeKeyPair(n);
    }
    return this.logger.info("KeyPair retrieved with public key", {
      keypair: r.getPublicKeyToHex()
    }), r;
  }
};
Wx = uie([
  ke(),
  Rl(0, H(Me.LoggerPublisher)),
  Rl(1, H(zt.StorageService)),
  Rl(2, H(Ii.GenerateKeyPairUseCase)),
  Rl(3, H(Ii.GetEncryptionKeyUseCase)),
  Rl(4, H(Ii.EncryptKeyPairUseCase)),
  Rl(5, H(Ii.DecryptKeyPairUseCase))
], Wx);
function lie({
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  stub: r
}) {
  return new $r(({ bind: e }) => {
    e(Ii.GenerateKeyPairUseCase).to(
      Kx
    ), e(Ii.EncryptKeyPairUseCase).to(
      Sx
    ), e(Ii.GetEncryptionKeyUseCase).to(
      qx
    ), e(Ii.GetOrCreateKeyPairUseCase).to(
      Wx
    ), e(Ii.DecryptKeyPairUseCase).to(
      _x
    );
  });
}
var die = Object.getOwnPropertyDescriptor, hie = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? die(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, DR = (r, e) => (t, n) => e(t, n, r);
let Zx = class {
  constructor(r, e) {
    h(this, "dAppConfig", null);
    this.config = r, this.backendService = e;
  }
  async getDAppConfig() {
    if (this.dAppConfig)
      return this.dAppConfig;
    const r = this.config.dAppIdentifier, e = await this.backendService.getConfig({ dAppIdentifier: r });
    if (e.isRight())
      this.dAppConfig = e.extract();
    else
      throw new Error("Failed to get DApp config");
    return this.dAppConfig;
  }
};
Zx = hie([
  ke(),
  DR(0, H(Dt.Config)),
  DR(1, H(xc.BackendService))
], Zx);
const fie = {
  // Generic stub dAppConfig for local/dev usage.
  supportedBlockchains: [
    {
      id: "1",
      currency_id: "ethereum",
      currency_name: "Ethereum",
      currency_ticker: "ETH"
    },
    {
      id: "42161",
      currency_id: "arbitrum",
      currency_name: "Arbitrum",
      currency_ticker: "ARB"
    },
    {
      id: "43114",
      currency_id: "avalanche_c_chain",
      currency_name: "Avalanche C-Chain",
      currency_ticker: "AVAX"
    },
    {
      id: "8453",
      currency_id: "base",
      currency_name: "Base",
      currency_ticker: "BASE"
    },
    {
      id: "56",
      currency_id: "bsc",
      currency_name: "Binance Smart Chain",
      currency_ticker: "BNB"
    },
    {
      id: "59144",
      currency_id: "linea",
      currency_name: "Linea",
      currency_ticker: "LINEA"
    },
    {
      id: "10",
      currency_id: "optimism",
      currency_name: "Optimism",
      currency_ticker: "OP"
    },
    {
      id: "137",
      currency_id: "polygon",
      currency_name: "Polygon",
      currency_ticker: "MATIC"
    },
    {
      id: "146",
      currency_id: "sonic",
      currency_name: "Sonic",
      currency_ticker: "SONIC"
    },
    {
      id: "324",
      currency_id: "zksync",
      currency_name: "ZKsync",
      currency_ticker: "ZK"
    },
    {
      id: "100",
      currency_id: "ethereum/erc20/gnosis",
      // NOTE: this is just a reminder, tokens won't show on Ledger Sync
      currency_name: "Gnosis",
      currency_ticker: "GNO"
    }
  ],
  referralUrl: "https://shop.ledger.com/pages/hardware-wallets-comparison",
  domainUrl: "https://example.com/",
  appDependencies: [
    {
      blockchain: "ethereum",
      // For EVM chains (Ethereum, Base, Arbitrum, ...), the device app to open is "Ethereum".
      appName: "Ethereum",
      dependencies: ["Ethereum"]
    }
  ]
};
function pie({ stub: r }) {
  return new $r(({ rebindSync: e, bind: t }) => {
    t(mc.DAppConfigService).to(
      Zx
    ), r && e(
      mc.DAppConfigService
    ).toConstantValue({
      getDAppConfig() {
        return Promise.resolve(fie);
      }
    });
  });
}
const gie = 15e3, mie = 400, yie = 1200, vie = 3e3, bie = 500, TR = 8;
let wie = class {
  constructor(e, t) {
    h(this, "_dependencies");
    h(this, "_apduFrameSegmenter", pe.empty());
    h(this, "_apduSenderFactory");
    h(this, "_apduReceiverFactory");
    h(this, "_apduFrameReceiver");
    h(this, "_logger");
    h(this, "_mtuNegotiated$", new fa(!1));
    h(this, "_notificationsReady", !1);
    h(this, "_mtuRequestInProgress", !1);
    h(this, "_pendingResponseResolver", pe.empty());
    h(this, "_handleNotification", (e) => {
      const t = e.target;
      if (!t.value) return;
      const n = new Uint8Array(t.value.buffer);
      if (!this._mtuNegotiated$.value) {
        if (!this._mtuRequestInProgress) {
          this._logger.debug("Dropping pre-handshake frame", { data: { data: n } });
          return;
        }
        if (n.length < 6 || n[0] !== TR) {
          this._logger.debug("Non-MTU frame during handshake; dropping", { data: { data: n } });
          return;
        }
        this._handleMtuNegotiationFrame(n);
        return;
      }
      this._handleApduFrame(n);
    });
    this._dependencies = { writeCharacteristic: e.writeCharacteristic, notifyCharacteristic: e.notifyCharacteristic }, this._apduSenderFactory = e.apduSenderFactory, this._apduReceiverFactory = e.apduReceiverFactory, this._apduFrameReceiver = e.apduReceiverFactory(), this._logger = t("WebBleApduSender");
  }
  async sendApdu(e, t, n) {
    try {
      const a = Math.max(1800, n ?? 0);
      await this._waitUntilMtuNegotiated(a);
    } catch (a) {
      return N(a);
    }
    if (!this._isGattConnected()) return this._markLinkUnavailable(), N(new _s("GATT not connected"));
    if (this._apduFrameSegmenter.isNothing()) return N(new LT("Unknown MTU / sender not ready"));
    let i;
    const s = new Promise((a) => {
      this._pendingResponseResolver = pe.of((c) => {
        i && clearTimeout(i), a(c);
      });
    }), o = this._apduFrameSegmenter.map((a) => a.getFrames(e)).orDefault([]);
    for (const a of o) try {
      await this._writeToGattCharacteristic(a.getRawData().slice().buffer);
    } catch (c) {
      const u = t ? "Frame write failed during expected drop" : "Frame write failed";
      this._logger[t ? "debug" : "error"](u, { data: { e: c } }), this._failPendingSend(new _s("Write failed"));
      break;
    }
    return n && (i = setTimeout(() => {
      this._logger.debug("[sendApdu] Abort timeout triggered"), this._pendingResponseResolver.map((a) => a(N(new qL("Abort timeout"))));
    }, n)), s;
  }
  closeConnection() {
    var e;
    try {
      this._failPendingSend(new _s("Connection closed")), this._notificationsReady && (this._dependencies.notifyCharacteristic.removeEventListener("characteristicvaluechanged", this._handleNotification), this._dependencies.notifyCharacteristic.stopNotifications().catch(() => {
      }), this._notificationsReady = !1), (e = this._dependencies.notifyCharacteristic.service.device.gatt) == null || e.disconnect();
    } catch {
      this._logger.error("Failed to disconnect from device");
    } finally {
      this._mtuNegotiated$.next(!1), this._apduFrameSegmenter = pe.empty();
    }
  }
  getDependencies() {
    return this._dependencies;
  }
  setDependencies(e) {
    this._failPendingSend(new _s("Link changed"));
    try {
      this._notificationsReady && (this._dependencies.notifyCharacteristic.removeEventListener("characteristicvaluechanged", this._handleNotification), this._dependencies.notifyCharacteristic.stopNotifications().catch(() => {
      }));
    } catch {
    }
    this._notificationsReady = !1, this._mtuNegotiated$.next(!1), this._apduFrameSegmenter = pe.empty(), this._pendingResponseResolver = pe.empty(), this._dependencies = e, this._apduFrameReceiver = this._apduReceiverFactory();
  }
  async setupConnection() {
    const e = this._dependencies.notifyCharacteristic;
    this._notificationsReady || (await e.startNotifications(), this._logger.debug("Notify armed", { data: { notifyUuid: this._dependencies.notifyCharacteristic.uuid, writeUuid: this._dependencies.writeCharacteristic.uuid, props: this._dependencies.writeCharacteristic.properties } }), this._notificationsReady = !0, e.addEventListener("characteristicvaluechanged", this._handleNotification)), await this._sleep(120), this._mtuRequestInProgress = !0, this._mtuNegotiated$.next(!1), this._apduFrameSegmenter = pe.empty();
    const t = new Uint8Array([TR, 0, 0, 0, 0]);
    try {
      await this._writeToGattCharacteristic(t.buffer), await Promise.race([new Promise((n, i) => {
        const s = setTimeout(() => i(new Error("MTU negotiation timeout")), 2e3), o = this._mtuNegotiated$.subscribe((a) => {
          a && (clearTimeout(s), o.unsubscribe(), n());
        });
      }), this._sleep(2300).then(() => {
        if (!this._isGattConnected()) throw new _s("Link dropped during MTU");
      })]);
    } catch (n) {
      try {
        e.removeEventListener("characteristicvaluechanged", this._handleNotification), await e.stopNotifications().catch(() => {
        });
      } finally {
        this._notificationsReady = !1, this._mtuNegotiated$.next(!1), this._apduFrameSegmenter = pe.empty();
      }
      throw n;
    } finally {
      this._mtuRequestInProgress = !1;
    }
  }
  _isGattConnected() {
    var e;
    try {
      return !!((e = this._dependencies.notifyCharacteristic.service.device.gatt) != null && e.connected);
    } catch {
      return !1;
    }
  }
  _isGattDisconnectedError(e) {
    const t = e, n = (typeof t == "object" && t !== null && "name" in t ? t.name ?? "" : "").toString(), i = (typeof t == "object" && t !== null && "message" in t ? t.message ?? "" : "").toString().toLowerCase();
    return n === "NetworkError" || i.includes("gatt server is disconnected") || i.includes("not connected") || i.includes("cannot perform gatt operations");
  }
  _failPendingSend(e) {
    this._pendingResponseResolver.map((t) => t(N(e))), this._pendingResponseResolver = pe.empty();
  }
  _markLinkUnavailable() {
    this._notificationsReady && (this._dependencies.notifyCharacteristic.removeEventListener("characteristicvaluechanged", this._handleNotification), this._dependencies.notifyCharacteristic.stopNotifications().catch(() => {
    }), this._notificationsReady = !1), this._mtuNegotiated$.next(!1), this._apduFrameSegmenter = pe.empty(), this._pendingResponseResolver = pe.empty();
  }
  async _sleep(e) {
    return new Promise((t) => setTimeout(t, e));
  }
  _handleMtuNegotiationFrame(e) {
    const t = e[5];
    if (t === void 0 || !Number.isFinite(t) || t <= 0) throw new Error("MTU negotiation failed: invalid MTU");
    const n = t;
    this._apduFrameSegmenter = pe.of(this._apduSenderFactory({ frameSize: n })), this._mtuNegotiated$.next(!0);
  }
  _handleApduFrame(e) {
    this._apduFrameReceiver.handleFrame(e).map((t) => t.map((n) => {
      this._logger.debug("Received APDU", { data: { resp: n } }), this._pendingResponseResolver.map((i) => i(te(n))), this._pendingResponseResolver = pe.empty();
    })).mapLeft((t) => {
      this._pendingResponseResolver.map((n) => n(N(t))), this._pendingResponseResolver = pe.empty();
    });
  }
  async _writeToGattCharacteristic(e) {
    const t = this._dependencies.writeCharacteristic;
    if (!this._isGattConnected()) throw this._markLinkUnavailable(), new _s("GATT not connected");
    const n = typeof t.writeValueWithoutResponse == "function", i = typeof t.writeValueWithResponse == "function";
    if (t.properties.writeWithoutResponse && n) try {
      await t.writeValueWithoutResponse(e);
      return;
    } catch (s) {
      if (this._isGattDisconnectedError(s) || !this._isGattConnected()) throw this._markLinkUnavailable(), new _s("Write failed");
    }
    if (t.properties.write && i) {
      await t.writeValueWithResponse(e);
      return;
    }
    throw new Error("No supported write method for characteristic");
  }
  async _waitUntilMtuNegotiated(e = 2e3) {
    if (!(this._notificationsReady && this._mtuNegotiated$.value && this._isGattConnected())) return new Promise((t, n) => {
      const i = this._mtuNegotiated$.subscribe((o) => {
        o && this._notificationsReady && this._isGattConnected() && (clearTimeout(s), i.unsubscribe(), t());
      }), s = setTimeout(() => {
        i.unsubscribe(), n(new LT("Link not ready"));
      }, e);
      this._notificationsReady && this._mtuNegotiated$.value && this._isGattConnected() && (clearTimeout(s), i.unsubscribe(), t());
    });
  }
};
const yp = "WEB-BLE-RN-STYLE";
let _ie = class {
  constructor(e, t, n, i) {
    h(this, "_logger");
    h(this, "_connectionStateMachinesByDeviceId", /* @__PURE__ */ new Map());
    h(this, "_deviceRegistryById", /* @__PURE__ */ new Map());
    h(this, "_discoveredDevices$", new fa([]));
    this._deviceModelDataSource = e, this.loggerFactory = t, this._apduSenderFactory = n, this._apduReceiverFactory = i, this._logger = t("WebBleTransportRnStyle");
  }
  isSupported() {
    return typeof navigator < "u" && !!navigator.bluetooth;
  }
  getIdentifier() {
    return yp;
  }
  startDiscovering() {
    const e = this._deviceModelDataSource.getBluetoothServices().map((n) => ({ services: [n] })), t = this._deviceModelDataSource.getBluetoothServices();
    return rn(navigator.bluetooth.requestDevice({ filters: e, optionalServices: t })).pipe(Qr(async (n) => {
      const { serviceUuid: i, ledgerServiceInfo: s } = await this._identifyLedgerGattService(n), o = { id: n.id, deviceModel: s.deviceModel, transport: yp };
      return this._deviceRegistryById.set(n.id, { device: n, serviceUuid: i, ledgerServiceInfo: s, discoveredDevice: o }), this._publishDiscoveredDevices(), o;
    }));
  }
  stopDiscovering() {
  }
  listenToAvailableDevices() {
    return this._publishDiscoveredDevices(), this._discoveredDevices$.asObservable();
  }
  async connect(e) {
    const t = this._deviceRegistryById.get(e.deviceId);
    if (!t) return N(new Jl(`Unknown device ${e.deviceId}`));
    if (this._connectionStateMachinesByDeviceId.has(e.deviceId)) return N(new Cz(`Device ${e.deviceId} already connected`));
    try {
      const n = t.device;
      if (!n.gatt) throw new Gs("No GATT server available on device");
      n.gatt.connected || (await this._withTimeout(n.gatt.connect(), 6e3, "GATT connect timed out"), await this._sleep(150));
      const { service: i, ledgerServiceInfo: s } = await this._getPrimaryLedgerGattService(n), { writeCharacteristic: o, notifyCharacteristic: a } = await this._resolveLedgerServiceCharacteristics(i, s), c = new wie({ writeCharacteristic: o, notifyCharacteristic: a, apduSenderFactory: this._apduSenderFactory, apduReceiverFactory: this._apduReceiverFactory }, this.loggerFactory), u = new pF({ deviceId: e.deviceId, deviceApduSender: c, timeoutDuration: gie, tryToReconnect: () => {
        this._tryToReconnect(e.deviceId, e.onReconnect).catch((d) => this._logger.error("tryToReconnect() threw", { data: { e: d } }));
      }, onTerminated: () => {
        var d;
        try {
          (d = this._connectionStateMachinesByDeviceId.get(e.deviceId)) == null || d.closeConnection(), e.onDisconnect(e.deviceId);
        } finally {
          this._connectionStateMachinesByDeviceId.delete(e.deviceId);
          const f = this._deviceRegistryById.get(e.deviceId);
          f != null && f.gattDisconnectListener && (f.device.removeEventListener("gattserverdisconnected", f.gattDisconnectListener), f.gattDisconnectListener = void 0), this._publishDiscoveredDevices();
        }
      } });
      await c.setupConnection(), this._connectionStateMachinesByDeviceId.set(e.deviceId, u), t.serviceUuid = i.uuid, t.ledgerServiceInfo = s;
      const l = (d) => this._handleGattServerDisconnected(e.deviceId);
      return t.gattDisconnectListener = l, n.addEventListener("gattserverdisconnected", l), this._publishDiscoveredDevices(), te(new vE({ id: e.deviceId, deviceModel: s.deviceModel, type: "BLE", transport: yp, sendApdu: (...d) => u.sendApdu(...d) }));
    } catch (n) {
      return this._logger.error("connect() error", { data: { e: n } }), N(new Gs(n));
    }
  }
  async disconnect(e) {
    const t = e.connectedDevice.id, n = this._connectionStateMachinesByDeviceId.get(t), i = this._deviceRegistryById.get(t);
    if (!n) return N(new Jl(`Unknown device ${t}`));
    try {
      return n.closeConnection(), this._connectionStateMachinesByDeviceId.delete(t), i != null && i.gattDisconnectListener && (i.device.removeEventListener("gattserverdisconnected", i.gattDisconnectListener), i.gattDisconnectListener = void 0), await this._safelyCancelGattConnection(t), this._publishDiscoveredDevices(), te(void 0);
    } catch (s) {
      return N(new vn({ originalError: s }));
    }
  }
  _handleGattServerDisconnected(e) {
    this._logger.debug(`[${e}] gattserverdisconnected`);
    const t = this._connectionStateMachinesByDeviceId.get(e);
    t && t.eventDeviceDisconnected();
  }
  async _waitForAdvertisementInRange(e, t = {}) {
    const { startTimeoutMs: n = 500, advTimeoutMs: i = 1500 } = t;
    if (typeof e.watchAdvertisements != "function") return !1;
    const s = new AbortController(), o = setTimeout(() => s.abort(), n), a = await e.watchAdvertisements({ signal: s.signal }).then(() => !0).catch(() => !1);
    if (clearTimeout(o), !a) return !1;
    const c = await new Promise((u) => {
      const l = () => {
        e.removeEventListener("advertisementreceived", l), u(!0);
      };
      e.addEventListener("advertisementreceived", l), setTimeout(() => {
        e.removeEventListener("advertisementreceived", l), u(!1);
      }, i);
    });
    return s.abort(), c;
  }
  async _rediscoverPermittedDevice(e) {
    if (typeof navigator.bluetooth.getDevices != "function") return null;
    try {
      this._logger.debug(`Attempting to rediscover device ${e}`);
      const t = (await navigator.bluetooth.getDevices()).find((n) => n.id === e) ?? null;
      if (t) {
        const n = await this._waitForAdvertisementInRange(t, { startTimeoutMs: mie, advTimeoutMs: yie });
        this._logger.debug(`Rediscovered ${t.id}, inRange=${n}`);
      }
      return t;
    } catch {
      return null;
    }
  }
  async _tryToReconnect(e, t) {
    var n;
    for (await this._safelyCancelGattConnection(e); ; ) {
      const i = this._deviceRegistryById.get(e), s = this._connectionStateMachinesByDeviceId.get(e);
      if (!i || !s) {
        this._logger.debug(`[${e}] aborting reconnect: registry or state machine missing`);
        return;
      }
      try {
        const o = await this._withTimeout(this._rediscoverPermittedDevice(e), vie, "rediscovery timeout");
        if (!o) throw new Error("Device not found");
        if (!o.gatt) throw new Error("No GATT on device");
        try {
          await o.gatt.connect();
        } catch (f) {
          this._logger.error(`[${e}] gatt.connect() failed`, { data: { e: f } }), o.gatt.connected && o.gatt.disconnect();
        }
        const { service: a, ledgerServiceInfo: c } = await this._getPrimaryLedgerGattService(o), { writeCharacteristic: u, notifyCharacteristic: l } = await this._resolveLedgerServiceCharacteristics(a, c);
        s.setDependencies({ writeCharacteristic: u, notifyCharacteristic: l }), await s.setupConnection(), s.eventDeviceConnected(), i.serviceUuid = a.uuid, i.ledgerServiceInfo = c, i.gattDisconnectListener && o.removeEventListener("gattserverdisconnected", i.gattDisconnectListener);
        const d = (f) => this._handleGattServerDisconnected(e);
        o.addEventListener("gattserverdisconnected", d), i.gattDisconnectListener = d, await (t == null ? void 0 : t(e)), this._publishDiscoveredDevices();
        return;
      } catch (o) {
        this._logger.error(`[${e}] reconnect attempt failed`, { data: { e: o } }), (n = i == null ? void 0 : i.device.gatt) != null && n.connected && i.device.gatt.disconnect(), await this._sleep(bie);
        continue;
      }
    }
  }
  async _safelyCancelGattConnection(e) {
    var n;
    const t = this._deviceRegistryById.get(e);
    t && ((n = t.device.gatt) != null && n.connected && t.device.gatt.disconnect(), await this._sleep(100));
  }
  async _identifyLedgerGattService(e) {
    var t;
    if (!e.gatt) throw new Gs("No GATT server available on device");
    try {
      await this._withTimeout(e.gatt.connect(), 6e3, "connect timeout");
      const { service: n, ledgerServiceInfo: i } = await this._getPrimaryLedgerGattService(e);
      return { serviceUuid: n.uuid, ledgerServiceInfo: i };
    } finally {
      (t = e.gatt) == null || t.disconnect(), await this._sleep(200);
    }
  }
  async _getPrimaryLedgerGattService(e) {
    var s;
    const t = this._deviceModelDataSource.getBluetoothServices(), n = (s = this._deviceRegistryById.get(e.id)) == null ? void 0 : s.serviceUuid, i = n ? [n, ...t.filter((o) => o !== n)] : t.slice();
    for (const o of i) try {
      const a = await e.gatt.getPrimaryService(o), c = this._deviceModelDataSource.getBluetoothServicesInfos()[a.uuid];
      if (!c) throw new Jl(e.name || "");
      return { service: a, ledgerServiceInfo: c };
    } catch (a) {
      if ((a == null ? void 0 : a.name) === "SecurityError") throw new Gs(`Missing Web Bluetooth permission for service ${o}. Add it to optionalServices in requestDevice().`);
      try {
        const c = (await e.gatt.getPrimaryServices()).find((u) => u.uuid.toLowerCase() === o.toLowerCase());
        if (c) {
          const u = this._deviceModelDataSource.getBluetoothServicesInfos()[c.uuid];
          if (!u) throw new Jl(e.name || "");
          return { service: c, ledgerServiceInfo: u };
        }
      } catch {
        this._logger.error("Failed to get primary services", { data: { deviceId: e.id } });
      }
    }
    throw new Gs("Ledger GATT service not found");
  }
  async _resolveLedgerServiceCharacteristics(e, t) {
    const n = await e.getCharacteristic(t.notifyUuid);
    return { writeCharacteristic: await this._findWritableCharacteristic(e, t), notifyCharacteristic: n };
  }
  async _findWritableCharacteristic(e, t) {
    const n = [t.writeCmdUuid, t.writeUuid].filter(Boolean), i = [];
    for (const s of n) try {
      const o = await e.getCharacteristic(s);
      if (i.push(o), o.properties.writeWithoutResponse || o.properties.write) return o;
    } catch {
      this._logger.error("Failed to get write characteristic", { data: { deviceId: e.device.id } });
    }
    throw new Gs("No write characteristic available");
  }
  _publishDiscoveredDevices() {
    const e = [];
    for (const [n] of this._connectionStateMachinesByDeviceId) {
      const i = this._deviceRegistryById.get(n);
      i != null && i.ledgerServiceInfo && e.push({ id: n, deviceModel: i.ledgerServiceInfo.deviceModel, transport: yp });
    }
    const t = Array.from(this._deviceRegistryById.values()).map((n) => n.discoveredDevice).filter((n) => !this._connectionStateMachinesByDeviceId.has(n.id));
    this._discoveredDevices$.next([...e, ...t]);
  }
  _withTimeout(e, t, n, i) {
    return new Promise((s, o) => {
      const a = setTimeout(() => {
        o(new Gs(n)), i == null || i();
      }, t);
      e.then((c) => {
        clearTimeout(a), s(c);
      }, (c) => {
        this._logger.error("withTimeout() promise rejected", { data: { e: c } }), clearTimeout(a), o(c);
      });
    });
  }
  _sleep(e) {
    return new Promise((t) => setTimeout(t, e));
  }
};
const Sie = ({ deviceModelDataSource: r, loggerServiceFactory: e, apduSenderServiceFactory: t, apduReceiverServiceFactory: n }) => new _ie(r, e, t, n);
let Eie = class extends vn {
  constructor(t) {
    super(t);
    h(this, "_tag", "WebHidTransportNotSupportedError");
    this.err = t;
  }
}, xie = class extends vn {
  constructor(t) {
    super(t);
    h(this, "_tag", "WebHidSendReportError");
    this.err = t;
  }
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Ke = function() {
  return Ke = Object.assign || function(e) {
    for (var t, n = 1, i = arguments.length; n < i; n++) {
      t = arguments[n];
      for (var s in t) Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
    }
    return e;
  }, Ke.apply(this, arguments);
};
function Aie(r) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && r[e], n = 0;
  if (t) return t.call(r);
  if (r && typeof r.length == "number") return {
    next: function() {
      return r && n >= r.length && (r = void 0), { value: r && r[n++], done: !r };
    }
  };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Iie(r, e) {
  var t = typeof Symbol == "function" && r[Symbol.iterator];
  if (!t) return r;
  var n = t.call(r), i, s = [], o;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; ) s.push(i.value);
  } catch (a) {
    o = { error: a };
  } finally {
    try {
      i && !i.done && (t = n.return) && t.call(n);
    } finally {
      if (o) throw o.error;
    }
  }
  return s;
}
function Na() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r = r.concat(Iie(arguments[e]));
  return r;
}
function Cie() {
  return typeof __SENTRY_BROWSER_BUNDLE__ < "u" && !!__SENTRY_BROWSER_BUNDLE__;
}
function FC() {
  return !Cie() && Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]";
}
function Die(r, e) {
  return r.require(e);
}
var Tie = {};
function Dc() {
  return FC() ? global : typeof window < "u" ? window : typeof self < "u" ? self : Tie;
}
function MC(r, e, t) {
  var n = t || Dc(), i = n.__SENTRY__ = n.__SENTRY__ || {}, s = i[r] || (i[r] = e());
  return s;
}
var kie = Object.prototype.toString;
function Oie(r, e) {
  return kie.call(r) === "[object " + e + "]";
}
function O6(r) {
  return Oie(r, "Object");
}
function $6(r) {
  return !!(r && r.then && typeof r.then == "function");
}
var R6 = typeof __SENTRY_DEBUG__ > "u" ? !0 : __SENTRY_DEBUG__, $ie = Dc(), Rie = "Sentry Logger ", Jx = ["debug", "info", "warn", "error", "log", "assert"];
function P6(r) {
  var e = Dc();
  if (!("console" in e))
    return r();
  var t = e.console, n = {};
  Jx.forEach(function(i) {
    var s = t[i] && t[i].__sentry_original__;
    i in e.console && s && (n[i] = t[i], t[i] = s);
  });
  try {
    return r();
  } finally {
    Object.keys(n).forEach(function(i) {
      t[i] = n[i];
    });
  }
}
function kR() {
  var r = !1, e = {
    enable: function() {
      r = !0;
    },
    disable: function() {
      r = !1;
    }
  };
  return R6 ? Jx.forEach(function(t) {
    e[t] = function() {
      for (var n = [], i = 0; i < arguments.length; i++)
        n[i] = arguments[i];
      r && P6(function() {
        var s;
        (s = $ie.console)[t].apply(s, Na([Rie + "[" + t + "]:"], n));
      });
    };
  }) : Jx.forEach(function(t) {
    e[t] = function() {
    };
  }), e;
}
var tv;
R6 ? tv = MC("logger", kR) : tv = kR();
function Xx(r) {
  var e, t;
  if (O6(r)) {
    var n = {};
    try {
      for (var i = Aie(Object.keys(r)), s = i.next(); !s.done; s = i.next()) {
        var o = s.value;
        typeof r[o] < "u" && (n[o] = Xx(r[o]));
      }
    } catch (a) {
      e = { error: a };
    } finally {
      try {
        s && !s.done && (t = i.return) && t.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return n;
  }
  return Array.isArray(r) ? r.map(Xx) : r;
}
function Op() {
  var r = Dc(), e = r.crypto || r.msCrypto;
  if (e !== void 0 && e.getRandomValues) {
    var t = new Uint16Array(8);
    e.getRandomValues(t), t[3] = t[3] & 4095 | 16384, t[4] = t[4] & 16383 | 32768;
    var n = function(i) {
      for (var s = i.toString(16); s.length < 4; )
        s = "0" + s;
      return s;
    };
    return n(t[0]) + n(t[1]) + n(t[2]) + n(t[3]) + n(t[4]) + n(t[5]) + n(t[6]) + n(t[7]);
  }
  return "xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx".replace(/[xy]/g, function(i) {
    var s = Math.random() * 16 | 0, o = i === "x" ? s : s & 3 | 8;
    return o.toString(16);
  });
}
var Pie = (
  /** @class */
  (function() {
    function r(e) {
      var t = this;
      this._state = 0, this._handlers = [], this._resolve = function(n) {
        t._setResult(1, n);
      }, this._reject = function(n) {
        t._setResult(2, n);
      }, this._setResult = function(n, i) {
        if (t._state === 0) {
          if ($6(i)) {
            i.then(t._resolve, t._reject);
            return;
          }
          t._state = n, t._value = i, t._executeHandlers();
        }
      }, this._executeHandlers = function() {
        if (t._state !== 0) {
          var n = t._handlers.slice();
          t._handlers = [], n.forEach(function(i) {
            i[0] || (t._state === 1 && i[1](t._value), t._state === 2 && i[2](t._value), i[0] = !0);
          });
        }
      };
      try {
        e(this._resolve, this._reject);
      } catch (n) {
        this._reject(n);
      }
    }
    return r.prototype.then = function(e, t) {
      var n = this;
      return new r(function(i, s) {
        n._handlers.push([
          !1,
          function(o) {
            if (!e)
              i(o);
            else
              try {
                i(e(o));
              } catch (a) {
                s(a);
              }
          },
          function(o) {
            if (!t)
              s(o);
            else
              try {
                i(t(o));
              } catch (a) {
                s(a);
              }
          }
        ]), n._executeHandlers();
      });
    }, r.prototype.catch = function(e) {
      return this.then(function(t) {
        return t;
      }, e);
    }, r.prototype.finally = function(e) {
      var t = this;
      return new r(function(n, i) {
        var s, o;
        return t.then(function(a) {
          o = !1, s = a, e && e();
        }, function(a) {
          o = !0, s = a, e && e();
        }).then(function() {
          if (o) {
            i(s);
            return;
          }
          n(s);
        });
      });
    }, r;
  })()
), Yx = {
  nowSeconds: function() {
    return Date.now() / 1e3;
  }
};
function Nie() {
  var r = Dc().performance;
  if (!(!r || !r.now)) {
    var e = Date.now() - r.now();
    return {
      now: function() {
        return r.now();
      },
      timeOrigin: e
    };
  }
}
function Bie() {
  try {
    var r = Die(module, "perf_hooks");
    return r.performance;
  } catch {
    return;
  }
}
var I_ = FC() ? Bie() : Nie(), OR = I_ === void 0 ? Yx : {
  nowSeconds: function() {
    return (I_.timeOrigin + I_.now()) / 1e3;
  }
}, N6 = Yx.nowSeconds.bind(Yx), $R = OR.nowSeconds.bind(OR);
(function() {
  var r = Dc().performance;
  if (!(!r || !r.now)) {
    var e = 3600 * 1e3, t = r.now(), n = Date.now(), i = r.timeOrigin ? Math.abs(r.timeOrigin + t - n) : e, s = i < e, o = r.timing && r.timing.navigationStart, a = typeof o == "number", c = a ? Math.abs(o + t - n) : e, u = c < e;
    return s || u ? i <= c ? r.timeOrigin : o : n;
  }
})();
var RR = 100, Qx = (
  /** @class */
  (function() {
    function r() {
      this._notifyingListeners = !1, this._scopeListeners = [], this._eventProcessors = [], this._breadcrumbs = [], this._user = {}, this._tags = {}, this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {};
    }
    return r.clone = function(e) {
      var t = new r();
      return e && (t._breadcrumbs = Na(e._breadcrumbs), t._tags = Ke({}, e._tags), t._extra = Ke({}, e._extra), t._contexts = Ke({}, e._contexts), t._user = e._user, t._level = e._level, t._span = e._span, t._session = e._session, t._transactionName = e._transactionName, t._fingerprint = e._fingerprint, t._eventProcessors = Na(e._eventProcessors), t._requestSession = e._requestSession), t;
    }, r.prototype.addScopeListener = function(e) {
      this._scopeListeners.push(e);
    }, r.prototype.addEventProcessor = function(e) {
      return this._eventProcessors.push(e), this;
    }, r.prototype.setUser = function(e) {
      return this._user = e || {}, this._session && this._session.update({ user: e }), this._notifyScopeListeners(), this;
    }, r.prototype.getUser = function() {
      return this._user;
    }, r.prototype.getRequestSession = function() {
      return this._requestSession;
    }, r.prototype.setRequestSession = function(e) {
      return this._requestSession = e, this;
    }, r.prototype.setTags = function(e) {
      return this._tags = Ke(Ke({}, this._tags), e), this._notifyScopeListeners(), this;
    }, r.prototype.setTag = function(e, t) {
      var n;
      return this._tags = Ke(Ke({}, this._tags), (n = {}, n[e] = t, n)), this._notifyScopeListeners(), this;
    }, r.prototype.setExtras = function(e) {
      return this._extra = Ke(Ke({}, this._extra), e), this._notifyScopeListeners(), this;
    }, r.prototype.setExtra = function(e, t) {
      var n;
      return this._extra = Ke(Ke({}, this._extra), (n = {}, n[e] = t, n)), this._notifyScopeListeners(), this;
    }, r.prototype.setFingerprint = function(e) {
      return this._fingerprint = e, this._notifyScopeListeners(), this;
    }, r.prototype.setLevel = function(e) {
      return this._level = e, this._notifyScopeListeners(), this;
    }, r.prototype.setTransactionName = function(e) {
      return this._transactionName = e, this._notifyScopeListeners(), this;
    }, r.prototype.setTransaction = function(e) {
      return this.setTransactionName(e);
    }, r.prototype.setContext = function(e, t) {
      var n;
      return t === null ? delete this._contexts[e] : this._contexts = Ke(Ke({}, this._contexts), (n = {}, n[e] = t, n)), this._notifyScopeListeners(), this;
    }, r.prototype.setSpan = function(e) {
      return this._span = e, this._notifyScopeListeners(), this;
    }, r.prototype.getSpan = function() {
      return this._span;
    }, r.prototype.getTransaction = function() {
      var e = this.getSpan();
      return e && e.transaction;
    }, r.prototype.setSession = function(e) {
      return e ? this._session = e : delete this._session, this._notifyScopeListeners(), this;
    }, r.prototype.getSession = function() {
      return this._session;
    }, r.prototype.update = function(e) {
      if (!e)
        return this;
      if (typeof e == "function") {
        var t = e(this);
        return t instanceof r ? t : this;
      }
      return e instanceof r ? (this._tags = Ke(Ke({}, this._tags), e._tags), this._extra = Ke(Ke({}, this._extra), e._extra), this._contexts = Ke(Ke({}, this._contexts), e._contexts), e._user && Object.keys(e._user).length && (this._user = e._user), e._level && (this._level = e._level), e._fingerprint && (this._fingerprint = e._fingerprint), e._requestSession && (this._requestSession = e._requestSession)) : O6(e) && (e = e, this._tags = Ke(Ke({}, this._tags), e.tags), this._extra = Ke(Ke({}, this._extra), e.extra), this._contexts = Ke(Ke({}, this._contexts), e.contexts), e.user && (this._user = e.user), e.level && (this._level = e.level), e.fingerprint && (this._fingerprint = e.fingerprint), e.requestSession && (this._requestSession = e.requestSession)), this;
    }, r.prototype.clear = function() {
      return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, this._requestSession = void 0, this._span = void 0, this._session = void 0, this._notifyScopeListeners(), this;
    }, r.prototype.addBreadcrumb = function(e, t) {
      var n = typeof t == "number" ? Math.min(t, RR) : RR;
      if (n <= 0)
        return this;
      var i = Ke({ timestamp: N6() }, e);
      return this._breadcrumbs = Na(this._breadcrumbs, [i]).slice(-n), this._notifyScopeListeners(), this;
    }, r.prototype.clearBreadcrumbs = function() {
      return this._breadcrumbs = [], this._notifyScopeListeners(), this;
    }, r.prototype.applyToEvent = function(e, t) {
      if (this._extra && Object.keys(this._extra).length && (e.extra = Ke(Ke({}, this._extra), e.extra)), this._tags && Object.keys(this._tags).length && (e.tags = Ke(Ke({}, this._tags), e.tags)), this._user && Object.keys(this._user).length && (e.user = Ke(Ke({}, this._user), e.user)), this._contexts && Object.keys(this._contexts).length && (e.contexts = Ke(Ke({}, this._contexts), e.contexts)), this._level && (e.level = this._level), this._transactionName && (e.transaction = this._transactionName), this._span) {
        e.contexts = Ke({ trace: this._span.getTraceContext() }, e.contexts);
        var n = this._span.transaction && this._span.transaction.name;
        n && (e.tags = Ke({ transaction: n }, e.tags));
      }
      return this._applyFingerprint(e), e.breadcrumbs = Na(e.breadcrumbs || [], this._breadcrumbs), e.breadcrumbs = e.breadcrumbs.length > 0 ? e.breadcrumbs : void 0, e.sdkProcessingMetadata = this._sdkProcessingMetadata, this._notifyEventProcessors(Na(Lie(), this._eventProcessors), e, t);
    }, r.prototype.setSDKProcessingMetadata = function(e) {
      return this._sdkProcessingMetadata = Ke(Ke({}, this._sdkProcessingMetadata), e), this;
    }, r.prototype._notifyEventProcessors = function(e, t, n, i) {
      var s = this;
      return i === void 0 && (i = 0), new Pie(function(o, a) {
        var c = e[i];
        if (t === null || typeof c != "function")
          o(t);
        else {
          var u = c(Ke({}, t), n);
          $6(u) ? u.then(function(l) {
            return s._notifyEventProcessors(e, l, n, i + 1).then(o);
          }).then(null, a) : s._notifyEventProcessors(e, u, n, i + 1).then(o).then(null, a);
        }
      });
    }, r.prototype._notifyScopeListeners = function() {
      var e = this;
      this._notifyingListeners || (this._notifyingListeners = !0, this._scopeListeners.forEach(function(t) {
        t(e);
      }), this._notifyingListeners = !1);
    }, r.prototype._applyFingerprint = function(e) {
      e.fingerprint = e.fingerprint ? Array.isArray(e.fingerprint) ? e.fingerprint : [e.fingerprint] : [], this._fingerprint && (e.fingerprint = e.fingerprint.concat(this._fingerprint)), e.fingerprint && !e.fingerprint.length && delete e.fingerprint;
    }, r;
  })()
);
function Lie() {
  return MC("globalEventProcessors", function() {
    return [];
  });
}
var Uie = (
  /** @class */
  (function() {
    function r(e) {
      this.errors = 0, this.sid = Op(), this.duration = 0, this.status = "ok", this.init = !0, this.ignoreDuration = !1;
      var t = $R();
      this.timestamp = t, this.started = t, e && this.update(e);
    }
    return r.prototype.update = function(e) {
      if (e === void 0 && (e = {}), e.user && (!this.ipAddress && e.user.ip_address && (this.ipAddress = e.user.ip_address), !this.did && !e.did && (this.did = e.user.id || e.user.email || e.user.username)), this.timestamp = e.timestamp || $R(), e.ignoreDuration && (this.ignoreDuration = e.ignoreDuration), e.sid && (this.sid = e.sid.length === 32 ? e.sid : Op()), e.init !== void 0 && (this.init = e.init), !this.did && e.did && (this.did = "" + e.did), typeof e.started == "number" && (this.started = e.started), this.ignoreDuration)
        this.duration = void 0;
      else if (typeof e.duration == "number")
        this.duration = e.duration;
      else {
        var t = this.timestamp - this.started;
        this.duration = t >= 0 ? t : 0;
      }
      e.release && (this.release = e.release), e.environment && (this.environment = e.environment), !this.ipAddress && e.ipAddress && (this.ipAddress = e.ipAddress), !this.userAgent && e.userAgent && (this.userAgent = e.userAgent), typeof e.errors == "number" && (this.errors = e.errors), e.status && (this.status = e.status);
    }, r.prototype.close = function(e) {
      e ? this.update({ status: e }) : this.status === "ok" ? this.update({ status: "exited" }) : this.update();
    }, r.prototype.toJSON = function() {
      return Xx({
        sid: "" + this.sid,
        init: this.init,
        // Make sure that sec is converted to ms for date constructor
        started: new Date(this.started * 1e3).toISOString(),
        timestamp: new Date(this.timestamp * 1e3).toISOString(),
        status: this.status,
        errors: this.errors,
        did: typeof this.did == "number" || typeof this.did == "string" ? "" + this.did : void 0,
        duration: this.duration,
        attrs: {
          release: this.release,
          environment: this.environment,
          ip_address: this.ipAddress,
          user_agent: this.userAgent
        }
      });
    }, r;
  })()
), PR = typeof __SENTRY_DEBUG__ > "u" ? !0 : __SENTRY_DEBUG__, VC = 4, Fie = 100, zC = (
  /** @class */
  (function() {
    function r(e, t, n) {
      t === void 0 && (t = new Qx()), n === void 0 && (n = VC), this._version = n, this._stack = [{}], this.getStackTop().scope = t, e && this.bindClient(e);
    }
    return r.prototype.isOlderThan = function(e) {
      return this._version < e;
    }, r.prototype.bindClient = function(e) {
      var t = this.getStackTop();
      t.client = e, e && e.setupIntegrations && e.setupIntegrations();
    }, r.prototype.pushScope = function() {
      var e = Qx.clone(this.getScope());
      return this.getStack().push({
        client: this.getClient(),
        scope: e
      }), e;
    }, r.prototype.popScope = function() {
      return this.getStack().length <= 1 ? !1 : !!this.getStack().pop();
    }, r.prototype.withScope = function(e) {
      var t = this.pushScope();
      try {
        e(t);
      } finally {
        this.popScope();
      }
    }, r.prototype.getClient = function() {
      return this.getStackTop().client;
    }, r.prototype.getScope = function() {
      return this.getStackTop().scope;
    }, r.prototype.getStack = function() {
      return this._stack;
    }, r.prototype.getStackTop = function() {
      return this._stack[this._stack.length - 1];
    }, r.prototype.captureException = function(e, t) {
      var n = this._lastEventId = t && t.event_id ? t.event_id : Op(), i = t;
      if (!t) {
        var s = void 0;
        try {
          throw new Error("Sentry syntheticException");
        } catch (o) {
          s = o;
        }
        i = {
          originalException: e,
          syntheticException: s
        };
      }
      return this._invokeClient("captureException", e, Ke(Ke({}, i), { event_id: n })), n;
    }, r.prototype.captureMessage = function(e, t, n) {
      var i = this._lastEventId = n && n.event_id ? n.event_id : Op(), s = n;
      if (!n) {
        var o = void 0;
        try {
          throw new Error(e);
        } catch (a) {
          o = a;
        }
        s = {
          originalException: e,
          syntheticException: o
        };
      }
      return this._invokeClient("captureMessage", e, t, Ke(Ke({}, s), { event_id: i })), i;
    }, r.prototype.captureEvent = function(e, t) {
      var n = t && t.event_id ? t.event_id : Op();
      return e.type !== "transaction" && (this._lastEventId = n), this._invokeClient("captureEvent", e, Ke(Ke({}, t), { event_id: n })), n;
    }, r.prototype.lastEventId = function() {
      return this._lastEventId;
    }, r.prototype.addBreadcrumb = function(e, t) {
      var n = this.getStackTop(), i = n.scope, s = n.client;
      if (!(!i || !s)) {
        var o = s.getOptions && s.getOptions() || {}, a = o.beforeBreadcrumb, c = a === void 0 ? null : a, u = o.maxBreadcrumbs, l = u === void 0 ? Fie : u;
        if (!(l <= 0)) {
          var d = N6(), f = Ke({ timestamp: d }, e), p = c ? P6(function() {
            return c(f, t);
          }) : f;
          p !== null && i.addBreadcrumb(p, l);
        }
      }
    }, r.prototype.setUser = function(e) {
      var t = this.getScope();
      t && t.setUser(e);
    }, r.prototype.setTags = function(e) {
      var t = this.getScope();
      t && t.setTags(e);
    }, r.prototype.setExtras = function(e) {
      var t = this.getScope();
      t && t.setExtras(e);
    }, r.prototype.setTag = function(e, t) {
      var n = this.getScope();
      n && n.setTag(e, t);
    }, r.prototype.setExtra = function(e, t) {
      var n = this.getScope();
      n && n.setExtra(e, t);
    }, r.prototype.setContext = function(e, t) {
      var n = this.getScope();
      n && n.setContext(e, t);
    }, r.prototype.configureScope = function(e) {
      var t = this.getStackTop(), n = t.scope, i = t.client;
      n && i && e(n);
    }, r.prototype.run = function(e) {
      var t = NR(this);
      try {
        e(this);
      } finally {
        NR(t);
      }
    }, r.prototype.getIntegration = function(e) {
      var t = this.getClient();
      if (!t)
        return null;
      try {
        return t.getIntegration(e);
      } catch {
        return PR && tv.warn("Cannot retrieve integration " + e.id + " from the current Hub"), null;
      }
    }, r.prototype.startSpan = function(e) {
      return this._callExtensionMethod("startSpan", e);
    }, r.prototype.startTransaction = function(e, t) {
      return this._callExtensionMethod("startTransaction", e, t);
    }, r.prototype.traceHeaders = function() {
      return this._callExtensionMethod("traceHeaders");
    }, r.prototype.captureSession = function(e) {
      if (e === void 0 && (e = !1), e)
        return this.endSession();
      this._sendSessionUpdate();
    }, r.prototype.endSession = function() {
      var e = this.getStackTop(), t = e && e.scope, n = t && t.getSession();
      n && n.close(), this._sendSessionUpdate(), t && t.setSession();
    }, r.prototype.startSession = function(e) {
      var t = this.getStackTop(), n = t.scope, i = t.client, s = i && i.getOptions() || {}, o = s.release, a = s.environment, c = Dc(), u = (c.navigator || {}).userAgent, l = new Uie(Ke(Ke(Ke({
        release: o,
        environment: a
      }, n && { user: n.getUser() }), u && { userAgent: u }), e));
      if (n) {
        var d = n.getSession && n.getSession();
        d && d.status === "ok" && d.update({ status: "exited" }), this.endSession(), n.setSession(l);
      }
      return l;
    }, r.prototype._sendSessionUpdate = function() {
      var e = this.getStackTop(), t = e.scope, n = e.client;
      if (t) {
        var i = t.getSession && t.getSession();
        i && n && n.captureSession && n.captureSession(i);
      }
    }, r.prototype._invokeClient = function(e) {
      for (var t, n = [], i = 1; i < arguments.length; i++)
        n[i - 1] = arguments[i];
      var s = this.getStackTop(), o = s.scope, a = s.client;
      a && a[e] && (t = a)[e].apply(t, Na(n, [o]));
    }, r.prototype._callExtensionMethod = function(e) {
      for (var t = [], n = 1; n < arguments.length; n++)
        t[n - 1] = arguments[n];
      var i = y0(), s = i.__SENTRY__;
      if (s && s.extensions && typeof s.extensions[e] == "function")
        return s.extensions[e].apply(this, t);
      PR && tv.warn("Extension method " + e + " couldn't be found, doing nothing.");
    }, r;
  })()
);
function y0() {
  var r = Dc();
  return r.__SENTRY__ = r.__SENTRY__ || {
    extensions: {},
    hub: void 0
  }, r;
}
function NR(r) {
  var e = y0(), t = Ba(e);
  return jC(e, r), t;
}
function Mie() {
  var r = y0();
  return (!B6(r) || Ba(r).isOlderThan(VC)) && jC(r, new zC()), FC() ? Vie(r) : Ba(r);
}
function Vie(r) {
  try {
    var e = y0().__SENTRY__, t = e && e.extensions && e.extensions.domain && e.extensions.domain.active;
    if (!t)
      return Ba(r);
    if (!B6(t) || Ba(t).isOlderThan(VC)) {
      var n = Ba(r).getStackTop();
      jC(t, new zC(n.client, Qx.clone(n.scope)));
    }
    return Ba(t);
  } catch {
    return Ba(r);
  }
}
function B6(r) {
  return !!(r && r.__SENTRY__ && r.__SENTRY__.hub);
}
function Ba(r) {
  return MC("hub", function() {
    return new zC();
  }, r);
}
function jC(r, e) {
  if (!r)
    return !1;
  var t = r.__SENTRY__ = r.__SENTRY__ || {};
  return t.hub = e, !0;
}
function zie(r) {
  for (var e = [], t = 1; t < arguments.length; t++)
    e[t - 1] = arguments[t];
  var n = Mie();
  if (n && n[r])
    return n[r].apply(n, Na(e));
  throw new Error("No hub defined or " + r + " was not found on the hub, please open a bug report.");
}
function vp(r, e) {
  var t = new Error("Sentry syntheticException");
  return zie("captureException", r, {
    captureContext: e,
    originalException: r,
    syntheticException: t
  });
}
const jie = 64, Hie = 6e3;
let Gie = class {
  constructor({ dependencies: e, apduSenderFactory: t, apduReceiverFactory: n }, i) {
    h(this, "dependencies");
    h(this, "apduSender");
    h(this, "apduReceiver");
    h(this, "sendApduPromiseResolver");
    h(this, "logger");
    const s = pe.of(ac.numberToByteArray(Math.floor(Math.random() * 65535), 2));
    this.logger = i("WebHidApduSender"), this.apduSender = t({ frameSize: jie, channel: s, padding: !0 }), this.apduReceiver = n({ channel: s }), this.sendApduPromiseResolver = ve, this.dependencies = e, this.logger.info(" Connected to device");
  }
  async sendApdu(e, t, n) {
    let i;
    const s = new Promise((o) => {
      this.sendApduPromiseResolver = pe.of((...a) => (i && clearTimeout(i), o(...a)));
    });
    for (const o of this.apduSender.getFrames(e)) try {
      await this.dependencies.device.sendReport(0, new Uint8Array(o.getRawData()));
    } catch (a) {
      return this.logger.info("Error sending frame", { data: { error: a } }), Promise.resolve(N(new xie(a)));
    }
    return n && (i = setTimeout(() => {
      this.logger.debug("[sendApdu] Abort timeout", { data: { abortTimeout: n } }), this.sendApduPromiseResolver.map((o) => o(N(new qL("Abort timeout"))));
    }, n)), s;
  }
  receiveHidInputReport(e) {
    const t = new Uint8Array(e.data.buffer);
    this.apduReceiver.handleFrame(t).map((n) => {
      n.map((i) => {
        this.sendApduPromiseResolver.map((s) => s(te(i)));
      });
    }).mapLeft((n) => {
      this.sendApduPromiseResolver.map((i) => i(N(n)));
    });
  }
  getDependencies() {
    return this.dependencies;
  }
  setDependencies(e) {
    this.dependencies = e;
  }
  async setupConnection() {
    try {
      this.dependencies.device.oninputreport = (e) => this.receiveHidInputReport(e), await this.dependencies.device.open();
    } catch (e) {
      if (e instanceof DOMException && e.name === "InvalidStateError") this.logger.info("Device is already opened");
      else {
        const t = new Gs(e);
        throw this.logger.error("Error while opening device", { data: { error: e } }), vp(t), e;
      }
    }
  }
  closeConnection() {
    this.logger.info(" Disconnect");
    try {
      this.dependencies.device.close();
    } catch (e) {
      this.logger.error("Error while closing device", { data: { device: this.dependencies.device, error: e } });
    }
  }
};
const L6 = "WEB-HID";
let Kie = class {
  constructor(e, t, n, i, s = (a) => new pF(a), o = (a, c) => new Gie(a, c)) {
    h(this, "_transportDiscoveredDevices", new fa([]));
    h(this, "_deviceConnectionsByHidDevice", /* @__PURE__ */ new Map());
    h(this, "_deviceConnectionsPendingReconnection", /* @__PURE__ */ new Set());
    h(this, "_connectionListenersAbortController", new AbortController());
    h(this, "_logger");
    h(this, "connectionType", "USB");
    h(this, "identifier", L6);
    this._deviceModelDataSource = e, this._loggerServiceFactory = t, this._apduSenderFactory = n, this._apduReceiverFactory = i, this._deviceConnectionStateMachineFactory = s, this._deviceApduSenderFactory = o, this._logger = t("WebWebHidTransport"), this.startListeningToConnectionEvents();
  }
  get hidApi() {
    return this.isSupported() ? te(navigator.hid) : N(new Eie("WebHID not supported"));
  }
  isSupported() {
    try {
      const e = !!(navigator != null && navigator.hid);
      return this._logger.debug(`isSupported: ${e}`), e;
    } catch (e) {
      return this._logger.error("isSupported: error", { data: { error: e } }), !1;
    }
  }
  getIdentifier() {
    return this.identifier;
  }
  async getDevices() {
    return me.liftEither(this.hidApi).map(async (e) => {
      try {
        return (await e.getDevices()).filter((t) => t.vendorId === dT);
      } catch (t) {
        const n = new sy(t);
        throw this._logger.error("getDevices: error getting devices", { data: { error: t } }), vp(n), n;
      }
    });
  }
  mapHIDDeviceToTransportDiscoveredDevice(e) {
    const t = this._transportDiscoveredDevices.getValue().find((i) => i.hidDevice === e);
    if (t) return t;
    const n = this._deviceConnectionsByHidDevice.get(e);
    return this.getDeviceModel(e).caseOf({ Just: (i) => {
      const s = (n == null ? void 0 : n.getDeviceId()) ?? pa(), o = { id: s, deviceModel: i, hidDevice: e, transport: this.identifier };
      return this._logger.debug(`Discovered device ${s} ${o.deviceModel.productName}`), o;
    }, Nothing: () => {
      throw this._logger.warn(`Device not recognized: hidDevice.productId: 0x${e.productId.toString(16)}`), new Dz(`Device not recognized: hidDevice.productId: 0x${e.productId.toString(16)}`);
    } });
  }
  listenToAvailableDevices() {
    return this.updateTransportDiscoveredDevices(), this._transportDiscoveredDevices.pipe(cr((e) => e.map(({ hidDevice: t, ...n }) => n)));
  }
  async updateTransportDiscoveredDevices() {
    (await this.getDevices()).caseOf({ Left: (e) => {
      this._logger.error("Error while getting accessible device", { data: { error: e } }), vp(e);
    }, Right: (e) => {
      this._transportDiscoveredDevices.next(e.map((t) => this.mapHIDDeviceToTransportDiscoveredDevice(t)));
    } });
  }
  async promptDeviceAccess() {
    return me.liftEither(this.hidApi).map(async (e) => {
      let t = [];
      try {
        t = await e.requestDevice({ filters: [{ vendorId: dT }] }), await this.updateTransportDiscoveredDevices();
      } catch (i) {
        const s = new sy(i);
        throw this._logger.error("promptDeviceAccess: error requesting device", { data: { error: i } }), vp(s), s;
      }
      if (this._logger.debug(`promptDeviceAccess: hidDevices len ${t.length}`), t.length === 0) throw this._logger.warn("No device was selected"), new sy("No selected device");
      const n = [];
      for (const i of t) n.push(i), this._logger.debug("promptDeviceAccess: selected device", { data: { hidDevice: i } });
      return n;
    }).run();
  }
  startDiscovering() {
    return this._logger.debug("startDiscovering"), rn(this.promptDeviceAccess()).pipe(Qr((e) => e.caseOf({ Left: (t) => {
      throw this._logger.error("Error while getting accessible device", { data: { error: t } }), vp(t), t;
    }, Right: (t) => {
      this._logger.info(`Got access to ${t.length} HID devices`);
      const n = t.map((i) => this.mapHIDDeviceToTransportDiscoveredDevice(i));
      return rn(n);
    } })));
  }
  stopDiscovering() {
  }
  startListeningToConnectionEvents() {
    this._logger.debug("startListeningToConnectionEvents"), this.hidApi.map((e) => {
      e.addEventListener("connect", (t) => this.handleDeviceConnectionEvent(t), { signal: this._connectionListenersAbortController.signal }), e.addEventListener("disconnect", (t) => this.handleDeviceDisconnectionEvent(t), { signal: this._connectionListenersAbortController.signal });
    });
  }
  stopListeningToConnectionEvents() {
    this._logger.debug("stopListeningToConnectionEvents"), this._connectionListenersAbortController.abort();
  }
  async connect({ deviceId: e, onDisconnect: t }) {
    this._logger.debug("connect", { data: { deviceId: e } });
    const n = this._transportDiscoveredDevices.getValue().find((u) => u.id === e);
    if (!n) return this._logger.error(`Unknown device ${e}`), N(new Jl(`Unknown device ${e}`));
    const { deviceModel: i } = n, s = this._deviceConnectionsByHidDevice.get(n.hidDevice);
    if (s) return te(new vE({ id: e, deviceModel: i, type: this.connectionType, sendApdu: (...u) => s.sendApdu(...u), transport: this.identifier }));
    const o = this._deviceApduSenderFactory({ apduSenderFactory: this._apduSenderFactory, apduReceiverFactory: this._apduReceiverFactory, dependencies: { device: n.hidDevice } }, this._loggerServiceFactory), a = this._deviceConnectionStateMachineFactory({ deviceId: e, deviceApduSender: o, timeoutDuration: Hie, tryToReconnect: () => {
      this._deviceConnectionsByHidDevice.forEach((u, l) => {
        u.getDeviceId() === e && (this._deviceConnectionsPendingReconnection.add(u), this._deviceConnectionsByHidDevice.delete(l));
      });
    }, onTerminated: () => {
      this._deviceConnectionsPendingReconnection.forEach((u) => {
        u.getDeviceId() === e && (this._deviceConnectionsPendingReconnection.delete(u), t(u.getDeviceId()));
      }), this._deviceConnectionsByHidDevice.forEach((u, l) => {
        u.getDeviceId() === e && (this._deviceConnectionsByHidDevice.delete(l), t(u.getDeviceId()));
      });
    } });
    try {
      await o.setupConnection();
    } catch (u) {
      return u instanceof Gs ? N(u) : N(new Gs(u));
    }
    this._deviceConnectionsByHidDevice.set(n.hidDevice, a);
    const c = new vE({ sendApdu: (...u) => a.sendApdu(...u), deviceModel: i, id: e, type: this.connectionType, transport: this.identifier });
    return te(c);
  }
  getDeviceModel(e) {
    const { productId: t } = e, n = this._deviceModelDataSource.getAllDeviceModels().find((i) => i.usbProductId === t >> 8 || i.bootloaderUsbProductId === t);
    return n ? pe.of(n) : pe.zero();
  }
  getHidUsbProductId(e) {
    return this.getDeviceModel(e).caseOf({ Just: (t) => t.usbProductId, Nothing: () => e.productId >> 8 });
  }
  async disconnect(e) {
    this._logger.debug("disconnect", { data: { connectedDevice: e } });
    const t = Array.from(this._deviceConnectionsByHidDevice.values()).find((n) => n.getDeviceId() === e.connectedDevice.id);
    return t ? (t.closeConnection(), Promise.resolve(te(void 0))) : (this._logger.error("No matching device connection found", { data: { connectedDevice: e } }), Promise.resolve(N(new Jl(`Unknown device ${e.connectedDevice.id}`))));
  }
  isHIDConnectionEvent(e) {
    return "device" in e && typeof e.device == "object" && e.device !== null && "productId" in e.device && typeof e.device.productId == "number";
  }
  async handleDeviceDisconnectionEvent(e) {
    if (!this.isHIDConnectionEvent(e)) {
      this._logger.error("Invalid event", { data: { event: e } });
      return;
    }
    this._logger.info("[handleDeviceDisconnectionEvent] Device disconnected", { data: { event: e } }), this.updateTransportDiscoveredDevices();
    try {
      await e.device.close();
    } catch (n) {
      this._logger.error("Error while closing device ", { data: { event: e, error: n } });
    }
    const t = this._deviceConnectionsByHidDevice.get(e.device);
    t && t.eventDeviceDisconnected();
  }
  async handleDeviceReconnection(e, t) {
    this._deviceConnectionsPendingReconnection.delete(e), this._deviceConnectionsByHidDevice.set(t, e);
    try {
      e.setDependencies({ device: t }), await e.setupConnection(), e.eventDeviceConnected();
    } catch (n) {
      this._logger.error("Error while reconnecting to device", { data: { event, error: n } }), e.closeConnection();
    }
  }
  async handleDeviceConnectionEvent(e) {
    if (!this.isHIDConnectionEvent(e)) {
      this._logger.error("Invalid event", { data: { event: e } });
      return;
    }
    this._logger.info("[handleDeviceConnectionEvent] Device connected", { data: { event: e } });
    const t = Array.from(this._deviceConnectionsPendingReconnection).find((n) => this.getHidUsbProductId(n.getDependencies().device) === this.getHidUsbProductId(e.device));
    t && await this.handleDeviceReconnection(t, e.device), this.updateTransportDiscoveredDevices();
  }
  destroy() {
    this.stopListeningToConnectionEvents(), this._deviceConnectionsByHidDevice.forEach((e) => {
      e.closeConnection();
    }), this._deviceConnectionsPendingReconnection.clear();
  }
};
const qie = ({ deviceModelDataSource: r, loggerServiceFactory: e, apduSenderServiceFactory: t, apduReceiverServiceFactory: n }) => new Kie(r, e, t, n);
class U6 {
  constructor(e) {
    this._connectedDevice = e;
  }
  get name() {
    return this._connectedDevice.name;
  }
  get modelId() {
    return this._connectedDevice.modelId;
  }
  get sessionId() {
    return this._connectedDevice.sessionId;
  }
  get type() {
    return this._connectedDevice.type;
  }
  get iconType() {
    switch (this.modelId) {
      case je.NANO_X:
      case je.NANO_S:
      case je.NANO_SP:
        return "nanox";
      case je.STAX:
        return "stax";
      case je.FLEX:
        return "flex";
      case je.APEX:
        return "apexp";
    }
  }
}
var Wie = Object.getOwnPropertyDescriptor, Zie = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? Wie(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, BR = (r, e) => (t, n) => e(t, n, r);
let eA = class {
  constructor(r, e) {
    h(this, "logger");
    h(this, "_dmk");
    h(this, "hidIdentifier", L6);
    h(this, "bleIdentifier", yp);
    h(this, "_currentSessionId");
    h(this, "_connectedDevice");
    this.logger = r("[DeviceManagementKit Service]");
    const t = new fG();
    t.addConfig(e).addLogger(new pG(Wr.Error)).addTransport(qie).addTransport(Sie), this._dmk = t.build();
  }
  get dmk() {
    return this._dmk;
  }
  get sessionId() {
    return this._currentSessionId;
  }
  get connectedDevice() {
    return this._connectedDevice;
  }
  async connectToDevice({ type: r }) {
    const e = r === "usb" ? this.hidIdentifier : this.bleIdentifier;
    this.logger.debug("Connecting to device", { identifier: e });
    const t = this.dmk;
    let n;
    try {
      n = await wz(
        t.startDiscovering({ transport: e })
      ), await t.stopDiscovering();
    } catch (i) {
      throw this.logger.error("Failed to start discovery", { error: i }), i instanceof sy ? new uo("No accessible device", {
        type: "no-accessible-device",
        error: i
      }) : new uo("Failed to start discovery", {
        type: "failed-to-start-discovery",
        error: i
      });
    }
    try {
      const i = await t.connect({
        device: n,
        sessionRefresherOptions: {
          isRefresherDisabled: !0
        }
      });
      return this._currentSessionId = i, this._connectedDevice = new U6(
        await t.getConnectedDevice({ sessionId: i })
      ), this._connectedDevice;
    } catch (i) {
      throw this.logger.error("Failed to connect to device", { error: i }), new uo("Failed to connect to device", {
        type: "failed-to-connect",
        error: i
      });
    }
  }
  async listAvailableDevices() {
    let r = 0;
    return new Promise((e, t) => {
      const n = this.dmk.listenToAvailableDevices({}).subscribe({
        next: (i) => {
          if (r++, i.length) {
            this.logger.debug("Known devices", { discoveredDevices: i }), e(i), n && n.unsubscribe();
            return;
          }
          if (r > 5 && !i.length) {
            e([]), n && n.unsubscribe();
            return;
          }
        },
        error: (i) => {
          this.logger.error("Failed to list known devices", { error: i }), t(i), n && n.unsubscribe();
        }
      });
    });
  }
  async disconnectFromDevice() {
    if (this._currentSessionId)
      try {
        await this.dmk.close(), this._currentSessionId = void 0;
      } catch (r) {
        throw this.logger.error("Failed to disconnect from device", { error: r }), new uo("Failed to disconnect from device", {
          type: "failed-to-disconnect",
          error: r
        });
      }
  }
};
eA = Zie([
  ke(),
  BR(0, H(Me.LoggerPublisher)),
  BR(1, H(gt.DmkConfig))
], eA);
var Jie = Object.getOwnPropertyDescriptor, Xie = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? Jie(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
};
let tA = class {
  constructor() {
    h(this, "dmk", {});
    h(this, "sessionId", "session-id-123");
    h(this, "connectedDevice", new U6({
      name: "GM's Flex",
      modelId: je.FLEX,
      sessionId: "session-id-123",
      type: "BLE",
      id: "device-1"
    }));
    h(this, "connectToDevice", () => Promise.resolve(this.connectedDevice));
    h(this, "disconnectFromDevice", () => Promise.resolve());
    h(this, "listAvailableDevices", () => Promise.resolve([
      {
        id: "device-1",
        name: "GM's Flex",
        deviceModel: {
          id: "flex-001",
          model: je.FLEX,
          name: "GM's Flex"
        },
        transport: "BLE"
      },
      {
        id: "device-2",
        name: "GM's Stax",
        deviceModel: {
          id: "stax-001",
          model: je.STAX,
          name: "GM's Stax"
        },
        transport: "USB"
      }
    ]));
  }
};
tA = Xie([
  ke()
], tA);
function rA(r, e) {
  const t = s0.from(r);
  t.signature = e;
  const n = t.serialized;
  return {
    rawTransaction: r,
    signedRawTransaction: n
  };
}
function Yie(r) {
  const e = {
    chainId: r.chainId,
    to: r.to,
    value: r.value,
    data: r.data,
    gasLimit: r.gas,
    maxFeePerGas: r.maxFeePerGas,
    maxPriorityFeePerGas: r.maxPriorityFeePerGas,
    gasPrice: r.gasPrice,
    nonce: r.nonce ? parseInt(r.nonce, 16) : void 0
  };
  console.log("Ethers: Sanitized transaction", { sanitizedTransaction: e });
  try {
    return s0.from(e).unsignedSerialized;
  } catch (t) {
    throw console.error("Failed to get raw transaction from Ethers", { error: t }), t;
  }
}
function F6(r) {
  return So.from(r).serialized;
}
var Qie = Object.getOwnPropertyDescriptor, ese = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? Qie(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, C_ = (r, e) => (t, n) => e(t, n, r);
let nA = class {
  constructor(r, e, t) {
    h(this, "logger");
    this.backendService = e, this.contextService = t, this.logger = r("[SendTransaction]");
  }
  async execute(r) {
    this.logger.debug("Transaction to be signed with signature", { params: r });
    const e = rA(
      r.rawTransaction,
      r.signature
    );
    this.logger.debug("Signed Transaction to broadcast", { signedTransaction: e });
    let t = this.contextService.getContext().chainId;
    const n = s0.from(r.rawTransaction).chainId;
    if (Number(n) !== t) {
      if (this.logger.error(
        "Chain ID mismatch between selected Chain ID and transaction Chain ID",
        {
          txChainId: n,
          eipProviderChainId: this.contextService.getContext().chainId.toString()
        }
      ), !gF(Number(n)))
        throw this.logger.error(
          "Unsupported chain ID for tx, cannot broadcast transaction",
          {
            txChainId: n
          }
        ), new Error(
          "Unsupported chain id for tx, cannot broadcast transaction"
        );
      t = Number(n);
    }
    const i = this.craftRequestFromSignedTransaction(
      e,
      t.toString()
    );
    return (await this.backendService.broadcast(i)).caseOf({
      Right: (o) => {
        if (wC(o)) {
          if (nd(o))
            return {
              hash: o.result,
              rawTransaction: r.rawTransaction,
              signedRawTransaction: e.signedRawTransaction
            };
          throw this.logger.error("Failed to broadcast transaction", {
            error: o.error
          }), new Error("Failed to broadcast transaction");
        }
        return {
          hash: o.transactionIdentifier,
          rawTransaction: r.rawTransaction,
          signedRawTransaction: e.signedRawTransaction
        };
      },
      Left: (o) => {
        throw this.logger.error("Failed to broadcast transaction", {
          error: o
        }), o;
      }
    });
  }
  craftRequestFromSignedTransaction(r, e) {
    return this.logger.debug("Crafting `eth_sendRawTransaction` request", {
      currencyId: e,
      signedTransaction: r
    }), {
      blockchain: { name: "ethereum", chainId: e },
      rpc: {
        method: "eth_sendRawTransaction",
        params: [r.signedRawTransaction],
        id: 1,
        jsonrpc: "2.0"
      }
    };
  }
};
nA = ese([
  ke(),
  C_(0, H(Me.LoggerPublisher)),
  C_(1, H(xc.BackendService)),
  C_(2, H(ci.ContextService))
], nA);
var tse = Object.getOwnPropertyDescriptor, rse = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? tse(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, LR = (r, e) => (t, n) => e(t, n, r);
let iA = class {
  constructor(r, e) {
    h(this, "logger");
    this.deviceManagementKitService = e, this.logger = r("[ConnectDevice UseCase]");
  }
  async execute({ type: r }) {
    this.logger.info("Connecting to device", { type: r });
    const e = await this.deviceManagementKitService.connectToDevice({
      type: r
    });
    if (e.modelId === je.NANO_S) {
      await this.deviceManagementKitService.disconnectFromDevice();
      const t = new V8("Device not supported", {
        modelId: e.modelId
      });
      throw this.logger.error("Device not supported", { error: t }), t;
    }
    return e;
  }
};
iA = rse([
  ke(),
  LR(0, H(Me.LoggerPublisher)),
  LR(1, H(gt.DeviceManagementKitService))
], iA);
var nse = Object.getOwnPropertyDescriptor, ise = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? nse(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, UR = (r, e) => (t, n) => e(t, n, r);
let sA = class {
  constructor(r, e) {
    h(this, "logger");
    this.deviceManagementKitService = e, this.logger = r("[DisconnectDevice UseCase]");
  }
  async execute() {
    return this.logger.info("Disconnecting from device"), this.deviceManagementKitService.disconnectFromDevice();
  }
};
sA = ise([
  ke(),
  UR(0, H(Me.LoggerPublisher)),
  UR(1, H(gt.DeviceManagementKitService))
], sA);
var sse = Object.getOwnPropertyDescriptor, ose = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? sse(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, FR = (r, e) => (t, n) => e(t, n, r);
let oA = class {
  constructor(r, e) {
    h(this, "logger");
    this.deviceManagementKitService = e, this.logger = r("[ListAvailableDevices UseCase]");
  }
  async execute() {
    return this.logger.info("Listing available devices"), this.deviceManagementKitService.listAvailableDevices();
  }
};
oA = ose([
  ke(),
  FR(0, H(Me.LoggerPublisher)),
  FR(1, H(gt.DeviceManagementKitService))
], oA);
var pi = ((r) => (r.OPEN_APP = "signer.eth.steps.openApp", r.GET_APP_CONFIG = "signer.eth.steps.getAppConfig", r.WEB3_CHECKS_OPT_IN = "signer.eth.steps.web3ChecksOptIn", r.WEB3_CHECKS_OPT_IN_RESULT = "signer.eth.steps.web3ChecksOptInResult", r.PARSE_TRANSACTION = "signer.eth.steps.parseTransaction", r.BUILD_CONTEXTS = "signer.eth.steps.buildContexts", r.PROVIDE_CONTEXTS = "signer.eth.steps.provideContexts", r.SIGN_TRANSACTION = "signer.eth.steps.signTransaction", r.BLIND_SIGN_TRANSACTION_FALLBACK = "signer.eth.steps.blindSignTransactionFallback", r))(pi || {}), js = ((r) => (r.OPEN_APP = "signer.eth.steps.openApp", r.GET_APP_CONFIG = "signer.eth.steps.getAppConfig", r.WEB3_CHECKS_OPT_IN = "signer.eth.steps.web3ChecksOptIn", r.WEB3_CHECKS_OPT_IN_RESULT = "signer.eth.steps.web3ChecksOptInResult", r.BUILD_CONTEXT = "signer.eth.steps.buildContext", r.PROVIDE_CONTEXT = "signer.eth.steps.provideContext", r.PROVIDE_GENERIC_CONTEXT = "signer.eth.steps.provideGenericContext", r.SIGN_TYPED_DATA = "signer.eth.steps.signTypedData", r.SIGN_TYPED_DATA_LEGACY = "signer.eth.steps.signTypedDataLegacy", r))(js || {}), aA = ((r) => (r[r.LEGACY = 0] = "LEGACY", r[r.EIP2930 = 1] = "EIP2930", r[r.EIP1559 = 2] = "EIP1559", r[r.EIP4844 = 3] = "EIP4844", r))(aA || {});
const yn = { Config: Symbol.for("config") }, Oi = { PkiCertificateDataSource: Symbol.for("PkiCertificateDataSource"), PkiCertificateLoader: Symbol.for("PkiCertificateLoader") };
var v0 = ((r) => (r.Test = "test", r.PersoV2 = "persov2", r.LedgerRootV3 = "ledger_root_v3", r.PluginSelectorKey = "plugin_selector_key", r.NftMetadataKey = "nft_metadata_key", r.PartnerMetadataKey = "partner_metadata_key", r.Erc20MetadataKey = "erc20_metadata_key", r.DomainMetadataKey = "domain_metadata_key", r.CalCalldataKey = "cal_calldata_key", r.CalTrustedNameKey = "cal_trusted_name_key", r.CalNetwork = "cal_network", r))(v0 || {}), Ir = ((r) => (r.GenuineCheck = "genuine_check", r.ExchangePayload = "exchange_payload", r.NftMeta = "nft_meta", r.TrustedName = "trusted_name", r.BackupProvider = "backup_provider", r.ProtectOrchestrator = "protect_orchestrator", r.PluginMeta = "plugin_meta", r.CoinMeta = "coin_meta", r.SeedIdAuth = "seed_id_auth", r.TxSimulationSigner = "tx_simu_signer", r.Calldata = "calldata", r.Network = "network", r))(Ir || {});
const $n = "X-Ledger-Client-Version", ks = "X-Ledger-Client-Origin";
var M = ((r) => (r.TOKEN = "token", r.NFT = "nft", r.TRUSTED_NAME = "trustedName", r.PLUGIN = "plugin", r.EXTERNAL_PLUGIN = "externalPlugin", r.TRANSACTION_INFO = "transactionInfo", r.PROXY_INFO = "proxyInfo", r.ENUM = "enum", r.TRANSACTION_FIELD_DESCRIPTION = "transactionFieldDescription", r.WEB3_CHECK = "web3Check", r.DYNAMIC_NETWORK = "dynamicNetwork", r.DYNAMIC_NETWORK_ICON = "dynamicNetworkIcon", r.ERROR = "error", r))(M || {}), Zr = ((r) => (r.TOKEN = "token", r.NFT = "nft", r.TRUSTED_NAME = "trustedName", r.ENUM = "enum", r.CALLDATA = "calldata", r))(Zr || {});
const ase = "15", MR = "81ff";
let rv = class {
  static stringToHex(e) {
    let t = "";
    for (let n = 0; n < e.length; n++) {
      const i = e.charCodeAt(n).toString(16);
      t += i.padStart(2, "0");
    }
    return t;
  }
  static appendSignatureToPayload(e, t, n) {
    t.length % 2 !== 0 && (t = "0" + t);
    let i = (t.length / 2).toString(16);
    return i.length % 2 !== 0 && (i = "0" + i), `${e}${n}${i}${t}`;
  }
};
const cse = "@ledgerhq/context-module", use = "1.8.0", lse = "Apache-2.0", dse = { ".": { types: "./lib/types/index.d.ts", import: "./lib/esm/index.js", require: "./lib/cjs/index.js" }, "./*": { types: "./lib/types/*", import: "./lib/esm/*", require: "./lib/cjs/*" } }, hse = ["./lib"], fse = { prebuild: "rimraf lib", build: "pnpm ldmk-tool build --entryPoints index.ts,src/**/*.ts --tsconfig tsconfig.prod.json", dev: 'concurrently "pnpm watch:builds" "pnpm watch:types"', "watch:builds": "pnpm ldmk-tool watch --entryPoints index.ts,src/**/*.ts --tsconfig tsconfig.prod.json", "watch:types": 'concurrently "tsc --watch -p tsconfig.prod.json" "tsc-alias --watch -p tsconfig.prod.json"', lint: "eslint", "lint:fix": "pnpm lint --fix", postpack: "find . -name '*.tgz' -exec cp {} ../../../dist/ \\; ", prettier: "prettier . --check", "prettier:fix": "prettier . --write", test: "vitest run", "test:watch": "vitest", "test:coverage": "vitest run --coverage", typecheck: "tsc --noEmit" }, pse = { "@ledgerhq/device-management-kit": "workspace:*", "@ledgerhq/ldmk-tool": "workspace:*", "@ledgerhq/eslint-config-dsdk": "workspace:*", "@ledgerhq/prettier-config-dsdk": "workspace:*", "@ledgerhq/tsconfig-dsdk": "workspace:*", "@ledgerhq/vitest-config-dmk": "workspace:*", "@types/crypto-js": "catalog:", "ts-node": "catalog:" }, gse = { axios: "catalog:", "crypto-js": "catalog:", ethers: "catalog:", inversify: "catalog:", "purify-ts": "catalog:", "reflect-metadata": "catalog:" }, mse = { "@ledgerhq/device-management-kit": "^0.9.0" }, Rn = {
  name: cse,
  version: use,
  private: !1,
  license: lse,
  exports: dse,
  files: hse,
  scripts: fse,
  devDependencies: pse,
  dependencies: gse,
  peerDependencies: mse
};
var yse = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, VR = (r, e) => (t, n) => e(t, n, r);
let nv = class {
  constructor(e, t, n) {
    this.config = e, this._certificateLoader = t, this.endpoint = n;
  }
  async getCalldataDescriptors({ chainId: e, address: t, selector: n, deviceModelId: i }) {
    var o, a;
    let s;
    try {
      s = (await He.request({ method: "GET", url: `${this.config.cal.url}/${this.endpoint}`, params: { output: "descriptors_calldata", chain_id: e, contracts: t, contract_address: t, ref: `branch:${this.config.cal.branch}` }, headers: { [$n]: `context-module/${Rn.version}`, [ks]: this.config.originToken } })).data;
    } catch (c) {
      return N(new Error(`[ContextModule] HttpCalldataDescriptorDataSource: Failed to fetch calldata descriptors: ${c}`));
    }
    if (!Array.isArray(s)) return N(new Error("[ContextModule] HttpCalldataDescriptorDataSource: Response is not an array"));
    if (s.length === 0) return N(new Error(`[ContextModule] HttpCalldataDescriptorDataSource: No data for contract ${t} and selector ${n}`));
    for (const c of s) {
      t = t.toLowerCase(), n = `0x${n.slice(2).toLowerCase()}`;
      const u = (a = (o = c.descriptors_calldata) == null ? void 0 : o[t]) == null ? void 0 : a[n];
      if (!u || !this.isCalldataDescriptorV1(u, this.config.cal.mode)) continue;
      const l = u.transaction_info.descriptor.data, d = u.transaction_info.descriptor.signatures[this.config.cal.mode], f = { targetDevice: i, keyUsage: Ir.Calldata, keyId: v0.CalCalldataKey }, p = await this._certificateLoader.loadCertificate(f), y = { type: M.TRANSACTION_INFO, payload: rv.appendSignatureToPayload(l, d, MR), certificate: p }, g = [];
      for (const [_, w] of Object.entries(u.enums)) for (const [E, { data: I, signatures: S }] of Object.entries(w)) g.push({ type: M.ENUM, id: Number(_), value: Number(E), payload: rv.appendSignatureToPayload(I, S[this.config.cal.mode], MR), certificate: p });
      const v = u.fields.map((_) => ({ type: M.TRANSACTION_FIELD_DESCRIPTION, payload: _.descriptor, reference: this.getReference(_.param) }));
      return te([y, ...g, ...v]);
    }
    return N(new Error(`[ContextModule] HttpCalldataDescriptorDataSource: Invalid response for contract ${t} and selector ${n}`));
  }
  getReference(e) {
    var t, n, i, s;
    if (e.type === "TOKEN_AMOUNT" && e.token !== void 0 && e.token.type === "path") return { type: Zr.TOKEN, valuePath: this.toGenericPath(e.token.binary_path) };
    if (e.type === "TOKEN_AMOUNT" && e.token !== void 0 && e.token.type === "constant") return { type: Zr.TOKEN, value: e.token.value };
    if (e.type === "NFT" && e.collection.type === "path") return { type: Zr.NFT, valuePath: this.toGenericPath(e.collection.binary_path) };
    if (e.type === "NFT" && e.collection.type === "constant") return { type: Zr.NFT, value: e.collection.value };
    if (e.type === "TRUSTED_NAME" && e.value.type === "path") return { type: Zr.TRUSTED_NAME, valuePath: this.toGenericPath(e.value.binary_path), types: e.types, sources: e.sources };
    if (e.type === "ENUM" && e.value.type === "path") return { type: Zr.ENUM, valuePath: this.toGenericPath(e.value.binary_path), id: e.id };
    if (e.type === "CALLDATA" && e.value.type === "path" && e.callee.type === "path") return { type: Zr.CALLDATA, valuePath: this.toGenericPath(e.value.binary_path), callee: this.toGenericPath(e.callee.binary_path), selector: ((t = e.selector) == null ? void 0 : t.type) === "path" ? this.toGenericPath(e.selector.binary_path) : void 0, amount: ((n = e.amount) == null ? void 0 : n.type) === "path" ? this.toGenericPath(e.amount.binary_path) : void 0, spender: ((i = e.spender) == null ? void 0 : i.type) === "path" ? this.toGenericPath(e.spender.binary_path) : void 0, chainId: ((s = e.chainId) == null ? void 0 : s.type) === "path" ? this.toGenericPath(e.chainId.binary_path) : void 0 };
  }
  toGenericPath(e) {
    return e.type === "CONTAINER" ? e.value : e.elements.map((t) => {
      if (t.type === "ARRAY") {
        const { weight: n, ...i } = t;
        return { itemSize: n, ...i };
      } else if (t.type === "LEAF") {
        const { leaf_type: n, ...i } = t;
        return { leafType: n, ...i };
      }
      return t;
    });
  }
  isCalldataDescriptorV1(e, t) {
    return typeof e == "object" && e.type === "calldata" && e.version === "v1" && this.isTransactionInfoV1(e.transaction_info, t) && this.isEnumV1(e.enums, t) && Array.isArray(e.fields) && e.fields.every((n) => this.isFieldV1(n));
  }
  isTransactionInfoV1(e, t) {
    return typeof e == "object" && typeof e.descriptor == "object" && typeof e.descriptor.data == "string" && typeof e.descriptor.signatures == "object" && typeof e.descriptor.signatures[t] == "string";
  }
  isEnumV1(e, t) {
    return typeof e == "object" && Object.entries(e).every(([n, i]) => typeof n == "string" && typeof i == "object" && Object.entries(i).every(([s, o]) => typeof s == "string" && typeof o == "object" && typeof o.data == "string" && o.signatures !== void 0 && this.isCalldataSignatures(o.signatures, t)));
  }
  isCalldataSignatures(e, t) {
    return typeof e == "object" && typeof e[t] == "string";
  }
  isFieldV1(e) {
    return typeof e == "object" && typeof e.descriptor == "string" && typeof e.param == "object" && typeof e.param.value == "object" && this.isDescriptorValueV1(e.param.value) && (e.param.type === "RAW" || e.param.type === "AMOUNT" || e.param.type === "DATETIME" || e.param.type === "DURATION" || e.param.type === "UNIT" || e.param.type === "ENUM" || e.param.type === "NFT" && this.isDescriptorValueV1(e.param.collection) || e.param.type === "TOKEN_AMOUNT" && (e.param.token === void 0 || this.isDescriptorValueV1(e.param.token)) || e.param.type === "TRUSTED_NAME" && Array.isArray(e.param.types) && Array.isArray(e.param.sources) && e.param.types.every((t) => typeof t == "string") && e.param.sources.every((t) => typeof t == "string") || e.param.type === "CALLDATA" && this.isDescriptorValueV1(e.param.value) && this.isDescriptorValueV1(e.param.callee) && (e.param.selector === void 0 || this.isDescriptorValueV1(e.param.selector)) && (e.param.amount === void 0 || this.isDescriptorValueV1(e.param.amount)) && (e.param.spender === void 0 || this.isDescriptorValueV1(e.param.spender)) && (e.param.chainId === void 0 || this.isDescriptorValueV1(e.param.chainId)));
  }
  isDescriptorValueV1(e) {
    return typeof e == "object" && typeof e.type_family == "string" && ["UINT", "INT", "UFIXED", "FIXED", "ADDRESS", "BOOL", "BYTES", "STRING"].includes(e.type_family) && (typeof e.type_size > "u" || typeof e.type_size == "number") && (e.type === "path" && this.isCalldataDescriptorValueBinaryPathV1(e) || e.type === "constant" && this.isCalldataDescriptorValueConstantV1(e));
  }
  isCalldataDescriptorValueConstantV1(e) {
    return typeof e == "object" && e.type === "constant" && typeof e.value == "string";
  }
  isCalldataDescriptorValueBinaryPathV1(e) {
    return typeof e == "object" && (e.type === "path" && e.binary_path.type === "CONTAINER" && ["FROM", "TO", "VALUE"].includes(e.binary_path.value) || e.binary_path.type === "DATA" && Array.isArray(e.binary_path.elements) && e.binary_path.elements.every((t) => this.isPathElementV1(t)));
  }
  isPathElementV1(e) {
    return typeof e == "object" && (e.type === "REF" || e.type === "TUPLE" && typeof e.offset == "number" || e.type === "ARRAY" && typeof e.weight == "number" && (typeof e.start > "u" || typeof e.start == "number") && (typeof e.end > "u" || typeof e.end == "number") || e.type === "LEAF" && typeof e.leaf_type == "string" && ["ARRAY_LEAF", "TUPLE_LEAF", "STATIC_LEAF", "DYNAMIC_LEAF"].includes(e.leaf_type) || e.type === "SLICE" && (typeof e.start > "u" || typeof e.start == "number") && (typeof e.end > "u" || typeof e.end == "number"));
  }
};
nv = yse([le(), VR(0, X(yn.Config)), VR(1, X(Oi.PkiCertificateLoader))], nv);
const wd = { CalldataContextLoader: Symbol.for("CalldataContextLoader"), DappCalldataDescriptorDataSource: Symbol.for("DappCalldataDescriptorDataSource"), TokenCalldataDescriptorDataSource: Symbol.for("TokenCalldataDescriptorDataSource") }, Nu = { ProxyDataSource: Symbol.for("ProxyDataSource"), ProxyContextFieldLoader: Symbol.for("ProxyContextFieldLoader") };
var vse = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, D_ = (r, e) => (t, n) => e(t, n, r);
const bse = [M.TRANSACTION_INFO, M.TRANSACTION_FIELD_DESCRIPTION, M.PROXY_INFO, M.ENUM];
let cA = class {
  constructor(e, t, n) {
    this.dappDataSource = e, this.tokenDataSource = t, this.proxyDataSource = n;
  }
  canHandle(e, t) {
    return typeof e == "object" && e !== null && "to" in e && "data" in e && "selector" in e && "chainId" in e && "deviceModelId" in e && e.deviceModelId !== void 0 && e.deviceModelId !== je.NANO_S && typeof e.chainId == "number" && br(e.to) && e.to !== "0x" && br(e.data) && br(e.selector) && e.selector !== "0x" && bse.every((n) => t.includes(n));
  }
  async load(e) {
    const { to: t, data: n, selector: i, chainId: s, deviceModelId: o } = e, a = { address: t, chainId: s, selector: i, deviceModelId: o, data: n };
    return this._getContexts(a, this.dappDataSource).alt(this._getContexts(a, this.tokenDataSource)).alt(this._getContextsWithProxy(a, this.dappDataSource)).orDefault([{ type: M.ERROR, error: new Error("[ContextModule] CalldataContextLoader: No calldata contexts found") }]);
  }
  _getContexts({ address: e, chainId: t, selector: n, deviceModelId: i }, s) {
    return Br(async ({ liftMaybe: o }) => {
      const a = await s.getCalldataDescriptors({ deviceModelId: i, address: e, chainId: t, selector: n });
      return o(a.toMaybe().filter((c) => c.length > 0));
    });
  }
  _getContextsWithProxy({ address: e, chainId: t, selector: n, deviceModelId: i, data: s }, o) {
    return Br(async ({ liftMaybe: a }) => {
      const c = await this.proxyDataSource.getProxyImplementationAddress({ calldata: s, proxyAddress: e, chainId: t, challenge: "" });
      return a(c.toMaybe());
    }).map(({ implementationAddress: a }) => {
      const c = { address: a, chainId: t, selector: n, deviceModelId: i, data: s };
      return this._getContexts(c, o).map((u) => [{ type: M.PROXY_INFO, payload: "0x" }, ...u]);
    }).join();
  }
};
cA = vse([le(), D_(0, X(wd.DappCalldataDescriptorDataSource)), D_(1, X(wd.TokenCalldataDescriptorDataSource)), D_(2, X(Nu.ProxyDataSource))], cA);
const iv = { DynamicNetworkDataSource: Symbol("DynamicNetworkDataSource"), DynamicNetworkContextLoader: Symbol("DynamicNetworkContextLoader") }, Bu = { TrustedNameDataSource: Symbol.for("TrustedNameDataSource"), TrustedNameContextLoader: Symbol.for("TrustedNameContextLoader"), TrustedNameContextFieldLoader: Symbol.for("TrustedNameContextFieldLoader") }, sv = { ExternalPluginDataSource: Symbol.for("externalPluginDataSource"), ExternalPluginContextLoader: Symbol.for("externalPluginContextLoader") }, Lu = { NftDataSource: Symbol.for("nftDataSource"), NftContextLoader: Symbol.for("nftContextLoader"), NftContextFieldLoader: Symbol.for("nftContextFieldLoader") }, ov = { SolanaDataSource: Symbol.for("SolanaDataSource"), SolanaContextLoader: Symbol.for("SolanaContextLoader") }, yo = { TokenDataSource: Symbol.for("TokenDataSource"), TokenContextLoader: Symbol.for("TokenContextLoader"), TokenContextFieldLoader: Symbol.for("TokenContextFieldLoader") }, av = { TypedDataDataSource: Symbol.for("TypedDataDataSource"), TypedDataContextLoader: Symbol.for("TypedDataContextLoader") }, _d = { AbiDecoderDataSource: Symbol.for("AbiDecoderDataSource"), CommandDecoderDataSource: Symbol.for("CommandDecoderDataSource"), UniswapContextLoader: Symbol.for("UniswapContextLoader") }, cv = { Web3CheckDataSource: Symbol.for("Web3CheckDataSource"), Web3CheckContextLoader: Symbol.for("Web3CheckContextLoader") }, wse = () => new mt(({ bind: r }) => {
  r(wd.DappCalldataDescriptorDataSource).toDynamicValue((e) => new nv(e.get(yn.Config), e.get(Oi.PkiCertificateLoader), "dapps")), r(wd.TokenCalldataDescriptorDataSource).toDynamicValue((e) => new nv(e.get(yn.Config), e.get(Oi.PkiCertificateLoader), "tokens")), r(wd.CalldataContextLoader).to(cA);
}), _se = (r) => new mt(({ bind: e }) => {
  e(yn.Config).toConstantValue(r);
});
var Sse = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Ese = (r, e) => (t, n) => e(t, n, r);
let uA = class {
  constructor(e) {
    this.config = e;
  }
  async getDynamicNetworkConfiguration(e) {
    let t;
    try {
      t = (await He.get(`${this.config.cal.url}/networks?output=id,descriptors,icons&chain_id=${e}`, { headers: { [$n]: `context-module/${Rn.version}` } })).data;
    } catch (s) {
      return N(s instanceof Error ? s : new Error("Failed to fetch network configuration"));
    }
    const n = t == null ? void 0 : t[0];
    if (!n) return N(new Error(`Network configuration not found for chain ID: ${e}`));
    if (!this.isValidNetworkData(n)) return N(new Error(`Invalid network configuration response for chain ID: ${e}`));
    const i = this.transformToNetworkConfiguration(n);
    return te(i);
  }
  isValidNetworkData(e) {
    if (!e || typeof e != "object") return !1;
    const t = e;
    if (typeof t.id != "string" || !t.descriptors || typeof t.descriptors != "object") return !1;
    for (const n of Object.values(t.descriptors)) if (!this.isValidDescriptor(n)) return !1;
    return !(t.icons && typeof t.icons != "object");
  }
  isValidDescriptor(e) {
    if (!e || typeof e != "object") return !1;
    const t = e;
    if (typeof t.data != "string" || typeof t.descriptorType != "string" || typeof t.descriptorVersion != "string" || !t.signatures || typeof t.signatures != "object") return !1;
    const n = t.signatures;
    return !(typeof n.prod != "string" || typeof n.test != "string");
  }
  transformToNetworkConfiguration(e) {
    const t = Object.entries(e.descriptors).reduce((n, [i, s]) => {
      var o;
      return n[i] = { descriptorType: s.descriptorType, descriptorVersion: s.descriptorVersion, data: s.data, signatures: s.signatures, icon: (o = e.icons) == null ? void 0 : o[i] }, n;
    }, {});
    return { id: e.id, descriptors: t };
  }
};
uA = Sse([le(), Ese(0, X(yn.Config))], uA);
var xse = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, T_ = (r, e) => (t, n) => e(t, n, r);
const Ase = "15", Ise = [M.DYNAMIC_NETWORK, M.DYNAMIC_NETWORK_ICON];
let lA = class {
  constructor(e, t, n) {
    h(this, "_networkDataSource");
    h(this, "_config");
    h(this, "_certificateLoader");
    this._networkDataSource = e, this._config = t, this._certificateLoader = n;
  }
  canHandle(e, t) {
    return typeof e == "object" && e !== null && "chainId" in e && "deviceModelId" in e && e.deviceModelId !== void 0 && e.deviceModelId !== je.NANO_S && typeof e.chainId == "number" && Ise.every((n) => t.includes(n));
  }
  async load(e) {
    const { chainId: t, deviceModelId: n } = e, i = await this._networkDataSource.getDynamicNetworkConfiguration(t), s = await this._certificateLoader.loadCertificate({ keyId: v0.CalNetwork, keyUsage: Ir.Network, targetDevice: n });
    return i.caseOf({ Left: () => [], Right: (o) => {
      const a = [], c = o.descriptors[n];
      if (!c) return [];
      const u = c.signatures[this._config.cal.mode];
      if (!u) return [];
      const l = rv.appendSignatureToPayload(c.data, u, Ase);
      return a.push({ type: M.DYNAMIC_NETWORK, payload: l, certificate: s }), c.icon && a.push({ type: M.DYNAMIC_NETWORK_ICON, payload: c.icon }), a;
    } });
  }
};
lA = xse([le(), T_(0, X(iv.DynamicNetworkDataSource)), T_(1, X(yn.Config)), T_(2, X(Oi.PkiCertificateLoader))], lA);
const Cse = () => new mt(({ bind: r }) => {
  r(iv.DynamicNetworkDataSource).to(uA), r(iv.DynamicNetworkContextLoader).to(lA);
});
var Dse = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Tse = (r, e) => (t, n) => e(t, n, r);
let dA = class {
  constructor(e) {
    this.config = e;
  }
  async getDappInfos({ chainId: e, address: t, selector: n }) {
    var i, s, o, a, c, u, l;
    try {
      const d = await He.request({ method: "GET", url: `${this.config.cal.url}/dapps`, params: { output: "b2c,b2c_signatures,abis", chain_id: e, contracts: t }, headers: { [$n]: `context-module/${Rn.version}`, [ks]: this.config.originToken } });
      if (!d.data[0]) return te(void 0);
      t = t.toLowerCase(), n = `0x${n.slice(2).toLowerCase()}`;
      const { erc20OfInterest: f, method: p, plugin: y } = ((a = (o = (s = (i = d.data[0].b2c) == null ? void 0 : i.contracts) == null ? void 0 : s.find((w) => w.address === t)) == null ? void 0 : o.selectors) == null ? void 0 : a[n]) || {}, { signature: g, serialized_data: v } = ((u = (c = d.data[0].b2c_signatures) == null ? void 0 : c[t]) == null ? void 0 : u[n]) || {};
      if (!f || !p || !y || !g || !v) return te(void 0);
      const _ = (l = d.data[0].abis) == null ? void 0 : l[t];
      return te(_ ? { selectorDetails: { method: p, plugin: y, erc20OfInterest: f, signature: g, serializedData: v }, abi: _ } : void 0);
    } catch {
      return N(new Error("[ContextModule] HttpExternalPluginDataSource: Error fetching dapp infos"));
    }
  }
};
dA = Dse([le(), Tse(0, X(yn.Config))], dA);
const kse = "6.14.1";
function Ose(r, e, t) {
  const n = e.split("|").map((s) => s.trim());
  for (let s = 0; s < n.length; s++)
    switch (e) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof r === e)
          return;
    }
  const i = new Error(`invalid value for type ${e}`);
  throw i.code = "INVALID_ARGUMENT", i.argument = `value.${t}`, i.value = r, i;
}
function Ht(r, e, t) {
  for (let n in e) {
    let i = e[n];
    const s = t ? t[n] : null;
    s && Ose(i, s, n), Object.defineProperty(r, n, { enumerable: !0, value: i, writable: !1 });
  }
}
function ad(r) {
  if (r == null)
    return "null";
  if (Array.isArray(r))
    return "[ " + r.map(ad).join(", ") + " ]";
  if (r instanceof Uint8Array) {
    const e = "0123456789abcdef";
    let t = "0x";
    for (let n = 0; n < r.length; n++)
      t += e[r[n] >> 4], t += e[r[n] & 15];
    return t;
  }
  if (typeof r == "object" && typeof r.toJSON == "function")
    return ad(r.toJSON());
  switch (typeof r) {
    case "boolean":
    case "symbol":
      return r.toString();
    case "bigint":
      return BigInt(r).toString();
    case "number":
      return r.toString();
    case "string":
      return JSON.stringify(r);
    case "object": {
      const e = Object.keys(r);
      return e.sort(), "{ " + e.map((t) => `${ad(t)}: ${ad(r[t])}`).join(", ") + " }";
    }
  }
  return "[ COULD NOT SERIALIZE ]";
}
function zR(r, e) {
  return r && r.code === e;
}
function M6(r, e, t) {
  let n = r;
  {
    const s = [];
    if (t) {
      if ("message" in t || "code" in t || "name" in t)
        throw new Error(`value will overwrite populated values: ${ad(t)}`);
      for (const o in t) {
        if (o === "shortMessage")
          continue;
        const a = t[o];
        s.push(o + "=" + ad(a));
      }
    }
    s.push(`code=${e}`), s.push(`version=${kse}`), s.length && (r += " (" + s.join(", ") + ")");
  }
  let i;
  switch (e) {
    case "INVALID_ARGUMENT":
      i = new TypeError(r);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      i = new RangeError(r);
      break;
    default:
      i = new Error(r);
  }
  return Ht(i, { code: e }), t && Object.assign(i, t), i.shortMessage == null && Ht(i, { shortMessage: n }), i;
}
function _t(r, e, t, n) {
  if (!r)
    throw M6(e, t, n);
}
function ne(r, e, t, n) {
  _t(r, e, "INVALID_ARGUMENT", { argument: t, value: n });
}
function V6(r, e, t) {
  t == null && (t = ""), t && (t = ": " + t), _t(r >= e, "missing argument" + t, "MISSING_ARGUMENT", {
    count: r,
    expectedCount: e
  }), _t(r <= e, "too many arguments" + t, "UNEXPECTED_ARGUMENT", {
    count: r,
    expectedCount: e
  });
}
["NFD", "NFC", "NFKD", "NFKC"].reduce((r, e) => {
  try {
    if ("test".normalize(e) !== "test")
      throw new Error("bad");
    if (e === "NFD" && "".normalize("NFD") !== "e")
      throw new Error("broken");
    r.push(e);
  } catch {
  }
  return r;
}, []);
function b0(r, e, t) {
  if (t == null && (t = ""), r !== e) {
    let n = t, i = "new";
    t && (n += ".", i += " " + t), _t(!1, `private constructor; use ${n}from* methods`, "UNSUPPORTED_OPERATION", {
      operation: i
    });
  }
}
function z6(r, e, t) {
  if (r instanceof Uint8Array)
    return t ? new Uint8Array(r) : r;
  if (typeof r == "string" && r.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
    const n = new Uint8Array((r.length - 2) / 2);
    let i = 2;
    for (let s = 0; s < n.length; s++)
      n[s] = parseInt(r.substring(i, i + 2), 16), i += 2;
    return n;
  }
  ne(!1, "invalid BytesLike value", e || "value", r);
}
function st(r, e) {
  return z6(r, e, !1);
}
function Cn(r, e) {
  return z6(r, e, !0);
}
function ti(r, e) {
  return !(typeof r != "string" || !r.match(/^0x[0-9A-Fa-f]*$/) || typeof e == "number" && r.length !== 2 + 2 * e || e === !0 && r.length % 2 !== 0);
}
function j6(r) {
  return ti(r, !0) || r instanceof Uint8Array;
}
const jR = "0123456789abcdef";
function Ne(r) {
  const e = st(r);
  let t = "0x";
  for (let n = 0; n < e.length; n++) {
    const i = e[n];
    t += jR[(i & 240) >> 4] + jR[i & 15];
  }
  return t;
}
function zr(r) {
  return "0x" + r.map((e) => Ne(e).substring(2)).join("");
}
function $p(r) {
  return ti(r, !0) ? (r.length - 2) / 2 : st(r).length;
}
function Pl(r, e, t) {
  const n = st(r);
  return t != null && t > n.length && _t(!1, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
    buffer: n,
    length: n.length,
    offset: t
  }), Ne(n.slice(e ?? 0, t ?? n.length));
}
function H6(r, e, t) {
  const n = st(r);
  _t(e >= n.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(n),
    length: e,
    offset: e + 1
  });
  const i = new Uint8Array(e);
  return i.fill(0), t ? i.set(n, e - n.length) : i.set(n, 0), Ne(i);
}
function la(r, e) {
  return H6(r, e, !0);
}
function $se(r, e) {
  return H6(r, e, !1);
}
const w0 = BigInt(0), Es = BigInt(1), cd = 9007199254740991;
function Rse(r, e) {
  const t = _0(r, "value"), n = BigInt(Ti(e, "width"));
  if (_t(t >> n === w0, "overflow", "NUMERIC_FAULT", {
    operation: "fromTwos",
    fault: "overflow",
    value: r
  }), t >> n - Es) {
    const i = (Es << n) - Es;
    return -((~t & i) + Es);
  }
  return t;
}
function G6(r, e) {
  let t = jt(r, "value");
  const n = BigInt(Ti(e, "width")), i = Es << n - Es;
  if (t < w0) {
    t = -t, _t(t <= i, "too low", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: r
    });
    const s = (Es << n) - Es;
    return (~t & s) + Es;
  } else
    _t(t < i, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: r
    });
  return t;
}
function bp(r, e) {
  const t = _0(r, "value"), n = BigInt(Ti(e, "bits"));
  return t & (Es << n) - Es;
}
function jt(r, e) {
  switch (typeof r) {
    case "bigint":
      return r;
    case "number":
      return ne(Number.isInteger(r), "underflow", e || "value", r), ne(r >= -cd && r <= cd, "overflow", e || "value", r), BigInt(r);
    case "string":
      try {
        if (r === "")
          throw new Error("empty string");
        return r[0] === "-" && r[1] !== "-" ? -BigInt(r.substring(1)) : BigInt(r);
      } catch (t) {
        ne(!1, `invalid BigNumberish string: ${t.message}`, e || "value", r);
      }
  }
  ne(!1, "invalid BigNumberish value", e || "value", r);
}
function _0(r, e) {
  const t = jt(r, e);
  return _t(t >= w0, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value: r
  }), t;
}
const HR = "0123456789abcdef";
function K6(r) {
  if (r instanceof Uint8Array) {
    let e = "0x0";
    for (const t of r)
      e += HR[t >> 4], e += HR[t & 15];
    return BigInt(e);
  }
  return jt(r);
}
function Ti(r, e) {
  switch (typeof r) {
    case "bigint":
      return ne(r >= -cd && r <= cd, "overflow", e || "value", r), Number(r);
    case "number":
      return ne(Number.isInteger(r), "underflow", e || "value", r), ne(r >= -cd && r <= cd, "overflow", e || "value", r), r;
    case "string":
      try {
        if (r === "")
          throw new Error("empty string");
        return Ti(BigInt(r), e);
      } catch (t) {
        ne(!1, `invalid numeric string: ${t.message}`, e || "value", r);
      }
  }
  ne(!1, "invalid numeric value", e || "value", r);
}
function Pse(r) {
  return Ti(K6(r));
}
function tl(r, e) {
  let n = _0(r, "value").toString(16);
  if (e == null)
    n.length % 2 && (n = "0" + n);
  else {
    const i = Ti(e, "width");
    for (_t(i * 2 >= n.length, `value exceeds width (${i} bytes)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: r
    }); n.length < i * 2; )
      n = "0" + n;
  }
  return "0x" + n;
}
function gn(r) {
  const e = _0(r, "value");
  if (e === w0)
    return new Uint8Array([]);
  let t = e.toString(16);
  t.length % 2 && (t = "0" + t);
  const n = new Uint8Array(t.length / 2);
  for (let i = 0; i < n.length; i++) {
    const s = i * 2;
    n[i] = parseInt(t.substring(s, s + 2), 16);
  }
  return n;
}
function Nse(r) {
  let e = Ne(j6(r) ? r : gn(r)).substring(2);
  for (; e.startsWith("0"); )
    e = e.substring(1);
  return e === "" && (e = "0"), "0x" + e;
}
function Bse(r, e, t, n, i) {
  ne(!1, `invalid codepoint at offset ${e}; ${r}`, "bytes", t);
}
function q6(r, e, t, n, i) {
  if (r === "BAD_PREFIX" || r === "UNEXPECTED_CONTINUE") {
    let s = 0;
    for (let o = e + 1; o < t.length && t[o] >> 6 === 2; o++)
      s++;
    return s;
  }
  return r === "OVERRUN" ? t.length - e - 1 : 0;
}
function Lse(r, e, t, n, i) {
  return r === "OVERLONG" ? (ne(typeof i == "number", "invalid bad code point for replacement", "badCodepoint", i), n.push(i), 0) : (n.push(65533), q6(r, e, t));
}
const Use = Object.freeze({
  error: Bse,
  ignore: q6,
  replace: Lse
});
function Fse(r, e) {
  e == null && (e = Use.error);
  const t = st(r, "bytes"), n = [];
  let i = 0;
  for (; i < t.length; ) {
    const s = t[i++];
    if (s >> 7 === 0) {
      n.push(s);
      continue;
    }
    let o = null, a = null;
    if ((s & 224) === 192)
      o = 1, a = 127;
    else if ((s & 240) === 224)
      o = 2, a = 2047;
    else if ((s & 248) === 240)
      o = 3, a = 65535;
    else {
      (s & 192) === 128 ? i += e("UNEXPECTED_CONTINUE", i - 1, t, n) : i += e("BAD_PREFIX", i - 1, t, n);
      continue;
    }
    if (i - 1 + o >= t.length) {
      i += e("OVERRUN", i - 1, t, n);
      continue;
    }
    let c = s & (1 << 8 - o - 1) - 1;
    for (let u = 0; u < o; u++) {
      let l = t[i];
      if ((l & 192) != 128) {
        i += e("MISSING_CONTINUE", i, t, n), c = null;
        break;
      }
      c = c << 6 | l & 63, i++;
    }
    if (c !== null) {
      if (c > 1114111) {
        i += e("OUT_OF_RANGE", i - 1 - o, t, n, c);
        continue;
      }
      if (c >= 55296 && c <= 57343) {
        i += e("UTF16_SURROGATE", i - 1 - o, t, n, c);
        continue;
      }
      if (c <= a) {
        i += e("OVERLONG", i - 1 - o, t, n, c);
        continue;
      }
      n.push(c);
    }
  }
  return n;
}
function W6(r, e) {
  ne(typeof r == "string", "invalid string value", "str", r);
  let t = [];
  for (let n = 0; n < r.length; n++) {
    const i = r.charCodeAt(n);
    if (i < 128)
      t.push(i);
    else if (i < 2048)
      t.push(i >> 6 | 192), t.push(i & 63 | 128);
    else if ((i & 64512) == 55296) {
      n++;
      const s = r.charCodeAt(n);
      ne(n < r.length && (s & 64512) === 56320, "invalid surrogate pair", "str", r);
      const o = 65536 + ((i & 1023) << 10) + (s & 1023);
      t.push(o >> 18 | 240), t.push(o >> 12 & 63 | 128), t.push(o >> 6 & 63 | 128), t.push(o & 63 | 128);
    } else
      t.push(i >> 12 | 224), t.push(i >> 6 & 63 | 128), t.push(i & 63 | 128);
  }
  return new Uint8Array(t);
}
function Mse(r) {
  return r.map((e) => e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10 & 1023) + 55296, (e & 1023) + 56320))).join("");
}
function Vse(r, e) {
  return Mse(Fse(r, e));
}
function zse(r) {
  let e = r.toString(16);
  for (; e.length < 2; )
    e = "0" + e;
  return "0x" + e;
}
function GR(r, e, t) {
  let n = 0;
  for (let i = 0; i < t; i++)
    n = n * 256 + r[e + i];
  return n;
}
function KR(r, e, t, n) {
  const i = [];
  for (; t < e + 1 + n; ) {
    const s = Z6(r, t);
    i.push(s.result), t += s.consumed, _t(t <= e + 1 + n, "child data too short", "BUFFER_OVERRUN", {
      buffer: r,
      length: n,
      offset: e
    });
  }
  return { consumed: 1 + n, result: i };
}
function Z6(r, e) {
  _t(r.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: r,
    length: 0,
    offset: 1
  });
  const t = (n) => {
    _t(n <= r.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: r,
      length: r.length,
      offset: n
    });
  };
  if (r[e] >= 248) {
    const n = r[e] - 247;
    t(e + 1 + n);
    const i = GR(r, e + 1, n);
    return t(e + 1 + n + i), KR(r, e, e + 1 + n, n + i);
  } else if (r[e] >= 192) {
    const n = r[e] - 192;
    return t(e + 1 + n), KR(r, e, e + 1, n);
  } else if (r[e] >= 184) {
    const n = r[e] - 183;
    t(e + 1 + n);
    const i = GR(r, e + 1, n);
    t(e + 1 + n + i);
    const s = Ne(r.slice(e + 1 + n, e + 1 + n + i));
    return { consumed: 1 + n + i, result: s };
  } else if (r[e] >= 128) {
    const n = r[e] - 128;
    t(e + 1 + n);
    const i = Ne(r.slice(e + 1, e + 1 + n));
    return { consumed: 1 + n, result: i };
  }
  return { consumed: 1, result: zse(r[e]) };
}
function vf(r) {
  const e = st(r, "data"), t = Z6(e, 0);
  return ne(t.consumed === e.length, "unexpected junk after rlp payload", "data", r), t.result;
}
function qR(r) {
  const e = [];
  for (; r; )
    e.unshift(r & 255), r >>= 8;
  return e;
}
function J6(r) {
  if (Array.isArray(r)) {
    let n = [];
    if (r.forEach(function(s) {
      n = n.concat(J6(s));
    }), n.length <= 55)
      return n.unshift(192 + n.length), n;
    const i = qR(n.length);
    return i.unshift(247 + i.length), i.concat(n);
  }
  const e = Array.prototype.slice.call(st(r, "object"));
  if (e.length === 1 && e[0] <= 127)
    return e;
  if (e.length <= 55)
    return e.unshift(128 + e.length), e;
  const t = qR(e.length);
  return t.unshift(183 + t.length), t.concat(e);
}
const WR = "0123456789abcdef";
function Sc(r) {
  let e = "0x";
  for (const t of J6(r))
    e += WR[t >> 4], e += WR[t & 15];
  return e;
}
const Dn = 32, hA = new Uint8Array(Dn), jse = ["then"], Mm = {}, X6 = /* @__PURE__ */ new WeakMap();
function Kc(r) {
  return X6.get(r);
}
function ZR(r, e) {
  X6.set(r, e);
}
function Mf(r, e) {
  const t = new Error(`deferred error during ABI decoding triggered accessing ${r}`);
  throw t.error = e, t;
}
function fA(r, e, t) {
  return r.indexOf(null) >= 0 ? e.map((n, i) => n instanceof Zh ? fA(Kc(n), n, t) : n) : r.reduce((n, i, s) => {
    let o = e.getValue(i);
    return i in n || (t && o instanceof Zh && (o = fA(Kc(o), o, t)), n[i] = o), n;
  }, {});
}
var dh;
const ud = class ud extends Array {
  /**
   *  @private
   */
  constructor(...t) {
    const n = t[0];
    let i = t[1], s = (t[2] || []).slice(), o = !0;
    n !== Mm && (i = t, s = [], o = !1);
    super(i.length);
    // No longer used; but cannot be removed as it will remove the
    // #private field from the .d.ts which may break backwards
    // compatibility
    L(this, dh);
    i.forEach((u, l) => {
      this[l] = u;
    });
    const a = s.reduce((u, l) => (typeof l == "string" && u.set(l, (u.get(l) || 0) + 1), u), /* @__PURE__ */ new Map());
    if (ZR(this, Object.freeze(i.map((u, l) => {
      const d = s[l];
      return d != null && a.get(d) === 1 ? d : null;
    }))), D(this, dh, []), m(this, dh) == null && m(this, dh), !o)
      return;
    Object.freeze(this);
    const c = new Proxy(this, {
      get: (u, l, d) => {
        if (typeof l == "string") {
          if (l.match(/^[0-9]+$/)) {
            const p = Ti(l, "%index");
            if (p < 0 || p >= this.length)
              throw new RangeError("out of result range");
            const y = u[p];
            return y instanceof Error && Mf(`index ${p}`, y), y;
          }
          if (jse.indexOf(l) >= 0)
            return Reflect.get(u, l, d);
          const f = u[l];
          if (f instanceof Function)
            return function(...p) {
              return f.apply(this === d ? u : this, p);
            };
          if (!(l in u))
            return u.getValue.apply(this === d ? u : this, [l]);
        }
        return Reflect.get(u, l, d);
      }
    });
    return ZR(c, Kc(this)), c;
  }
  /**
   *  Returns the Result as a normal Array. If %%deep%%, any children
   *  which are Result objects are also converted to a normal Array.
   *
   *  This will throw if there are any outstanding deferred
   *  errors.
   */
  toArray(t) {
    const n = [];
    return this.forEach((i, s) => {
      i instanceof Error && Mf(`index ${s}`, i), t && i instanceof ud && (i = i.toArray(t)), n.push(i);
    }), n;
  }
  /**
   *  Returns the Result as an Object with each name-value pair. If
   *  %%deep%%, any children which are Result objects are also
   *  converted to an Object.
   *
   *  This will throw if any value is unnamed, or if there are
   *  any outstanding deferred errors.
   */
  toObject(t) {
    const n = Kc(this);
    return n.reduce((i, s, o) => (_t(s != null, `value at index ${o} unnamed`, "UNSUPPORTED_OPERATION", {
      operation: "toObject()"
    }), fA(n, this, t)), {});
  }
  /**
   *  @_ignore
   */
  slice(t, n) {
    t == null && (t = 0), t < 0 && (t += this.length, t < 0 && (t = 0)), n == null && (n = this.length), n < 0 && (n += this.length, n < 0 && (n = 0)), n > this.length && (n = this.length);
    const i = Kc(this), s = [], o = [];
    for (let a = t; a < n; a++)
      s.push(this[a]), o.push(i[a]);
    return new ud(Mm, s, o);
  }
  /**
   *  @_ignore
   */
  filter(t, n) {
    const i = Kc(this), s = [], o = [];
    for (let a = 0; a < this.length; a++) {
      const c = this[a];
      c instanceof Error && Mf(`index ${a}`, c), t.call(n, c, a, this) && (s.push(c), o.push(i[a]));
    }
    return new ud(Mm, s, o);
  }
  /**
   *  @_ignore
   */
  map(t, n) {
    const i = [];
    for (let s = 0; s < this.length; s++) {
      const o = this[s];
      o instanceof Error && Mf(`index ${s}`, o), i.push(t.call(n, o, s, this));
    }
    return i;
  }
  /**
   *  Returns the value for %%name%%.
   *
   *  Since it is possible to have a key whose name conflicts with
   *  a method on a [[Result]] or its superclass Array, or any
   *  JavaScript keyword, this ensures all named values are still
   *  accessible by name.
   */
  getValue(t) {
    const n = Kc(this).indexOf(t);
    if (n === -1)
      return;
    const i = this[n];
    return i instanceof Error && Mf(`property ${JSON.stringify(t)}`, i.error), i;
  }
  /**
   *  Creates a new [[Result]] for %%items%% with each entry
   *  also accessible by its corresponding name in %%keys%%.
   */
  static fromItems(t, n) {
    return new ud(Mm, t, n);
  }
};
dh = new WeakMap();
let Zh = ud;
function JR(r) {
  let e = gn(r);
  return _t(e.length <= Dn, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: e, length: Dn, offset: e.length }), e.length !== Dn && (e = Cn(zr([hA.slice(e.length % Dn), e]))), e;
}
class ma {
  constructor(e, t, n, i) {
    // The coder name:
    //   - address, uint256, tuple, array, etc.
    h(this, "name");
    // The fully expanded type, including composite types:
    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.
    h(this, "type");
    // The localName bound in the signature, in this example it is "baz":
    //   - tuple(address foo, uint bar) baz
    h(this, "localName");
    // Whether this type is dynamic:
    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)
    h(this, "dynamic");
    Ht(this, { name: e, type: t, localName: n, dynamic: i }, {
      name: "string",
      type: "string",
      localName: "string",
      dynamic: "boolean"
    });
  }
  _throwError(e, t) {
    ne(!1, e, this.localName, t);
  }
}
var Qo, Su, hh, yy;
class pA {
  constructor() {
    L(this, hh);
    // An array of WordSize lengthed objects to concatenation
    L(this, Qo);
    L(this, Su);
    D(this, Qo, []), D(this, Su, 0);
  }
  get data() {
    return zr(m(this, Qo));
  }
  get length() {
    return m(this, Su);
  }
  appendWriter(e) {
    return R(this, hh, yy).call(this, Cn(e.data));
  }
  // Arrayish item; pad on the right to *nearest* WordSize
  writeBytes(e) {
    let t = Cn(e);
    const n = t.length % Dn;
    return n && (t = Cn(zr([t, hA.slice(n)]))), R(this, hh, yy).call(this, t);
  }
  // Numeric item; pad on the left *to* WordSize
  writeValue(e) {
    return R(this, hh, yy).call(this, JR(e));
  }
  // Inserts a numeric place-holder, returning a callback that can
  // be used to asjust the value later
  writeUpdatableValue() {
    const e = m(this, Qo).length;
    return m(this, Qo).push(hA), D(this, Su, m(this, Su) + Dn), (t) => {
      m(this, Qo)[e] = JR(t);
    };
  }
}
Qo = new WeakMap(), Su = new WeakMap(), hh = new WeakSet(), yy = function(e) {
  return m(this, Qo).push(e), D(this, Su, m(this, Su) + e.length), e.length;
};
var Gn, Si, Eu, xu, Ja, ll, mA, Y6;
const aD = class aD {
  constructor(e, t, n) {
    L(this, ll);
    // Allows incomplete unpadded data to be read; otherwise an error
    // is raised if attempting to overrun the buffer. This is required
    // to deal with an old Solidity bug, in which event data for
    // external (not public thoguh) was tightly packed.
    h(this, "allowLoose");
    L(this, Gn);
    L(this, Si);
    L(this, Eu);
    L(this, xu);
    L(this, Ja);
    Ht(this, { allowLoose: !!t }), D(this, Gn, Cn(e)), D(this, Eu, 0), D(this, xu, null), D(this, Ja, n ?? 1024), D(this, Si, 0);
  }
  get data() {
    return Ne(m(this, Gn));
  }
  get dataLength() {
    return m(this, Gn).length;
  }
  get consumed() {
    return m(this, Si);
  }
  get bytes() {
    return new Uint8Array(m(this, Gn));
  }
  // Create a sub-reader with the same underlying data, but offset
  subReader(e) {
    const t = new aD(m(this, Gn).slice(m(this, Si) + e), this.allowLoose, m(this, Ja));
    return D(t, xu, this), t;
  }
  // Read bytes
  readBytes(e, t) {
    let n = R(this, ll, Y6).call(this, 0, e, !!t);
    return R(this, ll, mA).call(this, e), D(this, Si, m(this, Si) + n.length), n.slice(0, e);
  }
  // Read a numeric values
  readValue() {
    return K6(this.readBytes(Dn));
  }
  readIndex() {
    return Pse(this.readBytes(Dn));
  }
};
Gn = new WeakMap(), Si = new WeakMap(), Eu = new WeakMap(), xu = new WeakMap(), Ja = new WeakMap(), ll = new WeakSet(), mA = function(e) {
  var t;
  if (m(this, xu))
    return R(t = m(this, xu), ll, mA).call(t, e);
  D(this, Eu, m(this, Eu) + e), _t(m(this, Ja) < 1 || m(this, Eu) <= m(this, Ja) * this.dataLength, `compressed ABI data exceeds inflation ratio of ${m(this, Ja)} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
    buffer: Cn(m(this, Gn)),
    offset: m(this, Si),
    length: e,
    info: {
      bytesRead: m(this, Eu),
      dataLength: this.dataLength
    }
  });
}, Y6 = function(e, t, n) {
  let i = Math.ceil(t / Dn) * Dn;
  return m(this, Si) + i > m(this, Gn).length && (this.allowLoose && n && m(this, Si) + t <= m(this, Gn).length ? i = t : _t(!1, "data out-of-bounds", "BUFFER_OVERRUN", {
    buffer: Cn(m(this, Gn)),
    length: m(this, Gn).length,
    offset: m(this, Si) + i
  })), m(this, Gn).slice(m(this, Si), m(this, Si) + i);
};
let gA = aD;
function Hse() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
  throw new Error("unable to locate global object");
}
const XR = Hse();
XR.crypto || XR.msCrypto;
function Gse(r) {
  switch (r) {
    case "sha256":
      return sC.create();
    case "sha512":
      return UM.create();
  }
  ne(!1, "invalid hashing algorithm name", "algorithm", r);
}
let Q6 = !1;
const e4 = function(r) {
  return zM(r);
};
let t4 = e4;
function Yr(r) {
  const e = st(r, "data");
  return Ne(t4(e));
}
Yr._ = e4;
Yr.lock = function() {
  Q6 = !0;
};
Yr.register = function(r) {
  if (Q6)
    throw new TypeError("keccak256 is locked");
  t4 = r;
};
Object.freeze(Yr);
const r4 = function(r) {
  return Gse("sha256").update(r).digest();
};
let n4 = r4, i4 = !1;
function bf(r) {
  const e = st(r, "data");
  return Ne(n4(e));
}
bf._ = r4;
bf.lock = function() {
  i4 = !0;
};
bf.register = function(r) {
  if (i4)
    throw new Error("sha256 is locked");
  n4 = r;
};
Object.freeze(bf);
Object.freeze(bf);
const s4 = "0x0000000000000000000000000000000000000000", YR = "0x0000000000000000000000000000000000000000000000000000000000000000", QR = BigInt(0), eP = BigInt(1), tP = BigInt(2), rP = BigInt(27), nP = BigInt(28), Vm = BigInt(35), Nl = {};
function iP(r) {
  return la(gn(r), 32);
}
var fh, ph, gh, Au;
const os = class os {
  /**
   *  @private
   */
  constructor(e, t, n, i) {
    L(this, fh);
    L(this, ph);
    L(this, gh);
    L(this, Au);
    b0(e, Nl, "Signature"), D(this, fh, t), D(this, ph, n), D(this, gh, i), D(this, Au, null);
  }
  /**
   *  The ``r`` value for a signature.
   *
   *  This represents the ``x`` coordinate of a "reference" or
   *  challenge point, from which the ``y`` can be computed.
   */
  get r() {
    return m(this, fh);
  }
  set r(e) {
    ne($p(e) === 32, "invalid r", "value", e), D(this, fh, Ne(e));
  }
  /**
   *  The ``s`` value for a signature.
   */
  get s() {
    return m(this, ph);
  }
  set s(e) {
    ne($p(e) === 32, "invalid s", "value", e);
    const t = Ne(e);
    ne(parseInt(t.substring(0, 3)) < 8, "non-canonical s", "value", t), D(this, ph, t);
  }
  /**
   *  The ``v`` value for a signature.
   *
   *  Since a given ``x`` value for ``r`` has two possible values for
   *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
   *  values to use.
   *
   *  It is normalized to the values ``27`` or ``28`` for legacy
   *  purposes.
   */
  get v() {
    return m(this, gh);
  }
  set v(e) {
    const t = Ti(e, "value");
    ne(t === 27 || t === 28, "invalid v", "v", e), D(this, gh, t);
  }
  /**
   *  The EIP-155 ``v`` for legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get networkV() {
    return m(this, Au);
  }
  /**
   *  The chain ID for EIP-155 legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get legacyChainId() {
    const e = this.networkV;
    return e == null ? null : os.getChainId(e);
  }
  /**
   *  The ``yParity`` for the signature.
   *
   *  See ``v`` for more details on how this value is used.
   */
  get yParity() {
    return this.v === 27 ? 0 : 1;
  }
  /**
   *  The [[link-eip-2098]] compact representation of the ``yParity``
   *  and ``s`` compacted into a single ``bytes32``.
   */
  get yParityAndS() {
    const e = st(this.s);
    return this.yParity && (e[0] |= 128), Ne(e);
  }
  /**
   *  The [[link-eip-2098]] compact representation.
   */
  get compactSerialized() {
    return zr([this.r, this.yParityAndS]);
  }
  /**
   *  The serialized representation.
   */
  get serialized() {
    return zr([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
  }
  /**
   *  Returns a new identical [[Signature]].
   */
  clone() {
    const e = new os(Nl, this.r, this.s, this.v);
    return this.networkV && D(e, Au, this.networkV), e;
  }
  /**
   *  Returns a representation that is compatible with ``JSON.stringify``.
   */
  toJSON() {
    const e = this.networkV;
    return {
      _type: "signature",
      networkV: e != null ? e.toString() : null,
      r: this.r,
      s: this.s,
      v: this.v
    };
  }
  /**
   *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
   *
   *  @example:
   *    Signature.getChainId(45)
   *    //_result:
   *
   *    Signature.getChainId(46)
   *    //_result:
   */
  static getChainId(e) {
    const t = jt(e, "v");
    return t == rP || t == nP ? QR : (ne(t >= Vm, "invalid EIP-155 v", "v", e), (t - Vm) / tP);
  }
  /**
   *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
   *
   *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
   *  property to include the chain ID.
   *
   *  @example:
   *    Signature.getChainIdV(5, 27)
   *    //_result:
   *
   *    Signature.getChainIdV(5, 28)
   *    //_result:
   *
   */
  static getChainIdV(e, t) {
    return jt(e) * tP + BigInt(35 + t - 27);
  }
  /**
   *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
   *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
   *
   *  @example:
   *    // The values 0 and 1 imply v is actually yParity
   *    Signature.getNormalizedV(0)
   *    //_result:
   *
   *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
   *    Signature.getNormalizedV(27)
   *    //_result:
   *
   *    // Legacy EIP-155 transaction (i.e. >= 35)
   *    Signature.getNormalizedV(46)
   *    //_result:
   *
   *    // Invalid values throw
   *    Signature.getNormalizedV(5)
   *    //_error:
   */
  static getNormalizedV(e) {
    const t = jt(e);
    return t === QR || t === rP ? 27 : t === eP || t === nP ? 28 : (ne(t >= Vm, "invalid v", "v", e), t & eP ? 27 : 28);
  }
  /**
   *  Creates a new [[Signature]].
   *
   *  If no %%sig%% is provided, a new [[Signature]] is created
   *  with default values.
   *
   *  If %%sig%% is a string, it is parsed.
   */
  static from(e) {
    function t(u, l) {
      ne(u, l, "signature", e);
    }
    if (e == null)
      return new os(Nl, YR, YR, 27);
    if (typeof e == "string") {
      const u = st(e, "signature");
      if (u.length === 64) {
        const l = Ne(u.slice(0, 32)), d = u.slice(32, 64), f = d[0] & 128 ? 28 : 27;
        return d[0] &= 127, new os(Nl, l, Ne(d), f);
      }
      if (u.length === 65) {
        const l = Ne(u.slice(0, 32)), d = u.slice(32, 64);
        t((d[0] & 128) === 0, "non-canonical s");
        const f = os.getNormalizedV(u[64]);
        return new os(Nl, l, Ne(d), f);
      }
      t(!1, "invalid raw signature length");
    }
    if (e instanceof os)
      return e.clone();
    const n = e.r;
    t(n != null, "missing r");
    const i = iP(n), s = (function(u, l) {
      if (u != null)
        return iP(u);
      if (l != null) {
        t(ti(l, 32), "invalid yParityAndS");
        const d = st(l);
        return d[0] &= 127, Ne(d);
      }
      t(!1, "missing s");
    })(e.s, e.yParityAndS);
    t((st(s)[0] & 128) == 0, "non-canonical s");
    const { networkV: o, v: a } = (function(u, l, d) {
      if (u != null) {
        const f = jt(u);
        return {
          networkV: f >= Vm ? f : void 0,
          v: os.getNormalizedV(f)
        };
      }
      if (l != null)
        return t(ti(l, 32), "invalid yParityAndS"), { v: st(l)[0] & 128 ? 28 : 27 };
      if (d != null) {
        switch (Ti(d, "sig.yParity")) {
          case 0:
            return { v: 27 };
          case 1:
            return { v: 28 };
        }
        t(!1, "invalid yParity");
      }
      t(!1, "missing v");
    })(e.v, e.yParityAndS, e.yParity), c = new os(Nl, i, s, a);
    return o && D(c, Au, o), t(e.yParity == null || Ti(e.yParity, "sig.yParity") === c.yParity, "yParity mismatch"), t(e.yParityAndS == null || e.yParityAndS === c.yParityAndS, "yParityAndS mismatch"), c;
  }
};
fh = new WeakMap(), ph = new WeakMap(), gh = new WeakMap(), Au = new WeakMap();
let Os = os;
var ea;
const qc = class qc {
  /**
   *  Creates a new **SigningKey** for %%privateKey%%.
   */
  constructor(e) {
    L(this, ea);
    ne($p(e) === 32, "invalid private key", "privateKey", "[REDACTED]"), D(this, ea, Ne(e));
  }
  /**
   *  The private key.
   */
  get privateKey() {
    return m(this, ea);
  }
  /**
   *  The uncompressed public key.
   *
   * This will always begin with the prefix ``0x04`` and be 132
   * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
   */
  get publicKey() {
    return qc.computePublicKey(m(this, ea));
  }
  /**
   *  The compressed public key.
   *
   *  This will always begin with either the prefix ``0x02`` or ``0x03``
   *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
   *  nibbles)
   */
  get compressedPublicKey() {
    return qc.computePublicKey(m(this, ea), !0);
  }
  /**
   *  Return the signature of the signed %%digest%%.
   */
  sign(e) {
    ne($p(e) === 32, "invalid digest length", "digest", e);
    const t = An.sign(Cn(e), Cn(m(this, ea)), {
      lowS: !0
    });
    return Os.from({
      r: tl(t.r, 32),
      s: tl(t.s, 32),
      v: t.recovery ? 28 : 27
    });
  }
  /**
   *  Returns the [[link-wiki-ecdh]] shared secret between this
   *  private key and the %%other%% key.
   *
   *  The %%other%% key may be any type of key, a raw public key,
   *  a compressed/uncompressed pubic key or aprivate key.
   *
   *  Best practice is usually to use a cryptographic hash on the
   *  returned value before using it as a symetric secret.
   *
   *  @example:
   *    sign1 = new SigningKey(id("some-secret-1"))
   *    sign2 = new SigningKey(id("some-secret-2"))
   *
   *    // Notice that privA.computeSharedSecret(pubB)...
   *    sign1.computeSharedSecret(sign2.publicKey)
   *    //_result:
   *
   *    // ...is equal to privB.computeSharedSecret(pubA).
   *    sign2.computeSharedSecret(sign1.publicKey)
   *    //_result:
   */
  computeSharedSecret(e) {
    const t = qc.computePublicKey(e);
    return Ne(An.getSharedSecret(Cn(m(this, ea)), st(t), !1));
  }
  /**
   *  Compute the public key for %%key%%, optionally %%compressed%%.
   *
   *  The %%key%% may be any type of key, a raw public key, a
   *  compressed/uncompressed public key or private key.
   *
   *  @example:
   *    sign = new SigningKey(id("some-secret"));
   *
   *    // Compute the uncompressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey)
   *    //_result:
   *
   *    // Compute the compressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey, true)
   *    //_result:
   *
   *    // Compute the uncompressed public key
   *    SigningKey.computePublicKey(sign.publicKey, false);
   *    //_result:
   *
   *    // Compute the Compressed a public key
   *    SigningKey.computePublicKey(sign.publicKey, true);
   *    //_result:
   */
  static computePublicKey(e, t) {
    let n = st(e, "key");
    if (n.length === 32) {
      const s = An.getPublicKey(n, !!t);
      return Ne(s);
    }
    if (n.length === 64) {
      const s = new Uint8Array(65);
      s[0] = 4, s.set(n, 1), n = s;
    }
    const i = An.ProjectivePoint.fromHex(n);
    return Ne(i.toRawBytes(t));
  }
  /**
   *  Returns the public key for the private key which produced the
   *  %%signature%% for the given %%digest%%.
   *
   *  @example:
   *    key = new SigningKey(id("some-secret"))
   *    digest = id("hello world")
   *    sig = key.sign(digest)
   *
   *    // Notice the signer public key...
   *    key.publicKey
   *    //_result:
   *
   *    // ...is equal to the recovered public key
   *    SigningKey.recoverPublicKey(digest, sig)
   *    //_result:
   *
   */
  static recoverPublicKey(e, t) {
    ne($p(e) === 32, "invalid digest length", "digest", e);
    const n = Os.from(t);
    let i = An.Signature.fromCompact(Cn(zr([n.r, n.s])));
    i = i.addRecoveryBit(n.yParity);
    const s = i.recoverPublicKey(Cn(e));
    return ne(s != null, "invalid signature for digest", "signature", t), "0x" + s.toHex(!1);
  }
  /**
   *  Returns the point resulting from adding the ellipic curve points
   *  %%p0%% and %%p1%%.
   *
   *  This is not a common function most developers should require, but
   *  can be useful for certain privacy-specific techniques.
   *
   *  For example, it is used by [[HDNodeWallet]] to compute child
   *  addresses from parent public keys and chain codes.
   */
  static addPoints(e, t, n) {
    const i = An.ProjectivePoint.fromHex(qc.computePublicKey(e).substring(2)), s = An.ProjectivePoint.fromHex(qc.computePublicKey(t).substring(2));
    return "0x" + i.add(s).toHex(!!n);
  }
};
ea = new WeakMap();
let Wp = qc;
const Kse = BigInt(0), qse = BigInt(36);
function sP(r) {
  r = r.toLowerCase();
  const e = r.substring(2).split(""), t = new Uint8Array(40);
  for (let i = 0; i < 40; i++)
    t[i] = e[i].charCodeAt(0);
  const n = st(Yr(t));
  for (let i = 0; i < 40; i += 2)
    n[i >> 1] >> 4 >= 8 && (e[i] = e[i].toUpperCase()), (n[i >> 1] & 15) >= 8 && (e[i + 1] = e[i + 1].toUpperCase());
  return "0x" + e.join("");
}
const HC = {};
for (let r = 0; r < 10; r++)
  HC[String(r)] = String(r);
for (let r = 0; r < 26; r++)
  HC[String.fromCharCode(65 + r)] = String(10 + r);
const oP = 15;
function Wse(r) {
  r = r.toUpperCase(), r = r.substring(4) + r.substring(0, 2) + "00";
  let e = r.split("").map((n) => HC[n]).join("");
  for (; e.length >= oP; ) {
    let n = e.substring(0, oP);
    e = parseInt(n, 10) % 97 + e.substring(n.length);
  }
  let t = String(98 - parseInt(e, 10) % 97);
  for (; t.length < 2; )
    t = "0" + t;
  return t;
}
const Zse = (function() {
  const r = {};
  for (let e = 0; e < 36; e++) {
    const t = "0123456789abcdefghijklmnopqrstuvwxyz"[e];
    r[t] = BigInt(e);
  }
  return r;
})();
function Jse(r) {
  r = r.toLowerCase();
  let e = Kse;
  for (let t = 0; t < r.length; t++)
    e = e * qse + Zse[r[t]];
  return e;
}
function $s(r) {
  if (ne(typeof r == "string", "invalid address", "address", r), r.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    r.startsWith("0x") || (r = "0x" + r);
    const e = sP(r);
    return ne(!r.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || e === r, "bad address checksum", "address", r), e;
  }
  if (r.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    ne(r.substring(2, 4) === Wse(r), "bad icap checksum", "address", r);
    let e = Jse(r.substring(4)).toString(16);
    for (; e.length < 40; )
      e = "0" + e;
    return sP("0x" + e);
  }
  ne(!1, "invalid address", "address", r);
}
const Lo = {};
function De(r, e) {
  let t = !1;
  return e < 0 && (t = !0, e *= -1), new si(Lo, `${t ? "" : "u"}int${e}`, r, { signed: t, width: e });
}
function bt(r, e) {
  return new si(Lo, `bytes${e || ""}`, r, { size: e });
}
const aP = Symbol.for("_ethers_typed");
var Iu;
const Uo = class Uo {
  /**
   *  @_ignore:
   */
  constructor(e, t, n, i) {
    /**
     *  The type, as a Solidity-compatible type.
     */
    h(this, "type");
    /**
     *  The actual value.
     */
    h(this, "value");
    L(this, Iu);
    /**
     *  @_ignore:
     */
    h(this, "_typedSymbol");
    i == null && (i = null), b0(Lo, e, "Typed"), Ht(this, { _typedSymbol: aP, type: t, value: n }), D(this, Iu, i), this.format();
  }
  /**
   *  Format the type as a Human-Readable type.
   */
  format() {
    if (this.type === "array")
      throw new Error("");
    if (this.type === "dynamicArray")
      throw new Error("");
    return this.type === "tuple" ? `tuple(${this.value.map((e) => e.format()).join(",")})` : this.type;
  }
  /**
   *  The default value returned by this type.
   */
  defaultValue() {
    return 0;
  }
  /**
   *  The minimum value for numeric types.
   */
  minValue() {
    return 0;
  }
  /**
   *  The maximum value for numeric types.
   */
  maxValue() {
    return 0;
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
   */
  isBigInt() {
    return !!this.type.match(/^u?int[0-9]+$/);
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
   */
  isData() {
    return this.type.startsWith("bytes");
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
   */
  isString() {
    return this.type === "string";
  }
  /**
   *  Returns the tuple name, if this is a tuple. Throws otherwise.
   */
  get tupleName() {
    if (this.type !== "tuple")
      throw TypeError("not a tuple");
    return m(this, Iu);
  }
  // Returns the length of this type as an array
  // - `null` indicates the length is unforced, it could be dynamic
  // - `-1` indicates the length is dynamic
  // - any other value indicates it is a static array and is its length
  /**
   *  Returns the length of the array type or ``-1`` if it is dynamic.
   *
   *  Throws if the type is not an array.
   */
  get arrayLength() {
    if (this.type !== "array")
      throw TypeError("not an array");
    return m(this, Iu) === !0 ? -1 : m(this, Iu) === !1 ? this.value.length : null;
  }
  /**
   *  Returns a new **Typed** of %%type%% with the %%value%%.
   */
  static from(e, t) {
    return new Uo(Lo, e, t);
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static uint8(e) {
    return De(e, 8);
  }
  /**
   *  Return a new ``uint16`` type for %%v%%.
   */
  static uint16(e) {
    return De(e, 16);
  }
  /**
   *  Return a new ``uint24`` type for %%v%%.
   */
  static uint24(e) {
    return De(e, 24);
  }
  /**
   *  Return a new ``uint32`` type for %%v%%.
   */
  static uint32(e) {
    return De(e, 32);
  }
  /**
   *  Return a new ``uint40`` type for %%v%%.
   */
  static uint40(e) {
    return De(e, 40);
  }
  /**
   *  Return a new ``uint48`` type for %%v%%.
   */
  static uint48(e) {
    return De(e, 48);
  }
  /**
   *  Return a new ``uint56`` type for %%v%%.
   */
  static uint56(e) {
    return De(e, 56);
  }
  /**
   *  Return a new ``uint64`` type for %%v%%.
   */
  static uint64(e) {
    return De(e, 64);
  }
  /**
   *  Return a new ``uint72`` type for %%v%%.
   */
  static uint72(e) {
    return De(e, 72);
  }
  /**
   *  Return a new ``uint80`` type for %%v%%.
   */
  static uint80(e) {
    return De(e, 80);
  }
  /**
   *  Return a new ``uint88`` type for %%v%%.
   */
  static uint88(e) {
    return De(e, 88);
  }
  /**
   *  Return a new ``uint96`` type for %%v%%.
   */
  static uint96(e) {
    return De(e, 96);
  }
  /**
   *  Return a new ``uint104`` type for %%v%%.
   */
  static uint104(e) {
    return De(e, 104);
  }
  /**
   *  Return a new ``uint112`` type for %%v%%.
   */
  static uint112(e) {
    return De(e, 112);
  }
  /**
   *  Return a new ``uint120`` type for %%v%%.
   */
  static uint120(e) {
    return De(e, 120);
  }
  /**
   *  Return a new ``uint128`` type for %%v%%.
   */
  static uint128(e) {
    return De(e, 128);
  }
  /**
   *  Return a new ``uint136`` type for %%v%%.
   */
  static uint136(e) {
    return De(e, 136);
  }
  /**
   *  Return a new ``uint144`` type for %%v%%.
   */
  static uint144(e) {
    return De(e, 144);
  }
  /**
   *  Return a new ``uint152`` type for %%v%%.
   */
  static uint152(e) {
    return De(e, 152);
  }
  /**
   *  Return a new ``uint160`` type for %%v%%.
   */
  static uint160(e) {
    return De(e, 160);
  }
  /**
   *  Return a new ``uint168`` type for %%v%%.
   */
  static uint168(e) {
    return De(e, 168);
  }
  /**
   *  Return a new ``uint176`` type for %%v%%.
   */
  static uint176(e) {
    return De(e, 176);
  }
  /**
   *  Return a new ``uint184`` type for %%v%%.
   */
  static uint184(e) {
    return De(e, 184);
  }
  /**
   *  Return a new ``uint192`` type for %%v%%.
   */
  static uint192(e) {
    return De(e, 192);
  }
  /**
   *  Return a new ``uint200`` type for %%v%%.
   */
  static uint200(e) {
    return De(e, 200);
  }
  /**
   *  Return a new ``uint208`` type for %%v%%.
   */
  static uint208(e) {
    return De(e, 208);
  }
  /**
   *  Return a new ``uint216`` type for %%v%%.
   */
  static uint216(e) {
    return De(e, 216);
  }
  /**
   *  Return a new ``uint224`` type for %%v%%.
   */
  static uint224(e) {
    return De(e, 224);
  }
  /**
   *  Return a new ``uint232`` type for %%v%%.
   */
  static uint232(e) {
    return De(e, 232);
  }
  /**
   *  Return a new ``uint240`` type for %%v%%.
   */
  static uint240(e) {
    return De(e, 240);
  }
  /**
   *  Return a new ``uint248`` type for %%v%%.
   */
  static uint248(e) {
    return De(e, 248);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint256(e) {
    return De(e, 256);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint(e) {
    return De(e, 256);
  }
  /**
   *  Return a new ``int8`` type for %%v%%.
   */
  static int8(e) {
    return De(e, -8);
  }
  /**
   *  Return a new ``int16`` type for %%v%%.
   */
  static int16(e) {
    return De(e, -16);
  }
  /**
   *  Return a new ``int24`` type for %%v%%.
   */
  static int24(e) {
    return De(e, -24);
  }
  /**
   *  Return a new ``int32`` type for %%v%%.
   */
  static int32(e) {
    return De(e, -32);
  }
  /**
   *  Return a new ``int40`` type for %%v%%.
   */
  static int40(e) {
    return De(e, -40);
  }
  /**
   *  Return a new ``int48`` type for %%v%%.
   */
  static int48(e) {
    return De(e, -48);
  }
  /**
   *  Return a new ``int56`` type for %%v%%.
   */
  static int56(e) {
    return De(e, -56);
  }
  /**
   *  Return a new ``int64`` type for %%v%%.
   */
  static int64(e) {
    return De(e, -64);
  }
  /**
   *  Return a new ``int72`` type for %%v%%.
   */
  static int72(e) {
    return De(e, -72);
  }
  /**
   *  Return a new ``int80`` type for %%v%%.
   */
  static int80(e) {
    return De(e, -80);
  }
  /**
   *  Return a new ``int88`` type for %%v%%.
   */
  static int88(e) {
    return De(e, -88);
  }
  /**
   *  Return a new ``int96`` type for %%v%%.
   */
  static int96(e) {
    return De(e, -96);
  }
  /**
   *  Return a new ``int104`` type for %%v%%.
   */
  static int104(e) {
    return De(e, -104);
  }
  /**
   *  Return a new ``int112`` type for %%v%%.
   */
  static int112(e) {
    return De(e, -112);
  }
  /**
   *  Return a new ``int120`` type for %%v%%.
   */
  static int120(e) {
    return De(e, -120);
  }
  /**
   *  Return a new ``int128`` type for %%v%%.
   */
  static int128(e) {
    return De(e, -128);
  }
  /**
   *  Return a new ``int136`` type for %%v%%.
   */
  static int136(e) {
    return De(e, -136);
  }
  /**
   *  Return a new ``int144`` type for %%v%%.
   */
  static int144(e) {
    return De(e, -144);
  }
  /**
   *  Return a new ``int52`` type for %%v%%.
   */
  static int152(e) {
    return De(e, -152);
  }
  /**
   *  Return a new ``int160`` type for %%v%%.
   */
  static int160(e) {
    return De(e, -160);
  }
  /**
   *  Return a new ``int168`` type for %%v%%.
   */
  static int168(e) {
    return De(e, -168);
  }
  /**
   *  Return a new ``int176`` type for %%v%%.
   */
  static int176(e) {
    return De(e, -176);
  }
  /**
   *  Return a new ``int184`` type for %%v%%.
   */
  static int184(e) {
    return De(e, -184);
  }
  /**
   *  Return a new ``int92`` type for %%v%%.
   */
  static int192(e) {
    return De(e, -192);
  }
  /**
   *  Return a new ``int200`` type for %%v%%.
   */
  static int200(e) {
    return De(e, -200);
  }
  /**
   *  Return a new ``int208`` type for %%v%%.
   */
  static int208(e) {
    return De(e, -208);
  }
  /**
   *  Return a new ``int216`` type for %%v%%.
   */
  static int216(e) {
    return De(e, -216);
  }
  /**
   *  Return a new ``int224`` type for %%v%%.
   */
  static int224(e) {
    return De(e, -224);
  }
  /**
   *  Return a new ``int232`` type for %%v%%.
   */
  static int232(e) {
    return De(e, -232);
  }
  /**
   *  Return a new ``int240`` type for %%v%%.
   */
  static int240(e) {
    return De(e, -240);
  }
  /**
   *  Return a new ``int248`` type for %%v%%.
   */
  static int248(e) {
    return De(e, -248);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int256(e) {
    return De(e, -256);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int(e) {
    return De(e, -256);
  }
  /**
   *  Return a new ``bytes1`` type for %%v%%.
   */
  static bytes1(e) {
    return bt(e, 1);
  }
  /**
   *  Return a new ``bytes2`` type for %%v%%.
   */
  static bytes2(e) {
    return bt(e, 2);
  }
  /**
   *  Return a new ``bytes3`` type for %%v%%.
   */
  static bytes3(e) {
    return bt(e, 3);
  }
  /**
   *  Return a new ``bytes4`` type for %%v%%.
   */
  static bytes4(e) {
    return bt(e, 4);
  }
  /**
   *  Return a new ``bytes5`` type for %%v%%.
   */
  static bytes5(e) {
    return bt(e, 5);
  }
  /**
   *  Return a new ``bytes6`` type for %%v%%.
   */
  static bytes6(e) {
    return bt(e, 6);
  }
  /**
   *  Return a new ``bytes7`` type for %%v%%.
   */
  static bytes7(e) {
    return bt(e, 7);
  }
  /**
   *  Return a new ``bytes8`` type for %%v%%.
   */
  static bytes8(e) {
    return bt(e, 8);
  }
  /**
   *  Return a new ``bytes9`` type for %%v%%.
   */
  static bytes9(e) {
    return bt(e, 9);
  }
  /**
   *  Return a new ``bytes10`` type for %%v%%.
   */
  static bytes10(e) {
    return bt(e, 10);
  }
  /**
   *  Return a new ``bytes11`` type for %%v%%.
   */
  static bytes11(e) {
    return bt(e, 11);
  }
  /**
   *  Return a new ``bytes12`` type for %%v%%.
   */
  static bytes12(e) {
    return bt(e, 12);
  }
  /**
   *  Return a new ``bytes13`` type for %%v%%.
   */
  static bytes13(e) {
    return bt(e, 13);
  }
  /**
   *  Return a new ``bytes14`` type for %%v%%.
   */
  static bytes14(e) {
    return bt(e, 14);
  }
  /**
   *  Return a new ``bytes15`` type for %%v%%.
   */
  static bytes15(e) {
    return bt(e, 15);
  }
  /**
   *  Return a new ``bytes16`` type for %%v%%.
   */
  static bytes16(e) {
    return bt(e, 16);
  }
  /**
   *  Return a new ``bytes17`` type for %%v%%.
   */
  static bytes17(e) {
    return bt(e, 17);
  }
  /**
   *  Return a new ``bytes18`` type for %%v%%.
   */
  static bytes18(e) {
    return bt(e, 18);
  }
  /**
   *  Return a new ``bytes19`` type for %%v%%.
   */
  static bytes19(e) {
    return bt(e, 19);
  }
  /**
   *  Return a new ``bytes20`` type for %%v%%.
   */
  static bytes20(e) {
    return bt(e, 20);
  }
  /**
   *  Return a new ``bytes21`` type for %%v%%.
   */
  static bytes21(e) {
    return bt(e, 21);
  }
  /**
   *  Return a new ``bytes22`` type for %%v%%.
   */
  static bytes22(e) {
    return bt(e, 22);
  }
  /**
   *  Return a new ``bytes23`` type for %%v%%.
   */
  static bytes23(e) {
    return bt(e, 23);
  }
  /**
   *  Return a new ``bytes24`` type for %%v%%.
   */
  static bytes24(e) {
    return bt(e, 24);
  }
  /**
   *  Return a new ``bytes25`` type for %%v%%.
   */
  static bytes25(e) {
    return bt(e, 25);
  }
  /**
   *  Return a new ``bytes26`` type for %%v%%.
   */
  static bytes26(e) {
    return bt(e, 26);
  }
  /**
   *  Return a new ``bytes27`` type for %%v%%.
   */
  static bytes27(e) {
    return bt(e, 27);
  }
  /**
   *  Return a new ``bytes28`` type for %%v%%.
   */
  static bytes28(e) {
    return bt(e, 28);
  }
  /**
   *  Return a new ``bytes29`` type for %%v%%.
   */
  static bytes29(e) {
    return bt(e, 29);
  }
  /**
   *  Return a new ``bytes30`` type for %%v%%.
   */
  static bytes30(e) {
    return bt(e, 30);
  }
  /**
   *  Return a new ``bytes31`` type for %%v%%.
   */
  static bytes31(e) {
    return bt(e, 31);
  }
  /**
   *  Return a new ``bytes32`` type for %%v%%.
   */
  static bytes32(e) {
    return bt(e, 32);
  }
  /**
   *  Return a new ``address`` type for %%v%%.
   */
  static address(e) {
    return new Uo(Lo, "address", e);
  }
  /**
   *  Return a new ``bool`` type for %%v%%.
   */
  static bool(e) {
    return new Uo(Lo, "bool", !!e);
  }
  /**
   *  Return a new ``bytes`` type for %%v%%.
   */
  static bytes(e) {
    return new Uo(Lo, "bytes", e);
  }
  /**
   *  Return a new ``string`` type for %%v%%.
   */
  static string(e) {
    return new Uo(Lo, "string", e);
  }
  /**
   *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
   */
  static array(e, t) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
   */
  static tuple(e, t) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static overrides(e) {
    return new Uo(Lo, "overrides", Object.assign({}, e));
  }
  /**
   *  Returns true only if %%value%% is a [[Typed]] instance.
   */
  static isTyped(e) {
    return e && typeof e == "object" && "_typedSymbol" in e && e._typedSymbol === aP;
  }
  /**
   *  If the value is a [[Typed]] instance, validates the underlying value
   *  and returns it, otherwise returns value directly.
   *
   *  This is useful for functions that with to accept either a [[Typed]]
   *  object or values.
   */
  static dereference(e, t) {
    if (Uo.isTyped(e)) {
      if (e.type !== t)
        throw new Error(`invalid type: expecetd ${t}, got ${e.type}`);
      return e.value;
    }
    return e;
  }
};
Iu = new WeakMap();
let si = Uo;
class Xse extends ma {
  constructor(e) {
    super("address", "address", e, !1);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(e, t) {
    let n = si.dereference(t, "string");
    try {
      n = $s(n);
    } catch (i) {
      return this._throwError(i.message, t);
    }
    return e.writeValue(n);
  }
  decode(e) {
    return $s(tl(e.readValue(), 20));
  }
}
class Yse extends ma {
  constructor(t) {
    super(t.name, t.type, "_", t.dynamic);
    h(this, "coder");
    this.coder = t;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(t, n) {
    return this.coder.encode(t, n);
  }
  decode(t) {
    return this.coder.decode(t);
  }
}
function o4(r, e, t) {
  let n = [];
  if (Array.isArray(t))
    n = t;
  else if (t && typeof t == "object") {
    let c = {};
    n = e.map((u) => {
      const l = u.localName;
      return _t(l, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder: u }, value: t }), _t(!c[l], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder: u }, value: t }), c[l] = !0, t[l];
    });
  } else
    ne(!1, "invalid tuple value", "tuple", t);
  ne(e.length === n.length, "types/value length mismatch", "tuple", t);
  let i = new pA(), s = new pA(), o = [];
  e.forEach((c, u) => {
    let l = n[u];
    if (c.dynamic) {
      let d = s.length;
      c.encode(s, l);
      let f = i.writeUpdatableValue();
      o.push((p) => {
        f(p + d);
      });
    } else
      c.encode(i, l);
  }), o.forEach((c) => {
    c(i.length);
  });
  let a = r.appendWriter(i);
  return a += r.appendWriter(s), a;
}
function a4(r, e) {
  let t = [], n = [], i = r.subReader(0);
  return e.forEach((s) => {
    let o = null;
    if (s.dynamic) {
      let a = r.readIndex(), c = i.subReader(a);
      try {
        o = s.decode(c);
      } catch (u) {
        if (zR(u, "BUFFER_OVERRUN"))
          throw u;
        o = u, o.baseType = s.name, o.name = s.localName, o.type = s.type;
      }
    } else
      try {
        o = s.decode(r);
      } catch (a) {
        if (zR(a, "BUFFER_OVERRUN"))
          throw a;
        o = a, o.baseType = s.name, o.name = s.localName, o.type = s.type;
      }
    if (o == null)
      throw new Error("investigate");
    t.push(o), n.push(s.localName || null);
  }), Zh.fromItems(t, n);
}
class Qse extends ma {
  constructor(t, n, i) {
    const s = t.type + "[" + (n >= 0 ? n : "") + "]", o = n === -1 || t.dynamic;
    super("array", s, i, o);
    h(this, "coder");
    h(this, "length");
    Ht(this, { coder: t, length: n });
  }
  defaultValue() {
    const t = this.coder.defaultValue(), n = [];
    for (let i = 0; i < this.length; i++)
      n.push(t);
    return n;
  }
  encode(t, n) {
    const i = si.dereference(n, "array");
    Array.isArray(i) || this._throwError("expected array value", i);
    let s = this.length;
    s === -1 && (s = i.length, t.writeValue(i.length)), V6(i.length, s, "coder array" + (this.localName ? " " + this.localName : ""));
    let o = [];
    for (let a = 0; a < i.length; a++)
      o.push(this.coder);
    return o4(t, o, i);
  }
  decode(t) {
    let n = this.length;
    n === -1 && (n = t.readIndex(), _t(n * Dn <= t.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: t.bytes, offset: n * Dn, length: t.dataLength }));
    let i = [];
    for (let s = 0; s < n; s++)
      i.push(new Yse(this.coder));
    return a4(t, i);
  }
}
class eoe extends ma {
  constructor(e) {
    super("bool", "bool", e, !1);
  }
  defaultValue() {
    return !1;
  }
  encode(e, t) {
    const n = si.dereference(t, "bool");
    return e.writeValue(n ? 1 : 0);
  }
  decode(e) {
    return !!e.readValue();
  }
}
class c4 extends ma {
  constructor(e, t) {
    super(e, e, t, !0);
  }
  defaultValue() {
    return "0x";
  }
  encode(e, t) {
    t = Cn(t);
    let n = e.writeValue(t.length);
    return n += e.writeBytes(t), n;
  }
  decode(e) {
    return e.readBytes(e.readIndex(), !0);
  }
}
class toe extends c4 {
  constructor(e) {
    super("bytes", e);
  }
  decode(e) {
    return Ne(super.decode(e));
  }
}
class roe extends ma {
  constructor(t, n) {
    let i = "bytes" + String(t);
    super(i, i, n, !1);
    h(this, "size");
    Ht(this, { size: t }, { size: "number" });
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(t, n) {
    let i = Cn(si.dereference(n, this.type));
    return i.length !== this.size && this._throwError("incorrect data length", n), t.writeBytes(i);
  }
  decode(t) {
    return Ne(t.readBytes(this.size));
  }
}
const noe = new Uint8Array([]);
class ioe extends ma {
  constructor(e) {
    super("null", "", e, !1);
  }
  defaultValue() {
    return null;
  }
  encode(e, t) {
    return t != null && this._throwError("not null", t), e.writeBytes(noe);
  }
  decode(e) {
    return e.readBytes(0), null;
  }
}
const soe = BigInt(0), ooe = BigInt(1), aoe = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
class coe extends ma {
  constructor(t, n, i) {
    const s = (n ? "int" : "uint") + t * 8;
    super(s, s, i, !1);
    h(this, "size");
    h(this, "signed");
    Ht(this, { size: t, signed: n }, { size: "number", signed: "boolean" });
  }
  defaultValue() {
    return 0;
  }
  encode(t, n) {
    let i = jt(si.dereference(n, this.type)), s = bp(aoe, Dn * 8);
    if (this.signed) {
      let o = bp(s, this.size * 8 - 1);
      (i > o || i < -(o + ooe)) && this._throwError("value out-of-bounds", n), i = G6(i, 8 * Dn);
    } else (i < soe || i > bp(s, this.size * 8)) && this._throwError("value out-of-bounds", n);
    return t.writeValue(i);
  }
  decode(t) {
    let n = bp(t.readValue(), this.size * 8);
    return this.signed && (n = Rse(n, this.size * 8)), n;
  }
}
class uoe extends c4 {
  constructor(e) {
    super("string", e);
  }
  defaultValue() {
    return "";
  }
  encode(e, t) {
    return super.encode(e, W6(si.dereference(t, "string")));
  }
  decode(e) {
    return Vse(super.decode(e));
  }
}
class zm extends ma {
  constructor(t, n) {
    let i = !1;
    const s = [];
    t.forEach((a) => {
      a.dynamic && (i = !0), s.push(a.type);
    });
    const o = "tuple(" + s.join(",") + ")";
    super("tuple", o, n, i);
    h(this, "coders");
    Ht(this, { coders: Object.freeze(t.slice()) });
  }
  defaultValue() {
    const t = [];
    this.coders.forEach((i) => {
      t.push(i.defaultValue());
    });
    const n = this.coders.reduce((i, s) => {
      const o = s.localName;
      return o && (i[o] || (i[o] = 0), i[o]++), i;
    }, {});
    return this.coders.forEach((i, s) => {
      let o = i.localName;
      !o || n[o] !== 1 || (o === "length" && (o = "_length"), t[o] == null && (t[o] = t[s]));
    }), Object.freeze(t);
  }
  encode(t, n) {
    const i = si.dereference(n, "tuple");
    return o4(t, this.coders, i);
  }
  decode(t) {
    return a4(t, this.coders);
  }
}
function k_(r, e) {
  return {
    address: $s(r),
    storageKeys: e.map((t, n) => (ne(ti(t, 32), "invalid slot", `storageKeys[${n}]`, t), t.toLowerCase()))
  };
}
function GC(r) {
  if (Array.isArray(r))
    return r.map((t, n) => Array.isArray(t) ? (ne(t.length === 2, "invalid slot set", `value[${n}]`, t), k_(t[0], t[1])) : (ne(t != null && typeof t == "object", "invalid address-slot set", "value", r), k_(t.address, t.storageKeys)));
  ne(r != null && typeof r == "object", "invalid access list", "value", r);
  const e = Object.keys(r).map((t) => {
    const n = r[t].reduce((i, s) => (i[s] = !0, i), {});
    return k_(t, Object.keys(n).sort());
  });
  return e.sort((t, n) => t.address.localeCompare(n.address)), e;
}
function loe(r) {
  return {
    address: $s(r.address),
    nonce: jt(r.nonce != null ? r.nonce : 0),
    chainId: jt(r.chainId != null ? r.chainId : 0),
    signature: Os.from(r.signature)
  };
}
function doe(r) {
  let e;
  return typeof r == "string" ? e = Wp.computePublicKey(r, !1) : e = r.publicKey, $s(Yr("0x" + e.substring(4)).substring(26));
}
function hoe(r, e) {
  return doe(Wp.recoverPublicKey(r, e));
}
const Mr = BigInt(0), foe = BigInt(2), poe = BigInt(27), goe = BigInt(28), moe = BigInt(35), yoe = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), O_ = 4096 * 32;
function voe(r) {
  return { blobToKzgCommitment: (n) => {
    if ("computeBlobProof" in r) {
      if ("blobToKzgCommitment" in r && typeof r.blobToKzgCommitment == "function")
        return st(r.blobToKzgCommitment(Ne(n)));
    } else if ("blobToKzgCommitment" in r && typeof r.blobToKzgCommitment == "function")
      return st(r.blobToKzgCommitment(n));
    if ("blobToKZGCommitment" in r && typeof r.blobToKZGCommitment == "function")
      return st(r.blobToKZGCommitment(Ne(n)));
    ne(!1, "unsupported KZG library", "kzg", r);
  }, computeBlobKzgProof: (n, i) => {
    if ("computeBlobProof" in r && typeof r.computeBlobProof == "function")
      return st(r.computeBlobProof(Ne(n), Ne(i)));
    if ("computeBlobKzgProof" in r && typeof r.computeBlobKzgProof == "function")
      return r.computeBlobKzgProof(n, i);
    if ("computeBlobKZGProof" in r && typeof r.computeBlobKZGProof == "function")
      return st(r.computeBlobKZGProof(Ne(n), Ne(i)));
    ne(!1, "unsupported KZG library", "kzg", r);
  } };
}
function cP(r, e) {
  let t = r.toString(16);
  for (; t.length < 2; )
    t = "0" + t;
  return t += bf(e).substring(4), "0x" + t;
}
function wf(r) {
  return r === "0x" ? null : $s(r);
}
function S0(r, e) {
  try {
    return GC(r);
  } catch (t) {
    ne(!1, t.message, e, r);
  }
}
function boe(r, e) {
  try {
    if (!Array.isArray(r))
      throw new Error("authorizationList: invalid array");
    const t = [];
    for (let n = 0; n < r.length; n++) {
      const i = r[n];
      if (!Array.isArray(i))
        throw new Error(`authorization[${n}]: invalid array`);
      if (i.length !== 6)
        throw new Error(`authorization[${n}]: wrong length`);
      if (!i[1])
        throw new Error(`authorization[${n}]: null address`);
      t.push({
        address: wf(i[1]),
        nonce: Rt(i[2], "nonce"),
        chainId: Rt(i[0], "chainId"),
        signature: Os.from({
          yParity: vl(i[3], "yParity"),
          r: la(i[4], 32),
          s: la(i[5], 32)
        })
      });
    }
    return t;
  } catch (t) {
    ne(!1, t.message, e, r);
  }
}
function vl(r, e) {
  return r === "0x" ? 0 : Ti(r, e);
}
function Rt(r, e) {
  if (r === "0x")
    return Mr;
  const t = jt(r, e);
  return ne(t <= yoe, "value exceeds uint size", e, t), t;
}
function dt(r, e) {
  const t = jt(r, "value"), n = gn(t);
  return ne(n.length <= 32, "value too large", `tx.${e}`, t), n;
}
function E0(r) {
  return GC(r).map((e) => [e.address, e.storageKeys]);
}
function woe(r) {
  return r.map((e) => [
    dt(e.chainId, "chainId"),
    e.address,
    dt(e.nonce, "nonce"),
    dt(e.signature.yParity, "yParity"),
    e.signature.r,
    e.signature.s
  ]);
}
function _oe(r, e) {
  ne(Array.isArray(r), `invalid ${e}`, "value", r);
  for (let t = 0; t < r.length; t++)
    ne(ti(r[t], 32), "invalid ${ param } hash", `value[${t}]`, r[t]);
  return r;
}
function Soe(r) {
  const e = vf(r);
  ne(Array.isArray(e) && (e.length === 9 || e.length === 6), "invalid field count for legacy transaction", "data", r);
  const t = {
    type: 0,
    nonce: vl(e[0], "nonce"),
    gasPrice: Rt(e[1], "gasPrice"),
    gasLimit: Rt(e[2], "gasLimit"),
    to: wf(e[3]),
    value: Rt(e[4], "value"),
    data: Ne(e[5]),
    chainId: Mr
  };
  if (e.length === 6)
    return t;
  const n = Rt(e[6], "v"), i = Rt(e[7], "r"), s = Rt(e[8], "s");
  if (i === Mr && s === Mr)
    t.chainId = n;
  else {
    let o = (n - moe) / foe;
    o < Mr && (o = Mr), t.chainId = o, ne(o !== Mr || n === poe || n === goe, "non-canonical legacy v", "v", e[6]), t.signature = Os.from({
      r: la(e[7], 32),
      s: la(e[8], 32),
      v: n
    });
  }
  return t;
}
function Eoe(r, e) {
  const t = [
    dt(r.nonce, "nonce"),
    dt(r.gasPrice || 0, "gasPrice"),
    dt(r.gasLimit, "gasLimit"),
    r.to || "0x",
    dt(r.value, "value"),
    r.data
  ];
  let n = Mr;
  if (r.chainId != Mr)
    n = jt(r.chainId, "tx.chainId"), ne(!e || e.networkV == null || e.legacyChainId === n, "tx.chainId/sig.v mismatch", "sig", e);
  else if (r.signature) {
    const s = r.signature.legacyChainId;
    s != null && (n = s);
  }
  if (!e)
    return n !== Mr && (t.push(gn(n)), t.push("0x"), t.push("0x")), Sc(t);
  let i = BigInt(27 + e.yParity);
  return n !== Mr ? i = Os.getChainIdV(n, e.v) : BigInt(e.v) !== i && ne(!1, "tx.chainId/sig.v mismatch", "sig", e), t.push(gn(i)), t.push(gn(e.r)), t.push(gn(e.s)), Sc(t);
}
function x0(r, e) {
  let t;
  try {
    if (t = vl(e[0], "yParity"), t !== 0 && t !== 1)
      throw new Error("bad yParity");
  } catch {
    ne(!1, "invalid yParity", "yParity", e[0]);
  }
  const n = la(e[1], 32), i = la(e[2], 32), s = Os.from({ r: n, s: i, yParity: t });
  r.signature = s;
}
function xoe(r) {
  const e = vf(st(r).slice(1));
  ne(Array.isArray(e) && (e.length === 9 || e.length === 12), "invalid field count for transaction type: 2", "data", Ne(r));
  const t = {
    type: 2,
    chainId: Rt(e[0], "chainId"),
    nonce: vl(e[1], "nonce"),
    maxPriorityFeePerGas: Rt(e[2], "maxPriorityFeePerGas"),
    maxFeePerGas: Rt(e[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: Rt(e[4], "gasLimit"),
    to: wf(e[5]),
    value: Rt(e[6], "value"),
    data: Ne(e[7]),
    accessList: S0(e[8], "accessList")
  };
  return e.length === 9 || x0(t, e.slice(9)), t;
}
function Aoe(r, e) {
  const t = [
    dt(r.chainId, "chainId"),
    dt(r.nonce, "nonce"),
    dt(r.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    dt(r.maxFeePerGas || 0, "maxFeePerGas"),
    dt(r.gasLimit, "gasLimit"),
    r.to || "0x",
    dt(r.value, "value"),
    r.data,
    E0(r.accessList || [])
  ];
  return e && (t.push(dt(e.yParity, "yParity")), t.push(gn(e.r)), t.push(gn(e.s))), zr(["0x02", Sc(t)]);
}
function Ioe(r) {
  const e = vf(st(r).slice(1));
  ne(Array.isArray(e) && (e.length === 8 || e.length === 11), "invalid field count for transaction type: 1", "data", Ne(r));
  const t = {
    type: 1,
    chainId: Rt(e[0], "chainId"),
    nonce: vl(e[1], "nonce"),
    gasPrice: Rt(e[2], "gasPrice"),
    gasLimit: Rt(e[3], "gasLimit"),
    to: wf(e[4]),
    value: Rt(e[5], "value"),
    data: Ne(e[6]),
    accessList: S0(e[7], "accessList")
  };
  return e.length === 8 || x0(t, e.slice(8)), t;
}
function Coe(r, e) {
  const t = [
    dt(r.chainId, "chainId"),
    dt(r.nonce, "nonce"),
    dt(r.gasPrice || 0, "gasPrice"),
    dt(r.gasLimit, "gasLimit"),
    r.to || "0x",
    dt(r.value, "value"),
    r.data,
    E0(r.accessList || [])
  ];
  return e && (t.push(dt(e.yParity, "recoveryParam")), t.push(gn(e.r)), t.push(gn(e.s))), zr(["0x01", Sc(t)]);
}
function Doe(r) {
  let e = vf(st(r).slice(1)), t = "3", n = null;
  if (e.length === 4 && Array.isArray(e[0])) {
    t = "3 (network format)";
    const s = e[1], o = e[2], a = e[3];
    ne(Array.isArray(s), "invalid network format: blobs not an array", "fields[1]", s), ne(Array.isArray(o), "invalid network format: commitments not an array", "fields[2]", o), ne(Array.isArray(a), "invalid network format: proofs not an array", "fields[3]", a), ne(s.length === o.length, "invalid network format: blobs/commitments length mismatch", "fields", e), ne(s.length === a.length, "invalid network format: blobs/proofs length mismatch", "fields", e), n = [];
    for (let c = 0; c < e[1].length; c++)
      n.push({
        data: s[c],
        commitment: o[c],
        proof: a[c]
      });
    e = e[0];
  }
  ne(Array.isArray(e) && (e.length === 11 || e.length === 14), `invalid field count for transaction type: ${t}`, "data", Ne(r));
  const i = {
    type: 3,
    chainId: Rt(e[0], "chainId"),
    nonce: vl(e[1], "nonce"),
    maxPriorityFeePerGas: Rt(e[2], "maxPriorityFeePerGas"),
    maxFeePerGas: Rt(e[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: Rt(e[4], "gasLimit"),
    to: wf(e[5]),
    value: Rt(e[6], "value"),
    data: Ne(e[7]),
    accessList: S0(e[8], "accessList"),
    maxFeePerBlobGas: Rt(e[9], "maxFeePerBlobGas"),
    blobVersionedHashes: e[10]
  };
  n && (i.blobs = n), ne(i.to != null, `invalid address for transaction type: ${t}`, "data", r), ne(Array.isArray(i.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", r);
  for (let s = 0; s < i.blobVersionedHashes.length; s++)
    ne(ti(i.blobVersionedHashes[s], 32), `invalid blobVersionedHash at index ${s}: must be length 32`, "data", r);
  return e.length === 11 || x0(i, e.slice(11)), i;
}
function Toe(r, e, t) {
  const n = [
    dt(r.chainId, "chainId"),
    dt(r.nonce, "nonce"),
    dt(r.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    dt(r.maxFeePerGas || 0, "maxFeePerGas"),
    dt(r.gasLimit, "gasLimit"),
    r.to || s4,
    dt(r.value, "value"),
    r.data,
    E0(r.accessList || []),
    dt(r.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
    _oe(r.blobVersionedHashes || [], "blobVersionedHashes")
  ];
  return e && (n.push(dt(e.yParity, "yParity")), n.push(gn(e.r)), n.push(gn(e.s)), t) ? zr([
    "0x03",
    Sc([
      n,
      t.map((i) => i.data),
      t.map((i) => i.commitment),
      t.map((i) => i.proof)
    ])
  ]) : zr(["0x03", Sc(n)]);
}
function koe(r) {
  const e = vf(st(r).slice(1));
  ne(Array.isArray(e) && (e.length === 10 || e.length === 13), "invalid field count for transaction type: 4", "data", Ne(r));
  const t = {
    type: 4,
    chainId: Rt(e[0], "chainId"),
    nonce: vl(e[1], "nonce"),
    maxPriorityFeePerGas: Rt(e[2], "maxPriorityFeePerGas"),
    maxFeePerGas: Rt(e[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: Rt(e[4], "gasLimit"),
    to: wf(e[5]),
    value: Rt(e[6], "value"),
    data: Ne(e[7]),
    accessList: S0(e[8], "accessList"),
    authorizationList: boe(e[9], "authorizationList")
  };
  return e.length === 10 || x0(t, e.slice(10)), t;
}
function Ooe(r, e) {
  const t = [
    dt(r.chainId, "chainId"),
    dt(r.nonce, "nonce"),
    dt(r.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    dt(r.maxFeePerGas || 0, "maxFeePerGas"),
    dt(r.gasLimit, "gasLimit"),
    r.to || "0x",
    dt(r.value, "value"),
    r.data,
    E0(r.accessList || []),
    woe(r.authorizationList || [])
  ];
  return e && (t.push(dt(e.yParity, "yParity")), t.push(gn(e.r)), t.push(gn(e.s))), zr(["0x04", Sc(t)]);
}
var bs, mh, yh, vh, bh, wh, _h, Sh, Eh, xh, Ah, Ih, Cu, Xa, Ys, Ya, Ch, Dh, vy;
const Hs = class Hs {
  /**
   *  Creates a new Transaction with default values.
   */
  constructor() {
    L(this, Dh);
    L(this, bs);
    L(this, mh);
    L(this, yh);
    L(this, vh);
    L(this, bh);
    L(this, wh);
    L(this, _h);
    L(this, Sh);
    L(this, Eh);
    L(this, xh);
    L(this, Ah);
    L(this, Ih);
    L(this, Cu);
    L(this, Xa);
    L(this, Ys);
    L(this, Ya);
    L(this, Ch);
    D(this, bs, null), D(this, mh, null), D(this, vh, 0), D(this, bh, Mr), D(this, wh, null), D(this, _h, null), D(this, Sh, null), D(this, yh, "0x"), D(this, Eh, Mr), D(this, xh, Mr), D(this, Ah, null), D(this, Ih, null), D(this, Cu, null), D(this, Xa, null), D(this, Ys, null), D(this, Ya, null), D(this, Ch, null);
  }
  /**
   *  The transaction type.
   *
   *  If null, the type will be automatically inferred based on
   *  explicit properties.
   */
  get type() {
    return m(this, bs);
  }
  set type(e) {
    switch (e) {
      case null:
        D(this, bs, null);
        break;
      case 0:
      case "legacy":
        D(this, bs, 0);
        break;
      case 1:
      case "berlin":
      case "eip-2930":
        D(this, bs, 1);
        break;
      case 2:
      case "london":
      case "eip-1559":
        D(this, bs, 2);
        break;
      case 3:
      case "cancun":
      case "eip-4844":
        D(this, bs, 3);
        break;
      case 4:
      case "pectra":
      case "eip-7702":
        D(this, bs, 4);
        break;
      default:
        ne(!1, "unsupported transaction type", "type", e);
    }
  }
  /**
   *  The name of the transaction type.
   */
  get typeName() {
    switch (this.type) {
      case 0:
        return "legacy";
      case 1:
        return "eip-2930";
      case 2:
        return "eip-1559";
      case 3:
        return "eip-4844";
      case 4:
        return "eip-7702";
    }
    return null;
  }
  /**
   *  The ``to`` address for the transaction or ``null`` if the
   *  transaction is an ``init`` transaction.
   */
  get to() {
    const e = m(this, mh);
    return e == null && this.type === 3 ? s4 : e;
  }
  set to(e) {
    D(this, mh, e == null ? null : $s(e));
  }
  /**
   *  The transaction nonce.
   */
  get nonce() {
    return m(this, vh);
  }
  set nonce(e) {
    D(this, vh, Ti(e, "value"));
  }
  /**
   *  The gas limit.
   */
  get gasLimit() {
    return m(this, bh);
  }
  set gasLimit(e) {
    D(this, bh, jt(e));
  }
  /**
   *  The gas price.
   *
   *  On legacy networks this defines the fee that will be paid. On
   *  EIP-1559 networks, this should be ``null``.
   */
  get gasPrice() {
    const e = m(this, wh);
    return e == null && (this.type === 0 || this.type === 1) ? Mr : e;
  }
  set gasPrice(e) {
    D(this, wh, e == null ? null : jt(e, "gasPrice"));
  }
  /**
   *  The maximum priority fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxPriorityFeePerGas() {
    const e = m(this, _h);
    return e ?? (this.type === 2 || this.type === 3 ? Mr : null);
  }
  set maxPriorityFeePerGas(e) {
    D(this, _h, e == null ? null : jt(e, "maxPriorityFeePerGas"));
  }
  /**
   *  The maximum total fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxFeePerGas() {
    const e = m(this, Sh);
    return e ?? (this.type === 2 || this.type === 3 ? Mr : null);
  }
  set maxFeePerGas(e) {
    D(this, Sh, e == null ? null : jt(e, "maxFeePerGas"));
  }
  /**
   *  The transaction data. For ``init`` transactions this is the
   *  deployment code.
   */
  get data() {
    return m(this, yh);
  }
  set data(e) {
    D(this, yh, Ne(e));
  }
  /**
   *  The amount of ether (in wei) to send in this transactions.
   */
  get value() {
    return m(this, Eh);
  }
  set value(e) {
    D(this, Eh, jt(e, "value"));
  }
  /**
   *  The chain ID this transaction is valid on.
   */
  get chainId() {
    return m(this, xh);
  }
  set chainId(e) {
    D(this, xh, jt(e));
  }
  /**
   *  If signed, the signature for this transaction.
   */
  get signature() {
    return m(this, Ah) || null;
  }
  set signature(e) {
    D(this, Ah, e == null ? null : Os.from(e));
  }
  /**
   *  The access list.
   *
   *  An access list permits discounted (but pre-paid) access to
   *  bytecode and state variable access within contract execution.
   */
  get accessList() {
    const e = m(this, Ih) || null;
    return e ?? (this.type === 1 || this.type === 2 || this.type === 3 ? [] : null);
  }
  set accessList(e) {
    D(this, Ih, e == null ? null : GC(e));
  }
  get authorizationList() {
    const e = m(this, Ch) || null;
    return e == null && this.type === 4 ? [] : e;
  }
  set authorizationList(e) {
    D(this, Ch, e == null ? null : e.map((t) => loe(t)));
  }
  /**
   *  The max fee per blob gas for Cancun transactions.
   */
  get maxFeePerBlobGas() {
    const e = m(this, Cu);
    return e == null && this.type === 3 ? Mr : e;
  }
  set maxFeePerBlobGas(e) {
    D(this, Cu, e == null ? null : jt(e, "maxFeePerBlobGas"));
  }
  /**
   *  The BLOb versioned hashes for Cancun transactions.
   */
  get blobVersionedHashes() {
    let e = m(this, Xa);
    return e == null && this.type === 3 ? [] : e;
  }
  set blobVersionedHashes(e) {
    if (e != null) {
      ne(Array.isArray(e), "blobVersionedHashes must be an Array", "value", e), e = e.slice();
      for (let t = 0; t < e.length; t++)
        ne(ti(e[t], 32), "invalid blobVersionedHash", `value[${t}]`, e[t]);
    }
    D(this, Xa, e);
  }
  /**
   *  The BLObs for the Transaction, if any.
   *
   *  If ``blobs`` is non-``null``, then the [[seriailized]]
   *  will return the network formatted sidecar, otherwise it
   *  will return the standard [[link-eip-2718]] payload. The
   *  [[unsignedSerialized]] is unaffected regardless.
   *
   *  When setting ``blobs``, either fully valid [[Blob]] objects
   *  may be specified (i.e. correctly padded, with correct
   *  committments and proofs) or a raw [[BytesLike]] may
   *  be provided.
   *
   *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**
   *  be already set. The blob will be correctly padded and the
   *  [[KzgLibrary]] will be used to compute the committment and
   *  proof for the blob.
   *
   *  A BLOb is a sequence of field elements, each of which must
   *  be within the BLS field modulo, so some additional processing
   *  may be required to encode arbitrary data to ensure each 32 byte
   *  field is within the valid range.
   *
   *  Setting this automatically populates [[blobVersionedHashes]],
   *  overwriting any existing values. Setting this to ``null``
   *  does **not** remove the [[blobVersionedHashes]], leaving them
   *  present.
   */
  get blobs() {
    return m(this, Ya) == null ? null : m(this, Ya).map((e) => Object.assign({}, e));
  }
  set blobs(e) {
    if (e == null) {
      D(this, Ya, null);
      return;
    }
    const t = [], n = [];
    for (let i = 0; i < e.length; i++) {
      const s = e[i];
      if (j6(s)) {
        _t(m(this, Ys), "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
          operation: "set blobs()"
        });
        let o = st(s);
        if (ne(o.length <= O_, "blob is too large", `blobs[${i}]`, s), o.length !== O_) {
          const u = new Uint8Array(O_);
          u.set(o), o = u;
        }
        const a = m(this, Ys).blobToKzgCommitment(o), c = Ne(m(this, Ys).computeBlobKzgProof(o, a));
        t.push({
          data: Ne(o),
          commitment: Ne(a),
          proof: c
        }), n.push(cP(1, a));
      } else {
        const o = Ne(s.commitment);
        t.push({
          data: Ne(s.data),
          commitment: o,
          proof: Ne(s.proof)
        }), n.push(cP(1, o));
      }
    }
    D(this, Ya, t), D(this, Xa, n);
  }
  get kzg() {
    return m(this, Ys);
  }
  set kzg(e) {
    e == null ? D(this, Ys, null) : D(this, Ys, voe(e));
  }
  /**
   *  The transaction hash, if signed. Otherwise, ``null``.
   */
  get hash() {
    return this.signature == null ? null : Yr(R(this, Dh, vy).call(this, !0, !1));
  }
  /**
   *  The pre-image hash of this transaction.
   *
   *  This is the digest that a [[Signer]] must sign to authorize
   *  this transaction.
   */
  get unsignedHash() {
    return Yr(this.unsignedSerialized);
  }
  /**
   *  The sending address, if signed. Otherwise, ``null``.
   */
  get from() {
    return this.signature == null ? null : hoe(this.unsignedHash, this.signature);
  }
  /**
   *  The public key of the sender, if signed. Otherwise, ``null``.
   */
  get fromPublicKey() {
    return this.signature == null ? null : Wp.recoverPublicKey(this.unsignedHash, this.signature);
  }
  /**
   *  Returns true if signed.
   *
   *  This provides a Type Guard that properties requiring a signed
   *  transaction are non-null.
   */
  isSigned() {
    return this.signature != null;
  }
  /**
   *  The serialized transaction.
   *
   *  This throws if the transaction is unsigned. For the pre-image,
   *  use [[unsignedSerialized]].
   */
  get serialized() {
    return R(this, Dh, vy).call(this, !0, !0);
  }
  /**
   *  The transaction pre-image.
   *
   *  The hash of this is the digest which needs to be signed to
   *  authorize this transaction.
   */
  get unsignedSerialized() {
    return R(this, Dh, vy).call(this, !1, !1);
  }
  /**
   *  Return the most "likely" type; currently the highest
   *  supported transaction type.
   */
  inferType() {
    const e = this.inferTypes();
    return e.indexOf(2) >= 0 ? 2 : e.pop();
  }
  /**
   *  Validates the explicit properties and returns a list of compatible
   *  transaction types.
   */
  inferTypes() {
    const e = this.gasPrice != null, t = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null, n = this.accessList != null, i = m(this, Cu) != null || m(this, Xa);
    this.maxFeePerGas != null && this.maxPriorityFeePerGas != null && _t(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this }), _t(!t || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this }), _t(this.type !== 0 || !n, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
    const s = [];
    return this.type != null ? s.push(this.type) : this.authorizationList && this.authorizationList.length ? s.push(4) : t ? s.push(2) : e ? (s.push(1), n || s.push(0)) : n ? (s.push(1), s.push(2)) : (i && this.to || (s.push(0), s.push(1), s.push(2)), s.push(3)), s.sort(), s;
  }
  /**
   *  Returns true if this transaction is a legacy transaction (i.e.
   *  ``type === 0``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if this transaction is berlin hardform transaction (i.e.
   *  ``type === 1``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if this transaction is london hardform transaction (i.e.
   *  ``type === 2``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if this transaction is an [[link-eip-4844]] BLOB
   *  transaction.
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Create a copy of this transaciton.
   */
  clone() {
    return Hs.from(this);
  }
  /**
   *  Return a JSON-friendly object.
   */
  toJSON() {
    const e = (t) => t == null ? null : t.toString();
    return {
      type: this.type,
      to: this.to,
      //            from: this.from,
      data: this.data,
      nonce: this.nonce,
      gasLimit: e(this.gasLimit),
      gasPrice: e(this.gasPrice),
      maxPriorityFeePerGas: e(this.maxPriorityFeePerGas),
      maxFeePerGas: e(this.maxFeePerGas),
      value: e(this.value),
      chainId: e(this.chainId),
      sig: this.signature ? this.signature.toJSON() : null,
      accessList: this.accessList
    };
  }
  /**
   *  Create a **Transaction** from a serialized transaction or a
   *  Transaction-like object.
   */
  static from(e) {
    if (e == null)
      return new Hs();
    if (typeof e == "string") {
      const n = st(e);
      if (n[0] >= 127)
        return Hs.from(Soe(n));
      switch (n[0]) {
        case 1:
          return Hs.from(Ioe(n));
        case 2:
          return Hs.from(xoe(n));
        case 3:
          return Hs.from(Doe(n));
        case 4:
          return Hs.from(koe(n));
      }
      _t(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
    }
    const t = new Hs();
    return e.type != null && (t.type = e.type), e.to != null && (t.to = e.to), e.nonce != null && (t.nonce = e.nonce), e.gasLimit != null && (t.gasLimit = e.gasLimit), e.gasPrice != null && (t.gasPrice = e.gasPrice), e.maxPriorityFeePerGas != null && (t.maxPriorityFeePerGas = e.maxPriorityFeePerGas), e.maxFeePerGas != null && (t.maxFeePerGas = e.maxFeePerGas), e.maxFeePerBlobGas != null && (t.maxFeePerBlobGas = e.maxFeePerBlobGas), e.data != null && (t.data = e.data), e.value != null && (t.value = e.value), e.chainId != null && (t.chainId = e.chainId), e.signature != null && (t.signature = Os.from(e.signature)), e.accessList != null && (t.accessList = e.accessList), e.authorizationList != null && (t.authorizationList = e.authorizationList), e.blobVersionedHashes != null && (t.blobVersionedHashes = e.blobVersionedHashes), e.kzg != null && (t.kzg = e.kzg), e.blobs != null && (t.blobs = e.blobs), e.hash != null && (ne(t.isSigned(), "unsigned transaction cannot define '.hash'", "tx", e), ne(t.hash === e.hash, "hash mismatch", "tx", e)), e.from != null && (ne(t.isSigned(), "unsigned transaction cannot define '.from'", "tx", e), ne(t.from.toLowerCase() === (e.from || "").toLowerCase(), "from mismatch", "tx", e)), t;
  }
};
bs = new WeakMap(), mh = new WeakMap(), yh = new WeakMap(), vh = new WeakMap(), bh = new WeakMap(), wh = new WeakMap(), _h = new WeakMap(), Sh = new WeakMap(), Eh = new WeakMap(), xh = new WeakMap(), Ah = new WeakMap(), Ih = new WeakMap(), Cu = new WeakMap(), Xa = new WeakMap(), Ys = new WeakMap(), Ya = new WeakMap(), Ch = new WeakMap(), Dh = new WeakSet(), vy = function(e, t) {
  _t(!e || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
  const n = e ? this.signature : null;
  switch (this.inferType()) {
    case 0:
      return Eoe(this, n);
    case 1:
      return Coe(this, n);
    case 2:
      return Aoe(this, n);
    case 3:
      return Toe(this, n, t ? this.blobs : null);
    case 4:
      return Ooe(this, n);
  }
  _t(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
};
let yA = Hs;
function rl(r) {
  return Yr(W6(r));
}
const u4 = new Uint8Array(32);
u4.fill(0);
const $oe = BigInt(-1), l4 = BigInt(0), d4 = BigInt(1), Roe = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function Poe(r) {
  const e = st(r), t = e.length % 32;
  return t ? zr([e, u4.slice(t)]) : Ne(e);
}
const Noe = tl(d4, 32), Boe = tl(l4, 32), uP = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
}, $_ = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function lP(r) {
  return function(e) {
    return ne(typeof e == "string", `invalid domain value for ${JSON.stringify(r)}`, `domain.${r}`, e), e;
  };
}
const Loe = {
  name: lP("name"),
  version: lP("version"),
  chainId: function(r) {
    const e = jt(r, "domain.chainId");
    return ne(e >= 0, "invalid chain ID", "domain.chainId", r), Number.isSafeInteger(e) ? Number(e) : Nse(e);
  },
  verifyingContract: function(r) {
    try {
      return $s(r).toLowerCase();
    } catch {
    }
    ne(!1, 'invalid domain value "verifyingContract"', "domain.verifyingContract", r);
  },
  salt: function(r) {
    const e = st(r, "domain.salt");
    return ne(e.length === 32, 'invalid domain value "salt"', "domain.salt", r), Ne(e);
  }
};
function R_(r) {
  {
    const e = r.match(/^(u?)int(\d+)$/);
    if (e) {
      const t = e[1] === "", n = parseInt(e[2]);
      ne(n % 8 === 0 && n !== 0 && n <= 256 && e[2] === String(n), "invalid numeric width", "type", r);
      const i = bp(Roe, t ? n - 1 : n), s = t ? (i + d4) * $oe : l4;
      return function(o) {
        const a = jt(o, "value");
        return ne(a >= s && a <= i, `value out-of-bounds for ${r}`, "value", a), tl(t ? G6(a, 256) : a, 32);
      };
    }
  }
  {
    const e = r.match(/^bytes(\d+)$/);
    if (e) {
      const t = parseInt(e[1]);
      return ne(t !== 0 && t <= 32 && e[1] === String(t), "invalid bytes width", "type", r), function(n) {
        const i = st(n);
        return ne(i.length === t, `invalid length for ${r}`, "value", n), Poe(n);
      };
    }
  }
  switch (r) {
    case "address":
      return function(e) {
        return la($s(e), 32);
      };
    case "bool":
      return function(e) {
        return e ? Noe : Boe;
      };
    case "bytes":
      return function(e) {
        return Yr(e);
      };
    case "string":
      return function(e) {
        return rl(e);
      };
  }
  return null;
}
function dP(r, e) {
  return `${r}(${e.map(({ name: t, type: n }) => n + " " + t).join(",")})`;
}
function jm(r) {
  const e = r.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
  return e ? {
    base: e[1],
    index: e[2] + e[4],
    array: {
      base: e[1],
      prefix: e[1] + e[2],
      count: e[5] ? parseInt(e[5]) : -1
    }
  } : { base: r };
}
var Fg, ta, Th, _v, h4;
const Li = class Li {
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   *
   *  This performs all necessary checking that types are valid and
   *  do not violate the [[link-eip-712]] structural constraints as
   *  well as computes the [[primaryType]].
   */
  constructor(e) {
    L(this, _v);
    /**
     *  The primary type for the structured [[types]].
     *
     *  This is derived automatically from the [[types]], since no
     *  recursion is possible, once the DAG for the types is consturcted
     *  internally, the primary type must be the only remaining type with
     *  no parent nodes.
     */
    h(this, "primaryType");
    L(this, Fg);
    L(this, ta);
    L(this, Th);
    D(this, ta, /* @__PURE__ */ new Map()), D(this, Th, /* @__PURE__ */ new Map());
    const t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), s = {};
    Object.keys(e).forEach((c) => {
      s[c] = e[c].map(({ name: u, type: l }) => {
        let { base: d, index: f } = jm(l);
        return d === "int" && !e.int && (d = "int256"), d === "uint" && !e.uint && (d = "uint256"), { name: u, type: d + (f || "") };
      }), t.set(c, /* @__PURE__ */ new Set()), n.set(c, []), i.set(c, /* @__PURE__ */ new Set());
    }), D(this, Fg, JSON.stringify(s));
    for (const c in s) {
      const u = /* @__PURE__ */ new Set();
      for (const l of s[c]) {
        ne(!u.has(l.name), `duplicate variable name ${JSON.stringify(l.name)} in ${JSON.stringify(c)}`, "types", e), u.add(l.name);
        const d = jm(l.type).base;
        ne(d !== c, `circular type reference to ${JSON.stringify(d)}`, "types", e), !R_(d) && (ne(n.has(d), `unknown type ${JSON.stringify(d)}`, "types", e), n.get(d).push(c), t.get(c).add(d));
      }
    }
    const o = Array.from(n.keys()).filter((c) => n.get(c).length === 0);
    ne(o.length !== 0, "missing primary type", "types", e), ne(o.length === 1, `ambiguous primary types or unused types: ${o.map((c) => JSON.stringify(c)).join(", ")}`, "types", e), Ht(this, { primaryType: o[0] });
    function a(c, u) {
      ne(!u.has(c), `circular type reference to ${JSON.stringify(c)}`, "types", e), u.add(c);
      for (const l of t.get(c))
        if (n.has(l)) {
          a(l, u);
          for (const d of u)
            i.get(d).add(l);
        }
      u.delete(c);
    }
    a(this.primaryType, /* @__PURE__ */ new Set());
    for (const [c, u] of i) {
      const l = Array.from(u);
      l.sort(), m(this, ta).set(c, dP(c, s[c]) + l.map((d) => dP(d, s[d])).join(""));
    }
  }
  /**
   *  The types.
   */
  get types() {
    return JSON.parse(m(this, Fg));
  }
  /**
   *  Returnthe encoder for the specific %%type%%.
   */
  getEncoder(e) {
    let t = m(this, Th).get(e);
    return t || (t = R(this, _v, h4).call(this, e), m(this, Th).set(e, t)), t;
  }
  /**
   *  Return the full type for %%name%%.
   */
  encodeType(e) {
    const t = m(this, ta).get(e);
    return ne(t, `unknown type: ${JSON.stringify(e)}`, "name", e), t;
  }
  /**
   *  Return the encoded %%value%% for the %%type%%.
   */
  encodeData(e, t) {
    return this.getEncoder(e)(t);
  }
  /**
   *  Returns the hash of %%value%% for the type of %%name%%.
   */
  hashStruct(e, t) {
    return Yr(this.encodeData(e, t));
  }
  /**
   *  Return the fulled encoded %%value%% for the [[types]].
   */
  encode(e) {
    return this.encodeData(this.primaryType, e);
  }
  /**
   *  Return the hash of the fully encoded %%value%% for the [[types]].
   */
  hash(e) {
    return this.hashStruct(this.primaryType, e);
  }
  /**
   *  @_ignore:
   */
  _visit(e, t, n) {
    if (R_(e))
      return n(e, t);
    const i = jm(e).array;
    if (i)
      return ne(i.count === -1 || i.count === t.length, `array length mismatch; expected length ${i.count}`, "value", t), t.map((o) => this._visit(i.prefix, o, n));
    const s = this.types[e];
    if (s)
      return s.reduce((o, { name: a, type: c }) => (o[a] = this._visit(c, t[a], n), o), {});
    ne(!1, `unknown type: ${e}`, "type", e);
  }
  /**
   *  Call %%calback%% for each value in %%value%%, passing the type and
   *  component within %%value%%.
   *
   *  This is useful for replacing addresses or other transformation that
   *  may be desired on each component, based on its type.
   */
  visit(e, t) {
    return this._visit(this.primaryType, e, t);
  }
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   */
  static from(e) {
    return new Li(e);
  }
  /**
   *  Return the primary type for %%types%%.
   */
  static getPrimaryType(e) {
    return Li.from(e).primaryType;
  }
  /**
   *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
   */
  static hashStruct(e, t, n) {
    return Li.from(t).hashStruct(e, n);
  }
  /**
   *  Return the domain hash for %%domain%%.
   */
  static hashDomain(e) {
    const t = [];
    for (const n in e) {
      if (e[n] == null)
        continue;
      const i = uP[n];
      ne(i, `invalid typed-data domain key: ${JSON.stringify(n)}`, "domain", e), t.push({ name: n, type: i });
    }
    return t.sort((n, i) => $_.indexOf(n.name) - $_.indexOf(i.name)), Li.hashStruct("EIP712Domain", { EIP712Domain: t }, e);
  }
  /**
   *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static encode(e, t, n) {
    return zr([
      "0x1901",
      Li.hashDomain(e),
      Li.from(t).hash(n)
    ]);
  }
  /**
   *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static hash(e, t, n) {
    return Yr(Li.encode(e, t, n));
  }
  // Replaces all address types with ENS names with their looked up address
  /**
   * Resolves to the value from resolving all addresses in %%value%% for
   * %%types%% and the %%domain%%.
   */
  static async resolveNames(e, t, n, i) {
    e = Object.assign({}, e);
    for (const a in e)
      e[a] == null && delete e[a];
    const s = {};
    e.verifyingContract && !ti(e.verifyingContract, 20) && (s[e.verifyingContract] = "0x");
    const o = Li.from(t);
    o.visit(n, (a, c) => (a === "address" && !ti(c, 20) && (s[c] = "0x"), c));
    for (const a in s)
      s[a] = await i(a);
    return e.verifyingContract && s[e.verifyingContract] && (e.verifyingContract = s[e.verifyingContract]), n = o.visit(n, (a, c) => a === "address" && s[c] ? s[c] : c), { domain: e, value: n };
  }
  /**
   *  Returns the JSON-encoded payload expected by nodes which implement
   *  the JSON-RPC [[link-eip-712]] method.
   */
  static getPayload(e, t, n) {
    Li.hashDomain(e);
    const i = {}, s = [];
    $_.forEach((c) => {
      const u = e[c];
      u != null && (i[c] = Loe[c](u), s.push({ name: c, type: uP[c] }));
    });
    const o = Li.from(t);
    t = o.types;
    const a = Object.assign({}, t);
    return ne(a.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", t), a.EIP712Domain = s, o.encode(n), {
      types: a,
      domain: i,
      primaryType: o.primaryType,
      message: o.visit(n, (c, u) => {
        if (c.match(/^bytes(\d*)/))
          return Ne(st(u));
        if (c.match(/^u?int/))
          return jt(u).toString();
        switch (c) {
          case "address":
            return u.toLowerCase();
          case "bool":
            return !!u;
          case "string":
            return ne(typeof u == "string", "invalid string", "value", u), u;
        }
        ne(!1, "unsupported type", "type", c);
      })
    };
  }
};
Fg = new WeakMap(), ta = new WeakMap(), Th = new WeakMap(), _v = new WeakSet(), h4 = function(e) {
  {
    const i = R_(e);
    if (i)
      return i;
  }
  const t = jm(e).array;
  if (t) {
    const i = t.prefix, s = this.getEncoder(i);
    return (o) => {
      ne(t.count === -1 || t.count === o.length, `array length mismatch; expected length ${t.count}`, "value", o);
      let a = o.map(s);
      return m(this, ta).has(i) && (a = a.map(Yr)), Yr(zr(a));
    };
  }
  const n = this.types[e];
  if (n) {
    const i = rl(m(this, ta).get(e));
    return (s) => {
      const o = n.map(({ name: a, type: c }) => {
        const u = this.getEncoder(c)(s[a]);
        return m(this, ta).has(c) ? Yr(u) : u;
      });
      return o.unshift(i), zr(o);
    };
  }
  ne(!1, `unknown type: ${e}`, "type", e);
};
let uv = Li;
function Tn(r) {
  const e = /* @__PURE__ */ new Set();
  return r.forEach((t) => e.add(t)), Object.freeze(e);
}
const Uoe = "external public payable override", Foe = Tn(Uoe.split(" ")), f4 = "constant external internal payable private public pure view override", Moe = Tn(f4.split(" ")), p4 = "constructor error event fallback function receive struct", g4 = Tn(p4.split(" ")), m4 = "calldata memory storage payable indexed", Voe = Tn(m4.split(" ")), zoe = "tuple returns", joe = [p4, m4, zoe, f4].join(" "), Hoe = Tn(joe.split(" ")), Goe = {
  "(": "OPEN_PAREN",
  ")": "CLOSE_PAREN",
  "[": "OPEN_BRACKET",
  "]": "CLOSE_BRACKET",
  ",": "COMMA",
  "@": "AT"
}, Koe = new RegExp("^(\\s*)"), qoe = new RegExp("^([0-9]+)"), Woe = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)"), y4 = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$"), v4 = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
var Kr, ws, Mg, vA;
const Sv = class Sv {
  constructor(e) {
    L(this, Mg);
    L(this, Kr);
    L(this, ws);
    D(this, Kr, 0), D(this, ws, e.slice());
  }
  get offset() {
    return m(this, Kr);
  }
  get length() {
    return m(this, ws).length - m(this, Kr);
  }
  clone() {
    return new Sv(m(this, ws));
  }
  reset() {
    D(this, Kr, 0);
  }
  // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
  popKeyword(e) {
    const t = this.peek();
    if (t.type !== "KEYWORD" || !e.has(t.text))
      throw new Error(`expected keyword ${t.text}`);
    return this.pop().text;
  }
  // Pops and returns the value of the next token if it is `type`; throws if out of tokens
  popType(e) {
    if (this.peek().type !== e) {
      const t = this.peek();
      throw new Error(`expected ${e}; got ${t.type} ${JSON.stringify(t.text)}`);
    }
    return this.pop().text;
  }
  // Pops and returns a "(" TOKENS ")"
  popParen() {
    const e = this.peek();
    if (e.type !== "OPEN_PAREN")
      throw new Error("bad start");
    const t = R(this, Mg, vA).call(this, m(this, Kr) + 1, e.match + 1);
    return D(this, Kr, e.match + 1), t;
  }
  // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
  popParams() {
    const e = this.peek();
    if (e.type !== "OPEN_PAREN")
      throw new Error("bad start");
    const t = [];
    for (; m(this, Kr) < e.match - 1; ) {
      const n = this.peek().linkNext;
      t.push(R(this, Mg, vA).call(this, m(this, Kr) + 1, n)), D(this, Kr, n);
    }
    return D(this, Kr, e.match + 1), t;
  }
  // Returns the top Token, throwing if out of tokens
  peek() {
    if (m(this, Kr) >= m(this, ws).length)
      throw new Error("out-of-bounds");
    return m(this, ws)[m(this, Kr)];
  }
  // Returns the next value, if it is a keyword in `allowed`
  peekKeyword(e) {
    const t = this.peekType("KEYWORD");
    return t != null && e.has(t) ? t : null;
  }
  // Returns the value of the next token if it is `type`
  peekType(e) {
    if (this.length === 0)
      return null;
    const t = this.peek();
    return t.type === e ? t.text : null;
  }
  // Returns the next token; throws if out of tokens
  pop() {
    const e = this.peek();
    return gD(this, Kr)._++, e;
  }
  toString() {
    const e = [];
    for (let t = m(this, Kr); t < m(this, ws).length; t++) {
      const n = m(this, ws)[t];
      e.push(`${n.type}:${n.text}`);
    }
    return `<TokenString ${e.join(" ")}>`;
  }
};
Kr = new WeakMap(), ws = new WeakMap(), Mg = new WeakSet(), vA = function(e = 0, t = 0) {
  return new Sv(m(this, ws).slice(e, t).map((n) => Object.freeze(Object.assign({}, n, {
    match: n.match - e,
    linkBack: n.linkBack - e,
    linkNext: n.linkNext - e
  }))));
};
let Rs = Sv;
function Tc(r) {
  const e = [], t = (o) => {
    const a = s < r.length ? JSON.stringify(r[s]) : "$EOI";
    throw new Error(`invalid token ${a} at ${s}: ${o}`);
  };
  let n = [], i = [], s = 0;
  for (; s < r.length; ) {
    let o = r.substring(s), a = o.match(Koe);
    a && (s += a[1].length, o = r.substring(s));
    const c = { depth: n.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset: s, value: -1 };
    e.push(c);
    let u = Goe[o[0]] || "";
    if (u) {
      if (c.type = u, c.text = o[0], s++, u === "OPEN_PAREN")
        n.push(e.length - 1), i.push(e.length - 1);
      else if (u == "CLOSE_PAREN")
        n.length === 0 && t("no matching open bracket"), c.match = n.pop(), e[c.match].match = e.length - 1, c.depth--, c.linkBack = i.pop(), e[c.linkBack].linkNext = e.length - 1;
      else if (u === "COMMA")
        c.linkBack = i.pop(), e[c.linkBack].linkNext = e.length - 1, i.push(e.length - 1);
      else if (u === "OPEN_BRACKET")
        c.type = "BRACKET";
      else if (u === "CLOSE_BRACKET") {
        let l = e.pop().text;
        if (e.length > 0 && e[e.length - 1].type === "NUMBER") {
          const d = e.pop().text;
          l = d + l, e[e.length - 1].value = Ti(d);
        }
        if (e.length === 0 || e[e.length - 1].type !== "BRACKET")
          throw new Error("missing opening bracket");
        e[e.length - 1].text += l;
      }
      continue;
    }
    if (a = o.match(Woe), a) {
      if (c.text = a[1], s += c.text.length, Hoe.has(c.text)) {
        c.type = "KEYWORD";
        continue;
      }
      if (c.text.match(v4)) {
        c.type = "TYPE";
        continue;
      }
      c.type = "ID";
      continue;
    }
    if (a = o.match(qoe), a) {
      c.text = a[1], c.type = "NUMBER", s += c.text.length;
      continue;
    }
    throw new Error(`unexpected token ${JSON.stringify(o[0])} at position ${s}`);
  }
  return new Rs(e.map((o) => Object.freeze(o)));
}
function hP(r, e) {
  let t = [];
  for (const n in e.keys())
    r.has(n) && t.push(n);
  if (t.length > 1)
    throw new Error(`conflicting types: ${t.join(", ")}`);
}
function A0(r, e) {
  if (e.peekKeyword(g4)) {
    const t = e.pop().text;
    if (t !== r)
      throw new Error(`expected ${r}, got ${t}`);
  }
  return e.popType("ID");
}
function da(r, e) {
  const t = /* @__PURE__ */ new Set();
  for (; ; ) {
    const n = r.peekType("KEYWORD");
    if (n == null || e && !e.has(n))
      break;
    if (r.pop(), t.has(n))
      throw new Error(`duplicate keywords: ${JSON.stringify(n)}`);
    t.add(n);
  }
  return Object.freeze(t);
}
function b4(r) {
  let e = da(r, Moe);
  return hP(e, Tn("constant payable nonpayable".split(" "))), hP(e, Tn("pure view payable nonpayable".split(" "))), e.has("view") ? "view" : e.has("pure") ? "pure" : e.has("payable") ? "payable" : e.has("nonpayable") ? "nonpayable" : e.has("constant") ? "view" : "nonpayable";
}
function ca(r, e) {
  return r.popParams().map((t) => tn.from(t, e));
}
function w4(r) {
  if (r.peekType("AT")) {
    if (r.pop(), r.peekType("NUMBER"))
      return jt(r.pop().text);
    throw new Error("invalid gas");
  }
  return null;
}
function nl(r) {
  if (r.length)
    throw new Error(`unexpected tokens at offset ${r.offset}: ${r.toString()}`);
}
const Zoe = new RegExp(/^(.*)\[([0-9]*)\]$/);
function fP(r) {
  const e = r.match(v4);
  if (ne(e, "invalid type", "type", r), r === "uint")
    return "uint256";
  if (r === "int")
    return "int256";
  if (e[2]) {
    const t = parseInt(e[2]);
    ne(t !== 0 && t <= 32, "invalid bytes length", "type", r);
  } else if (e[3]) {
    const t = parseInt(e[3]);
    ne(t !== 0 && t <= 256 && t % 8 === 0, "invalid numeric width", "type", r);
  }
  return r;
}
const rr = {}, ai = Symbol.for("_ethers_internal"), pP = "_ParamTypeInternal", gP = "_ErrorInternal", mP = "_EventInternal", yP = "_ConstructorInternal", vP = "_FallbackInternal", bP = "_FunctionInternal", wP = "_StructInternal";
var kh, by;
const Ui = class Ui {
  /**
   *  @private
   */
  constructor(e, t, n, i, s, o, a, c) {
    L(this, kh);
    /**
     *  The local name of the parameter (or ``""`` if unbound)
     */
    h(this, "name");
    /**
     *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
     *  ``"uint256[3][]"``)
     */
    h(this, "type");
    /**
     *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
     */
    h(this, "baseType");
    /**
     *  True if the parameters is indexed.
     *
     *  For non-indexable types this is ``null``.
     */
    h(this, "indexed");
    /**
     *  The components for the tuple.
     *
     *  For non-tuple types this is ``null``.
     */
    h(this, "components");
    /**
     *  The array length, or ``-1`` for dynamic-lengthed arrays.
     *
     *  For non-array types this is ``null``.
     */
    h(this, "arrayLength");
    /**
     *  The type of each child in the array.
     *
     *  For non-array types this is ``null``.
     */
    h(this, "arrayChildren");
    if (b0(e, rr, "ParamType"), Object.defineProperty(this, ai, { value: pP }), o && (o = Object.freeze(o.slice())), i === "array") {
      if (a == null || c == null)
        throw new Error("");
    } else if (a != null || c != null)
      throw new Error("");
    if (i === "tuple") {
      if (o == null)
        throw new Error("");
    } else if (o != null)
      throw new Error("");
    Ht(this, {
      name: t,
      type: n,
      baseType: i,
      indexed: s,
      components: o,
      arrayLength: a,
      arrayChildren: c
    });
  }
  /**
   *  Return a string representation of this type.
   *
   *  For example,
   *
   *  ``sighash" => "(uint256,address)"``
   *
   *  ``"minimal" => "tuple(uint256,address) indexed"``
   *
   *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
   */
  format(e) {
    if (e == null && (e = "sighash"), e === "json") {
      const n = this.name || "";
      if (this.isArray()) {
        const s = JSON.parse(this.arrayChildren.format("json"));
        return s.name = n, s.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`, JSON.stringify(s);
      }
      const i = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: n
      };
      return typeof this.indexed == "boolean" && (i.indexed = this.indexed), this.isTuple() && (i.components = this.components.map((s) => JSON.parse(s.format(e)))), JSON.stringify(i);
    }
    let t = "";
    return this.isArray() ? (t += this.arrayChildren.format(e), t += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`) : this.isTuple() ? t += "(" + this.components.map((n) => n.format(e)).join(e === "full" ? ", " : ",") + ")" : t += this.type, e !== "sighash" && (this.indexed === !0 && (t += " indexed"), e === "full" && this.name && (t += " " + this.name)), t;
  }
  /**
   *  Returns true if %%this%% is an Array type.
   *
   *  This provides a type gaurd ensuring that [[arrayChildren]]
   *  and [[arrayLength]] are non-null.
   */
  isArray() {
    return this.baseType === "array";
  }
  /**
   *  Returns true if %%this%% is a Tuple type.
   *
   *  This provides a type gaurd ensuring that [[components]]
   *  is non-null.
   */
  isTuple() {
    return this.baseType === "tuple";
  }
  /**
   *  Returns true if %%this%% is an Indexable type.
   *
   *  This provides a type gaurd ensuring that [[indexed]]
   *  is non-null.
   */
  isIndexable() {
    return this.indexed != null;
  }
  /**
   *  Walks the **ParamType** with %%value%%, calling %%process%%
   *  on each type, destructing the %%value%% recursively.
   */
  walk(e, t) {
    if (this.isArray()) {
      if (!Array.isArray(e))
        throw new Error("invalid array value");
      if (this.arrayLength !== -1 && e.length !== this.arrayLength)
        throw new Error("array is wrong length");
      const n = this;
      return e.map((i) => n.arrayChildren.walk(i, t));
    }
    if (this.isTuple()) {
      if (!Array.isArray(e))
        throw new Error("invalid tuple value");
      if (e.length !== this.components.length)
        throw new Error("array is wrong length");
      const n = this;
      return e.map((i, s) => n.components[s].walk(i, t));
    }
    return t(this.type, e);
  }
  /**
   *  Walks the **ParamType** with %%value%%, asynchronously calling
   *  %%process%% on each type, destructing the %%value%% recursively.
   *
   *  This can be used to resolve ENS names by walking and resolving each
   *  ``"address"`` type.
   */
  async walkAsync(e, t) {
    const n = [], i = [e];
    return R(this, kh, by).call(this, n, e, t, (s) => {
      i[0] = s;
    }), n.length && await Promise.all(n), i[0];
  }
  /**
   *  Creates a new **ParamType** for %%obj%%.
   *
   *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
   *  otherwise the ``indexed`` keyword will throw an error.
   */
  static from(e, t) {
    if (Ui.isParamType(e))
      return e;
    if (typeof e == "string")
      try {
        return Ui.from(Tc(e), t);
      } catch {
        ne(!1, "invalid param type", "obj", e);
      }
    else if (e instanceof Rs) {
      let a = "", c = "", u = null;
      da(e, Tn(["tuple"])).has("tuple") || e.peekType("OPEN_PAREN") ? (c = "tuple", u = e.popParams().map((g) => Ui.from(g)), a = `tuple(${u.map((g) => g.format()).join(",")})`) : (a = fP(e.popType("TYPE")), c = a);
      let l = null, d = null;
      for (; e.length && e.peekType("BRACKET"); ) {
        const g = e.pop();
        l = new Ui(rr, "", a, c, null, u, d, l), d = g.value, a += g.text, c = "array", u = null;
      }
      let f = null;
      if (da(e, Voe).has("indexed")) {
        if (!t)
          throw new Error("");
        f = !0;
      }
      const y = e.peekType("ID") ? e.pop().text : "";
      if (e.length)
        throw new Error("leftover tokens");
      return new Ui(rr, y, a, c, f, u, d, l);
    }
    const n = e.name;
    ne(!n || typeof n == "string" && n.match(y4), "invalid name", "obj.name", n);
    let i = e.indexed;
    i != null && (ne(t, "parameter cannot be indexed", "obj.indexed", e.indexed), i = !!i);
    let s = e.type, o = s.match(Zoe);
    if (o) {
      const a = parseInt(o[2] || "-1"), c = Ui.from({
        type: o[1],
        components: e.components
      });
      return new Ui(rr, n || "", s, "array", i, null, a, c);
    }
    if (s === "tuple" || s.startsWith(
      "tuple("
      /* fix: ) */
    ) || s.startsWith(
      "("
      /* fix: ) */
    )) {
      const a = e.components != null ? e.components.map((u) => Ui.from(u)) : null;
      return new Ui(rr, n || "", s, "tuple", i, a, null, null);
    }
    return s = fP(e.type), new Ui(rr, n || "", s, s, i, null, null, null);
  }
  /**
   *  Returns true if %%value%% is a **ParamType**.
   */
  static isParamType(e) {
    return e && e[ai] === pP;
  }
};
kh = new WeakSet(), by = function(e, t, n, i) {
  if (this.isArray()) {
    if (!Array.isArray(t))
      throw new Error("invalid array value");
    if (this.arrayLength !== -1 && t.length !== this.arrayLength)
      throw new Error("array is wrong length");
    const o = this.arrayChildren, a = t.slice();
    a.forEach((c, u) => {
      var l;
      R(l = o, kh, by).call(l, e, c, n, (d) => {
        a[u] = d;
      });
    }), i(a);
    return;
  }
  if (this.isTuple()) {
    const o = this.components;
    let a;
    if (Array.isArray(t))
      a = t.slice();
    else {
      if (t == null || typeof t != "object")
        throw new Error("invalid tuple value");
      a = o.map((c) => {
        if (!c.name)
          throw new Error("cannot use object value with unnamed components");
        if (!(c.name in t))
          throw new Error(`missing value for component ${c.name}`);
        return t[c.name];
      });
    }
    if (a.length !== this.components.length)
      throw new Error("array is wrong length");
    a.forEach((c, u) => {
      var l;
      R(l = o[u], kh, by).call(l, e, c, n, (d) => {
        a[u] = d;
      });
    }), i(a);
    return;
  }
  const s = n(this.type, t);
  s.then ? e.push((async function() {
    i(await s);
  })()) : i(s);
};
let tn = Ui;
class il {
  /**
   *  @private
   */
  constructor(e, t, n) {
    /**
     *  The type of the fragment.
     */
    h(this, "type");
    /**
     *  The inputs for the fragment.
     */
    h(this, "inputs");
    b0(e, rr, "Fragment"), n = Object.freeze(n.slice()), Ht(this, { type: t, inputs: n });
  }
  /**
   *  Creates a new **Fragment** for %%obj%%, wich can be any supported
   *  ABI frgament type.
   */
  static from(e) {
    if (typeof e == "string") {
      try {
        il.from(JSON.parse(e));
      } catch {
      }
      return il.from(Tc(e));
    }
    if (e instanceof Rs)
      switch (e.peekKeyword(g4)) {
        case "constructor":
          return sa.from(e);
        case "error":
          return Zn.from(e);
        case "event":
          return io.from(e);
        case "fallback":
        case "receive":
          return Vo.from(e);
        case "function":
          return so.from(e);
        case "struct":
          return Uu.from(e);
      }
    else if (typeof e == "object") {
      switch (e.type) {
        case "constructor":
          return sa.from(e);
        case "error":
          return Zn.from(e);
        case "event":
          return io.from(e);
        case "fallback":
        case "receive":
          return Vo.from(e);
        case "function":
          return so.from(e);
        case "struct":
          return Uu.from(e);
      }
      _t(!1, `unsupported type: ${e.type}`, "UNSUPPORTED_OPERATION", {
        operation: "Fragment.from"
      });
    }
    ne(!1, "unsupported frgament object", "obj", e);
  }
  /**
   *  Returns true if %%value%% is a [[ConstructorFragment]].
   */
  static isConstructor(e) {
    return sa.isFragment(e);
  }
  /**
   *  Returns true if %%value%% is an [[ErrorFragment]].
   */
  static isError(e) {
    return Zn.isFragment(e);
  }
  /**
   *  Returns true if %%value%% is an [[EventFragment]].
   */
  static isEvent(e) {
    return io.isFragment(e);
  }
  /**
   *  Returns true if %%value%% is a [[FunctionFragment]].
   */
  static isFunction(e) {
    return so.isFragment(e);
  }
  /**
   *  Returns true if %%value%% is a [[StructFragment]].
   */
  static isStruct(e) {
    return Uu.isFragment(e);
  }
}
class I0 extends il {
  /**
   *  @private
   */
  constructor(t, n, i, s) {
    super(t, n, s);
    /**
     *  The name of the fragment.
     */
    h(this, "name");
    ne(typeof i == "string" && i.match(y4), "invalid identifier", "name", i), s = Object.freeze(s.slice()), Ht(this, { name: i });
  }
}
function Zp(r, e) {
  return "(" + e.map((t) => t.format(r)).join(r === "full" ? ", " : ",") + ")";
}
class Zn extends I0 {
  /**
   *  @private
   */
  constructor(e, t, n) {
    super(e, "error", t, n), Object.defineProperty(this, ai, { value: gP });
  }
  /**
   *  The Custom Error selector.
   */
  get selector() {
    return rl(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this fragment as %%format%%.
   */
  format(e) {
    if (e == null && (e = "sighash"), e === "json")
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((n) => JSON.parse(n.format(e)))
      });
    const t = [];
    return e !== "sighash" && t.push("error"), t.push(this.name + Zp(e, this.inputs)), t.join(" ");
  }
  /**
   *  Returns a new **ErrorFragment** for %%obj%%.
   */
  static from(e) {
    if (Zn.isFragment(e))
      return e;
    if (typeof e == "string")
      return Zn.from(Tc(e));
    if (e instanceof Rs) {
      const t = A0("error", e), n = ca(e);
      return nl(e), new Zn(rr, t, n);
    }
    return new Zn(rr, e.name, e.inputs ? e.inputs.map(tn.from) : []);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **ErrorFragment**.
   */
  static isFragment(e) {
    return e && e[ai] === gP;
  }
}
class io extends I0 {
  /**
   *  @private
   */
  constructor(t, n, i, s) {
    super(t, "event", n, i);
    /**
     *  Whether this event is anonymous.
     */
    h(this, "anonymous");
    Object.defineProperty(this, ai, { value: mP }), Ht(this, { anonymous: s });
  }
  /**
   *  The Event topic hash.
   */
  get topicHash() {
    return rl(this.format("sighash"));
  }
  /**
   *  Returns a string representation of this event as %%format%%.
   */
  format(t) {
    if (t == null && (t = "sighash"), t === "json")
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((i) => JSON.parse(i.format(t)))
      });
    const n = [];
    return t !== "sighash" && n.push("event"), n.push(this.name + Zp(t, this.inputs)), t !== "sighash" && this.anonymous && n.push("anonymous"), n.join(" ");
  }
  /**
   *  Return the topic hash for an event with %%name%% and %%params%%.
   */
  static getTopicHash(t, n) {
    return n = (n || []).map((s) => tn.from(s)), new io(rr, t, n, !1).topicHash;
  }
  /**
   *  Returns a new **EventFragment** for %%obj%%.
   */
  static from(t) {
    if (io.isFragment(t))
      return t;
    if (typeof t == "string")
      try {
        return io.from(Tc(t));
      } catch {
        ne(!1, "invalid event fragment", "obj", t);
      }
    else if (t instanceof Rs) {
      const n = A0("event", t), i = ca(t, !0), s = !!da(t, Tn(["anonymous"])).has("anonymous");
      return nl(t), new io(rr, n, i, s);
    }
    return new io(rr, t.name, t.inputs ? t.inputs.map((n) => tn.from(n, !0)) : [], !!t.anonymous);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **EventFragment**.
   */
  static isFragment(t) {
    return t && t[ai] === mP;
  }
}
class sa extends il {
  /**
   *  @private
   */
  constructor(t, n, i, s, o) {
    super(t, n, i);
    /**
     *  Whether the constructor can receive an endowment.
     */
    h(this, "payable");
    /**
     *  The recommended gas limit for deployment or ``null``.
     */
    h(this, "gas");
    Object.defineProperty(this, ai, { value: yP }), Ht(this, { payable: s, gas: o });
  }
  /**
   *  Returns a string representation of this constructor as %%format%%.
   */
  format(t) {
    if (_t(t != null && t !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" }), t === "json")
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.payable ? "payable" : "undefined",
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(t)))
      });
    const n = [`constructor${Zp(t, this.inputs)}`];
    return this.payable && n.push("payable"), this.gas != null && n.push(`@${this.gas.toString()}`), n.join(" ");
  }
  /**
   *  Returns a new **ConstructorFragment** for %%obj%%.
   */
  static from(t) {
    if (sa.isFragment(t))
      return t;
    if (typeof t == "string")
      try {
        return sa.from(Tc(t));
      } catch {
        ne(!1, "invalid constuctor fragment", "obj", t);
      }
    else if (t instanceof Rs) {
      da(t, Tn(["constructor"]));
      const n = ca(t), i = !!da(t, Foe).has("payable"), s = w4(t);
      return nl(t), new sa(rr, "constructor", n, i, s);
    }
    return new sa(rr, "constructor", t.inputs ? t.inputs.map(tn.from) : [], !!t.payable, t.gas != null ? t.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **ConstructorFragment**.
   */
  static isFragment(t) {
    return t && t[ai] === yP;
  }
}
class Vo extends il {
  constructor(t, n, i) {
    super(t, "fallback", n);
    /**
     *  If the function can be sent value during invocation.
     */
    h(this, "payable");
    Object.defineProperty(this, ai, { value: vP }), Ht(this, { payable: i });
  }
  /**
   *  Returns a string representation of this fallback as %%format%%.
   */
  format(t) {
    const n = this.inputs.length === 0 ? "receive" : "fallback";
    if (t === "json") {
      const i = this.payable ? "payable" : "nonpayable";
      return JSON.stringify({ type: n, stateMutability: i });
    }
    return `${n}()${this.payable ? " payable" : ""}`;
  }
  /**
   *  Returns a new **FallbackFragment** for %%obj%%.
   */
  static from(t) {
    if (Vo.isFragment(t))
      return t;
    if (typeof t == "string")
      try {
        return Vo.from(Tc(t));
      } catch {
        ne(!1, "invalid fallback fragment", "obj", t);
      }
    else if (t instanceof Rs) {
      const n = t.toString(), i = t.peekKeyword(Tn(["fallback", "receive"]));
      if (ne(i, "type must be fallback or receive", "obj", n), t.popKeyword(Tn(["fallback", "receive"])) === "receive") {
        const c = ca(t);
        return ne(c.length === 0, "receive cannot have arguments", "obj.inputs", c), da(t, Tn(["payable"])), nl(t), new Vo(rr, [], !0);
      }
      let o = ca(t);
      o.length ? ne(o.length === 1 && o[0].type === "bytes", "invalid fallback inputs", "obj.inputs", o.map((c) => c.format("minimal")).join(", ")) : o = [tn.from("bytes")];
      const a = b4(t);
      if (ne(a === "nonpayable" || a === "payable", "fallback cannot be constants", "obj.stateMutability", a), da(t, Tn(["returns"])).has("returns")) {
        const c = ca(t);
        ne(c.length === 1 && c[0].type === "bytes", "invalid fallback outputs", "obj.outputs", c.map((u) => u.format("minimal")).join(", "));
      }
      return nl(t), new Vo(rr, o, a === "payable");
    }
    if (t.type === "receive")
      return new Vo(rr, [], !0);
    if (t.type === "fallback") {
      const n = [tn.from("bytes")], i = t.stateMutability === "payable";
      return new Vo(rr, n, i);
    }
    ne(!1, "invalid fallback description", "obj", t);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FallbackFragment**.
   */
  static isFragment(t) {
    return t && t[ai] === vP;
  }
}
class so extends I0 {
  /**
   *  @private
   */
  constructor(t, n, i, s, o, a) {
    super(t, "function", n, s);
    /**
     *  If the function is constant (e.g. ``pure`` or ``view`` functions).
     */
    h(this, "constant");
    /**
     *  The returned types for the result of calling this function.
     */
    h(this, "outputs");
    /**
     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
     *  or ``pure``)
     */
    h(this, "stateMutability");
    /**
     *  If the function can be sent value during invocation.
     */
    h(this, "payable");
    /**
     *  The recommended gas limit to send when calling this function.
     */
    h(this, "gas");
    Object.defineProperty(this, ai, { value: bP }), o = Object.freeze(o.slice()), Ht(this, { constant: i === "view" || i === "pure", gas: a, outputs: o, payable: i === "payable", stateMutability: i });
  }
  /**
   *  The Function selector.
   */
  get selector() {
    return rl(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this function as %%format%%.
   */
  format(t) {
    if (t == null && (t = "sighash"), t === "json")
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(t))),
        outputs: this.outputs.map((i) => JSON.parse(i.format(t)))
      });
    const n = [];
    return t !== "sighash" && n.push("function"), n.push(this.name + Zp(t, this.inputs)), t !== "sighash" && (this.stateMutability !== "nonpayable" && n.push(this.stateMutability), this.outputs && this.outputs.length && (n.push("returns"), n.push(Zp(t, this.outputs))), this.gas != null && n.push(`@${this.gas.toString()}`)), n.join(" ");
  }
  /**
   *  Return the selector for a function with %%name%% and %%params%%.
   */
  static getSelector(t, n) {
    return n = (n || []).map((s) => tn.from(s)), new so(rr, t, "view", n, [], null).selector;
  }
  /**
   *  Returns a new **FunctionFragment** for %%obj%%.
   */
  static from(t) {
    if (so.isFragment(t))
      return t;
    if (typeof t == "string")
      try {
        return so.from(Tc(t));
      } catch {
        ne(!1, "invalid function fragment", "obj", t);
      }
    else if (t instanceof Rs) {
      const i = A0("function", t), s = ca(t), o = b4(t);
      let a = [];
      da(t, Tn(["returns"])).has("returns") && (a = ca(t));
      const c = w4(t);
      return nl(t), new so(rr, i, o, s, a, c);
    }
    let n = t.stateMutability;
    return n == null && (n = "payable", typeof t.constant == "boolean" ? (n = "view", t.constant || (n = "payable", typeof t.payable == "boolean" && !t.payable && (n = "nonpayable"))) : typeof t.payable == "boolean" && !t.payable && (n = "nonpayable")), new so(rr, t.name, n, t.inputs ? t.inputs.map(tn.from) : [], t.outputs ? t.outputs.map(tn.from) : [], t.gas != null ? t.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FunctionFragment**.
   */
  static isFragment(t) {
    return t && t[ai] === bP;
  }
}
class Uu extends I0 {
  /**
   *  @private
   */
  constructor(e, t, n) {
    super(e, "struct", t, n), Object.defineProperty(this, ai, { value: wP });
  }
  /**
   *  Returns a string representation of this struct as %%format%%.
   */
  format() {
    throw new Error("@TODO");
  }
  /**
   *  Returns a new **StructFragment** for %%obj%%.
   */
  static from(e) {
    if (typeof e == "string")
      try {
        return Uu.from(Tc(e));
      } catch {
        ne(!1, "invalid struct fragment", "obj", e);
      }
    else if (e instanceof Rs) {
      const t = A0("struct", e), n = ca(e);
      return nl(e), new Uu(rr, t, n);
    }
    return new Uu(rr, e.name, e.inputs ? e.inputs.map(tn.from) : []);
  }
  // @TODO: fix this return type
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **StructFragment**.
   */
  static isFragment(e) {
    return e && e[ai] === wP;
  }
}
const Us = /* @__PURE__ */ new Map();
Us.set(0, "GENERIC_PANIC");
Us.set(1, "ASSERT_FALSE");
Us.set(17, "OVERFLOW");
Us.set(18, "DIVIDE_BY_ZERO");
Us.set(33, "ENUM_RANGE_ERROR");
Us.set(34, "BAD_STORAGE_DATA");
Us.set(49, "STACK_UNDERFLOW");
Us.set(50, "ARRAY_RANGE_ERROR");
Us.set(65, "OUT_OF_MEMORY");
Us.set(81, "UNINITIALIZED_FUNCTION_CALL");
const Joe = new RegExp(/^bytes([0-9]*)$/), Xoe = new RegExp(/^(u?int)([0-9]*)$/);
let P_ = null, _P = 1024;
function Yoe(r, e, t, n) {
  let i = "missing revert data", s = null;
  const o = null;
  let a = null;
  if (t) {
    i = "execution reverted";
    const u = st(t);
    if (t = Ne(t), u.length === 0)
      i += " (no data present; likely require(false) occurred", s = "require(false)";
    else if (u.length % 32 !== 4)
      i += " (could not decode reason; invalid data length)";
    else if (Ne(u.slice(0, 4)) === "0x08c379a0")
      try {
        s = n.decode(["string"], u.slice(4))[0], a = {
          signature: "Error(string)",
          name: "Error",
          args: [s]
        }, i += `: ${JSON.stringify(s)}`;
      } catch {
        i += " (could not decode reason; invalid string data)";
      }
    else if (Ne(u.slice(0, 4)) === "0x4e487b71")
      try {
        const l = Number(n.decode(["uint256"], u.slice(4))[0]);
        a = {
          signature: "Panic(uint256)",
          name: "Panic",
          args: [l]
        }, s = `Panic due to ${Us.get(l) || "UNKNOWN"}(${l})`, i += `: ${s}`;
      } catch {
        i += " (could not decode panic code)";
      }
    else
      i += " (unknown custom error)";
  }
  const c = {
    to: e.to ? $s(e.to) : null,
    data: e.data || "0x"
  };
  return e.from && (c.from = $s(e.from)), M6(i, "CALL_EXCEPTION", {
    action: r,
    data: t,
    reason: s,
    transaction: c,
    invocation: o,
    revert: a
  });
}
var Qa, Kl;
const Ev = class Ev {
  constructor() {
    L(this, Qa);
  }
  /**
   *  Get the default values for the given %%types%%.
   *
   *  For example, a ``uint`` is by default ``0`` and ``bool``
   *  is by default ``false``.
   */
  getDefaultValue(e) {
    const t = e.map((i) => R(this, Qa, Kl).call(this, tn.from(i)));
    return new zm(t, "_").defaultValue();
  }
  /**
   *  Encode the %%values%% as the %%types%% into ABI data.
   *
   *  @returns DataHexstring
   */
  encode(e, t) {
    V6(t.length, e.length, "types/values length mismatch");
    const n = e.map((o) => R(this, Qa, Kl).call(this, tn.from(o))), i = new zm(n, "_"), s = new pA();
    return i.encode(s, t), s.data;
  }
  /**
   *  Decode the ABI %%data%% as the %%types%% into values.
   *
   *  If %%loose%% decoding is enabled, then strict padding is
   *  not enforced. Some older versions of Solidity incorrectly
   *  padded event data emitted from ``external`` functions.
   */
  decode(e, t, n) {
    const i = e.map((o) => R(this, Qa, Kl).call(this, tn.from(o)));
    return new zm(i, "_").decode(new gA(t, n, _P));
  }
  static _setDefaultMaxInflation(e) {
    ne(typeof e == "number" && Number.isInteger(e), "invalid defaultMaxInflation factor", "value", e), _P = e;
  }
  /**
   *  Returns the shared singleton instance of a default [[AbiCoder]].
   *
   *  On the first call, the instance is created internally.
   */
  static defaultAbiCoder() {
    return P_ == null && (P_ = new Ev()), P_;
  }
  /**
   *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
   *  result %%data%% for the [[CallExceptionAction]] %%action%% against
   *  the Transaction %%tx%%.
   */
  static getBuiltinCallException(e, t, n) {
    return Yoe(e, t, n, Ev.defaultAbiCoder());
  }
};
Qa = new WeakSet(), Kl = function(e) {
  if (e.isArray())
    return new Qse(R(this, Qa, Kl).call(this, e.arrayChildren), e.arrayLength, e.name);
  if (e.isTuple())
    return new zm(e.components.map((n) => R(this, Qa, Kl).call(this, n)), e.name);
  switch (e.baseType) {
    case "address":
      return new Xse(e.name);
    case "bool":
      return new eoe(e.name);
    case "string":
      return new uoe(e.name);
    case "bytes":
      return new toe(e.name);
    case "":
      return new ioe(e.name);
  }
  let t = e.type.match(Xoe);
  if (t) {
    let n = parseInt(t[2] || "256");
    return ne(n !== 0 && n <= 256 && n % 8 === 0, "invalid " + t[1] + " bit length", "param", e), new coe(n / 8, t[1] === "int", e.name);
  }
  if (t = e.type.match(Joe), t) {
    let n = parseInt(t[1]);
    return ne(n !== 0 && n <= 32, "invalid bytes length", "param", e), new roe(n, e.name);
  }
  ne(!1, "invalid type", "type", e.type);
};
let Jp = Ev;
class Qoe {
  /**
   *  @_ignore:
   */
  constructor(e, t, n) {
    /**
     *  The matching fragment for the ``topic0``.
     */
    h(this, "fragment");
    /**
     *  The name of the Event.
     */
    h(this, "name");
    /**
     *  The full Event signature.
     */
    h(this, "signature");
    /**
     *  The topic hash for the Event.
     */
    h(this, "topic");
    /**
     *  The arguments passed into the Event with ``emit``.
     */
    h(this, "args");
    const i = e.name, s = e.format();
    Ht(this, {
      fragment: e,
      name: i,
      signature: s,
      topic: t,
      args: n
    });
  }
}
class eae {
  /**
   *  @_ignore:
   */
  constructor(e, t, n, i) {
    /**
     *  The matching fragment from the transaction ``data``.
     */
    h(this, "fragment");
    /**
     *  The name of the Function from the transaction ``data``.
     */
    h(this, "name");
    /**
     *  The arguments passed to the Function from the transaction ``data``.
     */
    h(this, "args");
    /**
     *  The full Function signature from the transaction ``data``.
     */
    h(this, "signature");
    /**
     *  The selector for the Function from the transaction ``data``.
     */
    h(this, "selector");
    /**
     *  The ``value`` (in wei) from the transaction.
     */
    h(this, "value");
    const s = e.name, o = e.format();
    Ht(this, {
      fragment: e,
      name: s,
      args: n,
      signature: o,
      selector: t,
      value: i
    });
  }
}
class tae {
  /**
   *  @_ignore:
   */
  constructor(e, t, n) {
    /**
     *  The matching fragment.
     */
    h(this, "fragment");
    /**
     *  The name of the Error.
     */
    h(this, "name");
    /**
     *  The arguments passed to the Error with ``revert``.
     */
    h(this, "args");
    /**
     *  The full Error signature.
     */
    h(this, "signature");
    /**
     *  The selector for the Error.
     */
    h(this, "selector");
    const i = e.name, s = e.format();
    Ht(this, {
      fragment: e,
      name: i,
      args: n,
      signature: s,
      selector: t
    });
  }
}
class SP {
  /**
   *  @_ignore:
   */
  constructor(e) {
    /**
     *  The ``keccak256`` of the value logged.
     */
    h(this, "hash");
    /**
     *  @_ignore:
     */
    h(this, "_isIndexed");
    Ht(this, { hash: e, _isIndexed: !0 });
  }
  /**
   *  Returns ``true`` if %%value%% is an **Indexed**.
   *
   *  This provides a Type Guard for property access.
   */
  static isIndexed(e) {
    return !!(e && e._isIndexed);
  }
}
const EP = {
  0: "generic panic",
  1: "assert(false)",
  17: "arithmetic overflow",
  18: "division or modulo by zero",
  33: "enum overflow",
  34: "invalid encoded storage byte array accessed",
  49: "out-of-bounds array access; popping on an empty array",
  50: "out-of-bounds access of an array or bytesN",
  65: "out of memory",
  81: "uninitialized function"
}, xP = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: (r) => `reverted with reason string ${JSON.stringify(r)}`
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
    reason: (r) => {
      let e = "unknown panic code";
      return r >= 0 && r <= 255 && EP[r.toString()] && (e = EP[r.toString()]), `reverted with panic code 0x${r.toString(16)} (${e})`;
    }
  }
};
var Qs, eo, to, hn, wo, wy, _y;
const Wc = class Wc {
  /**
   *  Create a new Interface for the %%fragments%%.
   */
  constructor(e) {
    L(this, wo);
    /**
     *  All the Contract ABI members (i.e. methods, events, errors, etc).
     */
    h(this, "fragments");
    /**
     *  The Contract constructor.
     */
    h(this, "deploy");
    /**
     *  The Fallback method, if any.
     */
    h(this, "fallback");
    /**
     *  If receiving ether is supported.
     */
    h(this, "receive");
    L(this, Qs);
    L(this, eo);
    L(this, to);
    //    #structs: Map<string, StructFragment>;
    L(this, hn);
    let t = [];
    typeof e == "string" ? t = JSON.parse(e) : t = e, D(this, to, /* @__PURE__ */ new Map()), D(this, Qs, /* @__PURE__ */ new Map()), D(this, eo, /* @__PURE__ */ new Map());
    const n = [];
    for (const o of t)
      try {
        n.push(il.from(o));
      } catch (a) {
        console.log(`[Warning] Invalid Fragment ${JSON.stringify(o)}:`, a.message);
      }
    Ht(this, {
      fragments: Object.freeze(n)
    });
    let i = null, s = !1;
    D(this, hn, this.getAbiCoder()), this.fragments.forEach((o, a) => {
      let c;
      switch (o.type) {
        case "constructor":
          if (this.deploy) {
            console.log("duplicate definition - constructor");
            return;
          }
          Ht(this, { deploy: o });
          return;
        case "fallback":
          o.inputs.length === 0 ? s = !0 : (ne(!i || o.payable !== i.payable, "conflicting fallback fragments", `fragments[${a}]`, o), i = o, s = i.payable);
          return;
        case "function":
          c = m(this, to);
          break;
        case "event":
          c = m(this, eo);
          break;
        case "error":
          c = m(this, Qs);
          break;
        default:
          return;
      }
      const u = o.format();
      c.has(u) || c.set(u, o);
    }), this.deploy || Ht(this, {
      deploy: sa.from("constructor()")
    }), Ht(this, { fallback: i, receive: s });
  }
  /**
   *  Returns the entire Human-Readable ABI, as an array of
   *  signatures, optionally as %%minimal%% strings, which
   *  removes parameter names and unneceesary spaces.
   */
  format(e) {
    const t = e ? "minimal" : "full";
    return this.fragments.map((i) => i.format(t));
  }
  /**
   *  Return the JSON-encoded ABI. This is the format Solidiy
   *  returns.
   */
  formatJson() {
    const e = this.fragments.map((t) => t.format("json"));
    return JSON.stringify(e.map((t) => JSON.parse(t)));
  }
  /**
   *  The ABI coder that will be used to encode and decode binary
   *  data.
   */
  getAbiCoder() {
    return Jp.defaultAbiCoder();
  }
  /**
   *  Get the function name for %%key%%, which may be a function selector,
   *  function name or function signature that belongs to the ABI.
   */
  getFunctionName(e) {
    const t = R(this, wo, wy).call(this, e, null, !1);
    return ne(t, "no matching function", "key", e), t.name;
  }
  /**
   *  Returns true if %%key%% (a function selector, function name or
   *  function signature) is present in the ABI.
   *
   *  In the case of a function name, the name may be ambiguous, so
   *  accessing the [[FunctionFragment]] may require refinement.
   */
  hasFunction(e) {
    return !!R(this, wo, wy).call(this, e, null, !1);
  }
  /**
   *  Get the [[FunctionFragment]] for %%key%%, which may be a function
   *  selector, function name or function signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple functions match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single function in
   *  the ABI, this will throw.
   */
  getFunction(e, t) {
    return R(this, wo, wy).call(this, e, t || null, !0);
  }
  /**
   *  Iterate over all functions, calling %%callback%%, sorted by their name.
   */
  forEachFunction(e) {
    const t = Array.from(m(this, to).keys());
    t.sort((n, i) => n.localeCompare(i));
    for (let n = 0; n < t.length; n++) {
      const i = t[n];
      e(m(this, to).get(i), n);
    }
  }
  /**
   *  Get the event name for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   */
  getEventName(e) {
    const t = R(this, wo, _y).call(this, e, null, !1);
    return ne(t, "no matching event", "key", e), t.name;
  }
  /**
   *  Returns true if %%key%% (an event topic hash, event name or
   *  event signature) is present in the ABI.
   *
   *  In the case of an event name, the name may be ambiguous, so
   *  accessing the [[EventFragment]] may require refinement.
   */
  hasEvent(e) {
    return !!R(this, wo, _y).call(this, e, null, !1);
  }
  /**
   *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple events match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single event in
   *  the ABI, this will throw.
   */
  getEvent(e, t) {
    return R(this, wo, _y).call(this, e, t || null, !0);
  }
  /**
   *  Iterate over all events, calling %%callback%%, sorted by their name.
   */
  forEachEvent(e) {
    const t = Array.from(m(this, eo).keys());
    t.sort((n, i) => n.localeCompare(i));
    for (let n = 0; n < t.length; n++) {
      const i = t[n];
      e(m(this, eo).get(i), n);
    }
  }
  /**
   *  Get the [[ErrorFragment]] for %%key%%, which may be an error
   *  selector, error name or error signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple errors match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single error in
   *  the ABI, this will throw.
   */
  getError(e, t) {
    if (ti(e)) {
      const i = e.toLowerCase();
      if (xP[i])
        return Zn.from(xP[i].signature);
      for (const s of m(this, Qs).values())
        if (i === s.selector)
          return s;
      return null;
    }
    if (e.indexOf("(") === -1) {
      const i = [];
      for (const [s, o] of m(this, Qs))
        s.split(
          "("
          /* fix:) */
        )[0] === e && i.push(o);
      if (i.length === 0)
        return e === "Error" ? Zn.from("error Error(string)") : e === "Panic" ? Zn.from("error Panic(uint256)") : null;
      if (i.length > 1) {
        const s = i.map((o) => JSON.stringify(o.format())).join(", ");
        ne(!1, `ambiguous error description (i.e. ${s})`, "name", e);
      }
      return i[0];
    }
    if (e = Zn.from(e).format(), e === "Error(string)")
      return Zn.from("error Error(string)");
    if (e === "Panic(uint256)")
      return Zn.from("error Panic(uint256)");
    const n = m(this, Qs).get(e);
    return n || null;
  }
  /**
   *  Iterate over all errors, calling %%callback%%, sorted by their name.
   */
  forEachError(e) {
    const t = Array.from(m(this, Qs).keys());
    t.sort((n, i) => n.localeCompare(i));
    for (let n = 0; n < t.length; n++) {
      const i = t[n];
      e(m(this, Qs).get(i), n);
    }
  }
  // Get the 4-byte selector used by Solidity to identify a function
  /*
  getSelector(fragment: ErrorFragment | FunctionFragment): string {
      if (typeof(fragment) === "string") {
          const matches: Array<Fragment> = [ ];
  
          try { matches.push(this.getFunction(fragment)); } catch (error) { }
          try { matches.push(this.getError(<string>fragment)); } catch (_) { }
  
          if (matches.length === 0) {
              logger.throwArgumentError("unknown fragment", "key", fragment);
          } else if (matches.length > 1) {
              logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
          }
  
          fragment = matches[0];
      }
  
      return dataSlice(id(fragment.format()), 0, 4);
  }
      */
  // Get the 32-byte topic hash used by Solidity to identify an event
  /*
  getEventTopic(fragment: EventFragment): string {
      //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
      return id(fragment.format());
  }
  */
  _decodeParams(e, t) {
    return m(this, hn).decode(e, t);
  }
  _encodeParams(e, t) {
    return m(this, hn).encode(e, t);
  }
  /**
   *  Encodes a ``tx.data`` object for deploying the Contract with
   *  the %%values%% as the constructor arguments.
   */
  encodeDeploy(e) {
    return this._encodeParams(this.deploy.inputs, e || []);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified error (see [[getError]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeErrorResult(e, t) {
    if (typeof e == "string") {
      const n = this.getError(e);
      ne(n, "unknown error", "fragment", e), e = n;
    }
    return ne(Pl(t, 0, 4) === e.selector, `data signature does not match error ${e.name}.`, "data", t), this._decodeParams(e.inputs, Pl(t, 4));
  }
  /**
   *  Encodes the transaction revert data for a call result that
   *  reverted from the the Contract with the sepcified %%error%%
   *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeErrorResult(e, t) {
    if (typeof e == "string") {
      const n = this.getError(e);
      ne(n, "unknown error", "fragment", e), e = n;
    }
    return zr([
      e.selector,
      this._encodeParams(e.inputs, t || [])
    ]);
  }
  /**
   *  Decodes the %%data%% from a transaction ``tx.data`` for
   *  the function specified (see [[getFunction]] for valid values
   *  for %%fragment%%).
   *
   *  Most developers should prefer the [[parseTransaction]] method
   *  instead, which will automatically detect the fragment.
   */
  decodeFunctionData(e, t) {
    if (typeof e == "string") {
      const n = this.getFunction(e);
      ne(n, "unknown function", "fragment", e), e = n;
    }
    return ne(Pl(t, 0, 4) === e.selector, `data signature does not match function ${e.name}.`, "data", t), this._decodeParams(e.inputs, Pl(t, 4));
  }
  /**
   *  Encodes the ``tx.data`` for a transaction that calls the function
   *  specified (see [[getFunction]] for valid values for %%fragment%%) with
   *  the %%values%%.
   */
  encodeFunctionData(e, t) {
    if (typeof e == "string") {
      const n = this.getFunction(e);
      ne(n, "unknown function", "fragment", e), e = n;
    }
    return zr([
      e.selector,
      this._encodeParams(e.inputs, t || [])
    ]);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeFunctionResult(e, t) {
    if (typeof e == "string") {
      const s = this.getFunction(e);
      ne(s, "unknown function", "fragment", e), e = s;
    }
    let n = "invalid length for result data";
    const i = Cn(t);
    if (i.length % 32 === 0)
      try {
        return m(this, hn).decode(e.outputs, i);
      } catch {
        n = "could not decode result data";
      }
    _t(!1, n, "BAD_DATA", {
      value: Ne(i),
      info: { method: e.name, signature: e.format() }
    });
  }
  makeError(e, t) {
    const n = st(e, "data"), i = Jp.getBuiltinCallException("call", t, n);
    if (i.message.startsWith("execution reverted (unknown custom error)")) {
      const a = Ne(n.slice(0, 4)), c = this.getError(a);
      if (c)
        try {
          const u = m(this, hn).decode(c.inputs, n.slice(4));
          i.revert = {
            name: c.name,
            signature: c.format(),
            args: u
          }, i.reason = i.revert.signature, i.message = `execution reverted: ${i.reason}`;
        } catch {
          i.message = "execution reverted (coult not decode custom error)";
        }
    }
    const o = this.parseTransaction(t);
    return o && (i.invocation = {
      method: o.name,
      signature: o.signature,
      args: o.args
    }), i;
  }
  /**
   *  Encodes the result data (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values
   *  for %%fragment%%) with %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeFunctionResult(e, t) {
    if (typeof e == "string") {
      const n = this.getFunction(e);
      ne(n, "unknown function", "fragment", e), e = n;
    }
    return Ne(m(this, hn).encode(e.outputs, t || []));
  }
  /*
      spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
          const promises: Array<Promise<>> = [ ];
          const process = function(type: ParamType, value: any): any {
              if (type.baseType === "array") {
                  return descend(type.child
              }
              if (type. === "address") {
              }
          };
  
          const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
              if (inputs.length !== values.length) { throw new Error("length mismatch"); }
              
          };
  
          const result: Array<any> = [ ];
          values.forEach((value, index) => {
              if (value == null) {
                  topics.push(null);
              } else if (param.baseType === "array" || param.baseType === "tuple") {
                  logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
              } else if (Array.isArray(value)) {
                  topics.push(value.map((value) => encodeTopic(param, value)));
              } else {
                  topics.push(encodeTopic(param, value));
              }
          });
      }
  */
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(e, t) {
    if (typeof e == "string") {
      const s = this.getEvent(e);
      ne(s, "unknown event", "eventFragment", e), e = s;
    }
    _t(t.length <= e.inputs.length, `too many arguments for ${e.format()}`, "UNEXPECTED_ARGUMENT", { count: t.length, expectedCount: e.inputs.length });
    const n = [];
    e.anonymous || n.push(e.topicHash);
    const i = (s, o) => s.type === "string" ? rl(o) : s.type === "bytes" ? Yr(Ne(o)) : (s.type === "bool" && typeof o == "boolean" ? o = o ? "0x01" : "0x00" : s.type.match(/^u?int/) ? o = tl(o) : s.type.match(/^bytes/) ? o = $se(o, 32) : s.type === "address" && m(this, hn).encode(["address"], [o]), la(Ne(o), 32));
    for (t.forEach((s, o) => {
      const a = e.inputs[o];
      if (!a.indexed) {
        ne(s == null, "cannot filter non-indexed parameters; must be null", "contract." + a.name, s);
        return;
      }
      s == null ? n.push(null) : a.baseType === "array" || a.baseType === "tuple" ? ne(!1, "filtering with tuples or arrays not supported", "contract." + a.name, s) : Array.isArray(s) ? n.push(s.map((c) => i(a, c))) : n.push(i(a, s));
    }); n.length && n[n.length - 1] === null; )
      n.pop();
    return n;
  }
  encodeEventLog(e, t) {
    if (typeof e == "string") {
      const o = this.getEvent(e);
      ne(o, "unknown event", "eventFragment", e), e = o;
    }
    const n = [], i = [], s = [];
    return e.anonymous || n.push(e.topicHash), ne(t.length === e.inputs.length, "event arguments/values mismatch", "values", t), e.inputs.forEach((o, a) => {
      const c = t[a];
      if (o.indexed)
        if (o.type === "string")
          n.push(rl(c));
        else if (o.type === "bytes")
          n.push(Yr(c));
        else {
          if (o.baseType === "tuple" || o.baseType === "array")
            throw new Error("not implemented");
          n.push(m(this, hn).encode([o.type], [c]));
        }
      else
        i.push(o), s.push(c);
    }), {
      data: m(this, hn).encode(i, s),
      topics: n
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(e, t, n) {
    if (typeof e == "string") {
      const p = this.getEvent(e);
      ne(p, "unknown event", "eventFragment", e), e = p;
    }
    if (n != null && !e.anonymous) {
      const p = e.topicHash;
      ne(ti(n[0], 32) && n[0].toLowerCase() === p, "fragment/topic mismatch", "topics[0]", n[0]), n = n.slice(1);
    }
    const i = [], s = [], o = [];
    e.inputs.forEach((p, y) => {
      p.indexed ? p.type === "string" || p.type === "bytes" || p.baseType === "tuple" || p.baseType === "array" ? (i.push(tn.from({ type: "bytes32", name: p.name })), o.push(!0)) : (i.push(p), o.push(!1)) : (s.push(p), o.push(!1));
    });
    const a = n != null ? m(this, hn).decode(i, zr(n)) : null, c = m(this, hn).decode(s, t, !0), u = [], l = [];
    let d = 0, f = 0;
    return e.inputs.forEach((p, y) => {
      let g = null;
      if (p.indexed)
        if (a == null)
          g = new SP(null);
        else if (o[y])
          g = new SP(a[f++]);
        else
          try {
            g = a[f++];
          } catch (v) {
            g = v;
          }
      else
        try {
          g = c[d++];
        } catch (v) {
          g = v;
        }
      u.push(g), l.push(p.name || null);
    }), Zh.fromItems(u, l);
  }
  /**
   *  Parses a transaction, finding the matching function and extracts
   *  the parameter values along with other useful function details.
   *
   *  If the matching function cannot be found, return null.
   */
  parseTransaction(e) {
    const t = st(e.data, "tx.data"), n = jt(e.value != null ? e.value : 0, "tx.value"), i = this.getFunction(Ne(t.slice(0, 4)));
    if (!i)
      return null;
    const s = m(this, hn).decode(i.inputs, t.slice(4));
    return new eae(i, i.selector, s, n);
  }
  parseCallResult(e) {
    throw new Error("@TODO");
  }
  /**
   *  Parses a receipt log, finding the matching event and extracts
   *  the parameter values along with other useful event details.
   *
   *  If the matching event cannot be found, returns null.
   */
  parseLog(e) {
    const t = this.getEvent(e.topics[0]);
    return !t || t.anonymous ? null : new Qoe(t, t.topicHash, this.decodeEventLog(t, e.data, e.topics));
  }
  /**
   *  Parses a revert data, finding the matching error and extracts
   *  the parameter values along with other useful error details.
   *
   *  If the matching error cannot be found, returns null.
   */
  parseError(e) {
    const t = Ne(e), n = this.getError(Pl(t, 0, 4));
    if (!n)
      return null;
    const i = m(this, hn).decode(n.inputs, Pl(t, 4));
    return new tae(n, n.selector, i);
  }
  /**
   *  Creates a new [[Interface]] from the ABI %%value%%.
   *
   *  The %%value%% may be provided as an existing [[Interface]] object,
   *  a JSON-encoded ABI or any Human-Readable ABI format.
   */
  static from(e) {
    return e instanceof Wc ? e : typeof e == "string" ? new Wc(JSON.parse(e)) : typeof e.formatJson == "function" ? new Wc(e.formatJson()) : typeof e.format == "function" ? new Wc(e.format("json")) : new Wc(e);
  }
};
Qs = new WeakMap(), eo = new WeakMap(), to = new WeakMap(), hn = new WeakMap(), wo = new WeakSet(), // Find a function definition by any means necessary (unless it is ambiguous)
wy = function(e, t, n) {
  if (ti(e)) {
    const s = e.toLowerCase();
    for (const o of m(this, to).values())
      if (s === o.selector)
        return o;
    return null;
  }
  if (e.indexOf("(") === -1) {
    const s = [];
    for (const [o, a] of m(this, to))
      o.split(
        "("
        /* fix:) */
      )[0] === e && s.push(a);
    if (t) {
      const o = t.length > 0 ? t[t.length - 1] : null;
      let a = t.length, c = !0;
      si.isTyped(o) && o.type === "overrides" && (c = !1, a--);
      for (let u = s.length - 1; u >= 0; u--) {
        const l = s[u].inputs.length;
        l !== a && (!c || l !== a - 1) && s.splice(u, 1);
      }
      for (let u = s.length - 1; u >= 0; u--) {
        const l = s[u].inputs;
        for (let d = 0; d < t.length; d++)
          if (si.isTyped(t[d])) {
            if (d >= l.length) {
              if (t[d].type === "overrides")
                continue;
              s.splice(u, 1);
              break;
            }
            if (t[d].type !== l[d].baseType) {
              s.splice(u, 1);
              break;
            }
          }
      }
    }
    if (s.length === 1 && t && t.length !== s[0].inputs.length) {
      const o = t[t.length - 1];
      (o == null || Array.isArray(o) || typeof o != "object") && s.splice(0, 1);
    }
    if (s.length === 0)
      return null;
    if (s.length > 1 && n) {
      const o = s.map((a) => JSON.stringify(a.format())).join(", ");
      ne(!1, `ambiguous function description (i.e. matches ${o})`, "key", e);
    }
    return s[0];
  }
  const i = m(this, to).get(so.from(e).format());
  return i || null;
}, // Find an event definition by any means necessary (unless it is ambiguous)
_y = function(e, t, n) {
  if (ti(e)) {
    const s = e.toLowerCase();
    for (const o of m(this, eo).values())
      if (s === o.topicHash)
        return o;
    return null;
  }
  if (e.indexOf("(") === -1) {
    const s = [];
    for (const [o, a] of m(this, eo))
      o.split(
        "("
        /* fix:) */
      )[0] === e && s.push(a);
    if (t) {
      for (let o = s.length - 1; o >= 0; o--)
        s[o].inputs.length < t.length && s.splice(o, 1);
      for (let o = s.length - 1; o >= 0; o--) {
        const a = s[o].inputs;
        for (let c = 0; c < t.length; c++)
          if (si.isTyped(t[c]) && t[c].type !== a[c].baseType) {
            s.splice(o, 1);
            break;
          }
      }
    }
    if (s.length === 0)
      return null;
    if (s.length > 1 && n) {
      const o = s.map((a) => JSON.stringify(a.format())).join(", ");
      ne(!1, `ambiguous event description (i.e. matches ${o})`, "key", e);
    }
    return s[0];
  }
  const i = m(this, eo).get(io.from(e).format());
  return i || null;
};
let lv = Wc;
var rae = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, AP = (r, e) => (t, n) => e(t, n, r);
const nae = [M.EXTERNAL_PLUGIN, M.TOKEN];
let bA = class {
  constructor(e, t) {
    h(this, "_externalPluginDataSource");
    h(this, "_tokenDataSource");
    this._externalPluginDataSource = e, this._tokenDataSource = t;
  }
  canHandle(e, t) {
    return typeof e == "object" && e !== null && "to" in e && "data" in e && "selector" in e && "chainId" in e && typeof e.chainId == "number" && br(e.to) && e.to !== "0x" && br(e.data) && e.data !== "0x" && br(e.selector) && e.selector !== "0x" && nae.every((n) => t.includes(n));
  }
  async load(e) {
    const { to: t, data: n, selector: i, chainId: s } = e, o = await this._externalPluginDataSource.getDappInfos({ address: t, chainId: s, selector: i });
    return me(async ({ liftEither: a }) => {
      const c = await a(o);
      if (!c) return [];
      const u = { type: M.EXTERNAL_PLUGIN, payload: c.selectorDetails.serializedData.concat(c.selectorDetails.signature) }, l = this.getDecodedCallData(c.abi, c.selectorDetails.method, n);
      if (l.isLeft()) return [{ type: M.ERROR, error: l.extract() }, u];
      const d = l.extract(), f = c.selectorDetails.erc20OfInterest.map(async (p) => this.getTokenPayload(e, p, d));
      return [...(await Promise.all(f)).map((p) => p.caseOf({ Left: (y) => ({ type: M.ERROR, error: y }), Right: (y) => ({ type: M.TOKEN, payload: y }) })), u];
    }).caseOf({ Left: (a) => [{ type: M.ERROR, error: a }], Right: (a) => a });
  }
  getTokenPayload(e, t, n) {
    const i = this.getAddressFromPath(t, n);
    return me(({ fromPromise: s }) => s(this._tokenDataSource.getTokenInfosPayload({ address: i, chainId: e.chainId })));
  }
  getDecodedCallData(e, t, n) {
    try {
      const i = new lv(e);
      return te(i.decodeFunctionData(t, n));
    } catch {
      return N(new Error("[ContextModule] ExternalPluginContextLoader: Unable to parse abi"));
    }
  }
  getAddressFromPath(e, t) {
    let n = t;
    for (const i of e.split(".")) i === "-1" ? n = n[n.length - 1] : n = n[i];
    if (!br(n)) throw new Error("[ContextModule] ExternalPluginContextLoader: Unable to get address");
    return n;
  }
};
bA = rae([le(), AP(0, X(sv.ExternalPluginDataSource)), AP(1, X(yo.TokenDataSource))], bA);
const iae = () => new mt(({ bind: r }) => {
  r(sv.ExternalPluginDataSource).to(dA), r(sv.ExternalPluginContextLoader).to(bA);
});
var sae = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, oae = (r, e) => (t, n) => e(t, n, r);
let wA = class {
  constructor(e) {
    this.config = e;
  }
  async getSetPluginPayload({ chainId: e, address: t, selector: n }) {
    try {
      const i = await He.request({ method: "GET", url: `${this.config.metadataServiceDomain.url}/v1/ethereum/${e}/contracts/${t}/plugin-selector/${n}`, headers: { [$n]: `context-module/${Rn.version}`, [ks]: this.config.originToken } });
      return i.data.payload ? te(i.data.payload) : N(new Error("[ContextModule] HttpNftDataSource: unexpected empty response"));
    } catch {
      return N(new Error("[ContextModule] HttpNftDataSource: Failed to fetch set plugin payload"));
    }
  }
  async getNftInfosPayload({ chainId: e, address: t }) {
    try {
      const n = await He.request({ method: "GET", url: `${this.config.metadataServiceDomain.url}/v1/ethereum/${e}/contracts/${t}`, headers: { [$n]: `context-module/${Rn.version}`, [ks]: this.config.originToken } });
      return n.data.payload ? te(n.data.payload) : N(new Error("[ContextModule] HttpNftDataSource: no nft metadata"));
    } catch {
      return N(new Error("[ContextModule] HttpNftDataSource: Failed to fetch nft informations"));
    }
  }
};
wA = sae([le(), oae(0, X(yn.Config))], wA);
var aae = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, cae = (r, e) => (t, n) => e(t, n, r);
let _A = class {
  constructor(e) {
    this._dataSource = e;
  }
  canHandle(e, t) {
    return t === M.NFT && typeof e == "object" && e !== null && "chainId" in e && "address" in e;
  }
  async loadField(e) {
    return (await this._dataSource.getNftInfosPayload({ address: e.address, chainId: e.chainId })).caseOf({ Left: (t) => ({ type: M.ERROR, error: t }), Right: (t) => ({ type: M.NFT, payload: t }) });
  }
};
_A = aae([le(), cae(0, X(Lu.NftDataSource))], _A);
var uae = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, lae = (r, e) => (t, n) => e(t, n, r), _4 = ((r) => (r.Approve = "0x095ea7b3", r.SetApprovalForAll = "0xa22cb465", r.TransferFrom = "0x23b872dd", r.SafeTransferFrom = "0x42842e0e", r.SafeTransferFromWithData = "0xb88d4fde", r))(_4 || {}), S4 = ((r) => (r.SetApprovalForAll = "0xa22cb465", r.SafeTransferFrom = "0xf242432a", r.SafeBatchTransferFrom = "0x2eb2c2d6", r))(S4 || {});
const dae = [...Object.values(_4), ...Object.values(S4)], hae = [M.PLUGIN, M.NFT];
let SA = class {
  constructor(e) {
    h(this, "_dataSource");
    this._dataSource = e;
  }
  canHandle(e, t) {
    return typeof e == "object" && e !== null && "to" in e && "selector" in e && "chainId" in e && typeof e.chainId == "number" && br(e.to) && e.to !== "0x" && br(e.selector) && this.isSelectorSupported(e.selector) && hae.every((n) => t.includes(n));
  }
  async load(e) {
    const t = [], { to: n, selector: i, chainId: s } = e, o = (await this._dataSource.getSetPluginPayload({ chainId: s, address: n, selector: i })).caseOf({ Left: (c) => ({ type: M.ERROR, error: c }), Right: (c) => ({ type: M.PLUGIN, payload: c }) });
    if (o.type === M.ERROR) return [o];
    t.push(o);
    const a = (await this._dataSource.getNftInfosPayload({ chainId: s, address: n })).caseOf({ Left: (c) => ({ type: M.ERROR, error: c }), Right: (c) => ({ type: M.NFT, payload: c }) });
    return a.type === M.ERROR ? [a] : (t.push(a), t);
  }
  isSelectorSupported(e) {
    return Object.values(dae).includes(e);
  }
};
SA = uae([le(), lae(0, X(Lu.NftDataSource))], SA);
const fae = () => new mt(({ bind: r }) => {
  r(Lu.NftDataSource).to(wA), r(Lu.NftContextLoader).to(SA), r(Lu.NftContextFieldLoader).to(_A);
});
var oS;
let pae = (oS = class {
  static mapKeyUsageForFirmware(e) {
    return Object.values(Ir).includes(e) ? this.keyUsageMap.get(e) ?? -1 : -1;
  }
}, h(oS, "keyUsageMap", /* @__PURE__ */ new Map([[Ir.GenuineCheck, 1], [Ir.ExchangePayload, 2], [Ir.NftMeta, 3], [Ir.TrustedName, 4], [Ir.BackupProvider, 5], [Ir.ProtectOrchestrator, 6], [Ir.PluginMeta, 7], [Ir.CoinMeta, 8], [Ir.SeedIdAuth, 9], [Ir.TxSimulationSigner, 10], [Ir.Calldata, 11], [Ir.Network, 12]])), oS);
var gae = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, mae = (r, e) => (t, n) => e(t, n, r);
let EA = class {
  constructor(e) {
    this.config = e;
  }
  async fetchCertificate(e) {
    const t = { output: "descriptor", target_device: e.targetDevice, latest: !0, public_key_id: e.keyId, public_key_usage: e.keyUsage };
    try {
      const n = await He.request({ method: "GET", url: `${this.config.cal.url}/certificates`, params: t, headers: { [$n]: `context-module/${Rn.version}` } });
      if (n.status == 200 && n.data !== void 0 && n.data.length > 0 && this.isValidPkiCertificateResponse(n.data[0], this.config.cal.mode)) {
        const i = _r(rv.appendSignatureToPayload(n.data[0].descriptor.data, n.data[0].descriptor.signatures[this.config.cal.mode], ase));
        if (!i) return N(Error("[ContextModule] HttpPkiCertificateDataSource: Cannot generate payload from fetched PKI Certificate"));
        const s = { payload: i, keyUsageNumber: pae.mapKeyUsageForFirmware(e.keyUsage) };
        return te(s);
      } else return N(Error("[ContextModule] HttpPkiCertificateDataSource: failed to fetch PKI for given descriptor"));
    } catch {
      return N(Error("[ContextModule] HttpPkiCertificateDataSource: failed to fetch PKI for given descriptor"));
    }
  }
  isValidPkiCertificateResponse(e, t) {
    return typeof e == "object" && e !== null && "descriptor" in e && typeof e.descriptor == "object" && e.descriptor !== null && "data" in e.descriptor && typeof e.descriptor.data == "string" && "signatures" in e.descriptor && typeof e.descriptor.signatures == "object" && e.descriptor.signatures !== null && t in e.descriptor.signatures && typeof e.descriptor.signatures[t] == "string";
  }
};
EA = gae([le(), mae(0, X(yn.Config))], EA);
var yae = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, vae = (r, e) => (t, n) => e(t, n, r);
let xA = class {
  constructor(e) {
    h(this, "_dataSource");
    this._dataSource = e;
  }
  async loadCertificate(e) {
    return (await this._dataSource.fetchCertificate(e)).orDefault(void 0);
  }
};
xA = yae([le(), vae(0, X(Oi.PkiCertificateDataSource))], xA);
const bae = () => new mt(({ bind: r }) => {
  r(Oi.PkiCertificateDataSource).to(EA), r(Oi.PkiCertificateLoader).to(xA);
});
var wae = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, _ae = (r, e) => (t, n) => e(t, n, r);
let AA = class {
  constructor(e) {
    this.config = e;
  }
  async getProxyImplementationAddress({ proxyAddress: e, chainId: t, challenge: n, calldata: i }) {
    let s;
    try {
      s = (await He.request({ method: "POST", url: `${this.config.metadataServiceDomain.url}/v2/ethereum/${t}/contract/proxy/delegate`, headers: { [$n]: `context-module/${Rn.version}`, [ks]: this.config.originToken }, data: { proxy: e, data: i, challenge: n } })).data;
    } catch {
      return N(new Error("[ContextModule] HttpProxyDataSource: Failed to fetch delegate proxy"));
    }
    return s ? this.isProxyDelegateCallDto(s) ? s.addresses[0] ? te({ implementationAddress: s.addresses[0], signedDescriptor: s.signedDescriptor, keyId: v0.DomainMetadataKey, keyUsage: Ir.TrustedName }) : N(new Error(`[ContextModule] HttpProxyDataSource: No implementation address found for proxy ${e} on chain ${t}`)) : N(new Error(`[ContextModule] HttpProxyDataSource: Invalid proxy delegate call response format for proxy ${e} on chain ${t}`)) : N(new Error(`[ContextModule] HttpProxyDataSource: No data received for proxy ${e} on chain ${t}`));
  }
  isProxyDelegateCallDto(e) {
    return typeof e == "object" && e !== null && "addresses" in e && "signedDescriptor" in e && Array.isArray(e.addresses) && e.addresses.every((t) => typeof t == "string") && typeof e.signedDescriptor == "string";
  }
};
AA = wae([le(), _ae(0, X(yn.Config))], AA);
var Sae = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Eae = (r, e) => (t, n) => e(t, n, r);
let IA = class {
  constructor(e) {
    this.config = e;
  }
  async getProxyImplementationAddress({ proxyAddress: e, chainId: t, challenge: n }) {
    let i;
    try {
      i = (await He.request({ method: "GET", url: `${this.config.metadataServiceDomain.url}/v3/ethereum/${t}/contract/proxy/${e}`, headers: { [$n]: `context-module/${Rn.version}`, [ks]: this.config.originToken }, params: { challenge: n, resolver: "SAFE_GATEWAY" } })).data;
    } catch {
      return N(new Error("[ContextModule] HttpSafeProxyDataSource: Failed to fetch safe proxy implementation"));
    }
    return i ? this.isSafeProxyImplementationAddressDto(i) ? te({ implementationAddress: i.implementationAddress, signedDescriptor: i.signedDescriptor, keyId: i.keyId, keyUsage: i.keyUsage }) : N(new Error(`[ContextModule] HttpSafeProxyDataSource: Invalid safe proxy response format for proxy ${e} on chain ${t}`)) : N(new Error(`[ContextModule] HttpSafeProxyDataSource: No data received for proxy ${e} on chain ${t}`));
  }
  isSafeProxyImplementationAddressDto(e) {
    return typeof e == "object" && e !== null && "proxyAddress" in e && "implementationAddress" in e && "standard" in e && "signedDescriptor" in e && "providedBy" in e && "keyId" in e && "keyUsage" in e && typeof e.proxyAddress == "string" && typeof e.implementationAddress == "string" && typeof e.standard == "string" && typeof e.signedDescriptor == "string" && typeof e.providedBy == "string" && typeof e.keyId == "string" && typeof e.keyUsage == "string";
  }
};
IA = Sae([le(), Eae(0, X(yn.Config))], IA);
var xae = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, IP = (r, e) => (t, n) => e(t, n, r);
let CA = class {
  constructor(e, t) {
    this._proxyDataSource = e, this._certificateLoader = t;
  }
  canHandle(e, t) {
    return t === M.PROXY_INFO && typeof e == "object" && e !== null && "chainId" in e && "proxyAddress" in e && "calldata" in e && "challenge" in e && "deviceModelId" in e;
  }
  async loadField(e) {
    return (await this._proxyDataSource.getProxyImplementationAddress({ calldata: e.calldata, proxyAddress: e.proxyAddress, chainId: e.chainId, challenge: e.challenge })).caseOf({ Left: (t) => Promise.resolve({ type: M.ERROR, error: t }), Right: async ({ signedDescriptor: t, keyId: n, keyUsage: i }) => {
      const s = await this._certificateLoader.loadCertificate({ keyId: n, keyUsage: i, targetDevice: e.deviceModelId });
      return { type: M.PROXY_INFO, payload: t, certificate: s };
    } });
  }
};
CA = xae([le(), IP(0, X(Nu.ProxyDataSource)), IP(1, X(Oi.PkiCertificateLoader))], CA);
const Aae = (r) => new mt(({ bind: e }) => {
  var t;
  ((t = r == null ? void 0 : r.datasource) == null ? void 0 : t.proxy) === "safe" ? e(Nu.ProxyDataSource).to(IA) : e(Nu.ProxyDataSource).to(AA), e(Nu.ProxyContextFieldLoader).to(CA);
});
var Iae = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Cae = (r, e) => (t, n) => e(t, n, r);
let DA = class {
  constructor(e) {
    if (this.config = e, !this.config.originToken) throw new Error("[ContextModule] - HttpSolanaOwnerInfoDataSource: origin token is required");
  }
  isSolanaSPLOwnerInfo(e) {
    return typeof e != "object" || e === null ? !1 : typeof e.tokenAccount == "string" && typeof e.owner == "string" && typeof e.contract == "string" && typeof e.signedDescriptor == "string";
  }
  async fetchAddressMetadata(e, t) {
    return await He.request({ method: "GET", url: `${this.config.metadataServiceDomain.url}/v2/solana/owner/${e}?challenge=${t}`, headers: { [$n]: `context-module/${Rn.version}`, [ks]: this.config.originToken } }).then((n) => this.isSolanaSPLOwnerInfo(n.data) ? te(n.data) : N(new Error("[ContextModule] - HttpSolanaOwnerInfoDataSource: invalid fetchAddressMetadata response shape"))).catch(() => N(new Error("[ContextModule] - HttpSolanaOwnerInfoDataSource: Failed to fetch address metadata")));
  }
  async computeAddressMetadata(e, t, n) {
    return await He.request({ method: "GET", url: `${this.config.metadataServiceDomain.url}/v2/solana/computed-token-account/${e}/${t}?challenge=${n}`, headers: { [$n]: `context-module/${Rn.version}`, "X-Ledger-Client-Origin": this.config.originToken } }).then((i) => this.isSolanaSPLOwnerInfo(i.data) ? te(i.data) : N(new Error("[ContextModule] - HttpSolanaOwnerInfoDataSource: invalid computeAddressMetadata response shape"))).catch(() => N(new Error("[ContextModule] - HttpSolanaOwnerInfoDataSource: Failed to compute address metadata")));
  }
  async getOwnerInfo(e) {
    const { tokenAddress: t, challenge: n, createATA: i } = e;
    if (!n) return N(new Error("[ContextModule] - HttpSolanaOwnerInfoDataSource: challenge is required"));
    let s;
    if (t) s = await this.fetchAddressMetadata(t, n);
    else if (i != null && i.address && (i != null && i.mintAddress)) s = await this.computeAddressMetadata(i.address, i.mintAddress, n);
    else return N(new Error("[ContextModule] - HttpSolanaOwnerInfoDataSource: either tokenAddress or valid createATA must be provided"));
    return s.chain((o) => {
      const a = _r(o.signedDescriptor);
      return a ? te({ descriptor: a, tokenAccount: o.tokenAccount, owner: o.owner, contract: o.contract }) : N(new Error("[ContextModule] - HttpSolanaOwnerInfoDataSource: invalid base64 descriptor received"));
    });
  }
};
DA = Iae([le(), Cae(0, X(yn.Config))], DA);
var Dae = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, CP = (r, e) => (t, n) => e(t, n, r);
let TA = class {
  constructor(e, t) {
    h(this, "_dataSource");
    this._certificateLoader = t, this._dataSource = e;
  }
  async load(e) {
    const t = await this._certificateLoader.loadCertificate({ keyId: "domain_metadata_key", keyUsage: Ir.TrustedName, targetDevice: e.deviceModelId });
    return t ? (await this._dataSource.getOwnerInfo(e)).map(({ descriptor: n, tokenAccount: i, owner: s, contract: o }) => ({ descriptor: n, tokenAccount: i, owner: s, contract: o, certificate: t })) : N(new Error("[ContextModule] - DefaultSolanaContextLoader: CAL certificate is undefined"));
  }
};
TA = Dae([le(), CP(0, X(ov.SolanaDataSource)), CP(1, X(Oi.PkiCertificateLoader))], TA);
const Tae = () => new mt(({ bind: r }) => {
  r(ov.SolanaDataSource).to(DA), r(ov.SolanaContextLoader).to(TA);
});
var kae = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Oae = (r, e) => (t, n) => e(t, n, r);
let kA = class {
  constructor(e) {
    this.config = e;
  }
  async getTokenInfosPayload({ chainId: e, address: t }) {
    var n;
    try {
      const i = (n = (await He.request({ method: "GET", url: `${this.config.cal.url}/tokens`, params: { contract_address: t, chain_id: e, output: "descriptor,ticker", ref: `branch:${this.config.cal.branch}` }, headers: { [$n]: `context-module/${Rn.version}` } })).data) == null ? void 0 : n[0];
      if (!i || !i.ticker || !i.descriptor || !i.descriptor.data || !i.descriptor.signatures || typeof i.descriptor.signatures[this.config.cal.mode] != "string") return N(new Error(`[ContextModule] HttpTokenDataSource: no token metadata for address ${t} on chain ${e}`));
      const s = i.ticker.length.toString(16).padStart(2, "0");
      return te([s, i.descriptor.data, i.descriptor.signatures[this.config.cal.mode]].join(""));
    } catch {
      return N(new Error("[ContextModule] HttpTokenDataSource: Failed to fetch token informations"));
    }
  }
};
kA = kae([le(), Oae(0, X(yn.Config))], kA);
var $ae = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Rae = (r, e) => (t, n) => e(t, n, r);
let OA = class {
  constructor(e) {
    this._dataSource = e;
  }
  canHandle(e, t) {
    return t === M.TOKEN && typeof e == "object" && e !== null && "chainId" in e && "address" in e;
  }
  async loadField(e) {
    return (await this._dataSource.getTokenInfosPayload({ address: e.address, chainId: e.chainId })).caseOf({ Left: (t) => ({ type: M.ERROR, error: t }), Right: (t) => ({ type: M.TOKEN, payload: t }) });
  }
};
OA = $ae([le(), Rae(0, X(yo.TokenDataSource))], OA);
var Pae = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Nae = (r, e) => (t, n) => e(t, n, r), E4 = ((r) => (r.Approve = "0x095ea7b3", r.Transfer = "0xa9059cbb", r))(E4 || {});
const Bae = Object.values(E4), Lae = [M.TOKEN];
let $A = class {
  constructor(e) {
    h(this, "_dataSource");
    this._dataSource = e;
  }
  canHandle(e, t) {
    return typeof e == "object" && e !== null && "to" in e && "selector" in e && "chainId" in e && typeof e.chainId == "number" && br(e.to) && e.to !== "0x" && br(e.selector) && this.isSelectorSupported(e.selector) && Lae.every((n) => t.includes(n));
  }
  async load(e) {
    const { to: t, chainId: n } = e;
    return [(await this._dataSource.getTokenInfosPayload({ address: t, chainId: n })).caseOf({ Left: (i) => ({ type: M.ERROR, error: i }), Right: (i) => ({ type: M.TOKEN, payload: i }) })];
  }
  isSelectorSupported(e) {
    return Object.values(Bae).includes(e);
  }
};
$A = Pae([le(), Nae(0, X(yo.TokenDataSource))], $A);
const Uae = () => new mt(({ bind: r }) => {
  r(yo.TokenDataSource).to(kA), r(yo.TokenContextLoader).to($A), r(yo.TokenContextFieldLoader).to(OA);
});
var Fae = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Mae = (r, e) => (t, n) => e(t, n, r);
let RA = class {
  constructor(e) {
    this.config = e;
  }
  async getDomainNamePayload({ chainId: e, domain: t, challenge: n }) {
    let i;
    try {
      i = (await He.request({ method: "GET", url: `${this.config.metadataServiceDomain.url}/v2/names/ethereum/${e}/forward/${t}?types=eoa&sources=ens&challenge=${n}`, headers: { [$n]: `context-module/${Rn.version}`, [ks]: this.config.originToken } })).data;
    } catch {
      return N(new Error("[ContextModule] HttpTrustedNameDataSource: Failed to fetch domain name"));
    }
    return i ? this.isTrustedNameDto(i) ? te({ data: i.signedDescriptor.data, keyId: i.keyId, keyUsage: i.keyUsage }) : N(new Error(`[ContextModule] HttpTrustedNameDataSource: Invalid trusted name response format for domain ${t} on chain ${e}`)) : N(new Error(`[ContextModule] HttpTrustedNameDataSource: No data received for domain ${t} on chain ${e}`));
  }
  async getTrustedNamePayload({ chainId: e, address: t, challenge: n, sources: i, types: s }) {
    let o;
    try {
      i = i.filter((c) => c === "ens" || c === "crypto_asset_list"), o = (await He.request({ method: "GET", url: `${this.config.metadataServiceDomain.url}/v2/names/ethereum/${e}/reverse/${t}?types=${s.join(",")}&sources=${i.join(",")}&challenge=${n}`, headers: { [$n]: `context-module/${Rn.version}`, [ks]: this.config.originToken } })).data;
    } catch {
      return N(new Error("[ContextModule] HttpTrustedNameDataSource: Failed to fetch trusted name"));
    }
    if (!o) return N(new Error(`[ContextModule] HttpTrustedNameDataSource: No data received for address ${t} on chain ${e}`));
    if (!this.isTrustedNameDto(o)) return N(new Error(`[ContextModule] HttpTrustedNameDataSource: Invalid trusted name response format for address ${t} on chain ${e}`));
    if (typeof o.signedDescriptor.signatures[this.config.cal.mode] != "string") return te({ data: o.signedDescriptor.data, keyId: o.keyId, keyUsage: o.keyUsage });
    const a = o.signedDescriptor.signatures[this.config.cal.mode];
    return te({ data: this.formatTrustedName(o.signedDescriptor.data, a), keyId: o.keyId, keyUsage: o.keyUsage });
  }
  formatTrustedName(e, t) {
    t.length % 2 !== 0 && (t = "0" + t);
    const n = "15", i = (t.length / 2).toString(16);
    return `${e}${n}${i}${t}`;
  }
  isTrustedNameDto(e) {
    return typeof e == "object" && e !== null && "signedDescriptor" in e && "keyId" in e && "keyUsage" in e && typeof e.keyId == "string" && typeof e.keyUsage == "string" && typeof e.signedDescriptor == "object" && e.signedDescriptor !== null && "data" in e.signedDescriptor && "signatures" in e.signedDescriptor && typeof e.signedDescriptor.data == "string" && typeof e.signedDescriptor.signatures == "object";
  }
};
RA = Fae([le(), Mae(0, X(yn.Config))], RA);
var Vae = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, DP = (r, e) => (t, n) => e(t, n, r);
let PA = class {
  constructor(e, t) {
    this._dataSource = e, this._certificateLoader = t;
  }
  canHandle(e, t) {
    return t === M.TRUSTED_NAME && typeof e == "object" && e !== null && "chainId" in e && "address" in e && "challenge" in e && "types" in e && "sources" in e && "deviceModelId" in e && e.deviceModelId !== void 0;
  }
  async loadField(e) {
    return await (await this._dataSource.getTrustedNamePayload({ chainId: e.chainId, address: e.address, challenge: e.challenge, types: e.types, sources: e.sources })).caseOf({ Left: (t) => Promise.resolve({ type: M.ERROR, error: t }), Right: async ({ data: t, keyId: n, keyUsage: i }) => {
      const s = await this._certificateLoader.loadCertificate({ keyId: n, keyUsage: i, targetDevice: e.deviceModelId });
      return { type: M.TRUSTED_NAME, payload: t, certificate: s };
    } });
  }
};
PA = Vae([le(), DP(0, X(Bu.TrustedNameDataSource)), DP(1, X(Oi.PkiCertificateLoader))], PA);
var zae = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, TP = (r, e) => (t, n) => e(t, n, r);
const jae = [M.TRUSTED_NAME];
let NA = class {
  constructor(e, t) {
    h(this, "_dataSource");
    this.certificateLoader = t, this._dataSource = e;
  }
  canHandle(e, t) {
    return typeof e == "object" && e !== null && "chainId" in e && "domain" in e && "challenge" in e && "deviceModelId" in e && e.deviceModelId !== void 0 && typeof e.chainId == "number" && typeof e.domain == "string" && e.domain.length > 0 && typeof e.challenge == "string" && e.challenge.length > 0 && jae.every((n) => t.includes(n));
  }
  async load(e) {
    const { chainId: t, domain: n, challenge: i, deviceModelId: s } = e;
    return this.isDomainValid(n) ? [await (await this._dataSource.getDomainNamePayload({ chainId: t, domain: n, challenge: i })).caseOf({ Left: (o) => Promise.resolve({ type: M.ERROR, error: o }), Right: async ({ data: o, keyId: a, keyUsage: c }) => {
      const u = await this.certificateLoader.loadCertificate({ keyId: a, keyUsage: c, targetDevice: s });
      return { type: M.TRUSTED_NAME, payload: o, certificate: u };
    } })] : [{ type: M.ERROR, error: new Error("[ContextModule] TrustedNameLoader: invalid domain") }];
  }
  isDomainValid(e) {
    const t = e.length > 0 && Number(e.length) < 30, n = new RegExp("^[a-zA-Z0-9\\-\\_\\.]+$").test(e);
    return t && n;
  }
};
NA = zae([le(), TP(0, X(Bu.TrustedNameDataSource)), TP(1, X(Oi.PkiCertificateLoader))], NA);
const Hae = () => new mt(({ bind: r }) => {
  r(Bu.TrustedNameDataSource).to(RA), r(Bu.TrustedNameContextLoader).to(NA), r(Bu.TrustedNameContextFieldLoader).to(PA);
});
var Sy = { exports: {} };
function Gae(r) {
  throw new Error('Could not dynamically require "' + r + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Ey = { exports: {} }, Kae = Ey.exports, kP;
function x4() {
  return kP || (kP = 1, (function(r, e) {
    (function(t, n) {
      r.exports = n();
    })(Kae, function() {
      var t = t || (function(n, i) {
        var s;
        if (typeof window < "u" && window.crypto && (s = window.crypto), typeof self < "u" && self.crypto && (s = self.crypto), typeof globalThis < "u" && globalThis.crypto && (s = globalThis.crypto), !s && typeof window < "u" && window.msCrypto && (s = window.msCrypto), !s && typeof As < "u" && As.crypto && (s = As.crypto), !s && typeof Gae == "function")
          try {
            s = rF;
          } catch {
          }
        var o = function() {
          if (s) {
            if (typeof s.getRandomValues == "function")
              try {
                return s.getRandomValues(new Uint32Array(1))[0];
              } catch {
              }
            if (typeof s.randomBytes == "function")
              try {
                return s.randomBytes(4).readInt32LE();
              } catch {
              }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        }, a = Object.create || /* @__PURE__ */ (function() {
          function w() {
          }
          return function(E) {
            var I;
            return w.prototype = E, I = new w(), w.prototype = null, I;
          };
        })(), c = {}, u = c.lib = {}, l = u.Base = /* @__PURE__ */ (function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(w) {
              var E = a(this);
              return w && E.mixIn(w), (!E.hasOwnProperty("init") || this.init === E.init) && (E.init = function() {
                E.$super.init.apply(this, arguments);
              }), E.init.prototype = E, E.$super = this, E;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var w = this.extend();
              return w.init.apply(w, arguments), w;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(w) {
              for (var E in w)
                w.hasOwnProperty(E) && (this[E] = w[E]);
              w.hasOwnProperty("toString") && (this.toString = w.toString);
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        })(), d = u.WordArray = l.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(w, E) {
            w = this.words = w || [], E != i ? this.sigBytes = E : this.sigBytes = w.length * 4;
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(w) {
            return (w || p).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(w) {
            var E = this.words, I = w.words, S = this.sigBytes, T = w.sigBytes;
            if (this.clamp(), S % 4)
              for (var b = 0; b < T; b++) {
                var C = I[b >>> 2] >>> 24 - b % 4 * 8 & 255;
                E[S + b >>> 2] |= C << 24 - (S + b) % 4 * 8;
              }
            else
              for (var P = 0; P < T; P += 4)
                E[S + P >>> 2] = I[P >>> 2];
            return this.sigBytes += T, this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var w = this.words, E = this.sigBytes;
            w[E >>> 2] &= 4294967295 << 32 - E % 4 * 8, w.length = n.ceil(E / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var w = l.clone.call(this);
            return w.words = this.words.slice(0), w;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(w) {
            for (var E = [], I = 0; I < w; I += 4)
              E.push(o());
            return new d.init(E, w);
          }
        }), f = c.enc = {}, p = f.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(w) {
            for (var E = w.words, I = w.sigBytes, S = [], T = 0; T < I; T++) {
              var b = E[T >>> 2] >>> 24 - T % 4 * 8 & 255;
              S.push((b >>> 4).toString(16)), S.push((b & 15).toString(16));
            }
            return S.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(w) {
            for (var E = w.length, I = [], S = 0; S < E; S += 2)
              I[S >>> 3] |= parseInt(w.substr(S, 2), 16) << 24 - S % 8 * 4;
            return new d.init(I, E / 2);
          }
        }, y = f.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(w) {
            for (var E = w.words, I = w.sigBytes, S = [], T = 0; T < I; T++) {
              var b = E[T >>> 2] >>> 24 - T % 4 * 8 & 255;
              S.push(String.fromCharCode(b));
            }
            return S.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(w) {
            for (var E = w.length, I = [], S = 0; S < E; S++)
              I[S >>> 2] |= (w.charCodeAt(S) & 255) << 24 - S % 4 * 8;
            return new d.init(I, E);
          }
        }, g = f.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(w) {
            try {
              return decodeURIComponent(escape(y.stringify(w)));
            } catch {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(w) {
            return y.parse(unescape(encodeURIComponent(w)));
          }
        }, v = u.BufferedBlockAlgorithm = l.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new d.init(), this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(w) {
            typeof w == "string" && (w = g.parse(w)), this._data.concat(w), this._nDataBytes += w.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(w) {
            var E, I = this._data, S = I.words, T = I.sigBytes, b = this.blockSize, C = b * 4, P = T / C;
            w ? P = n.ceil(P) : P = n.max((P | 0) - this._minBufferSize, 0);
            var Z = P * b, Y = n.min(Z * 4, T);
            if (Z) {
              for (var q = 0; q < Z; q += b)
                this._doProcessBlock(S, q);
              E = S.splice(0, Z), I.sigBytes -= Y;
            }
            return new d.init(E, Y);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var w = l.clone.call(this);
            return w._data = this._data.clone(), w;
          },
          _minBufferSize: 0
        });
        u.Hasher = v.extend({
          /**
           * Configuration options.
           */
          cfg: l.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(w) {
            this.cfg = this.cfg.extend(w), this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            v.reset.call(this), this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(w) {
            return this._append(w), this._process(), this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(w) {
            w && this._append(w);
            var E = this._doFinalize();
            return E;
          },
          blockSize: 16,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(w) {
            return function(E, I) {
              return new w.init(I).finalize(E);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(w) {
            return function(E, I) {
              return new _.HMAC.init(w, I).finalize(E);
            };
          }
        });
        var _ = c.algo = {};
        return c;
      })(Math);
      return t;
    });
  })(Ey)), Ey.exports;
}
var xy = { exports: {} }, qae = xy.exports, OP;
function Wae() {
  return OP || (OP = 1, (function(r, e) {
    (function(t, n) {
      r.exports = n(x4());
    })(qae, function(t) {
      return (function(n) {
        var i = t, s = i.lib, o = s.WordArray, a = s.Hasher, c = i.algo, u = [], l = [];
        (function() {
          function p(_) {
            for (var w = n.sqrt(_), E = 2; E <= w; E++)
              if (!(_ % E))
                return !1;
            return !0;
          }
          function y(_) {
            return (_ - (_ | 0)) * 4294967296 | 0;
          }
          for (var g = 2, v = 0; v < 64; )
            p(g) && (v < 8 && (u[v] = y(n.pow(g, 1 / 2))), l[v] = y(n.pow(g, 1 / 3)), v++), g++;
        })();
        var d = [], f = c.SHA256 = a.extend({
          _doReset: function() {
            this._hash = new o.init(u.slice(0));
          },
          _doProcessBlock: function(p, y) {
            for (var g = this._hash.words, v = g[0], _ = g[1], w = g[2], E = g[3], I = g[4], S = g[5], T = g[6], b = g[7], C = 0; C < 64; C++) {
              if (C < 16)
                d[C] = p[y + C] | 0;
              else {
                var P = d[C - 15], Z = (P << 25 | P >>> 7) ^ (P << 14 | P >>> 18) ^ P >>> 3, Y = d[C - 2], q = (Y << 15 | Y >>> 17) ^ (Y << 13 | Y >>> 19) ^ Y >>> 10;
                d[C] = Z + d[C - 7] + q + d[C - 16];
              }
              var J = I & S ^ ~I & T, O = v & _ ^ v & w ^ _ & w, x = (v << 30 | v >>> 2) ^ (v << 19 | v >>> 13) ^ (v << 10 | v >>> 22), k = (I << 26 | I >>> 6) ^ (I << 21 | I >>> 11) ^ (I << 7 | I >>> 25), B = b + k + J + l[C] + d[C], A = x + O;
              b = T, T = S, S = I, I = E + B | 0, E = w, w = _, _ = v, v = B + A | 0;
            }
            g[0] = g[0] + v | 0, g[1] = g[1] + _ | 0, g[2] = g[2] + w | 0, g[3] = g[3] + E | 0, g[4] = g[4] + I | 0, g[5] = g[5] + S | 0, g[6] = g[6] + T | 0, g[7] = g[7] + b | 0;
          },
          _doFinalize: function() {
            var p = this._data, y = p.words, g = this._nDataBytes * 8, v = p.sigBytes * 8;
            return y[v >>> 5] |= 128 << 24 - v % 32, y[(v + 64 >>> 9 << 4) + 14] = n.floor(g / 4294967296), y[(v + 64 >>> 9 << 4) + 15] = g, p.sigBytes = y.length * 4, this._process(), this._hash;
          },
          clone: function() {
            var p = a.clone.call(this);
            return p._hash = this._hash.clone(), p;
          }
        });
        i.SHA256 = a._createHelper(f), i.HmacSHA256 = a._createHmacHelper(f);
      })(Math), t.SHA256;
    });
  })(xy)), xy.exports;
}
var Zae = Sy.exports, $P;
function Jae() {
  return $P || ($P = 1, (function(r, e) {
    (function(t, n, i) {
      r.exports = n(x4(), Wae());
    })(Zae, function(t) {
      return (function() {
        var n = t, i = n.lib, s = i.WordArray, o = n.algo, a = o.SHA256, c = o.SHA224 = a.extend({
          _doReset: function() {
            this._hash = new s.init([
              3238371032,
              914150663,
              812702999,
              4144912697,
              4290775857,
              1750603025,
              1694076839,
              3204075428
            ]);
          },
          _doFinalize: function() {
            var u = a._doFinalize.call(this);
            return u.sigBytes -= 4, u;
          }
        });
        n.SHA224 = a._createHelper(c), n.HmacSHA224 = a._createHmacHelper(c);
      })(), t.SHA224;
    });
  })(Sy)), Sy.exports;
}
var Xae = Jae();
const Yae = /* @__PURE__ */ KI(Xae), BA = 255;
var oo = ((r) => (r.None = "none", r.Present = "present", r.VerifyingContract = "verifying_contract", r))(oo || {}), Qae = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, ece = (r, e) => (t, n) => e(t, n, r);
let LA = class {
  constructor(e) {
    this.config = e;
  }
  async getTypedDataFilters({ chainId: e, address: t, schema: n, version: i }) {
    var o, a, c, u;
    let s;
    try {
      const l = await He.request({ method: "GET", url: `${this.config.cal.url}/dapps`, params: { contracts: t, chain_id: e, output: "descriptors_eip712", descriptors_eip712_version: i, descriptors_eip712: "<set>", ref: `branch:${this.config.cal.branch}` }, headers: { [$n]: `context-module/${Rn.version}`, [ks]: this.config.originToken } }), d = Yae(JSON.stringify(this.sortTypes(n)).replace(" ", "")).toString();
      t = t.toLowerCase();
      const f = (u = (c = (a = (o = l.data) == null ? void 0 : o[0]) == null ? void 0 : a.descriptors_eip712) == null ? void 0 : c[t]) == null ? void 0 : u[d];
      if (!f) return N(new Error(`[ContextModule] HttpTypedDataDataSource: no typed data filters for address ${t} on chain ${e} for schema ${d}`));
      if (!f.schema || !Array.isArray(f.instructions)) return N(new Error(`[ContextModule] HttpTypedDataDataSource: no message info for address ${t} on chain ${e} for schema ${d}`));
      const p = [], y = {};
      for (const g of f.instructions) if (this.isInstructionContractInfo(g, this.config.cal.mode)) s = { displayName: g.display_name, signature: g.signatures[this.config.cal.mode], filtersCount: g.field_mappers_count };
      else if (i === "v1" && this.isInstructionFieldV1(g, this.config.cal.mode)) p.push({ type: "raw", displayName: g.display_name, path: g.field_path, signature: g.signatures[this.config.cal.mode] });
      else if (this.isInstructionFieldV2(g, this.config.cal.mode)) p.push({ type: g.format, displayName: g.display_name, path: g.field_path, signature: g.signatures[this.config.cal.mode] });
      else if (this.isInstructionFieldV2WithCoinRef(g, this.config.cal.mode)) p.push({ type: g.format, displayName: g.display_name, path: g.field_path, signature: g.signatures[this.config.cal.mode], tokenIndex: g.coin_ref });
      else if (this.isInstructionFieldV2WithName(g, this.config.cal.mode)) p.push({ type: g.format, displayName: g.display_name, path: g.field_path, signature: g.signatures[this.config.cal.mode], types: g.name_types, sources: g.name_sources, typesAndSourcesPayload: this.formatTrustedNameTypesAndSources(g) });
      else if (this.isInstructionCalldataInfo(g, this.config.cal.mode)) y[g.calldata_index] = { displayName: g.display_name, calldataIndex: g.calldata_index, valueFlag: g.value_filter_flag, calleeFlag: this.convertCalldataPresenceFlag(g.callee_filter_flag), amountFlag: g.amount_filter_flag, spenderFlag: this.convertCalldataPresenceFlag(g.spender_filter_flag), chainIdFlag: g.chain_id_filter_flag, selectorFlag: g.selector_filter_flag, signature: g.signatures[this.config.cal.mode] };
      else if (this.isInstructionFieldV2Calldata(g, this.config.cal.mode)) p.push({ type: g.format, displayName: g.display_name, path: g.field_path, signature: g.signatures[this.config.cal.mode], calldataIndex: g.calldata_index });
      else return N(new Error(`[ContextModule] HttpTypedDataDataSource: invalid typed data field for address ${t} on chain ${e} for schema ${d}`));
      return s ? te({ messageInfo: s, filters: p, calldatasInfos: y }) : N(new Error(`[ContextModule] HttpTypedDataDataSource: no message info for address ${t} on chain ${e} for schema ${d}`));
    } catch {
      return N(new Error("[ContextModule] HttpTypedDataDataSource: Failed to fetch typed data informations"));
    }
  }
  convertCalldataPresenceFlag(e) {
    switch (e) {
      case "none":
        return oo.None;
      case "present":
        return oo.Present;
      case "verifying_contract":
        return oo.VerifyingContract;
      default: {
        const t = e;
        throw new Error(`Unhandled flag: ${t}`);
      }
    }
  }
  formatTrustedNameTypesAndSources(e) {
    const t = e.name_types.length, n = e.name_sources.length, i = e.descriptor.slice((t + n) * 2 * -1, n * 2 * -1), s = e.descriptor.slice(n * 2 * -1), o = t.toString(16).padStart(2, "0"), a = n.toString(16).padStart(2, "0");
    return o + i + a + s;
  }
  isInstructionFieldV1(e, t) {
    return typeof e == "object" && typeof e.display_name == "string" && typeof e.field_path == "string" && typeof e.signatures == "object" && typeof e.signatures[t] == "string";
  }
  isInstructionFieldV2(e, t) {
    return typeof e == "object" && typeof e.display_name == "string" && typeof e.field_path == "string" && typeof e.signatures == "object" && typeof e.signatures[t] == "string" && typeof e.format == "string" && ["raw", "datetime"].includes(e.format) && e.coin_ref === void 0;
  }
  isInstructionFieldV2WithCoinRef(e, t) {
    return typeof e == "object" && typeof e.display_name == "string" && typeof e.field_path == "string" && typeof e.signatures == "object" && typeof e.signatures[t] == "string" && typeof e.format == "string" && ["token", "amount"].includes(e.format) && typeof e.coin_ref == "number";
  }
  isInstructionFieldV2WithName(e, t) {
    return typeof e == "object" && typeof e.display_name == "string" && typeof e.field_path == "string" && typeof e.signatures == "object" && typeof e.signatures[t] == "string" && typeof e.format == "string" && e.format === "trusted-name" && e.coin_ref === void 0 && Array.isArray(e.name_types) && Array.isArray(e.name_sources) && e.name_types.every((n) => typeof n == "string") && e.name_sources.every((n) => typeof n == "string");
  }
  isInstructionContractInfo(e, t) {
    return typeof e == "object" && typeof e.display_name == "string" && typeof e.field_mappers_count == "number" && typeof e.signatures == "object" && typeof e.signatures[t] == "string" && e.field_path === void 0;
  }
  isInstructionCalldataInfo(e, t) {
    return typeof e == "object" && typeof e.type == "string" && e.type === "calldata" && typeof e.display_name == "string" && typeof e.calldata_index == "number" && typeof e.value_filter_flag == "boolean" && typeof e.chain_id_filter_flag == "boolean" && typeof e.selector_filter_flag == "boolean" && typeof e.amount_filter_flag == "boolean" && ["none", "present", "verifying_contract"].includes(e.callee_filter_flag) && ["none", "present", "verifying_contract"].includes(e.spender_filter_flag) && typeof e.signatures == "object" && typeof e.signatures[t] == "string";
  }
  isInstructionFieldV2Calldata(e, t) {
    return typeof e == "object" && typeof e.display_name == "string" && typeof e.field_path == "string" && typeof e.signatures == "object" && typeof e.signatures[t] == "string" && typeof e.format == "string" && ["calldata-value", "calldata-callee", "calldata-chain-id", "calldata-selector", "calldata-amount", "calldata-spender"].includes(e.format) && typeof e.calldata_index == "number";
  }
  sortTypes(e) {
    return Object.fromEntries(Object.entries(e).sort(([t], [n]) => t.localeCompare(n)).map(([t, n]) => [t, n.map((i) => ({ name: i.name, type: i.type }))]));
  }
};
LA = Qae([le(), ece(0, X(yn.Config))], LA);
var tce = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Hm = (r, e) => (t, n) => e(t, n, r);
let UA = class {
  constructor(e, t, n, i) {
    this.dataSource = e, this.tokenDataSource = t, this.proxyDataSource = n, this._certificateLoader = i;
  }
  async load(e) {
    let t, n = await this.dataSource.getTypedDataFilters({ address: e.verifyingContract, chainId: e.chainId, version: e.version, schema: e.schema });
    if (n.isLeft()) {
      const { resolvedAddress: c, context: u } = await this.resolveProxy(e);
      if (u !== void 0 && (t = u, n = await this.dataSource.getTypedDataFilters({ address: c, chainId: e.chainId, version: e.version, schema: e.schema })), n.isLeft()) return { type: "error", error: n.extract() };
    }
    const { messageInfo: i, filters: s, calldatasInfos: o } = n.unsafeCoerce(), a = s.reduce((c, u) => (c[u.path] = u, c), {});
    return { type: "success", messageInfo: i, filters: a, trustedNamesAddresses: this.extractTrustedNames(s, e), tokens: await this.extractTokens(s, e), calldatas: this.extractCalldatas(s, o, e), proxy: t };
  }
  async resolveProxy(e) {
    const t = await this.proxyDataSource.getProxyImplementationAddress({ calldata: "0x", proxyAddress: e.verifyingContract, chainId: e.chainId, challenge: e.challenge ?? "" });
    if (t.isLeft()) return { resolvedAddress: e.verifyingContract, context: void 0 };
    const n = t.unsafeCoerce(), i = await this._certificateLoader.loadCertificate({ keyId: n.keyId, keyUsage: n.keyUsage, targetDevice: e.deviceModelId });
    return { resolvedAddress: n.implementationAddress, context: { type: M.PROXY_INFO, payload: n.signedDescriptor, certificate: i } };
  }
  extractTrustedNames(e, t) {
    return e.filter((n) => n.type === "trusted-name").reduce((n, i) => {
      const s = t.fieldsValues.filter((o) => o.path === i.path);
      if (s.length !== 0) {
        const o = s[0], a = this.convertAddressToHexaString(o.value);
        n[i.path] = a;
      }
      return n;
    }, {});
  }
  async extractTokens(e, t) {
    const n = {};
    for (const i of e) {
      if (i.type !== "token" && i.type !== "amount") continue;
      const s = i.tokenIndex;
      if (n[s] === void 0) {
        if (i.type === "token") {
          const o = t.fieldsValues.filter((u) => u.path === i.path);
          if (o.length === 0) continue;
          const a = o[0], c = this.convertAddressToHexaString(a.value);
          if (o.every((u) => this.convertAddressToHexaString(u.value) === c)) {
            const u = t.chainId;
            (await this.tokenDataSource.getTokenInfosPayload({ address: c, chainId: u })).ifRight((l) => {
              n[s] = l;
            });
          }
        } else if (i.type === "amount" && s === BA) {
          const o = t.verifyingContract, a = t.chainId;
          (await this.tokenDataSource.getTokenInfosPayload({ address: o, chainId: a })).ifRight((c) => {
            n[s] = c;
          });
        }
      }
    }
    return n;
  }
  extractCalldatas(e, t, n) {
    const i = e.reduce((o, a) => {
      if (a.type === "calldata-value" || a.type === "calldata-callee" || a.type === "calldata-chain-id" || a.type === "calldata-selector" || a.type === "calldata-amount" || a.type === "calldata-spender") {
        const c = o[a.calldataIndex];
        c === void 0 ? o[a.calldataIndex] = [a] : c.push(a);
      }
      return o;
    }, {}), s = {};
    for (const o in t) {
      const a = t[o], c = i[o];
      if (!c) continue;
      const u = this.extractHexaString(c.find((v) => v.type === "calldata-value"), n, "0x"), l = this.extractHexaString(c.find((v) => v.type === "calldata-selector"), n, u.slice(0, 10)), d = this.extractAddress(c.find((v) => v.type === "calldata-callee"), n, a.calleeFlag), f = this.extractAddress(c.find((v) => v.type === "calldata-spender"), n, a.spenderFlag), p = this.extractBigint(c.find((v) => v.type === "calldata-amount"), n, void 0), y = this.extractBigint(c.find((v) => v.type === "calldata-chain-id"), n, void 0), g = y !== void 0 && y < Number.MAX_SAFE_INTEGER ? Number(y) : n.chainId;
      s[o] = { filter: a, subset: { chainId: g, data: u, selector: l, to: d, value: p, from: f } };
    }
    return s;
  }
  extractHexaString(e, t, n) {
    if (e !== void 0) {
      const i = t.fieldsValues.filter((s) => s.path === e.path);
      if (i.length !== 0) return It(i[0].value);
    }
    return n;
  }
  extractAddress(e, t, n, i) {
    if (n === oo.VerifyingContract) return t.verifyingContract;
    if (e !== void 0) {
      const s = t.fieldsValues.filter((o) => o.path === e.path);
      if (s.length !== 0) return this.convertAddressToHexaString(s[0].value);
    }
    return i;
  }
  extractBigint(e, t, n) {
    if (e !== void 0) {
      const i = t.fieldsValues.filter((s) => s.path === e.path);
      if (i.length !== 0) return BigInt(It(i[0].value));
    }
    return n;
  }
  convertAddressToHexaString(e) {
    return `0x${Array.from(e, (t) => t.toString(16).padStart(2, "0")).join("").padStart(40, "0")}`;
  }
};
UA = tce([le(), Hm(0, X(av.TypedDataDataSource)), Hm(1, X(yo.TokenDataSource)), Hm(2, X(Nu.ProxyDataSource)), Hm(3, X(Oi.PkiCertificateLoader))], UA);
const rce = () => new mt(({ bind: r }) => {
  r(av.TypedDataDataSource).to(LA), r(av.TypedDataContextLoader).to(UA);
}), nce = ["function execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline) external payable"], RP = "0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad", PP = "0x3593564c";
var hi = ((r) => (r.V2_SWAP_EXACT_IN = "V2_SWAP_EXACT_IN", r.V2_SWAP_EXACT_OUT = "V2_SWAP_EXACT_OUT", r.V3_SWAP_EXACT_IN = "V3_SWAP_EXACT_IN", r.V3_SWAP_EXACT_OUT = "V3_SWAP_EXACT_OUT", r.WRAP_ETH = "WRAP_ETH", r.UNWRAP_ETH = "UNWRAP_ETH", r.PERMIT2_PERMIT = "PERMIT2_PERMIT", r.PERMIT2_TRANSFER_FROM = "PERMIT2_TRANSFER_FROM", r.PERMIT2_PERMIT_BATCH = "PERMIT2_PERMIT_BATCH", r.PERMIT2_TRANSFER_FROM_BATCH = "PERMIT2_TRANSFER_FROM_BATCH", r.PAY_PORTION = "PAY_PORTION", r.SWEEP = "SWEEP", r))(hi || {});
const ice = { "0x08": "V2_SWAP_EXACT_IN", "0x09": "V2_SWAP_EXACT_OUT", "0x00": "V3_SWAP_EXACT_IN", "0x01": "V3_SWAP_EXACT_OUT", "0x0b": "WRAP_ETH", "0x0c": "UNWRAP_ETH", "0x0a": "PERMIT2_PERMIT", "0x0d": "PERMIT2_TRANSFER_FROM", "0x02": "PERMIT2_PERMIT_BATCH", "0x03": "PERMIT2_TRANSFER_FROM_BATCH", "0x06": "PAY_PORTION", "0x04": "SWEEP" }, sce = ["V2_SWAP_EXACT_IN", "V2_SWAP_EXACT_OUT", "V3_SWAP_EXACT_IN", "V3_SWAP_EXACT_OUT"];
var A4 = ((r) => (r[r.ETHEREUM_MAINNET = 1] = "ETHEREUM_MAINNET", r[r.ETHEREUM_GOERLI = 5] = "ETHEREUM_GOERLI", r[r.ETHEREUM_SEPOLIA = 11155111] = "ETHEREUM_SEPOLIA", r[r.ARBITRUM_ONE = 42161] = "ARBITRUM_ONE", r[r.ARBITRUM_GOERLI = 421613] = "ARBITRUM_GOERLI", r[r.AVALANCHE_C_CHAIN = 43114] = "AVALANCHE_C_CHAIN", r[r.BSC = 56] = "BSC", r[r.BASE = 8453] = "BASE", r[r.BASE_GOERLI = 84531] = "BASE_GOERLI", r[r.BLAST = 23888] = "BLAST", r[r.OPTIMISM = 10] = "OPTIMISM", r[r.OPTIMISM_GOERLI = 420] = "OPTIMISM_GOERLI", r[r.POLYGON = 137] = "POLYGON", r[r.POLYGON_MUMBAI = 80001] = "POLYGON_MUMBAI", r))(A4 || {});
const oce = { 1: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", 5: "0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6", 11155111: "0xfFf9976782d46CC05630D1f6eBAb18b2324d6B14", 42161: "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1", 421613: "0xe39Ab88f8A4777030A534146A9Ca3B52bd5D43A3", 43114: "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7", 56: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c", 8453: "0x4200000000000000000000000000000000000006", 84531: "0x44D627f900da8AdaC7561bD73aA745F132450798", 23888: "0x4300000000000000000000000000000000000004", 10: "0x4200000000000000000000000000000000000006", 420: "0x4200000000000000000000000000000000000006", 137: "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270", 80001: "0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889" };
var ace = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, cce = (r, e) => (t, n) => e(t, n, r);
const N_ = 40, NP = 6;
let FA = class {
  constructor(e) {
    h(this, "_decodeSweep", (e) => {
      const [t] = this.abiDecoder.decode(["address", "address", "uint256"], e);
      return typeof t != "string" || !br(t) ? [] : [t.toLowerCase()];
    });
    this.abiDecoder = e;
  }
  decode(e, t, n) {
    switch (e) {
      case hi.V2_SWAP_EXACT_IN:
        return this._decodeSwapV2(t);
      case hi.V2_SWAP_EXACT_OUT:
        return this._decodeSwapV2(t);
      case hi.V3_SWAP_EXACT_IN:
        return this._decodeSwapV3(t);
      case hi.V3_SWAP_EXACT_OUT:
        return this._decodeSwapV3(t);
      case hi.WRAP_ETH:
        return this._decodeWrappedEth(t, n);
      case hi.UNWRAP_ETH:
        return this._decodeWrappedEth(t, n);
      case hi.SWEEP:
        return this._decodeSweep(t);
      case hi.PERMIT2_PERMIT:
      case hi.PERMIT2_TRANSFER_FROM:
      case hi.PERMIT2_PERMIT_BATCH:
      case hi.PERMIT2_TRANSFER_FROM_BATCH:
      case hi.PAY_PORTION:
        return [];
      default:
        return [];
    }
  }
  _decodeSwapV2(e) {
    const [, , , t] = this.abiDecoder.decode(["address", "uint256", "uint256", "address[]", "bool"], e);
    return !Array.isArray(t) || !t.every(br) ? [] : t.map((n) => n.toLowerCase());
  }
  _decodeSwapV3(e) {
    const [, , , t] = this.abiDecoder.decode(["address", "uint256", "uint256", "bytes", "bool"], e);
    if (typeof t != "string" || !br(t) || t.length < 2 + N_ * 2 + NP) return [];
    const n = [];
    for (let i = 2; i < t.length; i += N_ + NP) n.push(t.slice(i, i + N_));
    return n.map((i) => i.toLowerCase()).map((i) => `0x${i}`);
  }
  _isSupportedChainId(e) {
    return Object.values(A4).includes(e);
  }
  _decodeWrappedEth(e, t) {
    return this._isSupportedChainId(t) ? [oce[t].toLowerCase()] : [];
  }
};
FA = ace([le(), cce(0, X(_d.AbiDecoderDataSource))], FA);
var uce = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
};
let MA = class {
  decode(e, t) {
    try {
      return Jp.defaultAbiCoder().decode(e, t);
    } catch {
      return [];
    }
  }
};
MA = uce([le()], MA);
const lce = "0x3044022014391e8f355867a57fe88f6a5a4dbcb8bf8f888a9db3ff3449caf72d120396bd02200c13d9c3f79400fe0aa0434ac54d59b79503c9964a4abc3e8cd22763e0242935", BP = "Uniswap";
var dce = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, LP = (r, e) => (t, n) => e(t, n, r);
const hce = [M.EXTERNAL_PLUGIN, M.TOKEN];
let VA = class {
  constructor(e, t) {
    this.commandDecoderDataSource = e, this.tokenDataSource = t;
  }
  canHandle(e, t) {
    return typeof e == "object" && e !== null && "to" in e && "data" in e && "selector" in e && "chainId" in e && typeof e.chainId == "number" && br(e.data) && e.data !== "0x" && br(e.selector) && e.selector === PP && br(e.to) && e.to === RP && hce.every((n) => t.includes(n));
  }
  async load(e) {
    const { data: t, chainId: n } = e, i = this._buildUniswapPluginCommandData(), s = await this._extractClearSignContexts(t, n);
    return s.length > 0 ? [i, ...s] : [];
  }
  _buildUniswapPluginCommandData() {
    const e = new Ds().add8BitUIntToData(BP.length).addAsciiStringToData(BP).addBufferToData(_r(RP)).addBufferToData(_r(PP)).addBufferToData(_r(lce)).build();
    return { type: M.EXTERNAL_PLUGIN, payload: It(e, !1) };
  }
  async _extractClearSignContexts(e, t) {
    try {
      const n = new lv(nce).parseTransaction({ data: e }), i = n == null ? void 0 : n.args[0], s = n == null ? void 0 : n.args[1];
      if (!br(i) || !this._isHexaStringArray(s)) return [];
      const o = this._extractCommands(i).orDefault([]);
      if (i.length === 0 || s.length !== o.length) return [];
      const a = o.reduce((u, l, d) => {
        const f = s[d], p = this.commandDecoderDataSource.decode(l, f, t);
        return u.push([l, p]), u;
      }, []);
      if (!this._isChainingSwapSupported(a)) return [];
      const c = [...new Set(a.flatMap(([, u]) => u))];
      return (await Promise.all(c.map((u) => this.tokenDataSource.getTokenInfosPayload({ address: u, chainId: t })))).map((u) => u.caseOf({ Left: (l) => ({ type: M.ERROR, error: l }), Right: (l) => ({ type: M.TOKEN, payload: l }) }));
    } catch {
      return [];
    }
  }
  _extractCommands(e) {
    return pe.fromNullable(e.slice(2).match(/../g)).map((t) => t.map((n) => `0x${n}`)).map((t) => t.map((n) => ice[n])).chain((t) => t.every((n) => n !== void 0) ? pe.of(t) : ve);
  }
  _isChainingSwapSupported(e) {
    let t, n;
    for (const [i, s] of e) {
      if (!sce.includes(i)) continue;
      const o = i.slice(0, 2);
      if (t && (t !== s[0] || n !== o)) return !1;
      t = s[s.length - 1], n = o;
    }
    return !0;
  }
  _isHexaStringArray(e) {
    return Array.isArray(e) && e.every((t) => typeof t == "string" && br(t));
  }
};
VA = dce([le(), LP(0, X(_d.CommandDecoderDataSource)), LP(1, X(yo.TokenDataSource))], VA);
const fce = () => new mt(({ bind: r }) => {
  r(_d.AbiDecoderDataSource).to(MA), r(_d.CommandDecoderDataSource).to(FA), r(_d.UniswapContextLoader).to(VA);
});
var pce = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, UP = (r, e) => (t, n) => e(t, n, r);
let zA = class {
  constructor(e, t) {
    if (this.config = e, this._certificateLoader = t, !this.config.originToken) throw new Error("Origin token is required");
  }
  async getWeb3Checks(e) {
    const { from: t, deviceModelId: n } = e;
    let i, s, o;
    this.isTypedDataContext(e) ? (s = { msg: { from: t, data: e.data } }, o = `${this.config.web3checks.url}/ethereum/scan/eip-712`) : (s = { tx: { from: t, raw: e.rawTx }, chain: e.chainId }, o = `${this.config.web3checks.url}/ethereum/scan/tx`);
    try {
      i = (await He.request({ method: "POST", url: o, data: s, headers: { [$n]: `context-module/${Rn.version}`, [ks]: this.config.originToken } })).data;
    } catch {
      return N(new Error("[ContextModule] HttpWeb3CheckDataSource: Failed to fetch web3 checks informations"));
    }
    if (!this.isWeb3CheckDto(i)) return N(new Error("[ContextModule] HttpWeb3CheckDataSource: Cannot exploit Web3 checks data received"));
    const a = await this._certificateLoader.loadCertificate({ keyId: i.public_key_id, keyUsage: Ir.TxSimulationSigner, targetDevice: n }), c = { publicKeyId: i.public_key_id, descriptor: i.descriptor, certificate: a };
    return te(c);
  }
  isTypedDataContext(e) {
    return "data" in e;
  }
  isWeb3CheckDto(e) {
    return e != null && typeof e == "object" && "public_key_id" in e && e.public_key_id != null && typeof e.public_key_id == "string" && "descriptor" in e && e.descriptor != null && typeof e.descriptor == "string";
  }
};
zA = pce([le(), UP(0, X(yn.Config)), UP(1, X(Oi.PkiCertificateLoader))], zA);
var gce = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, mce = (r, e) => (t, n) => e(t, n, r);
let jA = class {
  constructor(e) {
    h(this, "_dataSource");
    this._dataSource = e;
  }
  async load(e) {
    return await this._dataSource.getWeb3Checks(e);
  }
};
jA = gce([le(), mce(0, X(cv.Web3CheckDataSource))], jA);
const yce = () => new mt(({ bind: r }) => {
  r(cv.Web3CheckDataSource).to(zA), r(cv.Web3CheckContextLoader).to(jA);
}), vce = ({ config: r }) => {
  const e = new Uv();
  return e.loadSync(_se(r), iae(), Cse(), fae(), Aae(r), Uae(), wse(), Hae(), rce(), bae(), fce(), yce(), Tae()), e;
};
class bce {
  constructor(e) {
    h(this, "_container");
    h(this, "_loaders");
    h(this, "_typedDataLoader");
    h(this, "_web3CheckLoader");
    h(this, "_solanaLoader");
    h(this, "_fieldLoaders");
    this._container = vce({ config: e }), this._loaders = e.defaultLoaders ? this._getDefaultLoaders() : [], this._loaders.push(...e.customLoaders), this._fieldLoaders = e.defaultFieldLoaders ? this._getDefaultFieldLoaders() : [], this._fieldLoaders.push(...e.customFieldLoaders), this._typedDataLoader = e.customTypedDataLoader ?? this._getDefaultTypedDataLoader(), this._web3CheckLoader = e.customWeb3CheckLoader ?? this._getWeb3CheckLoader(), this._solanaLoader = e.customSolanaLoader ?? this._getSolanaLoader();
  }
  _getDefaultFieldLoaders() {
    return [this._container.get(Lu.NftContextFieldLoader), this._container.get(yo.TokenContextFieldLoader), this._container.get(Bu.TrustedNameContextFieldLoader), this._container.get(Nu.ProxyContextFieldLoader)];
  }
  _getDefaultLoaders() {
    return [this._container.get(sv.ExternalPluginContextLoader), this._container.get(Bu.TrustedNameContextLoader), this._container.get(Lu.NftContextLoader), this._container.get(yo.TokenContextLoader), this._container.get(wd.CalldataContextLoader), this._container.get(_d.UniswapContextLoader), this._container.get(iv.DynamicNetworkContextLoader)];
  }
  _getDefaultTypedDataLoader() {
    return this._container.get(av.TypedDataContextLoader);
  }
  _getWeb3CheckLoader() {
    return this._container.get(cv.Web3CheckContextLoader);
  }
  _getSolanaLoader() {
    try {
      return this._container.get(ov.SolanaContextLoader);
    } catch {
      return { load: async (e) => N(new Error("[ContextModule] - DefaultContextModule: no SolanaContextLoader bound")) };
    }
  }
  async getContexts(e, t) {
    const n = Object.values(M), i = this._loaders.filter((s) => s.canHandle(e, t ?? n)).map((s) => s.load(e));
    return (await Promise.all(i)).flat();
  }
  async getFieldContext(e, t) {
    const n = this._fieldLoaders.filter((i) => i.canHandle(e, t));
    if (n.length === 0) return Promise.resolve({ type: M.ERROR, error: new Error(`Loader not found for field: ${e} and expected type: ${t}`) });
    for (const i of n) {
      const s = await i.loadField(e);
      if (s.type !== M.ERROR) return s;
    }
    return { type: M.ERROR, error: new Error(`Loader not found for field: ${e} and expected type: ${t}`) };
  }
  async getTypedDataFilters(e) {
    return this._typedDataLoader.load(e);
  }
  async getWeb3Checks(e) {
    return (await this._web3CheckLoader.load(e)).caseOf({ Right: (t) => ({ type: M.WEB3_CHECK, payload: t.descriptor, certificate: t.certificate }), Left: () => null });
  }
  async getSolanaContext(e) {
    return await this._solanaLoader.load(e);
  }
}
const wce = "https://crypto-assets-service.api.ledger.com/v1", _ce = "https://web3checks-backend.api.ledger.com/v3", Sce = "https://nft.api.live.ledger.com", Ece = { cal: { url: wce, mode: "prod", branch: "main" }, web3checks: { url: _ce }, metadataServiceDomain: { url: Sce }, defaultLoaders: !0, customLoaders: [], defaultFieldLoaders: !0, customFieldLoaders: [], customTypedDataLoader: void 0, customSolanaLoader: void 0 };
let xce = class {
  constructor({ originToken: e } = {}) {
    h(this, "config", Ece);
    h(this, "needOriginToken", !0);
    h(this, "originToken");
    this.originToken = e;
  }
  removeDefaultLoaders() {
    return this.config.defaultLoaders = !1, this;
  }
  addLoader(e) {
    return this.config.customLoaders.push(e), this;
  }
  addTypedDataLoader(e) {
    return this.config.customTypedDataLoader = e, this;
  }
  addWeb3CheckLoader(e) {
    return this.needOriginToken = !1, this.config.customWeb3CheckLoader = e, this;
  }
  addSolanaLoader(e) {
    return this.config.customSolanaLoader = e, this;
  }
  setCalConfig(e) {
    return this.config.cal = e, this;
  }
  setMetadataServiceConfig(e) {
    return this.config.metadataServiceDomain = e, this;
  }
  setWeb3ChecksConfig(e) {
    return this.config.web3checks = e, this;
  }
  setDatasourceConfig(e) {
    return this.config.datasource = e, this;
  }
  build() {
    if (this.needOriginToken && !this.originToken) throw new Error("Origin token is required");
    const e = { ...this.config, originToken: this.originToken };
    return new bce(e);
  }
};
var Ay = ((r) => (r.FROM = "FROM", r.TO = "TO", r.VALUE = "VALUE", r))(Ay || {}), zc = ((r) => (r.TUPLE = "TUPLE", r.ARRAY = "ARRAY", r.REF = "REF", r.LEAF = "LEAF", r.SLICE = "SLICE", r))(zc || {}), wp = ((r) => (r.STATIC_LEAF = "STATIC_LEAF", r.DYNAMIC_LEAF = "DYNAMIC_LEAF", r.TUPLE_LEAF = "TUPLE_LEAF", r.ARRAY_LEAF = "ARRAY_LEAF", r))(wp || {});
const I4 = { GetAddressUseCase: Symbol.for("GetAddressUseCase") }, bl = { AppBinding: Symbol.for("AppBinder") };
var Ace = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Ice = (r, e) => (t, n) => e(t, n, r);
let HA = class {
  constructor(e) {
    h(this, "_appBinder");
    this._appBinder = e;
  }
  execute(e, t) {
    return this._appBinder.getAddress({ derivationPath: e, checkOnDevice: (t == null ? void 0 : t.checkOnDevice) ?? !1, returnChainCode: (t == null ? void 0 : t.returnChainCode) ?? !1, skipOpenApp: (t == null ? void 0 : t.skipOpenApp) ?? !1 });
  }
};
HA = Ace([le(), Ice(0, X(bl.AppBinding))], HA);
const Cce = () => new mt(({ bind: r }) => {
  r(I4.GetAddressUseCase).to(HA);
});
let Kt = class {
  constructor(e, t, n = Jr.isSuccessResponse) {
    this._errors = e, this._errorFactory = t, this._isSuccessResponse = n;
  }
  getError(e) {
    const t = new kr(e).encodeToHexaString(e.statusCode);
    if (hl(t, this._errors)) return ye({ error: this._errorFactory({ ...this._errors[t], errorCode: t }) });
    if (!this._isSuccessResponse(e)) return ye({ error: ha.handle(e) });
  }
};
var aS;
let _f = (aS = class {
  static splitPath(e) {
    const t = [];
    return e.split("/").forEach((n) => {
      let i = parseInt(n, 10);
      if (isNaN(i)) throw new Error("invalid number provided");
      n.length > 1 && n[n.length - 1] === "'" && (i += this.PADDING), t.push(i);
    }), t;
  }
}, h(aS, "PADDING", 2147483648), aS);
const qt = { 6001: { message: "Mode check fail" }, 6501: { message: "TransactionType not supported" }, 6502: { message: "Output buffer too small for chainId conversion" }, 6800: { message: "Internal error (Please report)" }, 6982: { message: "Security status not satisfied (Canceled by user)" }, 6983: { message: "Wrong Data length" }, 6984: { message: "Plugin not installed" }, 6985: { message: "Condition not satisfied" }, "6a00": { message: "Error without info" }, "6a80": { message: "Invalid data" }, "6a84": { message: "Insufficient memory" }, "6a88": { message: "Data not found" }, "6b00": { message: "Incorrect parameter P1 or P2" }, "6d00": { message: "Incorrect parameter INS" }, "6e00": { message: "Incorrect parameter CLA" }, "6f00": { message: "Technical problem (Internal error, please report)" }, "911c": { message: "Command code not supported (i.e., Ledger-PKI not yet available)" } };
let Jh = class extends dl {
  constructor(e) {
    super({ tag: "EthAppCommandError", ...e });
  }
};
const Wt = (r) => new Jh(r);
let C4 = class {
  constructor() {
    h(this, "errorHelper", new Kt(qt, Wt));
  }
  getApdu() {
    const e = { cla: 224, ins: 6, p1: 0, p2: 0 };
    return new ot(e).build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefaultLazy(() => {
      const t = new kr(e), n = t.extract8BitUInt();
      if (n === void 0) return ye({ error: new ht("Cannot extract config flags") });
      const i = t.extract8BitUInt(), s = t.extract8BitUInt(), o = t.extract8BitUInt();
      if (i === void 0 || s === void 0 || o === void 0) return ye({ error: new ht("Cannot extract version") });
      const a = !!(n & 1), c = !!(n & 16), u = !!(n & 32), l = { blindSigningEnabled: a, web3ChecksEnabled: c, web3ChecksOptIn: u, version: `${i}.${s}.${o}` };
      return ye({ data: l });
    });
  }
};
const Dce = 32, Tce = 32;
let D4 = class {
  constructor(e) {
    h(this, "errorHelper", new Kt(qt, Wt));
    this.args = e;
  }
  getApdu() {
    const { derivationPath: e, legacyArgs: t } = this.args, n = { cla: 224, ins: 12, p1: 0, p2: t.isJust() ? 0 : 1 }, i = _f.splitPath(e), s = new ot(n);
    s.add8BitUIntToData(i.length);
    for (const o of i) s.add32BitUIntToData(o);
    return t.ifJust(({ domainHash: o, messageHash: a }) => {
      s.addHexaStringToData(o), s.addHexaStringToData(a);
    }), s.build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefaultLazy(() => {
      const t = new kr(e), n = t.extract8BitUInt();
      if (n === void 0) return ye({ error: new ht("V is missing") });
      const i = t.encodeToHexaString(t.extractFieldByLength(Dce), !0);
      if (!i) return ye({ error: new ht("R is missing") });
      const s = t.encodeToHexaString(t.extractFieldByLength(Tce), !0);
      return ye(s ? { data: { r: i, s, v: n } } : { error: new ht("S is missing") });
    });
  }
}, T4 = class {
  constructor() {
    h(this, "errorHelper", new Kt(qt, Wt));
  }
  getApdu() {
    const e = { cla: 224, ins: 50, p1: 1, p2: 0 };
    return new ot(e).build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefaultLazy(() => {
      const t = new kr(e).extract8BitUInt();
      return ye(t === void 0 ? { data: { enabled: !1 } } : { data: { enabled: t !== 0 } });
    });
  }
};
var Xh = ((r) => (r.BASIC = "basic", r.EIP7730 = "eip7730", r))(Xh || {});
const FP = 4;
let Yh = class {
  constructor() {
    h(this, "errorHelper", new Kt(qt, Wt));
  }
  getApdu() {
    const e = { cla: 224, ins: 32, p1: 0, p2: 0 };
    return new ot(e).build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefaultLazy(() => {
      const t = new kr(e);
      if (t.testMinimalLength(FP) === !1) return ye({ error: new ht("Challenge key is missing") });
      const n = t.encodeToHexaString(t.extractFieldByLength(FP));
      return ye({ data: { challenge: n } });
    });
  }
};
const MP = 32;
class k4 {
  constructor(e) {
    h(this, "args");
    h(this, "errorHelper", new Kt(qt, Wt));
    this.args = e;
  }
  getApdu() {
    const e = { cla: 224, ins: 2, p1: this.args.checkOnDevice ? 1 : 0, p2: this.args.returnChainCode ? 1 : 0 }, t = new ot(e), n = this.args.derivationPath, i = _f.splitPath(n);
    return t.add8BitUIntToData(i.length), i.forEach((s) => {
      t.add32BitUIntToData(s);
    }), t.add32BitUIntToData(0), t.add32BitUIntToData(1), t.build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefaultLazy(() => {
      const t = new kr(e), n = t.extract8BitUInt();
      if (n === void 0) return ye({ error: new ht("Public key length is missing") });
      if (t.testMinimalLength(n) === !1) return ye({ error: new ht("Public key is missing") });
      const i = t.encodeToHexaString(t.extractFieldByLength(n)), s = t.extract8BitUInt();
      if (s === void 0) return ye({ error: new ht("Ethereum address length is missing") });
      if (t.testMinimalLength(s) === !1) return ye({ error: new ht("Ethereum address is missing") });
      const o = `0x${t.encodeToString(t.extractFieldByLength(s))}`;
      if (br(o) === !1) return ye({ error: new ht("Invalid Ethereum address") });
      let a;
      if (this.args.returnChainCode) {
        if (t.testMinimalLength(MP) === !1) return ye({ error: new ht("Invalid Chaincode") });
        a = t.encodeToHexaString(t.extractFieldByLength(MP));
      }
      return ye({ data: { publicKey: i, address: o, chainCode: a } });
    });
  }
}
let O4 = class {
  constructor(e, t) {
    this.api = e, this.args = t;
  }
  async run() {
    const e = await this.api.sendCommand(new k4({ derivationPath: this.args.derivationPath, checkOnDevice: !1, returnChainCode: !1 }));
    if (!We(e)) return { web3Check: null, error: e.error };
    const t = e.data.address, { deviceModelId: n } = this.api.getDeviceSessionState(), { contextModule: i } = this.args;
    let s;
    if (this.isRawTx(this.args)) {
      const { subset: o, transaction: a } = this.args, c = { deviceModelId: n, from: t, rawTx: It(a), chainId: o.chainId };
      s = await i.getWeb3Checks(c);
    } else {
      const o = { deviceModelId: n, from: t, data: this.args.data };
      s = await i.getWeb3Checks(o);
    }
    return s === null || (s == null ? void 0 : s.type) !== M.WEB3_CHECK ? { web3Check: null } : { web3Check: s };
  }
  isRawTx(e) {
    return "transaction" in e;
  }
}, Xp = class {
  constructor(e, t) {
    h(this, "isCompatible", !0);
    h(this, "version", "0.0.1");
    h(this, "modelId");
    if (this.modelId = e.deviceModelId, e.sessionStateType === wr.Connected) {
      this.isCompatible = !1;
      return;
    }
    if (e.currentApp.name === "Exchange") {
      this.isCompatible = !1;
      return;
    } else e.currentApp.name === "Ethereum" ? this.version = e.currentApp.version : this.version = t.version;
  }
  withMinVersionInclusive(e) {
    return Et.gte(this.version, e) || (this.isCompatible = !1), this;
  }
  withMinVersionExclusive(e) {
    return Et.gt(this.version, e) || (this.isCompatible = !1), this;
  }
  excludeDeviceModel(e) {
    return this.modelId === e && (this.isCompatible = !1), this;
  }
  check() {
    return this.isCompatible;
  }
};
const kce = [M.TRANSACTION_INFO, M.TRANSACTION_FIELD_DESCRIPTION, M.ENUM, M.PROXY_INFO], Oce = [M.TRANSACTION_INFO, M.TRANSACTION_FIELD_DESCRIPTION, M.PROXY_INFO, M.WEB3_CHECK, M.DYNAMIC_NETWORK, M.DYNAMIC_NETWORK_ICON, M.ENUM, M.TRUSTED_NAME, M.TOKEN, M.NFT, M.PLUGIN, M.EXTERNAL_PLUGIN];
let $ce = class {
  constructor(e, t, n = (i, s) => new O4(i, s)) {
    this._api = e, this._args = t, this.getWeb3ChecksFactory = n;
  }
  async run() {
    const { contextModule: e, options: t, appConfig: n, derivationPath: i, transaction: s, subset: o } = this._args, a = s === void 0, c = this._api.getDeviceSessionState();
    let u;
    if (c.deviceModelId !== je.NANO_S) {
      const f = await this._api.sendCommand(new Yh());
      We(f) && (u = f.data.challenge);
    }
    const l = await e.getContexts({ challenge: u, domain: t.domain, deviceModelId: c.deviceModelId, ...o }, a ? kce : Oce);
    if (s && n.web3ChecksEnabled) {
      const f = (await this.getWeb3ChecksFactory(this._api, { contextModule: e, derivationPath: i, subset: o, transaction: s }).run()).web3Check;
      f && l.unshift(f);
    }
    const d = l.filter((f) => f.type !== M.ERROR);
    return this._supportsGenericParser(c, n) && this._hasValidTransactionInfo(d) ? this._getERC7730Contexts(d) : this._getBasicContexts(d);
  }
  _getERC7730Contexts(e) {
    const t = e.filter((i) => this._isContextNeededForERC7730ClearSigning(i)).sort((i, s) => this._getContextPriority(i) - this._getContextPriority(s)), n = e.filter((i) => i.type === M.ENUM);
    return { clearSignContexts: t, clearSignContextsOptional: n, clearSigningType: Xh.EIP7730 };
  }
  _getBasicContexts(e) {
    return { clearSignContexts: e.filter((t) => this._isContextNeededForBasicClearSigning(t)).sort((t, n) => this._getContextPriority(t) - this._getContextPriority(n)), clearSignContextsOptional: [], clearSigningType: Xh.BASIC };
  }
  _isContextNeededForBasicClearSigning({ type: e }) {
    switch (e) {
      case M.WEB3_CHECK:
      case M.PLUGIN:
      case M.EXTERNAL_PLUGIN:
      case M.DYNAMIC_NETWORK:
      case M.DYNAMIC_NETWORK_ICON:
      case M.TRUSTED_NAME:
      case M.TOKEN:
      case M.NFT:
        return !0;
      case M.TRANSACTION_INFO:
      case M.TRANSACTION_FIELD_DESCRIPTION:
      case M.ENUM:
      case M.PROXY_INFO:
      case M.SAFE:
      case M.SIGNER:
        return !1;
      default: {
        const t = e;
        throw new Error(`Unhandled context type ${String(t)}`);
      }
    }
  }
  _isContextNeededForERC7730ClearSigning({ type: e }) {
    switch (e) {
      case M.TRANSACTION_INFO:
      case M.TRANSACTION_FIELD_DESCRIPTION:
      case M.PROXY_INFO:
      case M.WEB3_CHECK:
      case M.DYNAMIC_NETWORK:
      case M.DYNAMIC_NETWORK_ICON:
        return !0;
      case M.ENUM:
      case M.TRUSTED_NAME:
      case M.TOKEN:
      case M.NFT:
      case M.PLUGIN:
      case M.EXTERNAL_PLUGIN:
      case M.SAFE:
      case M.SIGNER:
        return !1;
      default: {
        const t = e;
        throw new Error(`Unhandled context type ${String(t)}`);
      }
    }
  }
  _hasValidTransactionInfo(e) {
    var t;
    return ((t = e.find((n) => n.type === M.TRANSACTION_INFO)) == null ? void 0 : t.certificate) !== void 0;
  }
  _supportsGenericParser(e, t) {
    return new Xp(e, t).withMinVersionExclusive("1.14.0").excludeDeviceModel(je.NANO_S).check();
  }
  _getContextPriority({ type: e }) {
    switch (e) {
      case M.WEB3_CHECK:
        return 10;
      case M.DYNAMIC_NETWORK:
      case M.DYNAMIC_NETWORK_ICON:
      case M.PROXY_INFO:
        return 30;
      case M.TRANSACTION_INFO:
        return 50;
      case M.PLUGIN:
      case M.EXTERNAL_PLUGIN:
      case M.TOKEN:
      case M.NFT:
      case M.TRUSTED_NAME:
      case M.TRANSACTION_FIELD_DESCRIPTION:
      case M.ENUM:
        return 70;
      case M.SAFE:
      case M.SIGNER:
        return 90;
      default: {
        const t = e;
        throw new Error(`Unhandled context type for priority: ${String(t)}`);
      }
    }
  }
}, Rce = class {
  constructor(e, t) {
    this.api = e, this.args = t;
  }
  run() {
    const e = this.args.context, t = e.type;
    switch (t) {
      case M.TRANSACTION_INFO:
      case M.WEB3_CHECK:
      case M.PLUGIN:
      case M.EXTERNAL_PLUGIN:
      case M.DYNAMIC_NETWORK:
      case M.DYNAMIC_NETWORK_ICON:
      case M.ENUM:
      case M.TRUSTED_NAME:
      case M.TOKEN:
      case M.NFT:
      case M.SAFE:
      case M.SIGNER:
        return { subcontextCallbacks: [] };
      case M.TRANSACTION_FIELD_DESCRIPTION:
        return { subcontextCallbacks: e.reference ? this._getSubcontextsFromReference(e.reference) : [] };
      case M.PROXY_INFO:
        return { subcontextCallbacks: this._getSubcontextFromProxy(e) };
      default: {
        const n = t;
        throw new Error(`Uncovered type: ${n}`);
      }
    }
  }
  _getSubcontextsFromReference(e) {
    const t = e.type;
    switch (t) {
      case Zr.TOKEN:
      case Zr.NFT:
        return this._getSubcontextsFromTokenOrNftReference(e);
      case Zr.ENUM:
        return this._getSubcontextsFromEnumReference(e);
      case Zr.TRUSTED_NAME:
        return this._getSubcontextsFromTrustedNameReference(e);
      case Zr.CALLDATA:
        return [];
      default: {
        const n = t;
        throw new Error(`Uncovered reference type: ${n}`);
      }
    }
  }
  _getSubcontextsFromTokenOrNftReference(e) {
    if (e.value !== void 0) {
      const n = { chainId: this.args.subset.chainId, address: e.value }, i = e.type === Zr.TOKEN ? M.TOKEN : M.NFT;
      return [() => this.args.contextModule.getFieldContext(n, i)];
    }
    const t = [];
    if (e.valuePath !== void 0) {
      const n = this.args.transactionParser.extractValue(this.args.subset, e.valuePath).orDefault([]);
      for (const i of n) {
        const s = It(i.slice(Math.max(0, i.length - 20))), o = e.type === Zr.TOKEN ? M.TOKEN : M.NFT;
        t.push(() => this.args.contextModule.getFieldContext({ chainId: this.args.subset.chainId, address: s }, o));
      }
    }
    return t;
  }
  _getSubcontextsFromEnumReference(e) {
    const t = [];
    if (!e.valuePath) return t;
    const n = this.args.transactionParser.extractValue(this.args.subset, e.valuePath).orDefault([]);
    for (const i of n) {
      const s = i[i.length - 1];
      if (s === void 0) continue;
      const o = this.args.contextOptional.filter((a) => a.type === M.ENUM).find((a) => a.value === s && a.id === e.id);
      o && t.push(() => Promise.resolve(o));
    }
    return t;
  }
  _getSubcontextsFromTrustedNameReference(e) {
    const t = [];
    if (!e.valuePath) return t;
    const n = this.args.transactionParser.extractValue(this.args.subset, e.valuePath).orDefault([]);
    for (const i of n) t.push(async () => {
      const s = It(i.slice(Math.max(0, i.length - 20))), o = await this.api.sendCommand(new Yh());
      return We(o) ? await this.args.contextModule.getFieldContext({ chainId: this.args.subset.chainId, address: s, challenge: o.data.challenge, types: e.types, sources: e.sources, deviceModelId: this.args.deviceModelId }, M.TRUSTED_NAME) : { type: M.ERROR, error: new Error("Failed to get challenge") };
    });
    return t;
  }
  _getSubcontextFromProxy(e) {
    return [async () => {
      const t = await this.api.sendCommand(new Yh());
      return We(t) ? this.args.subset.to === void 0 ? { type: M.ERROR, error: new Error("Failed to get proxy address") } : await this.args.contextModule.getFieldContext({ chainId: this.args.subset.chainId, proxyAddress: this.args.subset.to, calldata: this.args.subset.data, deviceModelId: this.args.deviceModelId, challenge: t.data.challenge }, M.PROXY_INFO) : { type: M.ERROR, error: new Error("Failed to get challenge") };
    }];
  }
};
const Pce = 10;
let Nce = class {
  constructor(e) {
    this._args = e;
  }
  run() {
    var l;
    const { parser: e, subset: t, context: n } = this._args, i = [];
    if (!n.reference || n.reference.type !== Zr.CALLDATA || !n.reference.valuePath) throw new Error("Invalid reference for nested call data. Expected a reference with type CALLDATA and a value path.");
    const { valuePath: s } = n.reference, o = e.extractValue(t, s).unsafeCoerce(), a = e.extractValue(t, n.reference.callee).unsafeCoerce(), c = n.reference.selector ? e.extractValue(t, n.reference.selector).orDefault([]) : [], u = n.reference.chainId ? e.extractValue(t, n.reference.chainId).orDefault([]) : [];
    for (let d = 0; d < o.length; d++) {
      const f = o[d], p = u[d], y = (l = a[d]) == null ? void 0 : l.slice(Math.max(0, a[d].length - 20)), g = c[d], v = { data: f ? It(f) : "0x", chainId: p ? Number(p) : t.chainId, to: y ? It(y) : t.to, selector: g ? It(g) : f ? It(f).slice(0, Pce) : "0x" };
      i.push(v);
    }
    return { subsets: i };
  }
}, $4 = class R4 {
  constructor(e, t, n = (o, a) => new Rce(o, a), i = (o, a) => new $ce(o, a), s = (o) => new Nce(o)) {
    this._api = e, this._args = t, this._buildSubcontextsTaskFactory = n, this._buildBaseContextsTaskFactory = i, this._preBuildNestedCallDataTaskFactory = s;
  }
  async run() {
    var o;
    const { clearSignContexts: e, clearSigningType: t, clearSignContextsOptional: n } = await this._buildBaseContextsTaskFactory(this._api, this._args).run(), i = e.map((a) => {
      const { subcontextCallbacks: c } = this._buildSubcontextsTaskFactory(this._api, { context: a, contextOptional: n, contextModule: this._args.contextModule, subset: this._args.subset, transactionParser: this._args.parser, deviceModelId: this._args.deviceModelId }).run();
      return { context: a, subcontextCallbacks: c };
    }), s = [];
    for (const a of i) if (s.push(a), a.context.type === M.TRANSACTION_FIELD_DESCRIPTION && ((o = a.context.reference) == null ? void 0 : o.type) === Zr.CALLDATA) {
      const { subsets: c } = this._preBuildNestedCallDataTaskFactory({ parser: this._args.parser, subset: this._args.subset, context: a.context }).run();
      for (const u of c) {
        const { clearSignContexts: l } = await new R4(this._api, { ...this._args, transaction: void 0, subset: u }, this._buildSubcontextsTaskFactory, this._buildBaseContextsTaskFactory, this._preBuildNestedCallDataTaskFactory).run();
        s.push(...l);
      }
    }
    return { clearSignContexts: s, clearSigningType: t };
  }
}, Iy = class {
  constructor(e, t, n) {
    this.typeName = e, this.name = t, this.size = n;
  }
}, ql = class {
  constructor(e, t, n, i, s) {
    this.typeName = e, this.rootType = t, this.rowType = n, this.count = i, this.levels = s;
  }
}, dv = class {
  constructor(e) {
    this.typeName = e;
  }
}, P4 = class {
  constructor(e) {
    this.root = e;
  }
}, GA = class {
  constructor(e) {
    this.length = e;
  }
}, KC = class {
  constructor(e) {
    this.data = e;
  }
};
const Bce = "0x0000000000000000000000000000000000000000";
let Lce = class {
  constructor(e, t, n, i, s, o, a, c, u = (d, f) => new O4(d, f), l = (d, f) => new $4(d, f)) {
    this.api = e, this.contextModule = t, this.parser = n, this.transactionParser = i, this.transactionMapper = s, this.data = o, this.derivationPath = a, this.appConfig = c, this.getWeb3ChecksFactory = u, this.buildFullContextFactory = l;
  }
  async run() {
    var l;
    let e = null;
    this.appConfig.web3ChecksEnabled && (e = (await this.getWeb3ChecksFactory(this.api, { contextModule: this.contextModule, derivationPath: this.derivationPath, data: this.data }).run()).web3Check);
    const t = this.parser.parse(this.data);
    if (t.isLeft()) throw t.extract();
    const { types: n, domain: i, message: s } = t.unsafeCoerce(), o = this.api.getDeviceSessionState();
    let a = ve, c = {};
    const u = this.getClearSignVersion(o);
    if (u.isJust()) {
      let d;
      const f = await this.api.sendCommand(new Yh());
      We(f) && (d = f.data.challenge);
      const p = ((l = this.data.domain.verifyingContract) == null ? void 0 : l.toLowerCase()) || Bce, y = this.data.domain.chainId || 0, g = s.filter((_) => _.value instanceof KC).map((_) => ({ path: _.path, value: _.value.data })), v = await this.contextModule.getTypedDataFilters({ verifyingContract: p, chainId: y, version: u.extract(), schema: this.data.types, challenge: d, deviceModelId: o.deviceModelId, fieldsValues: g });
      v.type === "success" && (a = Le(v), c = await this.getCalldatasContexts(o, v));
    }
    return { derivationPath: this.derivationPath, web3Check: e, types: n, domain: i, message: s, clearSignContext: a, calldatasContexts: c, deviceModelId: o.deviceModelId };
  }
  getClearSignVersion(e) {
    return new Xp(e, this.appConfig).withMinVersionInclusive("1.10.0").excludeDeviceModel(je.NANO_S).check() ? new Xp(e, this.appConfig).withMinVersionInclusive("1.12.0").check() ? Le("v2") : Le("v1") : ve;
  }
  async getCalldatasContexts(e, t) {
    const n = {};
    for (const i in t.calldatas) {
      const { subset: s } = t.calldatas[i], o = await this.buildFullContextFactory(this.api, { contextModule: this.contextModule, mapper: this.transactionMapper, parser: this.transactionParser, options: {}, appConfig: this.appConfig, derivationPath: this.derivationPath, subset: s, deviceModelId: e.deviceModelId }).run();
      o.clearSigningType === Xh.EIP7730 && (n[i] = o.clearSignContexts);
    }
    return n;
  }
}, N4 = class {
  constructor(e) {
    h(this, "errorHelper", new Kt(qt, Wt));
    this.args = e;
  }
  getApdu() {
    const e = { cla: 224, ins: 42, p1: this.args.isFirstChunk ? 1 : 0, p2: 0 };
    return new ot(e).addBufferToData(this.args.data).build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefault(ye({ data: void 0 }));
  }
}, B4 = class {
  constructor(e) {
    h(this, "errorHelper", new Kt(qt, Wt));
    this.args = e;
  }
  getApdu() {
    const e = { cla: 224, ins: 10, p1: 0, p2: 0 };
    return new ot(e).addHexaStringToData(this.args.payload).build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefaultLazy(() => {
      const t = new kr(e).extract8BitUInt() ?? 0;
      return ye({ data: { tokenIndex: t } });
    });
  }
}, L4 = class {
  constructor(e) {
    h(this, "errorHelper", new Kt(qt, Wt));
    this.args = e;
  }
  getApdu() {
    const e = { cla: 224, ins: 34, p1: this.args.isFirstChunk ? 1 : 0, p2: 0 };
    return new ot(e).addBufferToData(this.args.data).build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefault(ye({ data: void 0 }));
  }
}, U4 = class {
  constructor(e) {
    h(this, "errorHelper", new Kt(qt, Wt));
    this.args = e;
  }
  getApdu() {
    const e = { cla: 224, ins: 50, p1: 0, p2: this.args.isFirstChunk ? 1 : 0 };
    return new ot(e).addBufferToData(this.args.payload).build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefault(ye({ data: void 0 }));
  }
};
var dn = ((r) => (r.Activation = "activation", r.DiscardedPath = "discarded_path", r.MessageInfo = "message_info", r.Datetime = "datetime", r.Raw = "raw", r.Amount = "amount", r.Token = "token", r.TrustedName = "trusted-name", r.CalldataInfo = "calldata-info", r.CalldataValue = "calldata-value", r.CalldataCallee = "calldata-callee", r.CalldataChainId = "calldata-chain-id", r.CalldataSelector = "calldata-selector", r.CalldataAmount = "calldata-amount", r.CalldataSpender = "calldata-spender", r))(dn || {}), Cy = ((r) => (r[r.None = 0] = "None", r[r.Present = 1] = "Present", r[r.VerifyingContract = 2] = "VerifyingContract", r))(Cy || {});
const Uce = { activation: 0, discarded_path: 1, message_info: 15, "calldata-spender": 244, "calldata-amount": 245, "calldata-selector": 246, "calldata-chain-id": 247, "calldata-callee": 248, "calldata-value": 249, "calldata-info": 250, "trusted-name": 251, datetime: 252, token: 253, amount: 254, raw: 255 };
let wn = class {
  constructor(e) {
    h(this, "errorHelper", new Kt(qt, Wt));
    this.args = e;
  }
  getApdu() {
    const e = { cla: 224, ins: 30, p1: "discarded" in this.args && this.args.discarded ? 1 : 0, p2: Uce[this.args.type] }, t = new ot(e);
    switch (this.args.type) {
      case "message_info":
        t.encodeInLVFromAscii(this.args.displayName).add8BitUIntToData(this.args.filtersCount).encodeInLVFromHexa(this.args.signature);
        break;
      case "discarded_path":
        t.encodeInLVFromAscii(this.args.path);
        break;
      case "datetime":
      case "raw":
        t.encodeInLVFromAscii(this.args.displayName).encodeInLVFromHexa(this.args.signature);
        break;
      case "trusted-name":
        t.encodeInLVFromAscii(this.args.displayName).addHexaStringToData(this.args.typesAndSourcesPayload).encodeInLVFromHexa(this.args.signature);
        break;
      case "token":
      case "amount":
        this.args.type === "amount" && t.encodeInLVFromAscii(this.args.displayName), t.add8BitUIntToData(this.args.tokenIndex).encodeInLVFromHexa(this.args.signature);
        break;
      case "calldata-info":
        t.add8BitUIntToData(this.args.calldataIndex).add8BitUIntToData(this.args.valueFlag ? 1 : 0).add8BitUIntToData(this.args.calleeFlag).add8BitUIntToData(this.args.chainIdFlag ? 1 : 0).add8BitUIntToData(this.args.selectorFlag ? 1 : 0).add8BitUIntToData(this.args.amountFlag ? 1 : 0).add8BitUIntToData(this.args.spenderFlag).encodeInLVFromHexa(this.args.signature);
        break;
      case "calldata-value":
      case "calldata-callee":
      case "calldata-chain-id":
      case "calldata-selector":
      case "calldata-amount":
      case "calldata-spender":
        t.add8BitUIntToData(this.args.calldataIndex).encodeInLVFromHexa(this.args.signature);
        break;
    }
    return t.build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefault(ye({ data: void 0 }));
  }
};
var KA = ((r) => (r[r.Name = 0] = "Name", r[r.Field = 255] = "Field", r))(KA || {});
let VP = class {
  constructor(e) {
    h(this, "errorHelper", new Kt(qt, Wt));
    this.args = e;
  }
  getApdu() {
    const e = { cla: 224, ins: 26, p1: 0, p2: this.args.command };
    if (this.args.command === 0) return new ot(e).addAsciiStringToData(this.args.name).build();
    const t = new ot(e), n = this.constructTypeDescByte(this.args.type);
    if (t.add8BitUIntToData(n), this.getTypeCustomName(this.args.type).ifJust((i) => {
      t.encodeInLVFromAscii(i);
    }), this.getTypeSize(this.args.type).ifJust((i) => {
      t.add8BitUIntToData(i);
    }), this.args.type instanceof ql) {
      t.add8BitUIntToData(this.args.type.levels.length);
      for (const i of this.args.type.levels) i.caseOf({ Just: (s) => {
        t.add8BitUIntToData(1).add8BitUIntToData(s);
      }, Nothing: () => {
        t.add8BitUIntToData(0);
      } });
    }
    return t.encodeInLVFromAscii(this.args.name).build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefault(ye({ data: void 0 }));
  }
  constructTypeDescByte(e) {
    const t = e instanceof ql ? 1 : 0, n = this.getTypeSize(e).isJust() ? 1 : 0, i = this.getType(e);
    return t << 7 | n << 6 | i;
  }
  getTypeSize(e) {
    return e instanceof ql ? this.getTypeSize(e.rootType) : e instanceof Iy ? e.size : ve;
  }
  getTypeCustomName(e) {
    return e instanceof ql ? this.getTypeCustomName(e.rootType) : e instanceof dv ? Le(e.typeName) : ve;
  }
  getType(e) {
    if (e instanceof ql) return this.getType(e.rootType);
    if (e instanceof dv) return 0;
    switch (e.name) {
      case "int":
        return 1;
      case "uint":
        return 2;
      case "address":
        return 3;
      case "bool":
        return 4;
      case "string":
        return 5;
      case "bytes":
        return e.size.isJust() ? 6 : 7;
    }
  }
};
var Sd = ((r) => (r[r.ROOT = 0] = "ROOT", r[r.ARRAY = 15] = "ARRAY", r[r.FIELD = 255] = "FIELD", r))(Sd || {});
let zP = class {
  constructor(e) {
    h(this, "errorHelper", new Kt(qt, Wt));
    this.args = e;
  }
  getApdu() {
    const e = { cla: 224, ins: 28, p1: this.args.type != 255 || this.args.value.isLastChunk ? 0 : 1, p2: this.args.type };
    switch (this.args.type) {
      case 0:
        return new ot(e).addAsciiStringToData(this.args.value).build();
      case 15:
        return new ot(e).add8BitUIntToData(this.args.value).build();
      case 255:
        return new ot(e).addBufferToData(this.args.value.data).build();
    }
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefault(ye({ data: void 0 }));
  }
}, B_ = class {
  constructor(e, t) {
    this.api = e, this.args = t;
  }
  async run() {
    if (this.args.type !== Sd.FIELD) return await this.api.sendCommand(new zP(this.args));
    let e = ye({ data: void 0 });
    const t = new Ds(this.args.value.length + 2).add16BitUIntToData(this.args.value.length).addBufferToData(this.args.value).build();
    for (let n = 0; n < t.length; n += Is) if (e = await this.api.sendCommand(new zP({ type: Sd.FIELD, value: { data: t.slice(n, n + Is), isLastChunk: n >= t.length - Is } })), !We(e)) return e;
    return e;
  }
}, Fce = class {
  constructor(e) {
    h(this, "errorHelper", new Kt(qt, Wt));
    this.args = e;
  }
  getApdu() {
    const { serializedTransaction: e, isFirstChunk: t } = this.args, n = { cla: 224, ins: 4, p1: t ? 0 : 128, p2: 1 };
    return new ot(n).addBufferToData(e).build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefault(ye({ data: void 0 }));
  }
}, Mce = class {
  constructor(e) {
    h(this, "errorHelper", new Kt(qt, Wt));
    this.args = e;
  }
  getApdu() {
    const e = { cla: 224, ins: 36, p1: this.args.isFirstChunk ? 1 : 0, p2: 0 };
    return new ot(e).addBufferToData(this.args.data).build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefault(ye({ data: void 0 }));
  }
};
var qA = ((r) => (r[r.CONFIGURATION = 0] = "CONFIGURATION", r[r.ICON = 1] = "ICON", r))(qA || {});
let jP = class {
  constructor(e) {
    h(this, "errorHelper", new Kt(qt, Wt));
    this.args = e;
  }
  getApdu() {
    const e = { cla: 224, ins: 48, p1: this.args.isFirstChunk ? 1 : 0, p2: this.args.configurationType };
    return new ot(e).addBufferToData(this.args.data).build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefault(ye({ data: void 0 }));
  }
}, Vce = class {
  constructor(e) {
    h(this, "errorHelper", new Kt(qt, Wt));
    this.args = e;
  }
  getApdu() {
    const e = { cla: 224, ins: 20, p1: 0, p2: 0 };
    return new ot(e).addHexaStringToData(this.args.payload).build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefault(ye({ data: void 0 }));
  }
};
var WA = ((r) => (r[r.SAFE_DESCRIPTOR = 0] = "SAFE_DESCRIPTOR", r[r.SIGNER_DESCRIPTOR = 1] = "SIGNER_DESCRIPTOR", r))(WA || {});
let HP = class {
  constructor(e) {
    h(this, "errorHelper", new Kt(qt, Wt));
    this.args = e;
  }
  getApdu() {
    const e = { cla: 224, ins: 54, p1: this.args.isFirstChunk ? 1 : 0, p2: this.args.type };
    return new ot(e).addBufferToData(this.args.data).build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefault(ye({ data: void 0 }));
  }
}, zce = class {
  constructor(e) {
    h(this, "errorHelper", new Kt(qt, Wt));
    this.args = e;
  }
  getApdu() {
    const e = { cla: 224, ins: 40, p1: this.args.isFirstChunk ? 1 : 0, p2: 0 };
    return new ot(e).addBufferToData(this.args.data).build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefault(ye({ data: void 0 }));
  }
}, jce = class {
  constructor(e) {
    h(this, "errorHelper", new Kt(qt, Wt));
    this.args = e;
  }
  getApdu() {
    const e = { cla: 224, ins: 38, p1: this.args.isFirstChunk ? 1 : 0, p2: 0 };
    return new ot(e).addBufferToData(this.args.data).build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefault(ye({ data: void 0 }));
  }
}, Hce = class {
  constructor(e) {
    h(this, "errorHelper", new Kt(qt, Wt));
    this.args = e;
  }
  getApdu() {
    const e = { cla: 224, ins: 18, p1: 0, p2: 0 };
    return new ot(e).addHexaStringToData(this.args.payload).addHexaStringToData(this.args.signature ?? "").build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefault(ye({ data: void 0 }));
  }
}, Gce = class {
  constructor(e) {
    h(this, "errorHelper", new Kt(qt, Wt));
    this.args = e;
  }
  getApdu() {
    const e = { cla: 224, ins: 22, p1: 0, p2: 0 };
    return new ot(e).addHexaStringToData(this.args.payload).build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefault(ye({ data: void 0 }));
  }
};
var cS;
let Kce = (cS = class {
  static getBufferFromPayload(e) {
    const t = _r(e);
    return t === null || t.length === 0 ? null : new Ds(t.length + this.PAYLOAD_LENGTH_BYTES).add16BitUIntToData(t.length).addBufferToData(t).build();
  }
}, h(cS, "PAYLOAD_LENGTH_BYTES", 2), cS), C0 = class {
  constructor(e, t) {
    this.api = e, this.args = t;
  }
  async run() {
    const { data: e, commandFactory: t } = this.args, n = new Ds(e.length).addBufferToData(e).build();
    for (let i = 0; i < n.length; i += Is) {
      const s = i + Is >= n.length, o = await this.api.sendCommand(t({ chunkedData: n.slice(i, i + Is), isFirstChunk: i === 0 }));
      if (!We(o)) return o;
      if (s) return ye({ data: o.data });
    }
    throw new ht("No result");
  }
}, Dy = class {
  constructor(e, t) {
    this.api = e, this.args = t;
  }
  async run() {
    const { payload: e, withPayloadLength: t = !0 } = this.args;
    let n = null;
    return t ? n = Kce.getBufferFromPayload(e) : n = _r(e), n ? new C0(this.api, { data: n, commandFactory: this.args.commandFactory }).run() : ye({ error: new ht("Invalid payload") });
  }
};
class F4 {
  constructor(e, t, n = (i, s) => new Dy(i, s)) {
    this._api = e, this._args = t, this._sendPayloadInChunksTaskFactory = n;
  }
  async run() {
    const { type: e, payload: t, certificate: n } = this._args.context;
    switch (n && await this._api.sendCommand(new uS({ keyUsage: n.keyUsageNumber, certificate: n.payload })), e) {
      case M.PLUGIN:
        return await this._api.sendCommand(new Gce({ payload: t }));
      case M.EXTERNAL_PLUGIN:
        return await this._api.sendCommand(new Hce({ payload: t }));
      case M.NFT:
        return await this._api.sendCommand(new Vce({ payload: t }));
      case M.TOKEN:
        return await this._api.sendCommand(new B4({ payload: t }));
      case M.TRANSACTION_INFO:
        return await this._sendPayloadInChunksTaskFactory(this._api, { payload: t, commandFactory: (i) => new jce({ data: i.chunkedData, isFirstChunk: i.isFirstChunk }) }).run();
      case M.TRUSTED_NAME:
        return this._sendPayloadInChunksTaskFactory(this._api, { payload: t, commandFactory: (i) => new L4({ data: i.chunkedData, isFirstChunk: i.isFirstChunk }) }).run();
      case M.ENUM:
        return this._sendPayloadInChunksTaskFactory(this._api, { payload: t, commandFactory: (i) => new Mce({ data: i.chunkedData, isFirstChunk: i.isFirstChunk }) }).run();
      case M.TRANSACTION_FIELD_DESCRIPTION:
        return this._sendPayloadInChunksTaskFactory(this._api, { payload: t, commandFactory: (i) => new zce({ data: i.chunkedData, isFirstChunk: i.isFirstChunk }) }).run();
      case M.WEB3_CHECK:
        return this._sendPayloadInChunksTaskFactory(this._api, { payload: t, commandFactory: (i) => new U4({ payload: i.chunkedData, isFirstChunk: i.isFirstChunk }) }).run();
      case M.PROXY_INFO:
        return this._sendPayloadInChunksTaskFactory(this._api, { payload: t, commandFactory: (i) => new N4({ data: i.chunkedData, isFirstChunk: i.isFirstChunk }) }).run();
      case M.DYNAMIC_NETWORK:
        return this._sendPayloadInChunksTaskFactory(this._api, { payload: t, commandFactory: (i) => new jP({ data: i.chunkedData, isFirstChunk: i.isFirstChunk, configurationType: qA.CONFIGURATION }) }).run();
      case M.DYNAMIC_NETWORK_ICON:
        return this._sendPayloadInChunksTaskFactory(this._api, { payload: t, commandFactory: (i) => new jP({ data: i.chunkedData, isFirstChunk: i.isFirstChunk, configurationType: qA.ICON }), withPayloadLength: !1 }).run();
      case M.SAFE:
        return this._sendPayloadInChunksTaskFactory(this._api, { payload: t, commandFactory: (i) => new HP({ data: i.chunkedData, isFirstChunk: i.isFirstChunk, type: WA.SAFE_DESCRIPTOR }) }).run();
      case M.SIGNER:
        return this._sendPayloadInChunksTaskFactory(this._api, { payload: t, commandFactory: (i) => new HP({ data: i.chunkedData, isFirstChunk: i.isFirstChunk, type: WA.SIGNER_DESCRIPTOR }) }).run();
      default: {
        const i = e;
        return ye({ error: new ht(`The context type [${i}] is not covered`) });
      }
    }
  }
}
let M4 = class {
  constructor(e, t, n = (s, o) => new F4(s, o), i = (s, o) => new C0(s, o)) {
    this._api = e, this._args = t, this._provideContextTaskFactory = n, this._sendCommandInChunksTaskFactory = i;
  }
  async run() {
    let e = !1;
    for (const { context: t, subcontextCallbacks: n } of this._args.contexts) {
      for (const s of n) {
        const o = await s();
        o.type !== M.ERROR && await this._provideContextTaskFactory(this._api, { context: o }).run();
      }
      if (t.type === M.PROXY_INFO) continue;
      if (!e && this._args.serializedTransaction !== void 0 && t.type === M.TRANSACTION_INFO) {
        e = !0;
        const s = _f.splitPath(this._args.derivationPath), o = new Ds();
        o.add8BitUIntToData(s.length), s.forEach((a) => {
          o.add32BitUIntToData(a);
        }), o.addBufferToData(this._args.serializedTransaction), await this._sendCommandInChunksTaskFactory(this._api, { data: o.build(), commandFactory: (a) => new Fce({ serializedTransaction: a.chunkedData, isFirstChunk: a.isFirstChunk }) }).run();
      }
      const i = await this._provideContextTaskFactory(this._api, { context: t }).run();
      if (!We(i)) return N(i);
    }
    return te(void 0);
  }
};
const GP = 5;
class qce {
  constructor(e, t, n, i = (s) => new M4(this.api, s)) {
    h(this, "chainId", ve);
    h(this, "calldataMetadatas", {});
    this.api = e, this.contextModule = t, this.args = n, this.provideContextFactory = i;
    for (const s of this.args.domain) if (s.path === "chainId" && s.value instanceof KC) {
      const o = BigInt(It(s.value.data));
      o <= Number.MAX_SAFE_INTEGER && (this.chainId = Le(Number(o)));
      break;
    }
  }
  async run() {
    this.args.web3Check && await this.provideContext(this.args.web3Check), await this.args.clearSignContext.ifJust(async (i) => {
      i.proxy !== void 0 && await this.provideContext(i.proxy);
    });
    const e = ye({ data: void 0 }), t = Object.entries(this.args.types).sort(([i], [s]) => i.localeCompare(s));
    for (const [i, s] of t) {
      const o = await this.api.sendCommand(new VP({ command: KA.Name, name: i }));
      if (!We(o)) return o;
      for (const [a, c] of Object.entries(s)) {
        const u = await this.api.sendCommand(new VP({ command: KA.Field, name: a, type: c }));
        if (!We(u)) return u;
      }
    }
    if (this.args.clearSignContext.isJust()) {
      const i = await this.api.sendCommand(new wn({ type: dn.Activation }));
      if (!We(i)) return i;
    }
    for (const i of this.args.domain) {
      const s = await this.getImplementationTask(i).run();
      if (!We(s)) return s;
    }
    if (this.args.clearSignContext.isJust()) {
      const i = this.args.clearSignContext.extract(), s = await this.api.sendCommand(new wn({ type: dn.MessageInfo, displayName: i.messageInfo.displayName, filtersCount: i.messageInfo.filtersCount, signature: i.messageInfo.signature }));
      if (!We(s)) return s;
    }
    const n = { indexes: {}, nextIndex: 0 };
    for (const i of this.args.message) {
      const s = await this.provideTokenInformation(i, n);
      if (s.isJust()) return s.extract();
      const o = await this.provideTrustedName(i);
      if (o.isJust()) return o.extract();
      const a = await this.filterValue(i, n);
      if (a.isJust() && !We(a.extract())) return a.extract();
      const c = await this.getImplementationTask(i).run();
      if (!We(c)) return c;
      if (await this.tryProvideTransactionContext(), this.args.clearSignContext.isJust() && i.value instanceof GA && i.value.length === 0) {
        const u = Object.entries(this.args.clearSignContext.extract().filters).filter(([l]) => l.startsWith(`${i.path}.[]`)).map(([, l]) => l);
        for (const l of u) {
          const d = await this.api.sendCommand(new wn({ type: dn.DiscardedPath, path: l.path }));
          if (!We(d)) return d;
          const f = await this.provideFiltering(l, n, !0);
          if (!We(f)) return f;
        }
      }
    }
    return e;
  }
  async provideContext({ type: e, payload: t, certificate: n }) {
    switch (n && await this.api.sendCommand(new uS({ keyUsage: n.keyUsageNumber, certificate: n.payload })), e) {
      case M.WEB3_CHECK:
        await new Dy(this.api, { payload: t, commandFactory: (i) => new U4({ payload: i.chunkedData, isFirstChunk: i.isFirstChunk }) }).run();
        break;
      case M.PROXY_INFO:
        await new Dy(this.api, { payload: t, commandFactory: (i) => new N4({ data: i.chunkedData, isFirstChunk: i.isFirstChunk }) }).run();
        break;
      case M.TOKEN:
      case M.NFT:
      case M.TRUSTED_NAME:
      case M.PLUGIN:
      case M.EXTERNAL_PLUGIN:
      case M.ENUM:
      case M.TRANSACTION_INFO:
      case M.TRANSACTION_FIELD_DESCRIPTION:
      case M.DYNAMIC_NETWORK:
      case M.DYNAMIC_NETWORK_ICON:
      case M.SAFE:
      case M.SIGNER:
        throw new Error(`Context type ${e} not supported in EIP712 messages`);
      default: {
        const i = e;
        throw new Error(`Unhandled context type ${i}`);
      }
    }
  }
  getImplementationTask(e) {
    return e.value instanceof P4 ? new B_(this.api, { type: Sd.ROOT, value: e.value.root }) : e.value instanceof GA ? new B_(this.api, { type: Sd.ARRAY, value: e.value.length }) : new B_(this.api, { type: Sd.FIELD, value: e.value.data });
  }
  async provideTokenInformation(e, t) {
    if (this.args.clearSignContext.isJust()) {
      const n = this.args.clearSignContext.extract().filters[e.path];
      if (n !== void 0 && (n.type === "amount" || n.type === "token") && t.indexes[n.tokenIndex] === void 0) {
        const i = n.tokenIndex, s = this.args.clearSignContext.extract().tokens[i];
        if (s === void 0) return ve;
        const o = await this.api.sendCommand(new B4({ payload: s }));
        if (!We(o)) return pe.of(o);
        let { tokenIndex: a } = o.data;
        t.nextIndex = (a + 1) % GP, Number(i) === BA && (a = BA), t.indexes[Number(i)] = a;
      }
    }
    return ve;
  }
  async provideTrustedName(e) {
    if (this.args.clearSignContext.isJust() && this.chainId.isJust()) {
      const t = this.args.clearSignContext.extract(), n = t.filters[e.path], i = t.trustedNamesAddresses[e.path];
      if (n !== void 0 && n.type === "trusted-name" && i !== void 0) {
        const s = await this.api.sendCommand(new Yh());
        if (!We(s)) return Le(s);
        const o = await this.contextModule.getFieldContext({ chainId: this.chainId.extract(), address: i, challenge: s.data.challenge, types: n.types, sources: n.sources, deviceModelId: this.args.deviceModelId }, M.TRUSTED_NAME);
        if (o.type === M.TRUSTED_NAME) {
          o.certificate && await this.api.sendCommand(new uS({ keyUsage: o.certificate.keyUsageNumber, certificate: o.certificate.payload }));
          const a = await new Dy(this.api, { payload: o.payload, commandFactory: (c) => new L4({ data: c.chunkedData, isFirstChunk: c.isFirstChunk }) }).run();
          if (!We(a)) return Le(a);
        }
      }
    }
    return ve;
  }
  async filterValue(e, t) {
    if (this.args.clearSignContext.isJust()) {
      const n = this.args.clearSignContext.extract().filters[e.path];
      if (n === void 0) return ve;
      const i = await this.provideFiltering(n, t, !1);
      return pe.of(i);
    }
    return ve;
  }
  async provideFiltering(e, t, n) {
    switch (e.type) {
      case "trusted-name":
        return await this.api.sendCommand(new wn({ type: dn.TrustedName, discarded: n, displayName: e.displayName, typesAndSourcesPayload: e.typesAndSourcesPayload, signature: e.signature }));
      case "datetime":
        return await this.api.sendCommand(new wn({ type: dn.Datetime, discarded: n, displayName: e.displayName, signature: e.signature }));
      case "raw":
        return await this.api.sendCommand(new wn({ type: dn.Raw, discarded: n, displayName: e.displayName, signature: e.signature }));
      case "token":
        return this.sanitizeDeviceIndex(e.tokenIndex, t), await this.api.sendCommand(new wn({ type: dn.Token, discarded: n, tokenIndex: t.indexes[e.tokenIndex], signature: e.signature }));
      case "amount":
        return this.sanitizeDeviceIndex(e.tokenIndex, t), await this.api.sendCommand(new wn({ type: dn.Amount, discarded: n, displayName: e.displayName, tokenIndex: t.indexes[e.tokenIndex], signature: e.signature }));
      case "calldata-value":
        return await this.provideCalldataInfos(e.calldataIndex), await this.api.sendCommand(new wn({ type: dn.CalldataValue, discarded: n, calldataIndex: e.calldataIndex, signature: e.signature }));
      case "calldata-callee":
        return await this.provideCalldataInfos(e.calldataIndex), await this.api.sendCommand(new wn({ type: dn.CalldataCallee, discarded: n, calldataIndex: e.calldataIndex, signature: e.signature }));
      case "calldata-spender":
        return await this.provideCalldataInfos(e.calldataIndex), await this.api.sendCommand(new wn({ type: dn.CalldataSpender, discarded: n, calldataIndex: e.calldataIndex, signature: e.signature }));
      case "calldata-chain-id":
        return await this.provideCalldataInfos(e.calldataIndex), await this.api.sendCommand(new wn({ type: dn.CalldataChainId, discarded: n, calldataIndex: e.calldataIndex, signature: e.signature }));
      case "calldata-selector":
        return await this.provideCalldataInfos(e.calldataIndex), await this.api.sendCommand(new wn({ type: dn.CalldataSelector, discarded: n, calldataIndex: e.calldataIndex, signature: e.signature }));
      case "calldata-amount":
        return await this.provideCalldataInfos(e.calldataIndex), await this.api.sendCommand(new wn({ type: dn.CalldataAmount, discarded: n, calldataIndex: e.calldataIndex, signature: e.signature }));
      default: {
        const i = e;
        throw new Error(`ProvideEIP712ContextTask/provideFiltering - Unhandled filter ${i}`);
      }
    }
  }
  async provideCalldataInfos(e) {
    if (this.args.clearSignContext.isJust()) {
      if (this.calldataMetadatas[e] !== void 0) return this.calldataMetadatas[e].remainingFilters--, ve;
      const t = this.args.clearSignContext.extract().calldatas[e];
      if (t === void 0) return ve;
      const n = [t.filter.valueFlag, t.filter.calleeFlag === oo.Present, t.filter.chainIdFlag, t.filter.selectorFlag, t.filter.amountFlag, t.filter.spenderFlag === oo.Present].filter((i) => i).length;
      return this.calldataMetadatas[e] = { remainingFilters: n - 1, contexts: this.args.calldatasContexts[e] }, pe.of(await this.api.sendCommand(new wn({ type: dn.CalldataInfo, discarded: !1, calldataIndex: e, valueFlag: t.filter.valueFlag, calleeFlag: this.mapCalldataPresence(t.filter.calleeFlag), chainIdFlag: t.filter.chainIdFlag, selectorFlag: t.filter.selectorFlag, amountFlag: t.filter.amountFlag, spenderFlag: this.mapCalldataPresence(t.filter.spenderFlag), signature: t.filter.signature })));
    }
    return ve;
  }
  async tryProvideTransactionContext() {
    for (const e in this.calldataMetadatas) {
      const t = this.calldataMetadatas[e];
      t.remainingFilters === 0 && (t.contexts !== void 0 && await this.provideContextFactory({ contexts: t.contexts, derivationPath: this.args.derivationPath }).run(), delete this.calldataMetadatas[e]);
    }
  }
  mapCalldataPresence(e) {
    switch (e) {
      case oo.None:
        return Cy.None;
      case oo.Present:
        return Cy.Present;
      case oo.VerifyingContract:
        return Cy.VerifyingContract;
      default: {
        const t = e;
        throw new Error(`Unhandled presence ${t}`);
      }
    }
  }
  sanitizeDeviceIndex(e, t) {
    t.indexes[e] === void 0 && (t.indexes[e] = t.nextIndex, t.nextIndex = (t.nextIndex + 1) % GP);
  }
}
let Wce = class {
  constructor(e, t, n) {
    this.api = e, this.data = t, this.derivationPath = n;
  }
  async run() {
    const e = uv.hashDomain(this.data.domain);
    if (!this.data.types[this.data.primaryType]) throw new Error(`Primary type "${this.data.primaryType}" is not defined in the types.`);
    const t = this.data.types, { EIP712Domain: n, ...i } = t, s = uv.hashStruct(this.data.primaryType, i, this.data.message);
    return await this.api.sendCommand(new D4({ derivationPath: this.derivationPath, legacyArgs: Le({ domainHash: e, messageHash: s }) }));
  }
}, Zce = class extends Qi {
  makeStateMachine(e) {
    const { getAppConfig: t, web3CheckOptIn: n, buildContext: i, provideContext: s, signTypedData: o, signTypedDataLegacy: a } = this.extractDependencies(e);
    return Or({ actors: { openAppStateMachine: new uf({ input: { appName: "Ethereum" } }).makeStateMachine(e), getAppConfig: tt(t), web3CheckOptIn: tt(n), buildContext: tt(i), provideContext: tt(s), signTypedData: tt(o), signTypedDataLegacy: tt(a) }, guards: { noInternalError: ({ context: c }) => c._internalState.error === null, notRefusedByUser: ({ context: c }) => c._internalState.error !== null && (!("errorCode" in c._internalState.error) || c._internalState.error.errorCode !== "6985"), isWeb3ChecksSupported: ({ context: c }) => new Xp(e.getDeviceSessionState(), c._internalState.appConfig).withMinVersionExclusive("1.15.0").excludeDeviceModel(je.NANO_S).excludeDeviceModel(je.NANO_SP).excludeDeviceModel(je.NANO_X).check(), shouldOptIn: ({ context: c }) => !c._internalState.appConfig.web3ChecksEnabled && !c._internalState.appConfig.web3ChecksOptIn, skipOpenApp: ({ context: c }) => c.input.skipOpenApp }, actions: { assignErrorFromEvent: Q({ _internalState: (c) => ({ ...c.context._internalState, error: c.event.error }) }) } }).createMachine({ id: "SignTypedDataDeviceAction", initial: "InitialState", context: ({ input: c }) => ({ input: c, intermediateValue: { requiredUserInteraction: $e.None, step: js.OPEN_APP }, _internalState: { error: null, appConfig: null, typedDataContext: null, signature: null } }), states: { InitialState: { always: [{ target: "GetAppConfig", guard: "skipOpenApp" }, "OpenAppDeviceAction"] }, OpenAppDeviceAction: { invoke: { id: "openAppStateMachine", input: { appName: "Ethereum" }, src: "openAppStateMachine", onSnapshot: { actions: Q({ intermediateValue: (c) => ({ ...c.event.snapshot.context.intermediateValue, step: js.OPEN_APP }) }) }, onDone: { actions: Q({ _internalState: (c) => c.event.output.caseOf({ Right: () => c.context._internalState, Left: (u) => ({ ...c.context._internalState, error: u }) }) }), target: "CheckOpenAppDeviceActionResult" } } }, CheckOpenAppDeviceActionResult: { always: [{ target: "GetAppConfig", guard: "noInternalError" }, "Error"] }, GetAppConfig: { entry: Q({ intermediateValue: { requiredUserInteraction: $e.None, step: js.GET_APP_CONFIG } }), invoke: { id: "getAppConfig", src: "getAppConfig", onDone: { target: "GetAppConfigResultCheck", actions: [Q({ _internalState: ({ event: c, context: u }) => We(c.output) ? { ...u._internalState, appConfig: c.output.data } : { ...u._internalState, error: c.output.error } })] }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, GetAppConfigResultCheck: { always: [{ target: "Web3ChecksOptIn", guard: rL(["noInternalError", "isWeb3ChecksSupported", "shouldOptIn"]) }, { target: "BuildContext", guard: "noInternalError" }, { target: "Error" }] }, Web3ChecksOptIn: { entry: Q({ intermediateValue: { requiredUserInteraction: $e.Web3ChecksOptIn, step: js.WEB3_CHECKS_OPT_IN } }), invoke: { id: "web3CheckOptIn", src: "web3CheckOptIn", onDone: { target: "Web3ChecksOptInResult", actions: [Q({ _internalState: ({ event: c, context: u }) => We(c.output) ? { ...u._internalState, appConfig: { ...u._internalState.appConfig, web3ChecksEnabled: c.output.data.enabled } } : u._internalState })] }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, Web3ChecksOptInResult: { entry: Q(({ context: c }) => ({ intermediateValue: { requiredUserInteraction: $e.None, step: js.WEB3_CHECKS_OPT_IN_RESULT, result: c._internalState.appConfig.web3ChecksEnabled } })), after: { 0: { target: "BuildContext" } } }, BuildContext: { entry: Q({ intermediateValue: { requiredUserInteraction: $e.None, step: js.BUILD_CONTEXT } }), invoke: { id: "buildContext", src: "buildContext", input: ({ context: c }) => ({ contextModule: c.input.contextModule, parser: c.input.parser, transactionParser: c.input.transactionParser, transactionMapper: c.input.transactionMapper, data: c.input.data, appConfig: c._internalState.appConfig, derivationPath: c.input.derivationPath }), onDone: { target: "ProvideContext", actions: [Q({ _internalState: ({ event: c, context: u }) => ({ ...u._internalState, typedDataContext: c.output }) })] }, onError: { target: "SignTypedDataLegacy" } } }, ProvideContext: { entry: Q({ intermediateValue: { requiredUserInteraction: $e.SignTypedData, step: js.PROVIDE_CONTEXT } }), invoke: { id: "provideContext", src: "provideContext", input: ({ context: c }) => ({ contextModule: c.input.contextModule, taskArgs: c._internalState.typedDataContext }), onDone: { actions: Q({ _internalState: (c) => We(c.event.output) ? c.context._internalState : { ...c.context._internalState, error: c.event.output.error } }), target: "ProvideContextResultCheck" }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, ProvideContextResultCheck: { always: [{ guard: "noInternalError", target: "SignTypedData" }, { guard: "notRefusedByUser", target: "SignTypedDataLegacy" }, { target: "Error" }] }, SignTypedData: { entry: Q({ intermediateValue: { requiredUserInteraction: $e.SignTypedData, step: js.SIGN_TYPED_DATA } }), invoke: { id: "signTypedData", src: "signTypedData", input: ({ context: c }) => ({ derivationPath: c.input.derivationPath }), onDone: { target: "SignTypedDataResultCheck", actions: [Q({ _internalState: ({ event: c, context: u }) => We(c.output) ? { ...u._internalState, signature: c.output.data } : { ...u._internalState, error: c.output.error } })] }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, SignTypedDataLegacy: { entry: Q({ intermediateValue: { requiredUserInteraction: $e.SignTypedData, step: js.SIGN_TYPED_DATA_LEGACY } }), invoke: { id: "signTypedDataLegacy", src: "signTypedDataLegacy", input: ({ context: c }) => ({ derivationPath: c.input.derivationPath, data: c.input.data }), onDone: { target: "SignTypedDataResultCheck", actions: [Q({ _internalState: ({ event: c, context: u }) => We(c.output) ? { ...u._internalState, signature: c.output.data } : { ...u._internalState, error: c.output.error } })] }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, SignTypedDataResultCheck: { always: [{ guard: "noInternalError", target: "Success" }, { target: "Error" }] }, Success: { type: "final" }, Error: { type: "final" } }, output: ({ context: c }) => c._internalState.signature ? te(c._internalState.signature) : N(c._internalState.error || new fo("No error in final state")) });
  }
  extractDependencies(e) {
    return { getAppConfig: async () => e.sendCommand(new C4()), web3CheckOptIn: async () => e.sendCommand(new T4()), buildContext: async (t) => new Lce(e, t.input.contextModule, t.input.parser, t.input.transactionParser, t.input.transactionMapper, t.input.data, t.input.derivationPath, t.input.appConfig).run(), provideContext: async (t) => new qce(e, t.input.contextModule, t.input.taskArgs).run(), signTypedData: async (t) => e.sendCommand(new D4({ derivationPath: t.input.derivationPath, legacyArgs: ve })), signTypedDataLegacy: async (t) => new Wce(e, t.input.data, t.input.derivationPath).run() };
  }
};
const Jce = 32, Xce = 32;
let Yce = class {
  constructor(e) {
    h(this, "args");
    h(this, "errorHelper", new Kt(qt, Wt));
    this.args = e;
  }
  getApdu() {
    const { data: e, isFirstChunk: t } = this.args, n = { cla: 224, ins: 8, p1: t ? 0 : 128, p2: 0 };
    return new ot(n).addBufferToData(e).build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefaultLazy(() => {
      const t = new kr(e), n = t.extract8BitUInt();
      if (n === void 0) return ye({ data: ve });
      const i = t.encodeToHexaString(t.extractFieldByLength(Jce), !0);
      if (!i) return ye({ error: new ht("R is missing") });
      const s = t.encodeToHexaString(t.extractFieldByLength(Xce), !0);
      return ye(s ? { data: Le({ r: i, s, v: n }) } : { error: new ht("S is missing") });
    });
  }
};
const Qce = 4;
class eue {
  constructor(e, t) {
    this.api = e, this.args = t;
  }
  async run() {
    const { derivationPath: e, message: t } = this.args, n = _f.splitPath(e), i = new Ds(t.length + 1 + (n.length + 1) * Qce);
    i.add8BitUIntToData(n.length), n.forEach((a) => {
      i.add32BitUIntToData(a);
    }), i.add32BitUIntToData(t.length), typeof t == "string" ? i.addAsciiStringToData(t) : i.addBufferToData(t);
    const s = i.build(), o = await new C0(this.api, { data: s, commandFactory: (a) => new Yce({ data: a.chunkedData, isFirstChunk: a.isFirstChunk }) }).run();
    return We(o) ? o.data.mapOrDefault((a) => ye({ data: a }), ye({ error: new ht("no signature returned") })) : o;
  }
}
const Ed = { Dmk: Symbol.for("Dmk"), SessionId: Symbol.for("SessionId"), ContextModule: Symbol.for("ContextModule") }, xd = { SignTransactionUseCase: Symbol.for("SignTransactionUseCase"), TransactionParserService: Symbol.for("TransactionParserService"), TransactionMapperService: Symbol.for("TransactionMapperService") };
let tue = class {
  constructor(e) {
    this._args = e;
  }
  run() {
    const { mapper: e, transaction: t } = this._args, { subset: n, type: i } = e.mapTransactionToSubset(t).unsafeCoerce();
    return { subset: n, type: i };
  }
};
const rue = 32, nue = 32;
class iue {
  constructor(e) {
    h(this, "errorHelper", new Kt(qt, Wt));
    h(this, "args");
    this.args = e;
  }
  getApdu() {
    const { serializedTransaction: e, isFirstChunk: t } = this.args, n = { cla: 224, ins: 4, p1: t ? 0 : 128, p2: 0 };
    return new ot(n).addBufferToData(e).build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefaultLazy(() => {
      const t = new kr(e), n = t.extract8BitUInt();
      if (n === void 0) return ye({ data: ve });
      const i = t.encodeToHexaString(t.extractFieldByLength(rue), !0);
      if (!i) return ye({ error: new ht("R is missing") });
      const s = t.encodeToHexaString(t.extractFieldByLength(nue), !0);
      return ye(s ? { data: Le({ v: n, r: i, s }) } : { error: new ht("S is missing") });
    });
  }
}
const sue = 32, oue = 32;
class aue {
  constructor() {
    h(this, "errorHelper", new Kt(qt, Wt));
  }
  getApdu() {
    const e = { cla: 224, ins: 4, p1: 0, p2: 2 };
    return new ot(e).build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefaultLazy(() => {
      const t = new kr(e), n = t.extract8BitUInt();
      if (n === void 0) return ye({ error: new ht("V is missing") });
      const i = t.encodeToHexaString(t.extractFieldByLength(sue), !0);
      if (!i) return ye({ error: new ht("R is missing") });
      const s = t.encodeToHexaString(t.extractFieldByLength(oue), !0);
      return ye(s ? { data: Le({ v: n, r: i, s }) } : { error: new ht("S is missing") });
    });
  }
}
const cue = 4;
class uue {
  constructor(e, t) {
    this.api = e, this.args = t;
  }
  async run() {
    if (this.args.clearSigningType === Xh.EIP7730) {
      const c = await this.api.sendCommand(new aue());
      return We(c) ? this.recoverSignature(c.data).mapOrDefault((u) => ye({ data: u }), ye({ error: new ht("no signature returned") })) : c;
    }
    const { derivationPath: e, serializedTransaction: t } = this.args, n = _f.splitPath(e), i = new Ds(t.length + 1 + n.length * cue);
    i.add8BitUIntToData(n.length), n.forEach((c) => {
      i.add32BitUIntToData(c);
    });
    const s = i.build(), o = this.getChunks(s, t);
    let a = ve;
    for (let c = 0; c < o.length; c++) {
      const u = await this.api.sendCommand(new iue({ serializedTransaction: o[c], isFirstChunk: c === 0 }));
      if (!We(u)) return u;
      a = u.data;
    }
    return this.recoverSignature(a).mapOrDefault((c) => ye({ data: c }), ye({ error: new ht("no signature returned") }));
  }
  getChunks(e, t) {
    const n = Uint8Array.from([...e, ...t]);
    let i = Is;
    if (n.length <= i) return [n];
    if (this.args.transactionType === aA.LEGACY) try {
      const a = vf(t);
      if (Array.isArray(a)) {
        const c = a.slice(-3), u = Sc(c), l = _r(u).subarray(1);
        for (i = Is; i > e.length; i--) {
          const d = n.length % i;
          if (d === 0 || d > l.length) break;
        }
      }
    } catch {
      i = Is;
    }
    let s = 0;
    const o = [];
    for (; s < n.length; ) o.push(n.slice(s, s + i)), s += i;
    return o;
  }
  recoverSignature(e) {
    return e.map(({ v: t, r: n, s: i }) => {
      if (this.args.transactionType !== aA.LEGACY) return { v: t, r: n, s: i };
      const s = 4294967295;
      let o = this.args.chainId;
      for (; o > s; ) o = o >> 8;
      const a = o * 2 + 35 & 255;
      return { v: (t == a ? 0 : 1) + this.args.chainId * 2 + 35, r: n, s: i };
    });
  }
}
class lue extends Qi {
  makeStateMachine(e) {
    const { getAppConfig: t, web3CheckOptIn: n, parseTransaction: i, buildContexts: s, signTransaction: o, provideContexts: a } = this.extractDependencies(e);
    return Or({ actors: { openAppStateMachine: new uf({ input: { appName: "Ethereum" } }).makeStateMachine(e), getAppConfig: tt(t), web3CheckOptIn: tt(n), parseTransaction: tt(i), buildContexts: tt(s), provideContexts: tt(a), signTransaction: tt(o) }, guards: { noInternalError: ({ context: c }) => c._internalState.error === null, notRefusedByUser: ({ context: c }) => c._internalState.error !== null && (!("errorCode" in c._internalState.error) || c._internalState.error.errorCode !== "6985"), isWeb3ChecksSupported: ({ context: c }) => new Xp(e.getDeviceSessionState(), c._internalState.appConfig).withMinVersionExclusive("1.15.0").excludeDeviceModel(je.NANO_S).excludeDeviceModel(je.NANO_SP).excludeDeviceModel(je.NANO_X).check(), shouldOptIn: ({ context: c }) => !c._internalState.appConfig.web3ChecksEnabled && !c._internalState.appConfig.web3ChecksOptIn, skipOpenApp: ({ context: c }) => !!c.input.options.skipOpenApp }, actions: { assignErrorFromEvent: Q({ _internalState: (c) => ({ ...c.context._internalState, error: c.event.error }) }) } }).createMachine({ id: "SignTransactionDeviceAction", initial: "InitialState", context: ({ input: c }) => ({ input: c, intermediateValue: { requiredUserInteraction: $e.None, step: pi.OPEN_APP }, _internalState: { error: null, appConfig: null, subset: null, contexts: [], clearSigningType: null, transactionType: null, signature: null } }), states: { InitialState: { always: [{ target: "GetAppConfig", guard: "skipOpenApp" }, "OpenAppDeviceAction"] }, OpenAppDeviceAction: { invoke: { id: "openAppStateMachine", input: { appName: "Ethereum" }, src: "openAppStateMachine", onSnapshot: { actions: Q({ intermediateValue: (c) => ({ ...c.event.snapshot.context.intermediateValue, step: pi.OPEN_APP }) }) }, onDone: { actions: Q({ _internalState: (c) => c.event.output.caseOf({ Right: () => c.context._internalState, Left: (u) => ({ ...c.context._internalState, error: u }) }) }), target: "CheckOpenAppDeviceActionResult" } } }, CheckOpenAppDeviceActionResult: { always: [{ target: "GetAppConfig", guard: "noInternalError" }, "Error"] }, GetAppConfig: { entry: Q({ intermediateValue: { requiredUserInteraction: $e.None, step: pi.GET_APP_CONFIG } }), invoke: { id: "getAppConfig", src: "getAppConfig", onDone: { target: "GetAppConfigResultCheck", actions: [Q({ _internalState: ({ event: c, context: u }) => We(c.output) ? { ...u._internalState, appConfig: c.output.data } : { ...u._internalState, error: c.output.error } })] }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, GetAppConfigResultCheck: { always: [{ target: "Web3ChecksOptIn", guard: rL(["noInternalError", "isWeb3ChecksSupported", "shouldOptIn"]) }, { target: "ParseTransaction", guard: "noInternalError" }, { target: "Error" }] }, Web3ChecksOptIn: { entry: Q({ intermediateValue: { requiredUserInteraction: $e.Web3ChecksOptIn, step: pi.WEB3_CHECKS_OPT_IN } }), invoke: { id: "web3CheckOptIn", src: "web3CheckOptIn", onDone: { target: "Web3ChecksOptInResult", actions: [Q({ _internalState: ({ event: c, context: u }) => We(c.output) ? { ...u._internalState, appConfig: { ...u._internalState.appConfig, web3ChecksEnabled: c.output.data.enabled } } : u._internalState })] }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, Web3ChecksOptInResult: { entry: Q(({ context: c }) => ({ intermediateValue: { requiredUserInteraction: $e.None, step: pi.WEB3_CHECKS_OPT_IN_RESULT, result: c._internalState.appConfig.web3ChecksEnabled } })), after: { 0: { target: "ParseTransaction" } } }, ParseTransaction: { entry: Q({ intermediateValue: { requiredUserInteraction: $e.None, step: pi.PARSE_TRANSACTION } }), invoke: { id: "parseTransaction", src: "parseTransaction", input: ({ context: c }) => ({ mapper: c.input.mapper, transaction: c.input.transaction }), onDone: { target: "BuildContexts", actions: Q({ _internalState: ({ event: c, context: u }) => ({ ...u._internalState, subset: c.output.subset, transactionType: c.output.type }) }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, BuildContexts: { entry: Q({ intermediateValue: { requiredUserInteraction: $e.None, step: pi.BUILD_CONTEXTS } }), invoke: { id: "buildContexts", src: "buildContexts", input: ({ context: c }) => ({ contextModule: c.input.contextModule, mapper: c.input.mapper, parser: c.input.parser, options: c.input.options, appConfig: c._internalState.appConfig, derivationPath: c.input.derivationPath, subset: c._internalState.subset, transaction: c.input.transaction, deviceModelId: e.getDeviceModel().id }), onDone: { target: "ProvideContexts", actions: [Q({ _internalState: ({ event: c, context: u }) => ({ ...u._internalState, contexts: c.output.clearSignContexts, clearSigningType: c.output.clearSigningType }) })] }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, ProvideContexts: { entry: Q({ intermediateValue: { requiredUserInteraction: $e.None, step: pi.PROVIDE_CONTEXTS } }), exit: Q({ _internalState: ({ context: c }) => ({ ...c._internalState, contexts: c._internalState.contexts.slice(1) }) }), invoke: { id: "provideContexts", src: "provideContexts", input: ({ context: c }) => ({ contexts: c._internalState.contexts, derivationPath: c.input.derivationPath, serializedTransaction: c.input.transaction }), onDone: { target: "SignTransaction" }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, SignTransaction: { entry: Q({ intermediateValue: { requiredUserInteraction: $e.SignTransaction, step: pi.SIGN_TRANSACTION } }), invoke: { id: "signTransaction", src: "signTransaction", input: ({ context: c }) => ({ derivationPath: c.input.derivationPath, serializedTransaction: c.input.transaction, chainId: c._internalState.subset.chainId, transactionType: c._internalState.transactionType, clearSigningType: c._internalState.clearSigningType }), onDone: { target: "SignTransactionResultCheck", actions: [Q({ _internalState: ({ event: c, context: u }) => We(c.output) ? { ...u._internalState, signature: c.output.data } : { ...u._internalState, error: c.output.error } })] }, onError: { target: "SignTransactionResultCheck", actions: "assignErrorFromEvent" } } }, SignTransactionResultCheck: { always: [{ guard: "noInternalError", target: "Success" }, { guard: "notRefusedByUser", target: "BlindSignTransactionFallback" }, { target: "Error" }] }, BlindSignTransactionFallback: { entry: Q({ intermediateValue: { requiredUserInteraction: $e.None, step: pi.BLIND_SIGN_TRANSACTION_FALLBACK } }), invoke: { id: "blindSignTransactionFallback", src: "signTransaction", input: ({ context: c }) => ({ derivationPath: c.input.derivationPath, serializedTransaction: c.input.transaction, chainId: c._internalState.subset.chainId, transactionType: c._internalState.transactionType, clearSigningType: Xh.BASIC }), onDone: { target: "BlindSignTransactionFallbackResultCheck", actions: [Q({ _internalState: ({ event: c, context: u }) => We(c.output) ? { ...u._internalState, signature: c.output.data } : { ...u._internalState, error: c.output.error } })] }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, BlindSignTransactionFallbackResultCheck: { always: [{ guard: "noInternalError", target: "Success" }, { target: "Error" }] }, Success: { type: "final" }, Error: { type: "final" } }, output: ({ context: c }) => c._internalState.signature ? te(c._internalState.signature) : N(c._internalState.error || new fo("No error in final state")) });
  }
  extractDependencies(e) {
    return { getAppConfig: async () => e.sendCommand(new C4()), web3CheckOptIn: async () => e.sendCommand(new T4()), parseTransaction: async (t) => Promise.resolve(new tue({ mapper: t.input.mapper, transaction: t.input.transaction }).run()), buildContexts: async (t) => new $4(e, t.input).run(), provideContexts: async (t) => new M4(e, t.input).run(), signTransaction: async (t) => new uue(e, { ...t.input }).run() };
  }
}
var _p = ((r) => (r.OPEN_APP = "signer.eth.steps.openApp", r.BUILD_CONTEXTS = "signer.eth.steps.buildContexts", r.PROVIDE_CONTEXTS = "signer.eth.steps.provideContexts", r.VERIFY_SAFE_ADDRESS = "signer.eth.steps.verifySafeAddress", r))(_p || {});
let due = class {
  constructor(e, t) {
    this._api = e, this._args = t;
  }
  async run() {
    const e = await this._api.sendCommand(new Yh());
    if (!We(e)) throw new Error("Failed to get challenge");
    const t = e.data.challenge, n = await this._args.contextModule.getContexts({ safeContractAddress: this._args.safeContractAddress, chainId: this._args.options.chainId, deviceModelId: this._args.deviceModelId, challenge: t }, [M.SAFE, M.SIGNER]);
    if (n.forEach((i) => {
      if (i.type === M.ERROR) throw new Error(i.error.message);
    }), n.length !== 2 || n.find((i) => i.type === M.SAFE) === void 0 || n.find((i) => i.type === M.SIGNER) === void 0) throw new Error("Invalid safe address contexts");
    return { clearSignContexts: n };
  }
};
class hue extends Qi {
  makeStateMachine(e) {
    const { buildSafeAddressContexts: t, provideContexts: n } = this.extractDependencies(e);
    return Or({ actors: { openAppStateMachine: new uf({ input: { appName: "Ethereum" } }).makeStateMachine(e), buildSafeAddressContexts: tt(t), provideContexts: tt(n) }, guards: { noInternalError: ({ context: i }) => i._internalState.error === null, skipOpenApp: ({ context: i }) => !!i.input.options.skipOpenApp }, actions: { assignErrorFromEvent: Q({ _internalState: (i) => ({ ...i.context._internalState, error: i.event.error }) }) } }).createMachine({ id: "VerifySafeAddressDeviceAction", initial: "InitialState", context: ({ input: i }) => ({ input: i, intermediateValue: { requiredUserInteraction: $e.None, step: _p.OPEN_APP }, _internalState: { error: null, contexts: [] } }), states: { InitialState: { always: [{ target: "BuildSafeAddressContexts", guard: "skipOpenApp" }, "OpenAppDeviceAction"] }, OpenAppDeviceAction: { invoke: { id: "openAppStateMachine", input: { appName: "Ethereum" }, src: "openAppStateMachine", onSnapshot: { actions: Q({ intermediateValue: (i) => ({ ...i.event.snapshot.context.intermediateValue, step: _p.OPEN_APP }) }) }, onDone: { actions: Q({ _internalState: (i) => i.event.output.caseOf({ Right: () => i.context._internalState, Left: (s) => ({ ...i.context._internalState, error: s }) }) }), target: "CheckOpenAppDeviceActionResult" } } }, CheckOpenAppDeviceActionResult: { always: [{ target: "BuildSafeAddressContexts", guard: "noInternalError" }, "Error"] }, BuildSafeAddressContexts: { entry: Q({ intermediateValue: { requiredUserInteraction: $e.None, step: _p.BUILD_CONTEXTS } }), invoke: { id: "buildSafeAddressContexts", src: "buildSafeAddressContexts", input: ({ context: i }) => ({ contextModule: i.input.contextModule, safeContractAddress: i.input.safeContractAddress, options: i.input.options, deviceModelId: e.getDeviceModel().id }), onDone: { target: "ProvideContexts", actions: [Q({ _internalState: ({ event: i, context: s }) => ({ ...s._internalState, contexts: i.output.clearSignContexts }) })] }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, ProvideContexts: { entry: Q({ intermediateValue: { requiredUserInteraction: $e.None, step: _p.VERIFY_SAFE_ADDRESS } }), invoke: { id: "provideContexts", src: "provideContexts", input: ({ context: i }) => ({ contexts: i._internalState.contexts }), onDone: { target: "ProvideContextsResultCheck", actions: [Q({ _internalState: ({ event: i, context: s }) => i.output.isLeft() ? { ...s._internalState, error: i.output.extract() } : { ...s._internalState, error: null } })] }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, ProvideContextsResultCheck: { always: [{ guard: "noInternalError", target: "Success" }, { target: "Error" }] }, Success: { type: "final" }, Error: { type: "final" } }, output: ({ context: i }) => i._internalState.error ? N(i._internalState.error) : te(void 0) });
  }
  extractDependencies(e) {
    return { provideContexts: async (t) => {
      for (const n of t.input.contexts) {
        const i = await new F4(e, { context: n }).run();
        if (!We(i)) return N(i.error);
      }
      return te(void 0);
    }, buildSafeAddressContexts: async (t) => new due(e, t.input).run() };
  }
}
const fue = 32, pue = 32;
class gue {
  constructor(e) {
    h(this, "args");
    h(this, "errorHelper", new Kt(qt, Wt));
    this.args = e;
  }
  getApdu() {
    const { data: e, isFirstChunk: t } = this.args, n = { cla: 224, ins: 52, p1: t ? 1 : 0, p2: 0 };
    return new ot(n).addBufferToData(e).build();
  }
  parseResponse(e) {
    return pe.fromNullable(this.errorHelper.getError(e)).orDefaultLazy(() => {
      const t = new kr(e), n = t.extract8BitUInt();
      if (n === void 0) return ye({ data: ve });
      const i = t.encodeToHexaString(t.extractFieldByLength(fue), !0);
      if (!i) return ye({ error: new ht("R is missing") });
      const s = t.encodeToHexaString(t.extractFieldByLength(pue), !0);
      return ye(s ? { data: Le({ r: i, s, v: n }) } : { error: new ht("S is missing") });
    });
  }
}
const mue = 0, yue = 1, vue = 2, bue = 3;
class wue {
  constructor(e, t) {
    this.api = e, this.args = t;
  }
  async run() {
    const { derivationPath: e, chainId: t, address: n, nonce: i } = this.args, s = _f.splitPath(e), o = this.buildData(s, t, n, i), a = await new C0(this.api, { data: o, commandFactory: (c) => new gue({ data: c.chunkedData, isFirstChunk: c.isFirstChunk }) }).run();
    return We(a) ? a.data.mapOrDefault((c) => ye({ data: c }), ye({ error: new ht("no signature returned") })) : a;
  }
  buildData(e, t, n, i) {
    const s = new Ds();
    s.add8BitUIntToData(e.length), e.forEach((c) => {
      s.add32BitUIntToData(c);
    });
    const o = new Ds();
    o.encodeInTLVFromBuffer(mue, Uint8Array.from([1])), o.encodeInTLVFromHexa(yue, n), o.encodeInTLVFromUInt64(vue, t), o.encodeInTLVFromUInt64(bue, i);
    const a = o.build();
    return s.add16BitUIntToData(a.length).addBufferToData(a).build();
  }
}
var _ue = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Vf = (r, e) => (t, n) => e(t, n, r);
let ZA = class {
  constructor(e, t, n, i, s) {
    this.dmk = e, this.contextModule = t, this.mapper = n, this.parser = i, this.sessionId = s;
  }
  getAddress(e) {
    return this.dmk.executeDeviceAction({ sessionId: this.sessionId, deviceAction: new Wz({ input: { command: new k4(e), appName: "Ethereum", requiredUserInteraction: e.checkOnDevice ? $e.VerifyAddress : $e.None, skipOpenApp: e.skipOpenApp } }) });
  }
  verifySafeAddress(e) {
    return this.dmk.executeDeviceAction({ sessionId: this.sessionId, deviceAction: new hue({ input: { safeContractAddress: e.safeContractAddress, contextModule: this.contextModule, options: e.options ?? { chainId: 1 } } }) });
  }
  signPersonalMessage(e) {
    return this.dmk.executeDeviceAction({ sessionId: this.sessionId, deviceAction: new UT({ input: { task: async (t) => new eue(t, e).run(), appName: "Ethereum", requiredUserInteraction: $e.SignPersonalMessage, skipOpenApp: e.skipOpenApp } }) });
  }
  signTransaction(e) {
    return this.dmk.executeDeviceAction({ sessionId: this.sessionId, deviceAction: new lue({ input: { derivationPath: e.derivationPath, transaction: e.transaction, mapper: this.mapper, parser: this.parser, contextModule: this.contextModule, options: e.options ?? {} } }) });
  }
  signTypedData(e) {
    return this.dmk.executeDeviceAction({ sessionId: this.sessionId, deviceAction: new Zce({ input: { derivationPath: e.derivationPath, data: e.data, parser: e.parser, transactionMapper: this.mapper, transactionParser: this.parser, contextModule: this.contextModule, skipOpenApp: e.skipOpenApp } }) });
  }
  signDelegationAuthorization(e) {
    return this.dmk.executeDeviceAction({ sessionId: this.sessionId, deviceAction: new UT({ input: { task: async (t) => new wue(t, e).run(), appName: "Ethereum", requiredUserInteraction: $e.SignDelegationAuthorization, skipOpenApp: !1 } }) });
  }
};
ZA = _ue([le(), Vf(0, X(Ed.Dmk)), Vf(1, X(Ed.ContextModule)), Vf(2, X(xd.TransactionMapperService)), Vf(3, X(xd.TransactionParserService)), Vf(4, X(Ed.SessionId))], ZA);
const Sue = () => new mt(({ bind: r }) => {
  r(bl.AppBinding).to(ZA);
}), V4 = { SignDelegationAuthorizationUseCase: Symbol.for("SignDelegationAuthorizationUseCase") };
var Eue = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, xue = (r, e) => (t, n) => e(t, n, r);
let JA = class {
  constructor(e) {
    h(this, "_appBinder");
    this._appBinder = e;
  }
  execute(e, t, n, i) {
    return this._appBinder.signDelegationAuthorization({ derivationPath: e, nonce: t, address: n, chainId: i });
  }
};
JA = Eue([le(), xue(0, X(bl.AppBinding))], JA);
const Aue = () => new mt(({ bind: r }) => {
  r(V4.SignDelegationAuthorizationUseCase).to(JA);
}), z4 = { SignMessageUseCase: Symbol.for("SignMessageUseCase") };
var Iue = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Cue = (r, e) => (t, n) => e(t, n, r);
let XA = class {
  constructor(r) {
    h(this, "_appBinder");
    this._appBinder = r;
  }
  execute(r, e, t) {
    return this._appBinder.signPersonalMessage({ derivationPath: r, message: e, skipOpenApp: (t == null ? void 0 : t.skipOpenApp) ?? !1 });
  }
};
XA = Iue([le(), Cue(0, X(bl.AppBinding))], XA);
const Due = () => new mt(({ bind: r }) => {
  r(z4.SignMessageUseCase).to(XA);
});
var Tue = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, kue = (r, e) => (t, n) => e(t, n, r);
let YA = class {
  constructor(r) {
    h(this, "_appBinder");
    this._appBinder = r;
  }
  execute(r, e) {
    return this._appBinder.verifySafeAddress({ safeContractAddress: r, options: e });
  }
};
YA = Tue([le(), kue(0, X(bl.AppBinding))], YA);
const j4 = { VerifySafeAddressUseCase: Symbol.for("VerifySafeAddressUseCase") }, Oue = () => new mt(({ bind: r }) => {
  r(j4.VerifySafeAddressUseCase).to(YA);
});
var $ue = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
};
const KP = 10;
let QA = class {
  constructor() {
  }
  mapTransactionToSubset(e) {
    try {
      const t = yA.from(It(e)), n = Number(t.chainId.toString());
      return n <= 0 ? N(new Error("Pre-EIP-155 transactions are not supported")) : te({ subset: { chainId: n, to: t.to ?? void 0, data: t.data, selector: t.data.length >= KP ? t.data.slice(0, KP) : t.data, value: t.value }, serializedTransaction: st(t.unsignedSerialized), type: t.type || 0 });
    } catch {
      return N(new Error("Invalid transaction"));
    }
  }
};
QA = $ue([le()], QA);
var Rue = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
};
const Pue = 4, zf = 32;
let eI = class {
  extractValue(e, t) {
    const { to: n, data: i, value: s } = e;
    return t === Ay.FROM ? N(new Error("Cannot get 'FROM' field of an unsigned transaction")) : t === Ay.TO ? pe.fromNullable(n).map((o) => _r(o)).filter((o) => o !== null).map((o) => [o]).toEither(new Error("Failed to extract TO field of transaction")) : t === Ay.VALUE ? pe.fromNullable(s).map((o) => new Ds().add256BitUIntToData(o).build()).map((o) => [o]).toEither(new Error("Failed to extract VALUE field of transaction")) : pe.fromNullable(i).toEither(new Error("Transaction calldata is empty")).chain((o) => pe.fromNullable(_r(o)).toEither(new Error(`Invalid hex string calldata: ${o}`))).chain((o) => this.extractCalldataValue(o, t));
  }
  extractCalldataValue(e, t) {
    return e = e.slice(Pue), t.length === 0 ? N(new Error("Path is empty")) : this.extractCalldataValueAt(e, t, 0, 0);
  }
  extractCalldataValueAt(e, t, n, i) {
    const s = t[t.length - 1], o = s.type === zc.SLICE ? s : null;
    for (; t.length > 0; ) {
      const a = t[0];
      switch (t = t.slice(1), a.type) {
        case zc.TUPLE:
          i = n, n += a.offset * zf;
          break;
        case zc.ARRAY:
          return this.getU256(e.slice(n)).toEither(new Error(`Invalid array length at offset ${n}`)).chain((c) => {
            n += zf, i = n;
            const u = a.start === void 0 ? 0 : a.start < 0 ? c + a.start : a.start, l = a.end === void 0 ? c : a.end < 0 ? c + a.end : a.end;
            return u < 0 || u >= c || l > c || u >= l ? N(new Error(`Array slice out of bounds, start=${a.start}, end=${a.end}`)) : Array.from({ length: l - u }, (d, f) => f).map((d) => n + (d + u) * a.itemSize * zf).reduce((d, f) => d.chain((p) => this.extractCalldataValueAt(e, t, f, i).map((y) => [...p, ...y])), te([]));
          });
        case zc.REF:
          if (this.getU256(e.slice(n)).ifJust((c) => n = i + c).isNothing()) return N(new Error(`Invalid ref at offset ${n}`));
          break;
        case zc.LEAF:
          switch (a.leafType) {
            case wp.ARRAY_LEAF:
              return N(new Error("Array leaf is not supported in v1 of protocol"));
            case wp.TUPLE_LEAF:
              return N(new Error("Tuple leaf is not supported in v1 of protocol"));
            case wp.STATIC_LEAF:
              return this.getSlice(e, n, zf).chain((c) => o === null ? te([c]) : this.sliceLeaf(c, o));
            case wp.DYNAMIC_LEAF:
              return this.getU256(e.slice(n)).toEither(new Error(`Invalid leaf length at offset ${n}`)).chain((c) => (n += zf, this.getSlice(e, n, c).chain((u) => o === null ? te([u]) : this.sliceLeaf(u, o))));
          }
          break;
        case zc.SLICE:
          return N(new Error("Slice can only be used as last element of the path"));
      }
    }
    return N(new Error("Path did not resolve to a leaf element"));
  }
  sliceLeaf(e, t) {
    const n = e.length, i = t.start === void 0 ? 0 : t.start < 0 ? n + t.start : t.start, s = t.end === void 0 ? n : t.end < 0 ? n + t.end : t.end;
    return i >= s ? N(new Error(`invalid leaf slice: start ${i}, end ${s}`)) : this.getSlice(e, i, s - i).map((o) => [o]);
  }
  getSlice(e, t, n) {
    return t < 0 || e.length < t + n ? N(new Error(`calldata too small to slice at offset ${t} of length ${n}`)) : te(e.slice(t, t + n));
  }
  getU256(e) {
    return pe.fromNullable(new OB(e).extract256BitUInt(!0)).filter((t) => t <= Number.MAX_SAFE_INTEGER).map((t) => Number(t));
  }
};
eI = Rue([le()], eI);
var Nue = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, Bue = (r, e) => (t, n) => e(t, n, r);
let tI = class {
  constructor(r) {
    h(this, "_appBinding");
    this._appBinding = r;
  }
  execute(r, e, t) {
    return this._appBinding.signTransaction({ derivationPath: r, transaction: e, options: t });
  }
};
tI = Nue([le(), Bue(0, X(bl.AppBinding))], tI);
const Lue = () => new mt(({ bind: r }) => {
  r(xd.SignTransactionUseCase).to(tI), r(xd.TransactionMapperService).to(QA), r(xd.TransactionParserService).to(eI);
}), hv = { SignTypedDataUseCase: Symbol.for("SignTypedDataUseCase"), TypedDataParserService: Symbol.for("TypedDataParserService") };
function Uue(r, e) {
  switch (r.name) {
    case "string":
      return typeof e != "string" ? ve : Le(new TextEncoder().encode(e));
    case "bytes":
    case "address":
      return typeof e != "string" ? ve : Fue(r, e);
    case "bool":
    case "uint":
    case "int":
      return r.name === "bool" && typeof e == "boolean" && (e = Number(e)), typeof e != "string" && typeof e != "number" && typeof e != "bigint" ? ve : Mue(r.name, r.size.mapOrDefault((t) => t * 8, 1), e);
  }
}
function Fue(r, e) {
  const t = r.name === "address" ? Le(20) : r.size;
  return pe.fromNullable(_r(e)).filter((n) => t.mapOrDefault((i) => n.length <= i, !0));
}
function Mue(r, e, t) {
  let n;
  switch (typeof t) {
    case "bigint":
      n = t;
      break;
    case "number":
      if (!Number.isInteger(t)) return ve;
      n = BigInt(t);
      break;
    case "string":
      if (t.length === 0) return ve;
      try {
        n = BigInt(t);
      } catch {
        return ve;
      }
      break;
  }
  const i = r === "int";
  return Vue(n, BigInt(e), i).chain((s) => pe.fromNullable(_r(s.toString(16))));
}
function Vue(r, e, t) {
  if (!t) return r >= 0n && r < 1n << e ? Le(r) : ve;
  const n = 1n << e - 1n;
  if (r >= n || r < -n) return ve;
  if (r < 0n) {
    const i = (1n << e) - 1n;
    r = -r, r = (~r & i) + 1n;
  }
  return Le(r);
}
class zue {
  constructor(e, t) {
    h(this, "domainTypeName", "EIP712Domain");
    h(this, "domainDefaultTypes", { name: "string", version: "string", chainId: "uint256", verifyingContract: "address", salt: "bytes32" });
    h(this, "structs");
    if (!(this.domainTypeName in e)) {
      const i = [];
      Object.entries(this.domainDefaultTypes).forEach(([s, o]) => {
        s in t && i.push({ name: s, type: o });
      }), i.length > 0 && (e[this.domainTypeName] = i);
    }
    const n = {};
    for (const [i, s] of Object.entries(e)) {
      const o = {};
      for (const a of s) o[a.name] = this.parseType(a.type);
      n[i] = o;
    }
    this.structs = n;
  }
  getStructDefinitions() {
    return this.structs;
  }
  parse(e, t) {
    if (!this.isRecord(t)) return N(new Error("Message is not a record"));
    const n = [{ path: "", type: "", value: new P4(e) }];
    return this.visitValue(e, t, "", (i) => n.push(i)) ? te(n) : N(new Error("Failed to parse"));
  }
  isRecord(e) {
    return typeof e == "object" && e !== null;
  }
  parseType(e) {
    return this.tryParsePrimitiveType(e).mapOrDefault((t) => t, this.tryParseArrayType(e).mapOrDefault((t) => t, new dv(e)));
  }
  tryParsePrimitiveType(e) {
    {
      const t = e.match(/^(((u?)int)(\d+))$/);
      if (t) {
        const n = parseInt(t[4]);
        return n % 8 !== 0 || n === 0 || n > 256 ? ve : Le(new Iy(t[1], t[3] ? "uint" : "int", Le(n / 8)));
      }
    }
    {
      const t = e.match(/^((bytes)(\d*))$/);
      if (t) {
        const n = t[3] ? parseInt(t[3]) : null;
        return n !== null && (n === 0 || n > 32) ? ve : Le(new Iy(t[1], "bytes", pe.fromNullable(n)));
      }
    }
    return e === "address" || e === "bool" || e === "string" ? Le(new Iy(e, e, ve)) : ve;
  }
  tryParseArrayType(e) {
    const t = e.match(/^([^[[]*)(((\[\d*\])*)\[\d*\])$/);
    if (t) {
      const n = [...t[2].matchAll(/\[(\d*)\]/g)];
      if (n && n.length > 0) {
        const i = n.map(([, o]) => o ? Le(parseInt(o)) : ve), s = this.tryParsePrimitiveType(t[1]).mapOrDefault((o) => o, new dv(t[1]));
        return Le(new ql(e, s, t[1] + t[3], i[i.length - 1], i));
      }
    }
    return ve;
  }
  visitValue(e, t, n, i) {
    return this.tryVisitStructValue(e, t, n, i) || this.tryVisitPrimitiveValue(e, t, n, i) || this.tryVisitArrayValue(e, t, n, i);
  }
  tryVisitPrimitiveValue(e, t, n, i) {
    return !this.isRecord(t) && !Array.isArray(t) && this.tryParsePrimitiveType(e).chain((s) => Uue(s, t).ifJust((o) => {
      i({ path: n, type: e, value: new KC(o) });
    })).isJust();
  }
  tryVisitStructValue(e, t, n, i) {
    const s = this.structs[e];
    if (s === void 0 || !this.isRecord(t)) return !1;
    for (const [o, a] of Object.entries(s)) {
      const c = t[o];
      if (c === void 0) return !1;
      const u = n.length ? `${n}.${o}` : o;
      if (!this.visitValue(a.typeName, c, `${u}`, i)) return !1;
    }
    return !0;
  }
  tryVisitArrayValue(e, t, n, i) {
    return Array.isArray(t) && this.tryParseArrayType(e).filter((s) => s.count.mapOrDefault((o) => t.length == o, !0)).mapOrDefault((s) => {
      i({ path: n, type: e, value: new GA(t.length) });
      for (const o of t) {
        const a = n.length ? `${n}.[]` : "[]";
        if (!this.visitValue(s.rowType, o, `${a}`, i)) return !1;
      }
      return !0;
    }, !1);
  }
}
var jue = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
};
let rI = class {
  parse(r) {
    const e = new zue(r.types, r.domain), t = e.getStructDefinitions(), n = e.parse("EIP712Domain", r.domain), i = e.parse(r.primaryType, r.message);
    return n.chain((s) => i.map((o) => ({ types: t, domain: s, message: o })));
  }
};
rI = jue([le()], rI);
var Hue = (r, e, t, n) => {
  for (var i = e, s = r.length - 1, o; s >= 0; s--) (o = r[s]) && (i = o(i) || i);
  return i;
}, qP = (r, e) => (t, n) => e(t, n, r);
let nI = class {
  constructor(r, e) {
    h(this, "_appBinding");
    h(this, "_parser");
    this._appBinding = r, this._parser = e;
  }
  execute(r, e, t) {
    return this._appBinding.signTypedData({ derivationPath: r, parser: this._parser, data: e, skipOpenApp: (t == null ? void 0 : t.skipOpenApp) ?? !1 });
  }
};
nI = Hue([le(), qP(0, X(bl.AppBinding)), qP(1, X(hv.TypedDataParserService))], nI);
const Gue = () => new mt(({ bind: r }) => {
  r(hv.SignTypedDataUseCase).to(nI), r(hv.TypedDataParserService).to(rI);
}), Kue = ({ dmk: r, sessionId: e, contextModule: t }) => {
  const n = new Uv();
  return n.bind(Ed.Dmk).toConstantValue(r), n.bind(Ed.ContextModule).toConstantValue(t), n.bind(Ed.SessionId).toConstantValue(e), n.loadSync(Cce(), Sue(), Aue(), Due(), Lue(), Gue(), Oue()), n;
};
class que {
  constructor({ dmk: e, sessionId: t, contextModule: n }) {
    h(this, "_container");
    this._container = Kue({ dmk: e, sessionId: t, contextModule: n });
  }
  signTransaction(e, t, n) {
    return this._container.get(xd.SignTransactionUseCase).execute(e, t, n);
  }
  signMessage(e, t, n) {
    return this._container.get(z4.SignMessageUseCase).execute(e, t, n);
  }
  signTypedData(e, t, n) {
    return this._container.get(hv.SignTypedDataUseCase).execute(e, t, n);
  }
  getAddress(e, t) {
    return this._container.get(I4.GetAddressUseCase).execute(e, t);
  }
  verifySafeAddress(e, t) {
    return this._container.get(j4.VerifySafeAddressUseCase).execute(e, t);
  }
  signDelegationAuthorization(e, t, n, i) {
    return this._container.get(V4.SignDelegationAuthorizationUseCase).execute(e, i, n, t);
  }
}
class qC {
  constructor({ dmk: e, sessionId: t, originToken: n }) {
    h(this, "_dmk");
    h(this, "_sessionId");
    h(this, "_customContextModule");
    h(this, "_originToken");
    this._dmk = e, this._sessionId = t, this._originToken = n;
  }
  withContextModule(e) {
    return this._customContextModule = e, this;
  }
  build() {
    const e = this._customContextModule ?? new xce({ originToken: this._originToken }).build();
    return new que({ dmk: this._dmk, sessionId: this._sessionId, contextModule: e });
  }
}
function WC(r) {
  return !!r && typeof r == "object" && "output" in r && typeof r.output == "object" && "address" in r.output;
}
function WP(r) {
  return !!r && typeof r == "object" && "rawTransaction" in r && "signedRawTransaction" in r;
}
function ZP(r) {
  return !!r && typeof r == "object" && "hash" in r;
}
function ZC(r) {
  return !!r && typeof r == "object" && "signature" in r;
}
const JP = {
  ethM: {
    derivationPath: "44'/60'/0'/<account>",
    skipFirst: !1
  },
  // MetaMask style
  ethMM: {
    derivationPath: "44'/60'/0'/0/<account>",
    skipFirst: !0
  },
  // MEW legacy derivation for eth
  etcM: {
    derivationPath: "44'/60'/160720'/0'/<account>",
    skipFirst: !1
  }
};
function JC(r) {
  const e = r.index;
  return JP[r.derivationMode] ? JP[r.derivationMode].derivationPath.replace(
    "<account>",
    e.toString()
  ) : `44'/60'/${e}'/0/0`;
}
var Wue = Object.getOwnPropertyDescriptor, Zue = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? Wue(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, jf = (r, e) => (t, n) => e(t, n, r);
let iI = class {
  constructor(r, e, t, n, i) {
    h(this, "logger");
    this.deviceManagementKitService = e, this.storageService = t, this.dappConfigService = n, this.config = i, this.logger = r("[SignPersonalMessage]");
  }
  execute(r) {
    this.logger.info("Starting signing message", { params: r });
    const e = this.deviceManagementKitService.sessionId;
    if (!e)
      throw this.logger.error("No device connected"), new uo(
        "No device connected. Please connect a device first.",
        { type: "not-connected" }
      );
    if (!this.deviceManagementKitService.connectedDevice)
      throw this.logger.error("No connected device found"), new uo("No connected device found", {
        type: "not-connected"
      });
    const [, n] = r, i = "personal-sign", s = new fa({
      signType: i,
      status: "debugging",
      message: "Initializing personal message signing"
    });
    try {
      const o = this.deviceManagementKitService.dmk, a = new qC({
        dmk: o,
        originToken: this.config.originToken,
        sessionId: e
      }).build(), c = this.storageService.getSelectedAccount().extract();
      if (!c)
        throw new qI("No account selected");
      const u = rn(this.createOpenAppConfig()).pipe(
        cr(
          (d) => new T1({
            input: d,
            inspect: !1
          })
        )
      ), l = JC(c);
      return u.pipe(
        Qr(
          (d) => o.executeDeviceAction({
            sessionId: e,
            deviceAction: d
          }).observable
        ),
        fn(
          (d) => {
            var f;
            return d.status !== Oe.Pending || ((f = d.intermediateValue) == null ? void 0 : f.requiredUserInteraction) !== $e.None;
          }
        ),
        po((d) => {
          s.next(
            this.getTransactionResultForEvent(d, n, i)
          );
        }),
        fn((d) => d.status === Oe.Error || d.status === Oe.Completed),
        Qr((d) => {
          if (d.status === Oe.Error)
            throw new Error("Open app with dependencies failed");
          const { observable: f } = a.getAddress(
            l,
            {
              skipOpenApp: !0
            }
          );
          return f.pipe(
            fn((p) => p.status === Oe.Error || p.status === Oe.Completed)
          );
        }),
        Qr((d) => {
          if (d.status === Oe.Error)
            throw d.error;
          if (d.status === Oe.Completed && d.output.address.toLowerCase() !== c.freshAddress.toLowerCase())
            throw new WI("Address mismatch");
          s.next({
            signType: i,
            status: "debugging",
            message: "Starting Sign Personal Message DA"
          });
          const { observable: f } = a.signMessage(
            l,
            n,
            {
              skipOpenApp: !0
            }
          );
          return f;
        }),
        fn(
          (d) => {
            var f;
            return d.status !== Oe.Pending || ((f = d.intermediateValue) == null ? void 0 : f.requiredUserInteraction) !== $e.None;
          }
        ),
        po((d) => {
          d.status !== Oe.Completed && d.status !== Oe.Error && s.next(
            this.getTransactionResultForEvent(d, n, i)
          );
        }),
        fn((d) => d.status === Oe.Error || d.status === Oe.Completed),
        po((d) => {
          s.next(
            this.getTransactionResultForEvent(d, n, i)
          );
        }),
        cr((d) => {
          if (d.status === Oe.Error)
            switch (!0) {
              case (d.error instanceof Jh && d.error.errorCode === "6985"):
                throw new ZI(
                  "User rejected transaction"
                );
              default:
                return d;
            }
          return d;
        })
      ).subscribe({
        next: (d) => {
          s.next(
            this.getTransactionResultForEvent(
              d,
              n,
              i
            )
          );
        },
        error: (d) => {
          this.logger.error("Personal message signing failed", { error: d }), s.next({ signType: i, status: "error", error: d });
        }
      }), s.asObservable();
    } catch (o) {
      return this.logger.error("Failed to sign personal message", { error: o }), Ji({
        signType: i,
        status: "error",
        error: o
      });
    }
  }
  async createOpenAppConfig() {
    const e = (await this.dappConfigService.getDAppConfig()).appDependencies.find(
      (t) => t.blockchain === "ethereum"
    );
    if (!e)
      throw new Error("Ethereum Blockchain dependencies not found");
    return {
      application: { name: e.appName },
      dependencies: e.dependencies.map((t) => ({
        name: t
      })),
      requireLatestFirmware: !1
      //TODO add this to the dApp config
    };
  }
  getTransactionResultForEvent(r, e, t) {
    var n, i;
    if (ZC(r))
      return {
        signType: t,
        status: "success",
        data: r
      };
    switch (r.status) {
      case Oe.Pending:
        switch ((n = r.intermediateValue) == null ? void 0 : n.requiredUserInteraction) {
          case "unlock-device":
            return {
              signType: t,
              status: "user-interaction-needed",
              interaction: "unlock-device"
            };
          case "allow-secure-connection":
            return {
              signType: t,
              status: "user-interaction-needed",
              interaction: "allow-secure-connection"
            };
          case "confirm-open-app":
            return {
              signType: t,
              status: "user-interaction-needed",
              interaction: "confirm-open-app"
            };
          case "sign-personal-message":
            return {
              signType: t,
              status: "user-interaction-needed",
              interaction: "sign-transaction"
            };
          case "allow-list-apps":
            return {
              signType: t,
              status: "user-interaction-needed",
              interaction: "allow-list-apps"
            };
          default:
            return {
              signType: t,
              status: "debugging",
              message: `Unhandled user interaction: ${JSON.stringify((i = r.intermediateValue) == null ? void 0 : i.requiredUserInteraction)}`
            };
        }
      case Oe.Completed: {
        if (WC(r))
          return {
            signType: t,
            status: "debugging",
            message: `Got address: ${r.output.address}`
          };
        if ("deviceMetadata" in r.output)
          return {
            signType: t,
            status: "debugging",
            message: "App Opened"
          };
        {
          const s = F6(r.output);
          return {
            signType: t,
            status: "success",
            data: {
              signature: s
            }
          };
        }
      }
      case Oe.Error:
        return {
          signType: t,
          status: "error",
          error: r.error
        };
      default:
        return {
          signType: t,
          status: "debugging",
          message: `DA status: ${r.status} - ${JSON.stringify(r)}`
        };
    }
  }
};
iI = Zue([
  ke(),
  jf(0, H(Me.LoggerPublisher)),
  jf(1, H(gt.DeviceManagementKitService)),
  jf(2, H(zt.StorageService)),
  jf(3, H(mc.DAppConfigService)),
  jf(4, H(Dt.Config))
], iI);
const XC = {
  ModalService: Symbol.for("ModalService")
};
var Jue = Object.getOwnPropertyDescriptor, Xue = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? Jue(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, $o = (r, e) => (t, n) => e(t, n, r);
let sI = class {
  constructor(r, e, t, n, i, s, o, a, c) {
    h(this, "logger");
    h(this, "pendingStep", "");
    this.deviceManagementKitService = e, this.storageService = t, this.config = n, this.dappConfigService = i, this.broadcastTransactionUseCase = s, this.trackTransactionStarted = o, this.trackTransactionCompleted = a, this.modalService = c, this.logger = r("[SignRawTransaction]");
  }
  execute(r) {
    this.logger.info("Starting transaction signing", { params: r });
    const e = this.deviceManagementKitService.sessionId;
    if (!e)
      throw this.logger.error("No device connected"), new uo(
        "No device connected. Please connect a device first.",
        { type: "not-connected" }
      );
    if (!this.deviceManagementKitService.connectedDevice)
      throw this.logger.error("No connected device found"), new uo("No connected device found", {
        type: "not-connected"
      });
    const { transaction: n, broadcast: i } = r, s = "transaction", o = new fa({
      signType: s,
      status: "debugging",
      message: "Initializing transaction signing"
    });
    try {
      const a = this.deviceManagementKitService.dmk, c = new qC({
        dmk: a,
        originToken: this.config.originToken,
        sessionId: e
      }).build(), u = _r(n);
      if (!u)
        throw Error("Invalid raw transaction format");
      const l = this.storageService.getSelectedAccount().extract();
      if (!l)
        throw new qI("No account selected");
      const d = rn(this.createOpenAppConfig()).pipe(
        cr(
          (p) => new T1({
            input: p,
            inspect: !1
          })
        )
      ), f = JC(l);
      return this.trackTransactionStarted.execute(n), d.pipe(
        Qr(
          (p) => a.executeDeviceAction({
            sessionId: e,
            deviceAction: p
          }).observable
        ),
        fn(
          (p) => {
            var y;
            return p.status !== Oe.Pending || ((y = p.intermediateValue) == null ? void 0 : y.requiredUserInteraction) !== $e.None;
          }
        ),
        po((p) => {
          o.next(
            this.getTransactionResultForEvent(p, n, s)
          );
        }),
        fn((p) => p.status === Oe.Error || p.status === Oe.Completed),
        Qr((p) => {
          if (p.status === Oe.Error)
            throw new Error("Open app with dependencies failed");
          const { observable: y } = c.getAddress(
            f,
            {
              skipOpenApp: !0
            }
          );
          return y.pipe(
            fn((g) => g.status === Oe.Error || g.status === Oe.Completed)
          );
        }),
        Qr((p) => {
          if (p.status === Oe.Error)
            throw p.error;
          if (p.status === Oe.Completed && p.output.address.toLowerCase() !== l.freshAddress.toLowerCase())
            throw new WI("Address mismatch");
          o.next({
            signType: s,
            status: "debugging",
            message: "Starting Sign Transaction DA"
          });
          const { observable: y } = c.signTransaction(
            f,
            u,
            {
              skipOpenApp: !0
            }
          );
          return y.pipe(
            po((g) => {
              var v;
              g.status === Oe.Pending && (this.pendingStep = ((v = g.intermediateValue) == null ? void 0 : v.step) ?? "");
            })
          );
        }),
        fn(
          (p) => {
            var y;
            return p.status !== Oe.Pending || ((y = p.intermediateValue) == null ? void 0 : y.requiredUserInteraction) !== $e.None;
          }
        ),
        po((p) => {
          p.status !== Oe.Completed && p.status !== Oe.Error && o.next(
            this.getTransactionResultForEvent(
              p,
              n,
              s
            )
          );
        }),
        fn((p) => p.status === Oe.Error || p.status === Oe.Completed),
        cr((p) => {
          if (p.status === Oe.Error)
            switch (!0) {
              case (p.error instanceof Jh && p.error.errorCode === "6a80" && this.pendingStep === pi.BLIND_SIGN_TRANSACTION_FALLBACK):
                throw new kB("Blind signing disabled");
              case (p.error instanceof Jh && p.error.errorCode === "6985"):
                throw new ZI(
                  "User rejected transaction"
                );
              default:
                throw p.error;
            }
          return p;
        }),
        fn((p) => p.status === Oe.Completed),
        Qr(async (p) => {
          if (i && this.modalService.open) {
            const g = {
              signature: p.output,
              rawTransaction: n
            };
            return await this.broadcastTransactionUseCase.execute(g);
          }
          return rA(n, {
            r: p.output.r,
            s: p.output.s,
            v: p.output.v
          });
        })
      ).subscribe({
        next: (p) => {
          (WP(p) || ZP(p)) && (ZP(p) && this.trackTransactionCompleted.execute(n, p), o.next(
            this.getTransactionResultForEvent(
              p,
              n,
              s
            )
          ));
        },
        error: (p) => {
          this.logger.error("Transaction signing failed", { error: p }), o.next({
            signType: s,
            status: "error",
            error: p
          });
        }
      }), o.asObservable();
    } catch (a) {
      return this.logger.error("Failed to sign transaction", { error: a }), Ji({
        signType: s,
        status: "error",
        error: new B8(`Transaction signing failed: ${a}`)
      });
    }
  }
  async createOpenAppConfig() {
    const e = (await this.dappConfigService.getDAppConfig()).appDependencies.find(
      (t) => t.blockchain === "ethereum"
    );
    if (!e)
      throw new Error("Ethereum Blockchain dependencies not found");
    return {
      application: { name: e.appName },
      dependencies: e.dependencies.map((t) => ({
        name: t
      })),
      requireLatestFirmware: !1
      //TODO add this to the dApp config
    };
  }
  getTransactionResultForEvent(r, e, t) {
    var n, i;
    if (WP(r) || ZC(r))
      return {
        signType: t,
        status: "success",
        data: r
      };
    switch (r.status) {
      case Oe.Pending:
        switch ((n = r.intermediateValue) == null ? void 0 : n.requiredUserInteraction) {
          case "unlock-device":
            return {
              signType: t,
              status: "user-interaction-needed",
              interaction: "unlock-device"
            };
          case "allow-secure-connection":
            return {
              signType: t,
              status: "user-interaction-needed",
              interaction: "allow-secure-connection"
            };
          case "confirm-open-app":
            return {
              signType: t,
              status: "user-interaction-needed",
              interaction: "confirm-open-app"
            };
          case "sign-transaction":
            return {
              signType: t,
              status: "user-interaction-needed",
              interaction: "sign-transaction"
            };
          case "allow-list-apps":
            return {
              signType: t,
              status: "user-interaction-needed",
              interaction: "allow-list-apps"
            };
          case "web3-checks-opt-in":
            return {
              signType: t,
              status: "user-interaction-needed",
              interaction: "web3-checks-opt-in"
            };
          default:
            return {
              signType: t,
              status: "debugging",
              message: `Unhandled user interaction: ${JSON.stringify((i = r.intermediateValue) == null ? void 0 : i.requiredUserInteraction)}`
            };
        }
      case Oe.Completed: {
        if (WC(r))
          return {
            signType: t,
            status: "debugging",
            message: `Got address: ${r.output.address}`
          };
        if ("r" in r.output) {
          const s = rA(e, {
            r: r.output.r,
            s: r.output.s,
            v: r.output.v
          });
          return {
            signType: t,
            status: "success",
            data: s
          };
        } else
          return {
            signType: t,
            status: "debugging",
            message: "App Opened"
          };
      }
      case Oe.Error:
        return {
          signType: t,
          status: "error",
          error: r
        };
      default:
        return {
          signType: t,
          status: "debugging",
          message: `DA status: ${r.status} - ${JSON.stringify(r)}`
        };
    }
  }
};
sI = Xue([
  ke(),
  $o(0, H(Me.LoggerPublisher)),
  $o(1, H(gt.DeviceManagementKitService)),
  $o(2, H(zt.StorageService)),
  $o(3, H(Dt.Config)),
  $o(4, H(mc.DAppConfigService)),
  $o(5, H(gt.BroadcastTransactionUseCase)),
  $o(6, H(rt.TrackTransactionStarted)),
  $o(7, H(rt.TrackTransactionCompleted)),
  $o(8, H(XC.ModalService))
], sI);
var Yue = Object.getOwnPropertyDescriptor, Que = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? Yue(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, Hf = (r, e) => (t, n) => e(t, n, r);
let oI = class {
  constructor(r, e, t, n, i) {
    h(this, "logger");
    this.gasFeeEstimationService = e, this.storageService = t, this.signRawTransaction = n, this.contextService = i, this.logger = r("[SignTransaction]");
  }
  execute(r) {
    this.logger.info("Starting transaction signing", { params: r });
    const { transaction: e, broadcast: t, method: n } = r;
    return rn(
      this.completeTransaction(e)
    ).pipe(
      Qr((s) => {
        const o = Yie(s);
        return this.logger.debug("Raw transaction", { rawTransaction: o }), this.signRawTransaction.execute({
          transaction: o,
          broadcast: t,
          method: n
        });
      })
    );
  }
  async addFeesToTransaction(r) {
    var e, t;
    try {
      const n = await this.gasFeeEstimationService.getFeesForTransaction({
        from: r.from || ((t = (e = this.storageService.getSelectedAccount()) == null ? void 0 : e.extract()) == null ? void 0 : t.freshAddress) || "",
        //Should never happen
        to: r.to,
        value: r.value,
        data: r.data,
        chainId: r.chainId.toString()
      }), i = {
        ...r,
        gas: n.gasLimit,
        maxFeePerGas: n.maxFeePerGas,
        maxPriorityFeePerGas: n.maxPriorityFeePerGas
      };
      return this.logger.debug("Transaction with fees", { transactionWithFees: i }), i;
    } catch (n) {
      throw this.logger.error("Failed to add fees to transaction", { error: n }), n;
    }
  }
  async addNonceToTransaction(r) {
    var e, t;
    try {
      const n = await this.gasFeeEstimationService.getNonceForTx({
        from: r.from || ((t = (e = this.storageService.getSelectedAccount()) == null ? void 0 : e.extract()) == null ? void 0 : t.freshAddress) || "",
        //Should never happen
        to: r.to,
        value: r.value,
        data: r.data,
        chainId: r.chainId.toString()
      }), i = {
        ...r,
        nonce: n
      };
      return this.logger.debug("Transaction with nonce", { transactionWithNonce: i }), i;
    } catch (n) {
      throw this.logger.error("Failed to add nonce to transaction", { error: n }), n;
    }
  }
  async completeTransaction(r) {
    let e = r;
    return e.chainId || (this.logger.debug("Chain ID is not set"), e = {
      ...e,
      chainId: this.contextService.getContext().chainId
    }), !e.gas && !e.maxFeePerGas && !e.maxPriorityFeePerGas && (this.logger.debug(
      "Gas or max fee per gas or max priority fee per gas is not set"
    ), e = await this.addFeesToTransaction(e)), e.nonce || (this.logger.debug("Nonce is not set"), e = await this.addNonceToTransaction(e)), this.logger.debug("Transaction completed", { completedTransaction: e }), e;
  }
};
oI = Que([
  ke(),
  Hf(0, H(Me.LoggerPublisher)),
  Hf(1, H(Ss.GasFeeEstimationService)),
  Hf(2, H(zt.StorageService)),
  Hf(3, H(gt.SignRawTransactionUseCase)),
  Hf(4, H(ci.ContextService))
], oI);
var ele = Object.getOwnPropertyDescriptor, tle = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? ele(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, Bc = (r, e) => (t, n) => e(t, n, r);
let aI = class {
  constructor(r, e, t, n, i, s, o) {
    h(this, "logger");
    h(this, "pendingStep", "");
    this.deviceManagementKitService = e, this.storageService = t, this.dappConfigService = n, this.config = i, this.trackTypedMessageStarted = s, this.trackTypedMessageCompleted = o, this.logger = r("[SignTypedData]");
  }
  execute(r) {
    this.logger.info("Starting transaction signing", { params: r });
    const [, e] = r;
    this.trackTypedMessageStarted.execute(e);
    const t = this.deviceManagementKitService.sessionId;
    if (!t)
      throw this.logger.error("No device connected"), new uo(
        "No device connected. Please connect a device first.",
        { type: "not-connected" }
      );
    if (!this.deviceManagementKitService.connectedDevice)
      throw this.logger.error("No connected device found"), new uo("No connected device found", {
        type: "not-connected"
      });
    const i = "typed-message", s = new fa({
      signType: i,
      status: "debugging",
      message: "Initializing transaction signing"
    });
    try {
      const o = this.deviceManagementKitService.dmk, a = new qC({
        dmk: o,
        originToken: this.config.originToken,
        sessionId: t
      }).build(), c = this.storageService.getSelectedAccount().extract();
      if (!c)
        throw new qI("No account selected");
      const u = rn(this.createOpenAppConfig()).pipe(
        cr(
          (d) => new T1({
            input: d,
            inspect: !1
          })
        )
      ), l = JC(c);
      return u.pipe(
        Qr(
          (d) => o.executeDeviceAction({
            sessionId: t,
            deviceAction: d
          }).observable
        ),
        fn(
          (d) => {
            var f;
            return d.status !== Oe.Pending || ((f = d.intermediateValue) == null ? void 0 : f.requiredUserInteraction) !== $e.None;
          }
        ),
        po((d) => {
          s.next(
            this.getTransactionResultForEvent(d, i)
          );
        }),
        fn((d) => d.status === Oe.Error || d.status === Oe.Completed),
        Qr((d) => {
          if (d.status === Oe.Error)
            throw new Error("Open app with dependencies failed");
          const { observable: f } = a.getAddress(
            l,
            {
              skipOpenApp: !0
            }
          );
          return f.pipe(
            fn((p) => p.status === Oe.Error || p.status === Oe.Completed)
          );
        }),
        Qr((d) => {
          if (d.status === Oe.Error)
            throw d.error;
          if (d.status === Oe.Completed && d.output.address.toLowerCase() !== c.freshAddress.toLowerCase())
            throw new WI("Address mismatch");
          s.next({
            signType: i,
            status: "debugging",
            message: "Starting Sign Typed Data DA"
          });
          const { observable: f } = a.signTypedData(
            l,
            e,
            {
              skipOpenApp: !0
            }
          );
          return f.pipe(
            po((p) => {
              var y;
              p.status === Oe.Pending && (this.pendingStep = ((y = p.intermediateValue) == null ? void 0 : y.step) ?? ""), p.status !== Oe.Completed && p.status !== Oe.Error && s.next(
                this.getTransactionResultForEvent(p, i)
              );
            })
          );
        }),
        fn(
          (d) => {
            var f;
            return d.status !== Oe.Pending || ((f = d.intermediateValue) == null ? void 0 : f.requiredUserInteraction) !== $e.None;
          }
        ),
        fn((d) => d.status === Oe.Error || d.status === Oe.Completed),
        cr((d) => {
          if (d.status === Oe.Error)
            switch (!0) {
              case (d.error instanceof Jh && d.error.errorCode === "6a80" && this.pendingStep === pi.BLIND_SIGN_TRANSACTION_FALLBACK):
                throw new kB("Blind signing disabled");
              case (d.error instanceof Jh && d.error.errorCode === "6985"):
                throw new ZI(
                  "User rejected transaction"
                );
              default:
                throw d.error;
            }
          return this.trackTypedMessageCompleted.execute(e), d;
        })
      ).subscribe({
        next: (d) => {
          s.next(
            this.getTransactionResultForEvent(d, i)
          );
        },
        error: (d) => {
          this.logger.error("Typed data signing failed", { error: d }), s.next({ signType: i, status: "error", error: d });
        }
      }), s.asObservable();
    } catch (o) {
      return console.error("Failed to sign typed data in SignTypedData", {
        error: o
      }), this.logger.error("Failed to sign typed data", { error: o }), Ji({
        signType: i,
        status: "error",
        error: o
      });
    }
  }
  async createOpenAppConfig() {
    const e = (await this.dappConfigService.getDAppConfig()).appDependencies.find(
      (t) => t.blockchain === "ethereum"
    );
    if (!e)
      throw new Error("Ethereum Blockchain dependencies not found");
    return {
      application: { name: e.appName },
      dependencies: e.dependencies.map((t) => ({
        name: t
      })),
      requireLatestFirmware: !1
      //TODO add this to the dApp config
    };
  }
  getTransactionResultForEvent(r, e) {
    var t, n;
    if (ZC(r))
      return {
        signType: e,
        status: "success",
        data: r
      };
    switch (r.status) {
      case Oe.Pending:
        switch ((t = r.intermediateValue) == null ? void 0 : t.requiredUserInteraction) {
          case "unlock-device":
            return {
              signType: e,
              status: "user-interaction-needed",
              interaction: "unlock-device"
            };
          case "allow-secure-connection":
            return {
              signType: e,
              status: "user-interaction-needed",
              interaction: "allow-secure-connection"
            };
          case "confirm-open-app":
            return {
              signType: e,
              status: "user-interaction-needed",
              interaction: "confirm-open-app"
            };
          case "sign-typed-data":
            return {
              signType: e,
              status: "user-interaction-needed",
              interaction: "sign-transaction"
            };
          case "allow-list-apps":
            return {
              signType: e,
              status: "user-interaction-needed",
              interaction: "allow-list-apps"
            };
          case "web3-checks-opt-in":
            return {
              signType: e,
              status: "user-interaction-needed",
              interaction: "web3-checks-opt-in"
            };
          default:
            return {
              signType: e,
              status: "debugging",
              message: `Unhandled user interaction: ${JSON.stringify((n = r.intermediateValue) == null ? void 0 : n.requiredUserInteraction)}`
            };
        }
      case Oe.Completed:
        return WC(r) ? {
          signType: e,
          status: "debugging",
          message: `Got address: ${r.output.address}`
        } : "deviceMetadata" in r.output ? (console.debug("Open app completed", { result: r }), {
          signType: e,
          status: "debugging",
          message: "App Opened"
        }) : {
          signType: e,
          status: "success",
          data: {
            signature: F6(r.output)
          }
        };
      case Oe.Error:
        return console.error("Error signing typed data in SignTypedData", {
          error: r.error.toString()
        }), {
          signType: e,
          status: "error",
          error: r.error
        };
      default:
        return {
          signType: e,
          status: "debugging",
          message: `DA status: ${r.status} - ${JSON.stringify(r)}`
        };
    }
  }
};
aI = tle([
  ke(),
  Bc(0, H(Me.LoggerPublisher)),
  Bc(1, H(gt.DeviceManagementKitService)),
  Bc(2, H(zt.StorageService)),
  Bc(3, H(mc.DAppConfigService)),
  Bc(4, H(Dt.Config)),
  Bc(5, H(rt.TrackTypedMessageStarted)),
  Bc(6, H(rt.TrackTypedMessageCompleted))
], aI);
var rle = Object.getOwnPropertyDescriptor, nle = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? rle(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, XP = (r, e) => (t, n) => e(t, n, r);
let cI = class {
  constructor(r, e) {
    h(this, "logger");
    this.deviceManagementKitService = e, this.logger = r("[SwitchDevice UseCase]");
  }
  async execute({ type: r }) {
    try {
      this.logger.info("Switching device", { type: r }), await this.deviceManagementKitService.disconnectFromDevice(), await this.deviceManagementKitService.connectToDevice({ type: r });
    } catch (e) {
      throw this.logger.error("Failed to switch device", { error: e }), e;
    }
  }
};
cI = nle([
  ke(),
  XP(0, H(Me.LoggerPublisher)),
  XP(1, H(gt.DeviceManagementKitService))
], cI);
function ile({ stub: r, dmkConfig: e }) {
  return new $r(({ bind: t, rebindSync: n }) => {
    t(gt.DmkConfig).toConstantValue(e), t(gt.DeviceManagementKitService).to(eA).inSingletonScope(), t(gt.ConnectDeviceUseCase).to(iA), t(gt.DisconnectDeviceUseCase).to(sA), t(gt.SwitchDeviceUseCase).to(cI), t(gt.SignRawTransactionUseCase).to(sI), t(gt.SignTransactionUseCase).to(oI), t(gt.BroadcastTransactionUseCase).to(
      nA
    ), t(gt.SignTypedDataUseCase).to(aI), t(gt.SignPersonalMessageUseCase).to(iI), t(gt.ListAvailableDevicesUseCase).to(
      oA
    ), r && n(gt.DeviceManagementKitService).to(
      tA
    );
  });
}
const H4 = /* @__PURE__ */ new Set([
  "BlindSigningDisabledError",
  "DeviceConnectionError",
  "SignTransactionError",
  "DeviceNotSupportedError",
  "DeviceDisconnectedError",
  "UserRejectedTransactionError",
  "LedgerKeyringProtocolError",
  "IncorrectSeedError",
  "LedgerSyncAuthenticationError",
  "LedgerSyncConnectionFailedError",
  "FailToOpenAppError",
  "AccountNotSelectedError",
  "LedgerSyncError",
  "LedgerSyncAuthContextMissingError",
  "LedgerSyncNoSessionIdError",
  "TransactionValidationError",
  "LedgerSyncConnectionError"
]);
function sle(r) {
  return H4.has(r);
}
const G4 = {
  enabled: !0,
  useWhitelist: !0,
  whitelist: H4
};
function Gr() {
  return crypto.randomUUID();
}
var ole = Object.defineProperty, ale = Object.getOwnPropertyDescriptor, cle = (r, e, t) => e in r ? ole(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, ule = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? ale(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, Gm = (r, e) => (t, n) => e(t, n, r), lle = (r, e, t) => cle(r, e + "", t);
let Yp = class {
  constructor(r, e, t, n) {
    h(this, "logger");
    h(this, "_sessionId");
    h(this, "eventQueue", []);
    h(this, "isFlushing", !1);
    this.backendService = r, this.config = e, this.contextService = n, this.logger = t("[Event Tracking]"), this._sessionId = Gr(), this.subscribeToContextChanges();
  }
  getSessionId() {
    return this._sessionId;
  }
  async trackEvent(r) {
    try {
      if (this.isAlwaysTrackedEvent(r)) {
        await this.processEvent(r);
        return;
      }
      const e = this.getConsentStatus();
      if (this.isFlushing && e === !0) {
        this.eventQueue.push(r), this.logger.debug("Event queued (queue flushing in progress)", { event: r });
        return;
      }
      if (e === !0) {
        await this.processEvent(r);
        return;
      }
      if (e === void 0) {
        this.eventQueue.push(r), this.logger.debug("Event queued (waiting for consent)", { event: r });
        return;
      }
      this.logger.debug("Event discarded (consent refused)", { event: r });
    } catch (e) {
      this.logger.error("Error tracking event", { error: e, event: r });
    }
  }
  isAlwaysTrackedEvent(r) {
    return Yp.ALWAYS_TRACKED_EVENTS.includes(
      r.type
    );
  }
  getConsentStatus() {
    return this.contextService.getContext().hasTrackingConsent;
  }
  async processEvent(r) {
    this.logger.info("Tracking event", { event: r }), (await this.backendService.event(
      r,
      this.config.dAppIdentifier
    )).caseOf({
      Left: (t) => {
        this.logger.error("Failed to track event", { error: t, event: r });
      },
      Right: (t) => {
        this.logger.debug("Event tracked successfully", { response: t });
      }
    });
  }
  subscribeToContextChanges() {
    this.contextService.observeContext().subscribe((r) => {
      r.hasTrackingConsent === !0 ? this.flushQueue() : r.hasTrackingConsent === !1 && this.clearQueue();
    });
  }
  async flushQueue() {
    if (this.eventQueue.length !== 0) {
      this.isFlushing = !0;
      try {
        const r = [...this.eventQueue];
        this.eventQueue = [], this.logger.info(`Flushing ${r.length} queued events`);
        for (const e of r)
          await this.processEvent(e);
        if (this.eventQueue.length > 0) {
          const e = [...this.eventQueue];
          this.eventQueue = [], this.logger.info(
            `Processing ${e.length} events queued during flush`
          );
          for (const t of e)
            await this.processEvent(t);
        }
      } finally {
        this.isFlushing = !1;
      }
    }
  }
  clearQueue() {
    const r = this.eventQueue.length;
    r > 0 && (this.logger.debug(`Clearing ${r} queued events (consent refused)`), this.eventQueue = []);
  }
};
lle(Yp, "ALWAYS_TRACKED_EVENTS", [
  ze.InvoicingTransactionSigned,
  ze.ErrorOccurred,
  ze.ConsentGiven
]);
Yp = ule([
  ke(),
  Gm(0, H(xc.BackendService)),
  Gm(1, H(Dt.Config)),
  Gm(2, H(Me.LoggerPublisher)),
  Gm(3, H(ci.ContextService))
], Yp);
var dle = Object.getOwnPropertyDescriptor, hle = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? dle(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
};
let uI = class {
  getSessionId() {
    return "session-id-123";
  }
  async trackEvent(r) {
    await new Promise((e) => setTimeout(e, 10));
  }
};
uI = hle([
  ke()
], uI);
const ya = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/, sl = /^[0-9a-f]+$/, fle = /^([1-9][0-9]*|0)$/, Do = my({
  event_id: ut().regex(ya, "Invalid UUID format"),
  transaction_dapp_id: ut(),
  timestamp_ms: PY().int().nonnegative()
}), ple = Do.extend(
  {
    event_type: Ts("invoicing_transaction_signed"),
    ledger_sync_user_id: ut().optional(),
    blockchain_network_selected: gf(["ethereum"]),
    transaction_hash: ut().regex(
      sl,
      "Transaction hash must be lowercase hex without 0x prefix"
    ),
    recipient_address: ut(),
    unsigned_transaction_hash: ut().regex(sl, "Sha256 hash without 0x prefix")
  }
), gle = Do.extend({
  event_type: Ts("consent_given")
}), mle = Do.extend({
  event_type: Ts("floating_button_clicked"),
  session_id: ut().regex(ya, "Invalid UUID format")
}), yle = Do.extend({
  event_type: Ts("open_session"),
  session_id: ut().regex(ya, "Invalid UUID format")
}), vle = Do.extend({
  event_type: Ts("open_ledger_sync"),
  session_id: ut().regex(ya, "Invalid UUID format")
}), ble = Do.extend({
  event_type: Ts("ledger_sync_activated"),
  session_id: ut().regex(ya, "Invalid UUID format"),
  ledger_sync_user_id: ut().optional()
}), wle = Do.extend({
  event_type: Ts("onboarding"),
  session_id: ut().regex(ya, "Invalid UUID format"),
  ledger_sync_user_id: ut().optional(),
  blockchain_network_selected: gf(["ethereum"]),
  account_currency: ut(),
  account_balance: ut().regex(
    fle,
    "Account balance must be a non-negative integer string"
  )
}), _le = Do.extend({
  event_type: Ts("transaction_flow_initialization"),
  session_id: ut().regex(ya, "Invalid UUID format"),
  ledger_sync_user_id: ut().optional(),
  blockchain_network_selected: gf(["ethereum"]),
  unsigned_transaction_hash: ut().regex(sl, "Sha256 hash without 0x prefix")
}), Sle = Do.extend({
  event_type: Ts("transaction_flow_completion"),
  session_id: ut().regex(ya, "Invalid UUID format"),
  ledger_sync_user_id: ut().optional(),
  blockchain_network_selected: gf(["ethereum"]),
  unsigned_transaction_hash: ut().regex(sl, "Sha256 hash without 0x prefix"),
  transaction_hash: ut().regex(
    sl,
    "Transaction hash must be lowercase hex without 0x prefix"
  )
}), Ele = Do.extend({
  event_type: Ts("session_authentication"),
  session_id: ut().regex(ya, "Invalid UUID format"),
  ledger_sync_user_id: ut().optional(),
  blockchain_network_selected: gf(["ethereum"]),
  unsigned_transaction_hash: ut().regex(
    sl,
    "Unsigned transaction hash must be lowercase hex without 0x prefix"
  ),
  transaction_type: Ts("authentication_tx"),
  transaction_hash: ut().regex(
    sl,
    "Transaction hash must be lowercase hex without 0x prefix"
  )
}), xle = jY("event_type", [
  ple,
  gle,
  mle,
  yle,
  vle,
  ble,
  wle,
  _le,
  Sle,
  Ele
]);
function Fi(r) {
  return r.toLowerCase().replace(/^0x/, "");
}
function K4(r) {
  const e = new TextEncoder().encode(r), t = It(e);
  return ga(t);
}
class ki {
  static validateEvent(e) {
    const t = xle.safeParse(e.data);
    return t.success ? { success: !0 } : {
      success: !1,
      errors: t.error.issues.map((n) => ({
        path: n.path.join("."),
        message: n.message
      }))
    };
  }
  static createOpenSessionEvent(e) {
    const t = {
      event_id: Gr(),
      transaction_dapp_id: e.dAppId,
      timestamp_ms: Date.now(),
      event_type: ze.OpenSession,
      session_id: e.sessionId
    };
    return {
      name: ze.OpenSession,
      type: ze.OpenSession,
      data: t
    };
  }
  static createOpenLedgerSyncEvent(e) {
    const t = {
      event_id: Gr(),
      transaction_dapp_id: e.dAppId,
      timestamp_ms: Date.now(),
      event_type: ze.OpenLedgerSync,
      session_id: e.sessionId
    };
    return {
      name: ze.OpenLedgerSync,
      type: ze.OpenLedgerSync,
      data: t
    };
  }
  static createLedgerSyncActivatedEvent(e) {
    const t = {
      event_id: Gr(),
      transaction_dapp_id: e.dAppId,
      timestamp_ms: Date.now(),
      event_type: ze.LedgerSyncActivated,
      session_id: e.sessionId,
      ledger_sync_user_id: e.trustChainId
    };
    return {
      name: ze.LedgerSyncActivated,
      type: ze.LedgerSyncActivated,
      data: t
    };
  }
  static createConsentGivenEvent(e) {
    const t = {
      event_id: Gr(),
      transaction_dapp_id: e.dAppId,
      timestamp_ms: Date.now(),
      event_type: ze.ConsentGiven
    };
    return {
      name: ze.ConsentGiven,
      type: ze.ConsentGiven,
      data: t
    };
  }
  static createFloatingButtonClickEvent(e) {
    const t = {
      event_id: Gr(),
      transaction_dapp_id: e.dAppId,
      timestamp_ms: Date.now(),
      event_type: ze.FloatingButtonClick,
      session_id: e.sessionId
    };
    return {
      name: ze.FloatingButtonClick,
      type: ze.FloatingButtonClick,
      data: t
    };
  }
  static createOnboardingEvent(e) {
    const t = {
      event_id: Gr(),
      transaction_dapp_id: e.dAppId,
      timestamp_ms: Date.now(),
      event_type: ze.Onboarding,
      session_id: e.sessionId,
      ledger_sync_user_id: e.trustChainId,
      blockchain_network_selected: "ethereum",
      chain_id: e.chainId,
      account_currency: e.accountCurrency,
      account_balance: e.accountBalance
    };
    return {
      name: ze.Onboarding,
      type: ze.Onboarding,
      data: t
    };
  }
  static createTransactionFlowInitializationEvent(e) {
    const t = {
      event_id: Gr(),
      transaction_dapp_id: e.dAppId,
      timestamp_ms: Date.now(),
      event_type: ze.TransactionFlowInitialization,
      session_id: e.sessionId,
      ledger_sync_user_id: e.trustChainId,
      blockchain_network_selected: "ethereum",
      unsigned_transaction_hash: Fi(
        e.unsignedTransactionHash
      ),
      chain_id: e.chainId
    };
    return {
      name: ze.TransactionFlowInitialization,
      type: ze.TransactionFlowInitialization,
      data: t
    };
  }
  static createTransactionFlowCompletionEvent(e) {
    const t = {
      event_id: Gr(),
      transaction_dapp_id: e.dAppId,
      timestamp_ms: Date.now(),
      event_type: ze.TransactionFlowCompletion,
      session_id: e.sessionId,
      ledger_sync_user_id: e.trustChainId,
      blockchain_network_selected: "ethereum",
      transaction_hash: Fi(e.transactionHash),
      unsigned_transaction_hash: Fi(
        e.unsignedTransactionHash
      ),
      chain_id: e.chainId
    };
    return {
      name: ze.TransactionFlowCompletion,
      type: ze.TransactionFlowCompletion,
      data: t
    };
  }
  static createSessionAuthenticationEvent(e) {
    const t = {
      event_id: Gr(),
      transaction_dapp_id: e.dAppId,
      timestamp_ms: Date.now(),
      event_type: ze.SessionAuthentication,
      session_id: e.sessionId,
      ledger_sync_user_id: e.trustChainId,
      blockchain_network_selected: "ethereum",
      unsigned_transaction_hash: Fi(
        e.unsignedTransactionHash
      ),
      transaction_type: "authentication_tx",
      transaction_hash: Fi(e.transactionHash)
    };
    return {
      name: ze.SessionAuthentication,
      type: ze.SessionAuthentication,
      data: t
    };
  }
  static createInvoicingTransactionSignedEvent(e) {
    const t = {
      event_id: Gr(),
      transaction_dapp_id: e.dAppId,
      timestamp_ms: Date.now(),
      event_type: ze.InvoicingTransactionSigned,
      ledger_sync_user_id: e.trustChainId,
      blockchain_network_selected: "ethereum",
      chain_id: e.chainId,
      transaction_hash: Fi(e.transactionHash),
      recipient_address: e.recipientAddress.toLowerCase(),
      unsigned_transaction_hash: Fi(
        e.unsignedTransactionHash
      )
    };
    return {
      name: ze.InvoicingTransactionSigned,
      type: ze.InvoicingTransactionSigned,
      data: t
    };
  }
  static createTypedMessageFlowInitializationEvent(e) {
    const t = {
      event_id: Gr(),
      transaction_dapp_id: e.dAppId,
      timestamp_ms: Date.now(),
      event_type: ze.TypedMessageFlowInitialization,
      session_id: e.sessionId,
      ledger_sync_user_id: e.trustChainId,
      blockchain_network_selected: "ethereum",
      chain_id: e.chainId,
      typed_message_hash: Fi(e.typedMessageHash)
    };
    return {
      name: ze.TypedMessageFlowInitialization,
      type: ze.TypedMessageFlowInitialization,
      data: t
    };
  }
  static createTypedMessageFlowCompletionEvent(e) {
    const t = {
      event_id: Gr(),
      transaction_dapp_id: e.dAppId,
      timestamp_ms: Date.now(),
      event_type: ze.TypedMessageFlowCompletion,
      session_id: e.sessionId,
      ledger_sync_user_id: e.trustChainId,
      blockchain_network_selected: "ethereum",
      chain_id: e.chainId,
      typed_message_hash: Fi(e.typedMessageHash)
    };
    return {
      name: ze.TypedMessageFlowCompletion,
      type: ze.TypedMessageFlowCompletion,
      data: t
    };
  }
  static createWalletActionClickedEvent(e) {
    const t = {
      event_id: Gr(),
      transaction_dapp_id: e.dAppId,
      timestamp_ms: Date.now(),
      event_type: ze.WalletActionClicked,
      session_id: e.sessionId,
      wallet_action: e.walletAction
    };
    return {
      name: ze.WalletActionClicked,
      type: ze.WalletActionClicked,
      data: t
    };
  }
  static createWalletRedirectConfirmedEvent(e) {
    const t = {
      event_id: Gr(),
      transaction_dapp_id: e.dAppId,
      timestamp_ms: Date.now(),
      event_type: ze.WalletRedirectConfirmed,
      session_id: e.sessionId,
      wallet_action: e.walletAction
    };
    return {
      name: ze.WalletRedirectConfirmed,
      type: ze.WalletRedirectConfirmed,
      data: t
    };
  }
  static createWalletRedirectCancelledEvent(e) {
    const t = {
      event_id: Gr(),
      transaction_dapp_id: e.dAppId,
      timestamp_ms: Date.now(),
      event_type: ze.WalletRedirectCancelled,
      session_id: e.sessionId,
      wallet_action: e.walletAction
    };
    return {
      name: ze.WalletRedirectCancelled,
      type: ze.WalletRedirectCancelled,
      data: t
    };
  }
}
var Ale = Object.getOwnPropertyDescriptor, Ile = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? Ale(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, L_ = (r, e) => (t, n) => e(t, n, r);
let lI = class {
  constructor(r, e, t) {
    h(this, "logger");
    this.eventTrackingService = e, this.config = t, this.logger = r("[TrackFloatingButtonClick UseCase]");
  }
  async execute() {
    const r = this.eventTrackingService.getSessionId(), e = ki.createFloatingButtonClickEvent({
      dAppId: this.config.dAppIdentifier,
      sessionId: r
    });
    this.logger.debug("Tracking floating button click event", { event: e }), await this.eventTrackingService.trackEvent(e);
  }
};
lI = Ile([
  ke(),
  L_(0, H(Me.LoggerPublisher)),
  L_(1, H(rt.EventTrackingService)),
  L_(2, H(Dt.Config))
], lI);
var Cle = Object.getOwnPropertyDescriptor, Dle = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? Cle(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, Km = (r, e) => (t, n) => e(t, n, r);
let dI = class {
  constructor(r, e, t, n) {
    h(this, "logger");
    this.eventTrackingService = e, this.config = t, this.contextService = n, this.logger = r("[TrackLedgerSyncActivated UseCase]");
  }
  async execute() {
    const r = this.eventTrackingService.getSessionId(), e = this.contextService.getContext().trustChainId, t = ki.createLedgerSyncActivatedEvent({
      dAppId: this.config.dAppIdentifier,
      sessionId: r,
      trustChainId: e
    });
    this.logger.debug("Tracking ledger sync activated event", { event: t }), await this.eventTrackingService.trackEvent(t);
  }
};
dI = Dle([
  ke(),
  Km(0, H(Me.LoggerPublisher)),
  Km(1, H(rt.EventTrackingService)),
  Km(2, H(Dt.Config)),
  Km(3, H(ci.ContextService))
], dI);
var Tle = Object.getOwnPropertyDescriptor, kle = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? Tle(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, U_ = (r, e) => (t, n) => e(t, n, r);
let hI = class {
  constructor(r, e, t) {
    h(this, "logger");
    this.eventTrackingService = e, this.config = t, this.logger = r("[TrackLedgerSyncOpened UseCase]");
  }
  async execute() {
    const r = this.eventTrackingService.getSessionId(), e = ki.createOpenLedgerSyncEvent({
      dAppId: this.config.dAppIdentifier,
      sessionId: r
    });
    this.logger.debug("Tracking ledger sync opened event", { event: e }), await this.eventTrackingService.trackEvent(e);
  }
};
hI = kle([
  ke(),
  U_(0, H(Me.LoggerPublisher)),
  U_(1, H(rt.EventTrackingService)),
  U_(2, H(Dt.Config))
], hI);
var Ole = Object.getOwnPropertyDescriptor, $le = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? Ole(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, qm = (r, e) => (t, n) => e(t, n, r);
let fI = class {
  constructor(r, e, t, n) {
    h(this, "logger");
    this.eventTrackingService = e, this.config = t, this.contextService = n, this.logger = r("[TrackOnboarding UseCase]");
  }
  async execute(r) {
    const e = this.eventTrackingService.getSessionId(), t = this.contextService.getContext().trustChainId, { currencyId: n, balance: i } = r, s = n, o = qg(n).toString(), a = ki.createOnboardingEvent({
      dAppId: this.config.dAppIdentifier,
      sessionId: e,
      trustChainId: t,
      accountCurrency: s,
      accountBalance: i ?? "",
      // Should always be defined when use here.
      chainId: o
    });
    this.logger.debug("Tracking ledger sync activated event", { event: a }), await this.eventTrackingService.trackEvent(a);
  }
};
fI = $le([
  ke(),
  qm(0, H(Me.LoggerPublisher)),
  qm(1, H(rt.EventTrackingService)),
  qm(2, H(Dt.Config)),
  qm(3, H(ci.ContextService))
], fI);
var Rle = Object.getOwnPropertyDescriptor, Ple = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? Rle(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, F_ = (r, e) => (t, n) => e(t, n, r);
let pI = class {
  constructor(r, e, t) {
    h(this, "logger");
    this.eventTrackingService = e, this.config = t, this.logger = r("[TrackOpenSession UseCase]");
  }
  async execute() {
    const r = this.eventTrackingService.getSessionId(), e = ki.createOpenSessionEvent({
      dAppId: this.config.dAppIdentifier,
      sessionId: r
    });
    this.logger.debug("Tracking open session event", { event: e }), await this.eventTrackingService.trackEvent(e);
  }
};
pI = Ple([
  ke(),
  F_(0, H(Me.LoggerPublisher)),
  F_(1, H(rt.EventTrackingService)),
  F_(2, H(Dt.Config))
], pI);
var Nle = Object.getOwnPropertyDescriptor, Ble = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? Nle(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, Wm = (r, e) => (t, n) => e(t, n, r);
let gI = class {
  constructor(r, e, t, n) {
    h(this, "logger");
    this.eventTrackingService = e, this.config = t, this.contextService = n, this.logger = r("[TrackTransactionCompleted UseCase]");
  }
  async execute(r, e) {
    this.logger.debug("Tracking transaction completed event");
    const t = this.eventTrackingService.getSessionId(), n = Fi(
      ga(r)
    ), i = this.contextService.getContext(), s = i.chainId.toString(), o = i.trustChainId, c = s0.from(r).to || "", u = Fi(e.hash), l = ki.createTransactionFlowCompletionEvent({
      dAppId: this.config.dAppIdentifier,
      sessionId: t,
      trustChainId: o,
      chainId: s,
      unsignedTransactionHash: n,
      transactionHash: u
    });
    await this.eventTrackingService.trackEvent(l);
    const d = ki.createInvoicingTransactionSignedEvent({
      dAppId: this.config.dAppIdentifier,
      sessionId: t,
      trustChainId: o,
      transactionHash: u,
      unsignedTransactionHash: n,
      chainId: s,
      recipientAddress: c
    });
    await this.eventTrackingService.trackEvent(d);
  }
};
gI = Ble([
  ke(),
  Wm(0, H(Me.LoggerPublisher)),
  Wm(1, H(rt.EventTrackingService)),
  Wm(2, H(Dt.Config)),
  Wm(3, H(ci.ContextService))
], gI);
var Lle = Object.getOwnPropertyDescriptor, Ule = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? Lle(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, Zm = (r, e) => (t, n) => e(t, n, r);
let mI = class {
  constructor(r, e, t, n) {
    h(this, "logger");
    this.eventTrackingService = e, this.config = t, this.contextService = n, this.logger = r("[TrackTransactionStarted UseCase]");
  }
  async execute(r) {
    const e = this.eventTrackingService.getSessionId(), t = Fi(
      ga(r)
    ), n = this.contextService.getContext(), i = n.chainId.toString(), s = n.trustChainId, o = ki.createTransactionFlowInitializationEvent({
      dAppId: this.config.dAppIdentifier,
      sessionId: e,
      trustChainId: s,
      unsignedTransactionHash: t,
      chainId: i
    });
    this.logger.debug("Tracking ledger sync activated event", { event: o }), await this.eventTrackingService.trackEvent(o);
  }
};
mI = Ule([
  ke(),
  Zm(0, H(Me.LoggerPublisher)),
  Zm(1, H(rt.EventTrackingService)),
  Zm(2, H(Dt.Config)),
  Zm(3, H(ci.ContextService))
], mI);
var Fle = Object.getOwnPropertyDescriptor, Mle = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? Fle(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, Jm = (r, e) => (t, n) => e(t, n, r);
let yI = class {
  constructor(r, e, t, n) {
    h(this, "logger");
    this.eventTrackingService = e, this.config = t, this.contextService = n, this.logger = r("[TrackTypedMessageCompleted UseCase]");
  }
  async execute(r) {
    const e = this.eventTrackingService.getSessionId(), t = K4(JSON.stringify(r)), n = this.contextService.getContext(), i = n.chainId.toString(), s = n.trustChainId, o = ki.createTypedMessageFlowCompletionEvent({
      dAppId: this.config.dAppIdentifier,
      sessionId: e,
      trustChainId: s,
      typedMessageHash: t,
      chainId: i
    });
    this.logger.debug("Tracking typed message flow completion event", {
      event: o
    }), await this.eventTrackingService.trackEvent(o);
  }
};
yI = Mle([
  ke(),
  Jm(0, H(Me.LoggerPublisher)),
  Jm(1, H(rt.EventTrackingService)),
  Jm(2, H(Dt.Config)),
  Jm(3, H(ci.ContextService))
], yI);
var Vle = Object.getOwnPropertyDescriptor, zle = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? Vle(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, Xm = (r, e) => (t, n) => e(t, n, r);
let vI = class {
  constructor(r, e, t, n) {
    h(this, "logger");
    this.eventTrackingService = e, this.config = t, this.contextService = n, this.logger = r("[TrackTypedMessageStarted UseCase]");
  }
  async execute(r) {
    const e = this.eventTrackingService.getSessionId(), t = K4(JSON.stringify(r)), n = this.contextService.getContext(), i = n.chainId.toString(), s = n.trustChainId, o = ki.createTypedMessageFlowInitializationEvent({
      dAppId: this.config.dAppIdentifier,
      sessionId: e,
      trustChainId: s,
      typedMessageHash: t,
      chainId: i
    });
    this.logger.debug("Tracking typed message flow initialization event", {
      event: o
    }), await this.eventTrackingService.trackEvent(o);
  }
};
vI = zle([
  ke(),
  Xm(0, H(Me.LoggerPublisher)),
  Xm(1, H(rt.EventTrackingService)),
  Xm(2, H(Dt.Config)),
  Xm(3, H(ci.ContextService))
], vI);
var jle = Object.getOwnPropertyDescriptor, Hle = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? jle(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, M_ = (r, e) => (t, n) => e(t, n, r);
let bI = class {
  constructor(r, e, t) {
    h(this, "logger");
    this.eventTrackingService = e, this.config = t, this.logger = r("[TrackWalletAction UseCase]");
  }
  async trackWalletActionClicked(r) {
    const e = this.eventTrackingService.getSessionId(), t = ki.createWalletActionClickedEvent({
      dAppId: this.config.dAppIdentifier,
      sessionId: e,
      walletAction: r
    });
    this.logger.debug("Tracking wallet action clicked event", { event: t }), await this.eventTrackingService.trackEvent(t);
  }
  async trackWalletRedirectConfirmed(r) {
    const e = this.eventTrackingService.getSessionId(), t = ki.createWalletRedirectConfirmedEvent({
      dAppId: this.config.dAppIdentifier,
      sessionId: e,
      walletAction: r
    });
    this.logger.debug("Tracking wallet redirect confirmed event", { event: t }), await this.eventTrackingService.trackEvent(t);
  }
  async trackWalletRedirectCancelled(r) {
    const e = this.eventTrackingService.getSessionId(), t = ki.createWalletRedirectCancelledEvent({
      dAppId: this.config.dAppIdentifier,
      sessionId: e,
      walletAction: r
    });
    this.logger.debug("Tracking wallet redirect cancelled event", { event: t }), await this.eventTrackingService.trackEvent(t);
  }
};
bI = Hle([
  ke(),
  M_(0, H(Me.LoggerPublisher)),
  M_(1, H(rt.EventTrackingService)),
  M_(2, H(Dt.Config))
], bI);
const Gle = ({
  stub: r = !1
} = {}) => new $r(({ bind: e }) => {
  if (r) {
    e(rt.EventTrackingService).to(uI).inSingletonScope();
    return;
  }
  e(rt.EventTrackingService).to(Yp).inSingletonScope(), e(
    rt.TrackFloatingButtonClick
  ).to(lI), e(rt.TrackOnboarding).to(
    fI
  ), e(
    rt.TrackTransactionStarted
  ).to(mI), e(
    rt.TrackTransactionCompleted
  ).to(gI), e(
    rt.TrackLedgerSyncOpened
  ).to(hI), e(rt.TrackOpenSession).to(
    pI
  ), e(
    rt.TrackLedgerSyncActivated
  ).to(dI), e(
    rt.TrackTypedMessageStarted
  ).to(vI), e(
    rt.TrackTypedMessageCompleted
  ).to(yI), e(rt.TrackWalletAction).to(
    bI
  );
});
/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
const Kle = 4, YP = 0, QP = 1, qle = 2;
function Sf(r) {
  let e = r.length;
  for (; --e >= 0; )
    r[e] = 0;
}
const Wle = 0, q4 = 1, Zle = 2, Jle = 3, Xle = 258, YC = 29, Qg = 256, Qp = Qg + 1 + YC, Ad = 30, QC = 19, W4 = 2 * Qp + 1, ru = 15, V_ = 16, Yle = 7, eD = 256, Z4 = 16, J4 = 17, X4 = 18, wI = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
), Ty = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
), Qle = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
), Y4 = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), ede = 512, zo = new Array((Qp + 2) * 2);
Sf(zo);
const Rp = new Array(Ad * 2);
Sf(Rp);
const eg = new Array(ede);
Sf(eg);
const tg = new Array(Xle - Jle + 1);
Sf(tg);
const tD = new Array(YC);
Sf(tD);
const fv = new Array(Ad);
Sf(fv);
function z_(r, e, t, n, i) {
  this.static_tree = r, this.extra_bits = e, this.extra_base = t, this.elems = n, this.max_length = i, this.has_stree = r && r.length;
}
let Q4, e8, t8;
function j_(r, e) {
  this.dyn_tree = r, this.max_code = 0, this.stat_desc = e;
}
const r8 = (r) => r < 256 ? eg[r] : eg[256 + (r >>> 7)], rg = (r, e) => {
  r.pending_buf[r.pending++] = e & 255, r.pending_buf[r.pending++] = e >>> 8 & 255;
}, ri = (r, e, t) => {
  r.bi_valid > V_ - t ? (r.bi_buf |= e << r.bi_valid & 65535, rg(r, r.bi_buf), r.bi_buf = e >> V_ - r.bi_valid, r.bi_valid += t - V_) : (r.bi_buf |= e << r.bi_valid & 65535, r.bi_valid += t);
}, ao = (r, e, t) => {
  ri(
    r,
    t[e * 2],
    t[e * 2 + 1]
    /*.Len*/
  );
}, n8 = (r, e) => {
  let t = 0;
  do
    t |= r & 1, r >>>= 1, t <<= 1;
  while (--e > 0);
  return t >>> 1;
}, tde = (r) => {
  r.bi_valid === 16 ? (rg(r, r.bi_buf), r.bi_buf = 0, r.bi_valid = 0) : r.bi_valid >= 8 && (r.pending_buf[r.pending++] = r.bi_buf & 255, r.bi_buf >>= 8, r.bi_valid -= 8);
}, rde = (r, e) => {
  const t = e.dyn_tree, n = e.max_code, i = e.stat_desc.static_tree, s = e.stat_desc.has_stree, o = e.stat_desc.extra_bits, a = e.stat_desc.extra_base, c = e.stat_desc.max_length;
  let u, l, d, f, p, y, g = 0;
  for (f = 0; f <= ru; f++)
    r.bl_count[f] = 0;
  for (t[r.heap[r.heap_max] * 2 + 1] = 0, u = r.heap_max + 1; u < W4; u++)
    l = r.heap[u], f = t[t[l * 2 + 1] * 2 + 1] + 1, f > c && (f = c, g++), t[l * 2 + 1] = f, !(l > n) && (r.bl_count[f]++, p = 0, l >= a && (p = o[l - a]), y = t[l * 2], r.opt_len += y * (f + p), s && (r.static_len += y * (i[l * 2 + 1] + p)));
  if (g !== 0) {
    do {
      for (f = c - 1; r.bl_count[f] === 0; )
        f--;
      r.bl_count[f]--, r.bl_count[f + 1] += 2, r.bl_count[c]--, g -= 2;
    } while (g > 0);
    for (f = c; f !== 0; f--)
      for (l = r.bl_count[f]; l !== 0; )
        d = r.heap[--u], !(d > n) && (t[d * 2 + 1] !== f && (r.opt_len += (f - t[d * 2 + 1]) * t[d * 2], t[d * 2 + 1] = f), l--);
  }
}, i8 = (r, e, t) => {
  const n = new Array(ru + 1);
  let i = 0, s, o;
  for (s = 1; s <= ru; s++)
    i = i + t[s - 1] << 1, n[s] = i;
  for (o = 0; o <= e; o++) {
    let a = r[o * 2 + 1];
    a !== 0 && (r[o * 2] = n8(n[a]++, a));
  }
}, nde = () => {
  let r, e, t, n, i;
  const s = new Array(ru + 1);
  for (t = 0, n = 0; n < YC - 1; n++)
    for (tD[n] = t, r = 0; r < 1 << wI[n]; r++)
      tg[t++] = n;
  for (tg[t - 1] = n, i = 0, n = 0; n < 16; n++)
    for (fv[n] = i, r = 0; r < 1 << Ty[n]; r++)
      eg[i++] = n;
  for (i >>= 7; n < Ad; n++)
    for (fv[n] = i << 7, r = 0; r < 1 << Ty[n] - 7; r++)
      eg[256 + i++] = n;
  for (e = 0; e <= ru; e++)
    s[e] = 0;
  for (r = 0; r <= 143; )
    zo[r * 2 + 1] = 8, r++, s[8]++;
  for (; r <= 255; )
    zo[r * 2 + 1] = 9, r++, s[9]++;
  for (; r <= 279; )
    zo[r * 2 + 1] = 7, r++, s[7]++;
  for (; r <= 287; )
    zo[r * 2 + 1] = 8, r++, s[8]++;
  for (i8(zo, Qp + 1, s), r = 0; r < Ad; r++)
    Rp[r * 2 + 1] = 5, Rp[r * 2] = n8(r, 5);
  Q4 = new z_(zo, wI, Qg + 1, Qp, ru), e8 = new z_(Rp, Ty, 0, Ad, ru), t8 = new z_(new Array(0), Qle, 0, QC, Yle);
}, s8 = (r) => {
  let e;
  for (e = 0; e < Qp; e++)
    r.dyn_ltree[e * 2] = 0;
  for (e = 0; e < Ad; e++)
    r.dyn_dtree[e * 2] = 0;
  for (e = 0; e < QC; e++)
    r.bl_tree[e * 2] = 0;
  r.dyn_ltree[eD * 2] = 1, r.opt_len = r.static_len = 0, r.sym_next = r.matches = 0;
}, o8 = (r) => {
  r.bi_valid > 8 ? rg(r, r.bi_buf) : r.bi_valid > 0 && (r.pending_buf[r.pending++] = r.bi_buf), r.bi_buf = 0, r.bi_valid = 0;
}, eN = (r, e, t, n) => {
  const i = e * 2, s = t * 2;
  return r[i] < r[s] || r[i] === r[s] && n[e] <= n[t];
}, H_ = (r, e, t) => {
  const n = r.heap[t];
  let i = t << 1;
  for (; i <= r.heap_len && (i < r.heap_len && eN(e, r.heap[i + 1], r.heap[i], r.depth) && i++, !eN(e, n, r.heap[i], r.depth)); )
    r.heap[t] = r.heap[i], t = i, i <<= 1;
  r.heap[t] = n;
}, tN = (r, e, t) => {
  let n, i, s = 0, o, a;
  if (r.sym_next !== 0)
    do
      n = r.pending_buf[r.sym_buf + s++] & 255, n += (r.pending_buf[r.sym_buf + s++] & 255) << 8, i = r.pending_buf[r.sym_buf + s++], n === 0 ? ao(r, i, e) : (o = tg[i], ao(r, o + Qg + 1, e), a = wI[o], a !== 0 && (i -= tD[o], ri(r, i, a)), n--, o = r8(n), ao(r, o, t), a = Ty[o], a !== 0 && (n -= fv[o], ri(r, n, a)));
    while (s < r.sym_next);
  ao(r, eD, e);
}, _I = (r, e) => {
  const t = e.dyn_tree, n = e.stat_desc.static_tree, i = e.stat_desc.has_stree, s = e.stat_desc.elems;
  let o, a, c = -1, u;
  for (r.heap_len = 0, r.heap_max = W4, o = 0; o < s; o++)
    t[o * 2] !== 0 ? (r.heap[++r.heap_len] = c = o, r.depth[o] = 0) : t[o * 2 + 1] = 0;
  for (; r.heap_len < 2; )
    u = r.heap[++r.heap_len] = c < 2 ? ++c : 0, t[u * 2] = 1, r.depth[u] = 0, r.opt_len--, i && (r.static_len -= n[u * 2 + 1]);
  for (e.max_code = c, o = r.heap_len >> 1; o >= 1; o--)
    H_(r, t, o);
  u = s;
  do
    o = r.heap[
      1
      /*SMALLEST*/
    ], r.heap[
      1
      /*SMALLEST*/
    ] = r.heap[r.heap_len--], H_(
      r,
      t,
      1
      /*SMALLEST*/
    ), a = r.heap[
      1
      /*SMALLEST*/
    ], r.heap[--r.heap_max] = o, r.heap[--r.heap_max] = a, t[u * 2] = t[o * 2] + t[a * 2], r.depth[u] = (r.depth[o] >= r.depth[a] ? r.depth[o] : r.depth[a]) + 1, t[o * 2 + 1] = t[a * 2 + 1] = u, r.heap[
      1
      /*SMALLEST*/
    ] = u++, H_(
      r,
      t,
      1
      /*SMALLEST*/
    );
  while (r.heap_len >= 2);
  r.heap[--r.heap_max] = r.heap[
    1
    /*SMALLEST*/
  ], rde(r, e), i8(t, c, r.bl_count);
}, rN = (r, e, t) => {
  let n, i = -1, s, o = e[1], a = 0, c = 7, u = 4;
  for (o === 0 && (c = 138, u = 3), e[(t + 1) * 2 + 1] = 65535, n = 0; n <= t; n++)
    s = o, o = e[(n + 1) * 2 + 1], !(++a < c && s === o) && (a < u ? r.bl_tree[s * 2] += a : s !== 0 ? (s !== i && r.bl_tree[s * 2]++, r.bl_tree[Z4 * 2]++) : a <= 10 ? r.bl_tree[J4 * 2]++ : r.bl_tree[X4 * 2]++, a = 0, i = s, o === 0 ? (c = 138, u = 3) : s === o ? (c = 6, u = 3) : (c = 7, u = 4));
}, nN = (r, e, t) => {
  let n, i = -1, s, o = e[1], a = 0, c = 7, u = 4;
  for (o === 0 && (c = 138, u = 3), n = 0; n <= t; n++)
    if (s = o, o = e[(n + 1) * 2 + 1], !(++a < c && s === o)) {
      if (a < u)
        do
          ao(r, s, r.bl_tree);
        while (--a !== 0);
      else s !== 0 ? (s !== i && (ao(r, s, r.bl_tree), a--), ao(r, Z4, r.bl_tree), ri(r, a - 3, 2)) : a <= 10 ? (ao(r, J4, r.bl_tree), ri(r, a - 3, 3)) : (ao(r, X4, r.bl_tree), ri(r, a - 11, 7));
      a = 0, i = s, o === 0 ? (c = 138, u = 3) : s === o ? (c = 6, u = 3) : (c = 7, u = 4);
    }
}, ide = (r) => {
  let e;
  for (rN(r, r.dyn_ltree, r.l_desc.max_code), rN(r, r.dyn_dtree, r.d_desc.max_code), _I(r, r.bl_desc), e = QC - 1; e >= 3 && r.bl_tree[Y4[e] * 2 + 1] === 0; e--)
    ;
  return r.opt_len += 3 * (e + 1) + 5 + 5 + 4, e;
}, sde = (r, e, t, n) => {
  let i;
  for (ri(r, e - 257, 5), ri(r, t - 1, 5), ri(r, n - 4, 4), i = 0; i < n; i++)
    ri(r, r.bl_tree[Y4[i] * 2 + 1], 3);
  nN(r, r.dyn_ltree, e - 1), nN(r, r.dyn_dtree, t - 1);
}, ode = (r) => {
  let e = 4093624447, t;
  for (t = 0; t <= 31; t++, e >>>= 1)
    if (e & 1 && r.dyn_ltree[t * 2] !== 0)
      return YP;
  if (r.dyn_ltree[18] !== 0 || r.dyn_ltree[20] !== 0 || r.dyn_ltree[26] !== 0)
    return QP;
  for (t = 32; t < Qg; t++)
    if (r.dyn_ltree[t * 2] !== 0)
      return QP;
  return YP;
};
let iN = !1;
const ade = (r) => {
  iN || (nde(), iN = !0), r.l_desc = new j_(r.dyn_ltree, Q4), r.d_desc = new j_(r.dyn_dtree, e8), r.bl_desc = new j_(r.bl_tree, t8), r.bi_buf = 0, r.bi_valid = 0, s8(r);
}, a8 = (r, e, t, n) => {
  ri(r, (Wle << 1) + (n ? 1 : 0), 3), o8(r), rg(r, t), rg(r, ~t), t && r.pending_buf.set(r.window.subarray(e, e + t), r.pending), r.pending += t;
}, cde = (r) => {
  ri(r, q4 << 1, 3), ao(r, eD, zo), tde(r);
}, ude = (r, e, t, n) => {
  let i, s, o = 0;
  r.level > 0 ? (r.strm.data_type === qle && (r.strm.data_type = ode(r)), _I(r, r.l_desc), _I(r, r.d_desc), o = ide(r), i = r.opt_len + 3 + 7 >>> 3, s = r.static_len + 3 + 7 >>> 3, s <= i && (i = s)) : i = s = t + 5, t + 4 <= i && e !== -1 ? a8(r, e, t, n) : r.strategy === Kle || s === i ? (ri(r, (q4 << 1) + (n ? 1 : 0), 3), tN(r, zo, Rp)) : (ri(r, (Zle << 1) + (n ? 1 : 0), 3), sde(r, r.l_desc.max_code + 1, r.d_desc.max_code + 1, o + 1), tN(r, r.dyn_ltree, r.dyn_dtree)), s8(r), n && o8(r);
}, lde = (r, e, t) => (r.pending_buf[r.sym_buf + r.sym_next++] = e, r.pending_buf[r.sym_buf + r.sym_next++] = e >> 8, r.pending_buf[r.sym_buf + r.sym_next++] = t, e === 0 ? r.dyn_ltree[t * 2]++ : (r.matches++, e--, r.dyn_ltree[(tg[t] + Qg + 1) * 2]++, r.dyn_dtree[r8(e) * 2]++), r.sym_next === r.sym_end);
var dde = ade, hde = a8, fde = ude, pde = lde, gde = cde, mde = {
  _tr_init: dde,
  _tr_stored_block: hde,
  _tr_flush_block: fde,
  _tr_tally: pde,
  _tr_align: gde
};
const yde = (r, e, t, n) => {
  let i = r & 65535 | 0, s = r >>> 16 & 65535 | 0, o = 0;
  for (; t !== 0; ) {
    o = t > 2e3 ? 2e3 : t, t -= o;
    do
      i = i + e[n++] | 0, s = s + i | 0;
    while (--o);
    i %= 65521, s %= 65521;
  }
  return i | s << 16 | 0;
};
var ng = yde;
const vde = () => {
  let r, e = [];
  for (var t = 0; t < 256; t++) {
    r = t;
    for (var n = 0; n < 8; n++)
      r = r & 1 ? 3988292384 ^ r >>> 1 : r >>> 1;
    e[t] = r;
  }
  return e;
}, bde = new Uint32Array(vde()), wde = (r, e, t, n) => {
  const i = bde, s = n + t;
  r ^= -1;
  for (let o = n; o < s; o++)
    r = r >>> 8 ^ i[(r ^ e[o]) & 255];
  return r ^ -1;
};
var Lr = wde, ol = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
}, em = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const { _tr_init: _de, _tr_stored_block: SI, _tr_flush_block: Sde, _tr_tally: dc, _tr_align: Ede } = mde, {
  Z_NO_FLUSH: hc,
  Z_PARTIAL_FLUSH: xde,
  Z_FULL_FLUSH: Ade,
  Z_FINISH: Hi,
  Z_BLOCK: sN,
  Z_OK: qr,
  Z_STREAM_END: oN,
  Z_STREAM_ERROR: vo,
  Z_DATA_ERROR: Ide,
  Z_BUF_ERROR: G_,
  Z_DEFAULT_COMPRESSION: Cde,
  Z_FILTERED: Dde,
  Z_HUFFMAN_ONLY: Ym,
  Z_RLE: Tde,
  Z_FIXED: kde,
  Z_DEFAULT_STRATEGY: Ode,
  Z_UNKNOWN: $de,
  Z_DEFLATED: D0
} = em, Rde = 9, Pde = 15, Nde = 8, Bde = 29, Lde = 256, EI = Lde + 1 + Bde, Ude = 30, Fde = 19, Mde = 2 * EI + 1, Vde = 15, ct = 3, sc = 258, bo = sc + ct + 1, zde = 32, Qh = 42, rD = 57, xI = 69, AI = 73, II = 91, CI = 103, nu = 113, Sp = 666, kn = 1, Ef = 2, al = 3, xf = 4, jde = 3, iu = (r, e) => (r.msg = ol[e], e), aN = (r) => r * 2 - (r > 4 ? 9 : 0), La = (r) => {
  let e = r.length;
  for (; --e >= 0; )
    r[e] = 0;
}, Hde = (r) => {
  let e, t, n, i = r.w_size;
  e = r.hash_size, n = e;
  do
    t = r.head[--n], r.head[n] = t >= i ? t - i : 0;
  while (--e);
  e = i, n = e;
  do
    t = r.prev[--n], r.prev[n] = t >= i ? t - i : 0;
  while (--e);
};
let Gde = (r, e, t) => (e << r.hash_shift ^ t) & r.hash_mask, fc = Gde;
const gi = (r) => {
  const e = r.state;
  let t = e.pending;
  t > r.avail_out && (t = r.avail_out), t !== 0 && (r.output.set(e.pending_buf.subarray(e.pending_out, e.pending_out + t), r.next_out), r.next_out += t, e.pending_out += t, r.total_out += t, r.avail_out -= t, e.pending -= t, e.pending === 0 && (e.pending_out = 0));
}, Ci = (r, e) => {
  Sde(r, r.block_start >= 0 ? r.block_start : -1, r.strstart - r.block_start, e), r.block_start = r.strstart, gi(r.strm);
}, St = (r, e) => {
  r.pending_buf[r.pending++] = e;
}, Gf = (r, e) => {
  r.pending_buf[r.pending++] = e >>> 8 & 255, r.pending_buf[r.pending++] = e & 255;
}, DI = (r, e, t, n) => {
  let i = r.avail_in;
  return i > n && (i = n), i === 0 ? 0 : (r.avail_in -= i, e.set(r.input.subarray(r.next_in, r.next_in + i), t), r.state.wrap === 1 ? r.adler = ng(r.adler, e, i, t) : r.state.wrap === 2 && (r.adler = Lr(r.adler, e, i, t)), r.next_in += i, r.total_in += i, i);
}, c8 = (r, e) => {
  let t = r.max_chain_length, n = r.strstart, i, s, o = r.prev_length, a = r.nice_match;
  const c = r.strstart > r.w_size - bo ? r.strstart - (r.w_size - bo) : 0, u = r.window, l = r.w_mask, d = r.prev, f = r.strstart + sc;
  let p = u[n + o - 1], y = u[n + o];
  r.prev_length >= r.good_match && (t >>= 2), a > r.lookahead && (a = r.lookahead);
  do
    if (i = e, !(u[i + o] !== y || u[i + o - 1] !== p || u[i] !== u[n] || u[++i] !== u[n + 1])) {
      n += 2, i++;
      do
        ;
      while (u[++n] === u[++i] && u[++n] === u[++i] && u[++n] === u[++i] && u[++n] === u[++i] && u[++n] === u[++i] && u[++n] === u[++i] && u[++n] === u[++i] && u[++n] === u[++i] && n < f);
      if (s = sc - (f - n), n = f - sc, s > o) {
        if (r.match_start = e, o = s, s >= a)
          break;
        p = u[n + o - 1], y = u[n + o];
      }
    }
  while ((e = d[e & l]) > c && --t !== 0);
  return o <= r.lookahead ? o : r.lookahead;
}, ef = (r) => {
  const e = r.w_size;
  let t, n, i;
  do {
    if (n = r.window_size - r.lookahead - r.strstart, r.strstart >= e + (e - bo) && (r.window.set(r.window.subarray(e, e + e - n), 0), r.match_start -= e, r.strstart -= e, r.block_start -= e, r.insert > r.strstart && (r.insert = r.strstart), Hde(r), n += e), r.strm.avail_in === 0)
      break;
    if (t = DI(r.strm, r.window, r.strstart + r.lookahead, n), r.lookahead += t, r.lookahead + r.insert >= ct)
      for (i = r.strstart - r.insert, r.ins_h = r.window[i], r.ins_h = fc(r, r.ins_h, r.window[i + 1]); r.insert && (r.ins_h = fc(r, r.ins_h, r.window[i + ct - 1]), r.prev[i & r.w_mask] = r.head[r.ins_h], r.head[r.ins_h] = i, i++, r.insert--, !(r.lookahead + r.insert < ct)); )
        ;
  } while (r.lookahead < bo && r.strm.avail_in !== 0);
}, u8 = (r, e) => {
  let t = r.pending_buf_size - 5 > r.w_size ? r.w_size : r.pending_buf_size - 5, n, i, s, o = 0, a = r.strm.avail_in;
  do {
    if (n = 65535, s = r.bi_valid + 42 >> 3, r.strm.avail_out < s || (s = r.strm.avail_out - s, i = r.strstart - r.block_start, n > i + r.strm.avail_in && (n = i + r.strm.avail_in), n > s && (n = s), n < t && (n === 0 && e !== Hi || e === hc || n !== i + r.strm.avail_in)))
      break;
    o = e === Hi && n === i + r.strm.avail_in ? 1 : 0, SI(r, 0, 0, o), r.pending_buf[r.pending - 4] = n, r.pending_buf[r.pending - 3] = n >> 8, r.pending_buf[r.pending - 2] = ~n, r.pending_buf[r.pending - 1] = ~n >> 8, gi(r.strm), i && (i > n && (i = n), r.strm.output.set(r.window.subarray(r.block_start, r.block_start + i), r.strm.next_out), r.strm.next_out += i, r.strm.avail_out -= i, r.strm.total_out += i, r.block_start += i, n -= i), n && (DI(r.strm, r.strm.output, r.strm.next_out, n), r.strm.next_out += n, r.strm.avail_out -= n, r.strm.total_out += n);
  } while (o === 0);
  return a -= r.strm.avail_in, a && (a >= r.w_size ? (r.matches = 2, r.window.set(r.strm.input.subarray(r.strm.next_in - r.w_size, r.strm.next_in), 0), r.strstart = r.w_size, r.insert = r.strstart) : (r.window_size - r.strstart <= a && (r.strstart -= r.w_size, r.window.set(r.window.subarray(r.w_size, r.w_size + r.strstart), 0), r.matches < 2 && r.matches++, r.insert > r.strstart && (r.insert = r.strstart)), r.window.set(r.strm.input.subarray(r.strm.next_in - a, r.strm.next_in), r.strstart), r.strstart += a, r.insert += a > r.w_size - r.insert ? r.w_size - r.insert : a), r.block_start = r.strstart), r.high_water < r.strstart && (r.high_water = r.strstart), o ? xf : e !== hc && e !== Hi && r.strm.avail_in === 0 && r.strstart === r.block_start ? Ef : (s = r.window_size - r.strstart, r.strm.avail_in > s && r.block_start >= r.w_size && (r.block_start -= r.w_size, r.strstart -= r.w_size, r.window.set(r.window.subarray(r.w_size, r.w_size + r.strstart), 0), r.matches < 2 && r.matches++, s += r.w_size, r.insert > r.strstart && (r.insert = r.strstart)), s > r.strm.avail_in && (s = r.strm.avail_in), s && (DI(r.strm, r.window, r.strstart, s), r.strstart += s, r.insert += s > r.w_size - r.insert ? r.w_size - r.insert : s), r.high_water < r.strstart && (r.high_water = r.strstart), s = r.bi_valid + 42 >> 3, s = r.pending_buf_size - s > 65535 ? 65535 : r.pending_buf_size - s, t = s > r.w_size ? r.w_size : s, i = r.strstart - r.block_start, (i >= t || (i || e === Hi) && e !== hc && r.strm.avail_in === 0 && i <= s) && (n = i > s ? s : i, o = e === Hi && r.strm.avail_in === 0 && n === i ? 1 : 0, SI(r, r.block_start, n, o), r.block_start += n, gi(r.strm)), o ? al : kn);
}, K_ = (r, e) => {
  let t, n;
  for (; ; ) {
    if (r.lookahead < bo) {
      if (ef(r), r.lookahead < bo && e === hc)
        return kn;
      if (r.lookahead === 0)
        break;
    }
    if (t = 0, r.lookahead >= ct && (r.ins_h = fc(r, r.ins_h, r.window[r.strstart + ct - 1]), t = r.prev[r.strstart & r.w_mask] = r.head[r.ins_h], r.head[r.ins_h] = r.strstart), t !== 0 && r.strstart - t <= r.w_size - bo && (r.match_length = c8(r, t)), r.match_length >= ct)
      if (n = dc(r, r.strstart - r.match_start, r.match_length - ct), r.lookahead -= r.match_length, r.match_length <= r.max_lazy_match && r.lookahead >= ct) {
        r.match_length--;
        do
          r.strstart++, r.ins_h = fc(r, r.ins_h, r.window[r.strstart + ct - 1]), t = r.prev[r.strstart & r.w_mask] = r.head[r.ins_h], r.head[r.ins_h] = r.strstart;
        while (--r.match_length !== 0);
        r.strstart++;
      } else
        r.strstart += r.match_length, r.match_length = 0, r.ins_h = r.window[r.strstart], r.ins_h = fc(r, r.ins_h, r.window[r.strstart + 1]);
    else
      n = dc(r, 0, r.window[r.strstart]), r.lookahead--, r.strstart++;
    if (n && (Ci(r, !1), r.strm.avail_out === 0))
      return kn;
  }
  return r.insert = r.strstart < ct - 1 ? r.strstart : ct - 1, e === Hi ? (Ci(r, !0), r.strm.avail_out === 0 ? al : xf) : r.sym_next && (Ci(r, !1), r.strm.avail_out === 0) ? kn : Ef;
}, Bl = (r, e) => {
  let t, n, i;
  for (; ; ) {
    if (r.lookahead < bo) {
      if (ef(r), r.lookahead < bo && e === hc)
        return kn;
      if (r.lookahead === 0)
        break;
    }
    if (t = 0, r.lookahead >= ct && (r.ins_h = fc(r, r.ins_h, r.window[r.strstart + ct - 1]), t = r.prev[r.strstart & r.w_mask] = r.head[r.ins_h], r.head[r.ins_h] = r.strstart), r.prev_length = r.match_length, r.prev_match = r.match_start, r.match_length = ct - 1, t !== 0 && r.prev_length < r.max_lazy_match && r.strstart - t <= r.w_size - bo && (r.match_length = c8(r, t), r.match_length <= 5 && (r.strategy === Dde || r.match_length === ct && r.strstart - r.match_start > 4096) && (r.match_length = ct - 1)), r.prev_length >= ct && r.match_length <= r.prev_length) {
      i = r.strstart + r.lookahead - ct, n = dc(r, r.strstart - 1 - r.prev_match, r.prev_length - ct), r.lookahead -= r.prev_length - 1, r.prev_length -= 2;
      do
        ++r.strstart <= i && (r.ins_h = fc(r, r.ins_h, r.window[r.strstart + ct - 1]), t = r.prev[r.strstart & r.w_mask] = r.head[r.ins_h], r.head[r.ins_h] = r.strstart);
      while (--r.prev_length !== 0);
      if (r.match_available = 0, r.match_length = ct - 1, r.strstart++, n && (Ci(r, !1), r.strm.avail_out === 0))
        return kn;
    } else if (r.match_available) {
      if (n = dc(r, 0, r.window[r.strstart - 1]), n && Ci(r, !1), r.strstart++, r.lookahead--, r.strm.avail_out === 0)
        return kn;
    } else
      r.match_available = 1, r.strstart++, r.lookahead--;
  }
  return r.match_available && (n = dc(r, 0, r.window[r.strstart - 1]), r.match_available = 0), r.insert = r.strstart < ct - 1 ? r.strstart : ct - 1, e === Hi ? (Ci(r, !0), r.strm.avail_out === 0 ? al : xf) : r.sym_next && (Ci(r, !1), r.strm.avail_out === 0) ? kn : Ef;
}, Kde = (r, e) => {
  let t, n, i, s;
  const o = r.window;
  for (; ; ) {
    if (r.lookahead <= sc) {
      if (ef(r), r.lookahead <= sc && e === hc)
        return kn;
      if (r.lookahead === 0)
        break;
    }
    if (r.match_length = 0, r.lookahead >= ct && r.strstart > 0 && (i = r.strstart - 1, n = o[i], n === o[++i] && n === o[++i] && n === o[++i])) {
      s = r.strstart + sc;
      do
        ;
      while (n === o[++i] && n === o[++i] && n === o[++i] && n === o[++i] && n === o[++i] && n === o[++i] && n === o[++i] && n === o[++i] && i < s);
      r.match_length = sc - (s - i), r.match_length > r.lookahead && (r.match_length = r.lookahead);
    }
    if (r.match_length >= ct ? (t = dc(r, 1, r.match_length - ct), r.lookahead -= r.match_length, r.strstart += r.match_length, r.match_length = 0) : (t = dc(r, 0, r.window[r.strstart]), r.lookahead--, r.strstart++), t && (Ci(r, !1), r.strm.avail_out === 0))
      return kn;
  }
  return r.insert = 0, e === Hi ? (Ci(r, !0), r.strm.avail_out === 0 ? al : xf) : r.sym_next && (Ci(r, !1), r.strm.avail_out === 0) ? kn : Ef;
}, qde = (r, e) => {
  let t;
  for (; ; ) {
    if (r.lookahead === 0 && (ef(r), r.lookahead === 0)) {
      if (e === hc)
        return kn;
      break;
    }
    if (r.match_length = 0, t = dc(r, 0, r.window[r.strstart]), r.lookahead--, r.strstart++, t && (Ci(r, !1), r.strm.avail_out === 0))
      return kn;
  }
  return r.insert = 0, e === Hi ? (Ci(r, !0), r.strm.avail_out === 0 ? al : xf) : r.sym_next && (Ci(r, !1), r.strm.avail_out === 0) ? kn : Ef;
};
function zs(r, e, t, n, i) {
  this.good_length = r, this.max_lazy = e, this.nice_length = t, this.max_chain = n, this.func = i;
}
const Ep = [
  /*      good lazy nice chain */
  new zs(0, 0, 0, 0, u8),
  /* 0 store only */
  new zs(4, 4, 8, 4, K_),
  /* 1 max speed, no lazy matches */
  new zs(4, 5, 16, 8, K_),
  /* 2 */
  new zs(4, 6, 32, 32, K_),
  /* 3 */
  new zs(4, 4, 16, 16, Bl),
  /* 4 lazy matches */
  new zs(8, 16, 32, 32, Bl),
  /* 5 */
  new zs(8, 16, 128, 128, Bl),
  /* 6 */
  new zs(8, 32, 128, 256, Bl),
  /* 7 */
  new zs(32, 128, 258, 1024, Bl),
  /* 8 */
  new zs(32, 258, 258, 4096, Bl)
  /* 9 max compression */
], Wde = (r) => {
  r.window_size = 2 * r.w_size, La(r.head), r.max_lazy_match = Ep[r.level].max_lazy, r.good_match = Ep[r.level].good_length, r.nice_match = Ep[r.level].nice_length, r.max_chain_length = Ep[r.level].max_chain, r.strstart = 0, r.block_start = 0, r.lookahead = 0, r.insert = 0, r.match_length = r.prev_length = ct - 1, r.match_available = 0, r.ins_h = 0;
};
function Zde() {
  this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = D0, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(Mde * 2), this.dyn_dtree = new Uint16Array((2 * Ude + 1) * 2), this.bl_tree = new Uint16Array((2 * Fde + 1) * 2), La(this.dyn_ltree), La(this.dyn_dtree), La(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(Vde + 1), this.heap = new Uint16Array(2 * EI + 1), La(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * EI + 1), La(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
}
const tm = (r) => {
  if (!r)
    return 1;
  const e = r.state;
  return !e || e.strm !== r || e.status !== Qh && //#ifdef GZIP
  e.status !== rD && //#endif
  e.status !== xI && e.status !== AI && e.status !== II && e.status !== CI && e.status !== nu && e.status !== Sp ? 1 : 0;
}, l8 = (r) => {
  if (tm(r))
    return iu(r, vo);
  r.total_in = r.total_out = 0, r.data_type = $de;
  const e = r.state;
  return e.pending = 0, e.pending_out = 0, e.wrap < 0 && (e.wrap = -e.wrap), e.status = //#ifdef GZIP
  e.wrap === 2 ? rD : (
    //#endif
    e.wrap ? Qh : nu
  ), r.adler = e.wrap === 2 ? 0 : 1, e.last_flush = -2, _de(e), qr;
}, d8 = (r) => {
  const e = l8(r);
  return e === qr && Wde(r.state), e;
}, Jde = (r, e) => tm(r) || r.state.wrap !== 2 ? vo : (r.state.gzhead = e, qr), h8 = (r, e, t, n, i, s) => {
  if (!r)
    return vo;
  let o = 1;
  if (e === Cde && (e = 6), n < 0 ? (o = 0, n = -n) : n > 15 && (o = 2, n -= 16), i < 1 || i > Rde || t !== D0 || n < 8 || n > 15 || e < 0 || e > 9 || s < 0 || s > kde || n === 8 && o !== 1)
    return iu(r, vo);
  n === 8 && (n = 9);
  const a = new Zde();
  return r.state = a, a.strm = r, a.status = Qh, a.wrap = o, a.gzhead = null, a.w_bits = n, a.w_size = 1 << a.w_bits, a.w_mask = a.w_size - 1, a.hash_bits = i + 7, a.hash_size = 1 << a.hash_bits, a.hash_mask = a.hash_size - 1, a.hash_shift = ~~((a.hash_bits + ct - 1) / ct), a.window = new Uint8Array(a.w_size * 2), a.head = new Uint16Array(a.hash_size), a.prev = new Uint16Array(a.w_size), a.lit_bufsize = 1 << i + 6, a.pending_buf_size = a.lit_bufsize * 4, a.pending_buf = new Uint8Array(a.pending_buf_size), a.sym_buf = a.lit_bufsize, a.sym_end = (a.lit_bufsize - 1) * 3, a.level = e, a.strategy = s, a.method = t, d8(r);
}, Xde = (r, e) => h8(r, e, D0, Pde, Nde, Ode), Yde = (r, e) => {
  if (tm(r) || e > sN || e < 0)
    return r ? iu(r, vo) : vo;
  const t = r.state;
  if (!r.output || r.avail_in !== 0 && !r.input || t.status === Sp && e !== Hi)
    return iu(r, r.avail_out === 0 ? G_ : vo);
  const n = t.last_flush;
  if (t.last_flush = e, t.pending !== 0) {
    if (gi(r), r.avail_out === 0)
      return t.last_flush = -1, qr;
  } else if (r.avail_in === 0 && aN(e) <= aN(n) && e !== Hi)
    return iu(r, G_);
  if (t.status === Sp && r.avail_in !== 0)
    return iu(r, G_);
  if (t.status === Qh && t.wrap === 0 && (t.status = nu), t.status === Qh) {
    let i = D0 + (t.w_bits - 8 << 4) << 8, s = -1;
    if (t.strategy >= Ym || t.level < 2 ? s = 0 : t.level < 6 ? s = 1 : t.level === 6 ? s = 2 : s = 3, i |= s << 6, t.strstart !== 0 && (i |= zde), i += 31 - i % 31, Gf(t, i), t.strstart !== 0 && (Gf(t, r.adler >>> 16), Gf(t, r.adler & 65535)), r.adler = 1, t.status = nu, gi(r), t.pending !== 0)
      return t.last_flush = -1, qr;
  }
  if (t.status === rD) {
    if (r.adler = 0, St(t, 31), St(t, 139), St(t, 8), t.gzhead)
      St(
        t,
        (t.gzhead.text ? 1 : 0) + (t.gzhead.hcrc ? 2 : 0) + (t.gzhead.extra ? 4 : 0) + (t.gzhead.name ? 8 : 0) + (t.gzhead.comment ? 16 : 0)
      ), St(t, t.gzhead.time & 255), St(t, t.gzhead.time >> 8 & 255), St(t, t.gzhead.time >> 16 & 255), St(t, t.gzhead.time >> 24 & 255), St(t, t.level === 9 ? 2 : t.strategy >= Ym || t.level < 2 ? 4 : 0), St(t, t.gzhead.os & 255), t.gzhead.extra && t.gzhead.extra.length && (St(t, t.gzhead.extra.length & 255), St(t, t.gzhead.extra.length >> 8 & 255)), t.gzhead.hcrc && (r.adler = Lr(r.adler, t.pending_buf, t.pending, 0)), t.gzindex = 0, t.status = xI;
    else if (St(t, 0), St(t, 0), St(t, 0), St(t, 0), St(t, 0), St(t, t.level === 9 ? 2 : t.strategy >= Ym || t.level < 2 ? 4 : 0), St(t, jde), t.status = nu, gi(r), t.pending !== 0)
      return t.last_flush = -1, qr;
  }
  if (t.status === xI) {
    if (t.gzhead.extra) {
      let i = t.pending, s = (t.gzhead.extra.length & 65535) - t.gzindex;
      for (; t.pending + s > t.pending_buf_size; ) {
        let a = t.pending_buf_size - t.pending;
        if (t.pending_buf.set(t.gzhead.extra.subarray(t.gzindex, t.gzindex + a), t.pending), t.pending = t.pending_buf_size, t.gzhead.hcrc && t.pending > i && (r.adler = Lr(r.adler, t.pending_buf, t.pending - i, i)), t.gzindex += a, gi(r), t.pending !== 0)
          return t.last_flush = -1, qr;
        i = 0, s -= a;
      }
      let o = new Uint8Array(t.gzhead.extra);
      t.pending_buf.set(o.subarray(t.gzindex, t.gzindex + s), t.pending), t.pending += s, t.gzhead.hcrc && t.pending > i && (r.adler = Lr(r.adler, t.pending_buf, t.pending - i, i)), t.gzindex = 0;
    }
    t.status = AI;
  }
  if (t.status === AI) {
    if (t.gzhead.name) {
      let i = t.pending, s;
      do {
        if (t.pending === t.pending_buf_size) {
          if (t.gzhead.hcrc && t.pending > i && (r.adler = Lr(r.adler, t.pending_buf, t.pending - i, i)), gi(r), t.pending !== 0)
            return t.last_flush = -1, qr;
          i = 0;
        }
        t.gzindex < t.gzhead.name.length ? s = t.gzhead.name.charCodeAt(t.gzindex++) & 255 : s = 0, St(t, s);
      } while (s !== 0);
      t.gzhead.hcrc && t.pending > i && (r.adler = Lr(r.adler, t.pending_buf, t.pending - i, i)), t.gzindex = 0;
    }
    t.status = II;
  }
  if (t.status === II) {
    if (t.gzhead.comment) {
      let i = t.pending, s;
      do {
        if (t.pending === t.pending_buf_size) {
          if (t.gzhead.hcrc && t.pending > i && (r.adler = Lr(r.adler, t.pending_buf, t.pending - i, i)), gi(r), t.pending !== 0)
            return t.last_flush = -1, qr;
          i = 0;
        }
        t.gzindex < t.gzhead.comment.length ? s = t.gzhead.comment.charCodeAt(t.gzindex++) & 255 : s = 0, St(t, s);
      } while (s !== 0);
      t.gzhead.hcrc && t.pending > i && (r.adler = Lr(r.adler, t.pending_buf, t.pending - i, i));
    }
    t.status = CI;
  }
  if (t.status === CI) {
    if (t.gzhead.hcrc) {
      if (t.pending + 2 > t.pending_buf_size && (gi(r), t.pending !== 0))
        return t.last_flush = -1, qr;
      St(t, r.adler & 255), St(t, r.adler >> 8 & 255), r.adler = 0;
    }
    if (t.status = nu, gi(r), t.pending !== 0)
      return t.last_flush = -1, qr;
  }
  if (r.avail_in !== 0 || t.lookahead !== 0 || e !== hc && t.status !== Sp) {
    let i = t.level === 0 ? u8(t, e) : t.strategy === Ym ? qde(t, e) : t.strategy === Tde ? Kde(t, e) : Ep[t.level].func(t, e);
    if ((i === al || i === xf) && (t.status = Sp), i === kn || i === al)
      return r.avail_out === 0 && (t.last_flush = -1), qr;
    if (i === Ef && (e === xde ? Ede(t) : e !== sN && (SI(t, 0, 0, !1), e === Ade && (La(t.head), t.lookahead === 0 && (t.strstart = 0, t.block_start = 0, t.insert = 0))), gi(r), r.avail_out === 0))
      return t.last_flush = -1, qr;
  }
  return e !== Hi ? qr : t.wrap <= 0 ? oN : (t.wrap === 2 ? (St(t, r.adler & 255), St(t, r.adler >> 8 & 255), St(t, r.adler >> 16 & 255), St(t, r.adler >> 24 & 255), St(t, r.total_in & 255), St(t, r.total_in >> 8 & 255), St(t, r.total_in >> 16 & 255), St(t, r.total_in >> 24 & 255)) : (Gf(t, r.adler >>> 16), Gf(t, r.adler & 65535)), gi(r), t.wrap > 0 && (t.wrap = -t.wrap), t.pending !== 0 ? qr : oN);
}, Qde = (r) => {
  if (tm(r))
    return vo;
  const e = r.state.status;
  return r.state = null, e === nu ? iu(r, Ide) : qr;
}, ehe = (r, e) => {
  let t = e.length;
  if (tm(r))
    return vo;
  const n = r.state, i = n.wrap;
  if (i === 2 || i === 1 && n.status !== Qh || n.lookahead)
    return vo;
  if (i === 1 && (r.adler = ng(r.adler, e, t, 0)), n.wrap = 0, t >= n.w_size) {
    i === 0 && (La(n.head), n.strstart = 0, n.block_start = 0, n.insert = 0);
    let c = new Uint8Array(n.w_size);
    c.set(e.subarray(t - n.w_size, t), 0), e = c, t = n.w_size;
  }
  const s = r.avail_in, o = r.next_in, a = r.input;
  for (r.avail_in = t, r.next_in = 0, r.input = e, ef(n); n.lookahead >= ct; ) {
    let c = n.strstart, u = n.lookahead - (ct - 1);
    do
      n.ins_h = fc(n, n.ins_h, n.window[c + ct - 1]), n.prev[c & n.w_mask] = n.head[n.ins_h], n.head[n.ins_h] = c, c++;
    while (--u);
    n.strstart = c, n.lookahead = ct - 1, ef(n);
  }
  return n.strstart += n.lookahead, n.block_start = n.strstart, n.insert = n.lookahead, n.lookahead = 0, n.match_length = n.prev_length = ct - 1, n.match_available = 0, r.next_in = o, r.input = a, r.avail_in = s, n.wrap = i, qr;
};
var the = Xde, rhe = h8, nhe = d8, ihe = l8, she = Jde, ohe = Yde, ahe = Qde, che = ehe, uhe = "pako deflate (from Nodeca project)", Pp = {
  deflateInit: the,
  deflateInit2: rhe,
  deflateReset: nhe,
  deflateResetKeep: ihe,
  deflateSetHeader: she,
  deflate: ohe,
  deflateEnd: ahe,
  deflateSetDictionary: che,
  deflateInfo: uhe
};
const lhe = (r, e) => Object.prototype.hasOwnProperty.call(r, e);
var dhe = function(r) {
  const e = Array.prototype.slice.call(arguments, 1);
  for (; e.length; ) {
    const t = e.shift();
    if (t) {
      if (typeof t != "object")
        throw new TypeError(t + "must be non-object");
      for (const n in t)
        lhe(t, n) && (r[n] = t[n]);
    }
  }
  return r;
}, hhe = (r) => {
  let e = 0;
  for (let n = 0, i = r.length; n < i; n++)
    e += r[n].length;
  const t = new Uint8Array(e);
  for (let n = 0, i = 0, s = r.length; n < s; n++) {
    let o = r[n];
    t.set(o, i), i += o.length;
  }
  return t;
}, T0 = {
  assign: dhe,
  flattenChunks: hhe
};
let f8 = !0;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch {
  f8 = !1;
}
const ig = new Uint8Array(256);
for (let r = 0; r < 256; r++)
  ig[r] = r >= 252 ? 6 : r >= 248 ? 5 : r >= 240 ? 4 : r >= 224 ? 3 : r >= 192 ? 2 : 1;
ig[254] = ig[254] = 1;
var fhe = (r) => {
  if (typeof TextEncoder == "function" && TextEncoder.prototype.encode)
    return new TextEncoder().encode(r);
  let e, t, n, i, s, o = r.length, a = 0;
  for (i = 0; i < o; i++)
    t = r.charCodeAt(i), (t & 64512) === 55296 && i + 1 < o && (n = r.charCodeAt(i + 1), (n & 64512) === 56320 && (t = 65536 + (t - 55296 << 10) + (n - 56320), i++)), a += t < 128 ? 1 : t < 2048 ? 2 : t < 65536 ? 3 : 4;
  for (e = new Uint8Array(a), s = 0, i = 0; s < a; i++)
    t = r.charCodeAt(i), (t & 64512) === 55296 && i + 1 < o && (n = r.charCodeAt(i + 1), (n & 64512) === 56320 && (t = 65536 + (t - 55296 << 10) + (n - 56320), i++)), t < 128 ? e[s++] = t : t < 2048 ? (e[s++] = 192 | t >>> 6, e[s++] = 128 | t & 63) : t < 65536 ? (e[s++] = 224 | t >>> 12, e[s++] = 128 | t >>> 6 & 63, e[s++] = 128 | t & 63) : (e[s++] = 240 | t >>> 18, e[s++] = 128 | t >>> 12 & 63, e[s++] = 128 | t >>> 6 & 63, e[s++] = 128 | t & 63);
  return e;
};
const phe = (r, e) => {
  if (e < 65534 && r.subarray && f8)
    return String.fromCharCode.apply(null, r.length === e ? r : r.subarray(0, e));
  let t = "";
  for (let n = 0; n < e; n++)
    t += String.fromCharCode(r[n]);
  return t;
};
var ghe = (r, e) => {
  const t = e || r.length;
  if (typeof TextDecoder == "function" && TextDecoder.prototype.decode)
    return new TextDecoder().decode(r.subarray(0, e));
  let n, i;
  const s = new Array(t * 2);
  for (i = 0, n = 0; n < t; ) {
    let o = r[n++];
    if (o < 128) {
      s[i++] = o;
      continue;
    }
    let a = ig[o];
    if (a > 4) {
      s[i++] = 65533, n += a - 1;
      continue;
    }
    for (o &= a === 2 ? 31 : a === 3 ? 15 : 7; a > 1 && n < t; )
      o = o << 6 | r[n++] & 63, a--;
    if (a > 1) {
      s[i++] = 65533;
      continue;
    }
    o < 65536 ? s[i++] = o : (o -= 65536, s[i++] = 55296 | o >> 10 & 1023, s[i++] = 56320 | o & 1023);
  }
  return phe(s, i);
}, mhe = (r, e) => {
  e = e || r.length, e > r.length && (e = r.length);
  let t = e - 1;
  for (; t >= 0 && (r[t] & 192) === 128; )
    t--;
  return t < 0 || t === 0 ? e : t + ig[r[t]] > e ? t : e;
}, sg = {
  string2buf: fhe,
  buf2string: ghe,
  utf8border: mhe
};
function yhe() {
  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
}
var p8 = yhe;
const g8 = Object.prototype.toString, {
  Z_NO_FLUSH: vhe,
  Z_SYNC_FLUSH: bhe,
  Z_FULL_FLUSH: whe,
  Z_FINISH: _he,
  Z_OK: pv,
  Z_STREAM_END: She,
  Z_DEFAULT_COMPRESSION: Ehe,
  Z_DEFAULT_STRATEGY: xhe,
  Z_DEFLATED: Ahe
} = em;
function rm(r) {
  this.options = T0.assign({
    level: Ehe,
    method: Ahe,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: xhe
  }, r || {});
  let e = this.options;
  e.raw && e.windowBits > 0 ? e.windowBits = -e.windowBits : e.gzip && e.windowBits > 0 && e.windowBits < 16 && (e.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new p8(), this.strm.avail_out = 0;
  let t = Pp.deflateInit2(
    this.strm,
    e.level,
    e.method,
    e.windowBits,
    e.memLevel,
    e.strategy
  );
  if (t !== pv)
    throw new Error(ol[t]);
  if (e.header && Pp.deflateSetHeader(this.strm, e.header), e.dictionary) {
    let n;
    if (typeof e.dictionary == "string" ? n = sg.string2buf(e.dictionary) : g8.call(e.dictionary) === "[object ArrayBuffer]" ? n = new Uint8Array(e.dictionary) : n = e.dictionary, t = Pp.deflateSetDictionary(this.strm, n), t !== pv)
      throw new Error(ol[t]);
    this._dict_set = !0;
  }
}
rm.prototype.push = function(r, e) {
  const t = this.strm, n = this.options.chunkSize;
  let i, s;
  if (this.ended)
    return !1;
  for (e === ~~e ? s = e : s = e === !0 ? _he : vhe, typeof r == "string" ? t.input = sg.string2buf(r) : g8.call(r) === "[object ArrayBuffer]" ? t.input = new Uint8Array(r) : t.input = r, t.next_in = 0, t.avail_in = t.input.length; ; ) {
    if (t.avail_out === 0 && (t.output = new Uint8Array(n), t.next_out = 0, t.avail_out = n), (s === bhe || s === whe) && t.avail_out <= 6) {
      this.onData(t.output.subarray(0, t.next_out)), t.avail_out = 0;
      continue;
    }
    if (i = Pp.deflate(t, s), i === She)
      return t.next_out > 0 && this.onData(t.output.subarray(0, t.next_out)), i = Pp.deflateEnd(this.strm), this.onEnd(i), this.ended = !0, i === pv;
    if (t.avail_out === 0) {
      this.onData(t.output);
      continue;
    }
    if (s > 0 && t.next_out > 0) {
      this.onData(t.output.subarray(0, t.next_out)), t.avail_out = 0;
      continue;
    }
    if (t.avail_in === 0) break;
  }
  return !0;
};
rm.prototype.onData = function(r) {
  this.chunks.push(r);
};
rm.prototype.onEnd = function(r) {
  r === pv && (this.result = T0.flattenChunks(this.chunks)), this.chunks = [], this.err = r, this.msg = this.strm.msg;
};
function nD(r, e) {
  const t = new rm(e);
  if (t.push(r, !0), t.err)
    throw t.msg || ol[t.err];
  return t.result;
}
function Ihe(r, e) {
  return e = e || {}, e.raw = !0, nD(r, e);
}
function Che(r, e) {
  return e = e || {}, e.gzip = !0, nD(r, e);
}
var Dhe = rm, The = nD, khe = Ihe, Ohe = Che, $he = {
  Deflate: Dhe,
  deflate: The,
  deflateRaw: khe,
  gzip: Ohe
};
const Qm = 16209, Rhe = 16191;
var Phe = function(e, t) {
  let n, i, s, o, a, c, u, l, d, f, p, y, g, v, _, w, E, I, S, T, b, C, P, Z;
  const Y = e.state;
  n = e.next_in, P = e.input, i = n + (e.avail_in - 5), s = e.next_out, Z = e.output, o = s - (t - e.avail_out), a = s + (e.avail_out - 257), c = Y.dmax, u = Y.wsize, l = Y.whave, d = Y.wnext, f = Y.window, p = Y.hold, y = Y.bits, g = Y.lencode, v = Y.distcode, _ = (1 << Y.lenbits) - 1, w = (1 << Y.distbits) - 1;
  e:
    do {
      y < 15 && (p += P[n++] << y, y += 8, p += P[n++] << y, y += 8), E = g[p & _];
      t:
        for (; ; ) {
          if (I = E >>> 24, p >>>= I, y -= I, I = E >>> 16 & 255, I === 0)
            Z[s++] = E & 65535;
          else if (I & 16) {
            S = E & 65535, I &= 15, I && (y < I && (p += P[n++] << y, y += 8), S += p & (1 << I) - 1, p >>>= I, y -= I), y < 15 && (p += P[n++] << y, y += 8, p += P[n++] << y, y += 8), E = v[p & w];
            r:
              for (; ; ) {
                if (I = E >>> 24, p >>>= I, y -= I, I = E >>> 16 & 255, I & 16) {
                  if (T = E & 65535, I &= 15, y < I && (p += P[n++] << y, y += 8, y < I && (p += P[n++] << y, y += 8)), T += p & (1 << I) - 1, T > c) {
                    e.msg = "invalid distance too far back", Y.mode = Qm;
                    break e;
                  }
                  if (p >>>= I, y -= I, I = s - o, T > I) {
                    if (I = T - I, I > l && Y.sane) {
                      e.msg = "invalid distance too far back", Y.mode = Qm;
                      break e;
                    }
                    if (b = 0, C = f, d === 0) {
                      if (b += u - I, I < S) {
                        S -= I;
                        do
                          Z[s++] = f[b++];
                        while (--I);
                        b = s - T, C = Z;
                      }
                    } else if (d < I) {
                      if (b += u + d - I, I -= d, I < S) {
                        S -= I;
                        do
                          Z[s++] = f[b++];
                        while (--I);
                        if (b = 0, d < S) {
                          I = d, S -= I;
                          do
                            Z[s++] = f[b++];
                          while (--I);
                          b = s - T, C = Z;
                        }
                      }
                    } else if (b += d - I, I < S) {
                      S -= I;
                      do
                        Z[s++] = f[b++];
                      while (--I);
                      b = s - T, C = Z;
                    }
                    for (; S > 2; )
                      Z[s++] = C[b++], Z[s++] = C[b++], Z[s++] = C[b++], S -= 3;
                    S && (Z[s++] = C[b++], S > 1 && (Z[s++] = C[b++]));
                  } else {
                    b = s - T;
                    do
                      Z[s++] = Z[b++], Z[s++] = Z[b++], Z[s++] = Z[b++], S -= 3;
                    while (S > 2);
                    S && (Z[s++] = Z[b++], S > 1 && (Z[s++] = Z[b++]));
                  }
                } else if ((I & 64) === 0) {
                  E = v[(E & 65535) + (p & (1 << I) - 1)];
                  continue r;
                } else {
                  e.msg = "invalid distance code", Y.mode = Qm;
                  break e;
                }
                break;
              }
          } else if ((I & 64) === 0) {
            E = g[(E & 65535) + (p & (1 << I) - 1)];
            continue t;
          } else if (I & 32) {
            Y.mode = Rhe;
            break e;
          } else {
            e.msg = "invalid literal/length code", Y.mode = Qm;
            break e;
          }
          break;
        }
    } while (n < i && s < a);
  S = y >> 3, n -= S, y -= S << 3, p &= (1 << y) - 1, e.next_in = n, e.next_out = s, e.avail_in = n < i ? 5 + (i - n) : 5 - (n - i), e.avail_out = s < a ? 257 + (a - s) : 257 - (s - a), Y.hold = p, Y.bits = y;
};
const Ll = 15, cN = 852, uN = 592, lN = 0, q_ = 1, dN = 2, Nhe = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]), Bhe = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]), Lhe = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]), Uhe = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]), Fhe = (r, e, t, n, i, s, o, a) => {
  const c = a.bits;
  let u = 0, l = 0, d = 0, f = 0, p = 0, y = 0, g = 0, v = 0, _ = 0, w = 0, E, I, S, T, b, C = null, P;
  const Z = new Uint16Array(Ll + 1), Y = new Uint16Array(Ll + 1);
  let q = null, J, O, x;
  for (u = 0; u <= Ll; u++)
    Z[u] = 0;
  for (l = 0; l < n; l++)
    Z[e[t + l]]++;
  for (p = c, f = Ll; f >= 1 && Z[f] === 0; f--)
    ;
  if (p > f && (p = f), f === 0)
    return i[s++] = 1 << 24 | 64 << 16 | 0, i[s++] = 1 << 24 | 64 << 16 | 0, a.bits = 1, 0;
  for (d = 1; d < f && Z[d] === 0; d++)
    ;
  for (p < d && (p = d), v = 1, u = 1; u <= Ll; u++)
    if (v <<= 1, v -= Z[u], v < 0)
      return -1;
  if (v > 0 && (r === lN || f !== 1))
    return -1;
  for (Y[1] = 0, u = 1; u < Ll; u++)
    Y[u + 1] = Y[u] + Z[u];
  for (l = 0; l < n; l++)
    e[t + l] !== 0 && (o[Y[e[t + l]]++] = l);
  if (r === lN ? (C = q = o, P = 20) : r === q_ ? (C = Nhe, q = Bhe, P = 257) : (C = Lhe, q = Uhe, P = 0), w = 0, l = 0, u = d, b = s, y = p, g = 0, S = -1, _ = 1 << p, T = _ - 1, r === q_ && _ > cN || r === dN && _ > uN)
    return 1;
  for (; ; ) {
    J = u - g, o[l] + 1 < P ? (O = 0, x = o[l]) : o[l] >= P ? (O = q[o[l] - P], x = C[o[l] - P]) : (O = 96, x = 0), E = 1 << u - g, I = 1 << y, d = I;
    do
      I -= E, i[b + (w >> g) + I] = J << 24 | O << 16 | x | 0;
    while (I !== 0);
    for (E = 1 << u - 1; w & E; )
      E >>= 1;
    if (E !== 0 ? (w &= E - 1, w += E) : w = 0, l++, --Z[u] === 0) {
      if (u === f)
        break;
      u = e[t + o[l]];
    }
    if (u > p && (w & T) !== S) {
      for (g === 0 && (g = p), b += d, y = u - g, v = 1 << y; y + g < f && (v -= Z[y + g], !(v <= 0)); )
        y++, v <<= 1;
      if (_ += 1 << y, r === q_ && _ > cN || r === dN && _ > uN)
        return 1;
      S = w & T, i[S] = p << 24 | y << 16 | b - s | 0;
    }
  }
  return w !== 0 && (i[b + w] = u - g << 24 | 64 << 16 | 0), a.bits = p, 0;
};
var Np = Fhe;
const Mhe = 0, m8 = 1, y8 = 2, {
  Z_FINISH: hN,
  Z_BLOCK: Vhe,
  Z_TREES: ey,
  Z_OK: cl,
  Z_STREAM_END: zhe,
  Z_NEED_DICT: jhe,
  Z_STREAM_ERROR: Yi,
  Z_DATA_ERROR: v8,
  Z_MEM_ERROR: b8,
  Z_BUF_ERROR: Hhe,
  Z_DEFLATED: fN
} = em, k0 = 16180, pN = 16181, gN = 16182, mN = 16183, yN = 16184, vN = 16185, bN = 16186, wN = 16187, _N = 16188, SN = 16189, gv = 16190, Ro = 16191, W_ = 16192, EN = 16193, Z_ = 16194, xN = 16195, AN = 16196, IN = 16197, CN = 16198, ty = 16199, ry = 16200, DN = 16201, TN = 16202, kN = 16203, ON = 16204, $N = 16205, J_ = 16206, RN = 16207, PN = 16208, Zt = 16209, w8 = 16210, _8 = 16211, Ghe = 852, Khe = 592, qhe = 15, Whe = qhe, NN = (r) => (r >>> 24 & 255) + (r >>> 8 & 65280) + ((r & 65280) << 8) + ((r & 255) << 24);
function Zhe() {
  this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
}
const wl = (r) => {
  if (!r)
    return 1;
  const e = r.state;
  return !e || e.strm !== r || e.mode < k0 || e.mode > _8 ? 1 : 0;
}, S8 = (r) => {
  if (wl(r))
    return Yi;
  const e = r.state;
  return r.total_in = r.total_out = e.total = 0, r.msg = "", e.wrap && (r.adler = e.wrap & 1), e.mode = k0, e.last = 0, e.havedict = 0, e.flags = -1, e.dmax = 32768, e.head = null, e.hold = 0, e.bits = 0, e.lencode = e.lendyn = new Int32Array(Ghe), e.distcode = e.distdyn = new Int32Array(Khe), e.sane = 1, e.back = -1, cl;
}, E8 = (r) => {
  if (wl(r))
    return Yi;
  const e = r.state;
  return e.wsize = 0, e.whave = 0, e.wnext = 0, S8(r);
}, x8 = (r, e) => {
  let t;
  if (wl(r))
    return Yi;
  const n = r.state;
  return e < 0 ? (t = 0, e = -e) : (t = (e >> 4) + 5, e < 48 && (e &= 15)), e && (e < 8 || e > 15) ? Yi : (n.window !== null && n.wbits !== e && (n.window = null), n.wrap = t, n.wbits = e, E8(r));
}, A8 = (r, e) => {
  if (!r)
    return Yi;
  const t = new Zhe();
  r.state = t, t.strm = r, t.window = null, t.mode = k0;
  const n = x8(r, e);
  return n !== cl && (r.state = null), n;
}, Jhe = (r) => A8(r, Whe);
let BN = !0, X_, Y_;
const Xhe = (r) => {
  if (BN) {
    X_ = new Int32Array(512), Y_ = new Int32Array(32);
    let e = 0;
    for (; e < 144; )
      r.lens[e++] = 8;
    for (; e < 256; )
      r.lens[e++] = 9;
    for (; e < 280; )
      r.lens[e++] = 7;
    for (; e < 288; )
      r.lens[e++] = 8;
    for (Np(m8, r.lens, 0, 288, X_, 0, r.work, { bits: 9 }), e = 0; e < 32; )
      r.lens[e++] = 5;
    Np(y8, r.lens, 0, 32, Y_, 0, r.work, { bits: 5 }), BN = !1;
  }
  r.lencode = X_, r.lenbits = 9, r.distcode = Y_, r.distbits = 5;
}, I8 = (r, e, t, n) => {
  let i;
  const s = r.state;
  return s.window === null && (s.wsize = 1 << s.wbits, s.wnext = 0, s.whave = 0, s.window = new Uint8Array(s.wsize)), n >= s.wsize ? (s.window.set(e.subarray(t - s.wsize, t), 0), s.wnext = 0, s.whave = s.wsize) : (i = s.wsize - s.wnext, i > n && (i = n), s.window.set(e.subarray(t - n, t - n + i), s.wnext), n -= i, n ? (s.window.set(e.subarray(t - n, t), 0), s.wnext = n, s.whave = s.wsize) : (s.wnext += i, s.wnext === s.wsize && (s.wnext = 0), s.whave < s.wsize && (s.whave += i))), 0;
}, Yhe = (r, e) => {
  let t, n, i, s, o, a, c, u, l, d, f, p, y, g, v = 0, _, w, E, I, S, T, b, C;
  const P = new Uint8Array(4);
  let Z, Y;
  const q = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (wl(r) || !r.output || !r.input && r.avail_in !== 0)
    return Yi;
  t = r.state, t.mode === Ro && (t.mode = W_), o = r.next_out, i = r.output, c = r.avail_out, s = r.next_in, n = r.input, a = r.avail_in, u = t.hold, l = t.bits, d = a, f = c, C = cl;
  e:
    for (; ; )
      switch (t.mode) {
        case k0:
          if (t.wrap === 0) {
            t.mode = W_;
            break;
          }
          for (; l < 16; ) {
            if (a === 0)
              break e;
            a--, u += n[s++] << l, l += 8;
          }
          if (t.wrap & 2 && u === 35615) {
            t.wbits === 0 && (t.wbits = 15), t.check = 0, P[0] = u & 255, P[1] = u >>> 8 & 255, t.check = Lr(t.check, P, 2, 0), u = 0, l = 0, t.mode = pN;
            break;
          }
          if (t.head && (t.head.done = !1), !(t.wrap & 1) || /* check if zlib header allowed */
          (((u & 255) << 8) + (u >> 8)) % 31) {
            r.msg = "incorrect header check", t.mode = Zt;
            break;
          }
          if ((u & 15) !== fN) {
            r.msg = "unknown compression method", t.mode = Zt;
            break;
          }
          if (u >>>= 4, l -= 4, b = (u & 15) + 8, t.wbits === 0 && (t.wbits = b), b > 15 || b > t.wbits) {
            r.msg = "invalid window size", t.mode = Zt;
            break;
          }
          t.dmax = 1 << t.wbits, t.flags = 0, r.adler = t.check = 1, t.mode = u & 512 ? SN : Ro, u = 0, l = 0;
          break;
        case pN:
          for (; l < 16; ) {
            if (a === 0)
              break e;
            a--, u += n[s++] << l, l += 8;
          }
          if (t.flags = u, (t.flags & 255) !== fN) {
            r.msg = "unknown compression method", t.mode = Zt;
            break;
          }
          if (t.flags & 57344) {
            r.msg = "unknown header flags set", t.mode = Zt;
            break;
          }
          t.head && (t.head.text = u >> 8 & 1), t.flags & 512 && t.wrap & 4 && (P[0] = u & 255, P[1] = u >>> 8 & 255, t.check = Lr(t.check, P, 2, 0)), u = 0, l = 0, t.mode = gN;
        /* falls through */
        case gN:
          for (; l < 32; ) {
            if (a === 0)
              break e;
            a--, u += n[s++] << l, l += 8;
          }
          t.head && (t.head.time = u), t.flags & 512 && t.wrap & 4 && (P[0] = u & 255, P[1] = u >>> 8 & 255, P[2] = u >>> 16 & 255, P[3] = u >>> 24 & 255, t.check = Lr(t.check, P, 4, 0)), u = 0, l = 0, t.mode = mN;
        /* falls through */
        case mN:
          for (; l < 16; ) {
            if (a === 0)
              break e;
            a--, u += n[s++] << l, l += 8;
          }
          t.head && (t.head.xflags = u & 255, t.head.os = u >> 8), t.flags & 512 && t.wrap & 4 && (P[0] = u & 255, P[1] = u >>> 8 & 255, t.check = Lr(t.check, P, 2, 0)), u = 0, l = 0, t.mode = yN;
        /* falls through */
        case yN:
          if (t.flags & 1024) {
            for (; l < 16; ) {
              if (a === 0)
                break e;
              a--, u += n[s++] << l, l += 8;
            }
            t.length = u, t.head && (t.head.extra_len = u), t.flags & 512 && t.wrap & 4 && (P[0] = u & 255, P[1] = u >>> 8 & 255, t.check = Lr(t.check, P, 2, 0)), u = 0, l = 0;
          } else t.head && (t.head.extra = null);
          t.mode = vN;
        /* falls through */
        case vN:
          if (t.flags & 1024 && (p = t.length, p > a && (p = a), p && (t.head && (b = t.head.extra_len - t.length, t.head.extra || (t.head.extra = new Uint8Array(t.head.extra_len)), t.head.extra.set(
            n.subarray(
              s,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              s + p
            ),
            /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
            b
          )), t.flags & 512 && t.wrap & 4 && (t.check = Lr(t.check, n, p, s)), a -= p, s += p, t.length -= p), t.length))
            break e;
          t.length = 0, t.mode = bN;
        /* falls through */
        case bN:
          if (t.flags & 2048) {
            if (a === 0)
              break e;
            p = 0;
            do
              b = n[s + p++], t.head && b && t.length < 65536 && (t.head.name += String.fromCharCode(b));
            while (b && p < a);
            if (t.flags & 512 && t.wrap & 4 && (t.check = Lr(t.check, n, p, s)), a -= p, s += p, b)
              break e;
          } else t.head && (t.head.name = null);
          t.length = 0, t.mode = wN;
        /* falls through */
        case wN:
          if (t.flags & 4096) {
            if (a === 0)
              break e;
            p = 0;
            do
              b = n[s + p++], t.head && b && t.length < 65536 && (t.head.comment += String.fromCharCode(b));
            while (b && p < a);
            if (t.flags & 512 && t.wrap & 4 && (t.check = Lr(t.check, n, p, s)), a -= p, s += p, b)
              break e;
          } else t.head && (t.head.comment = null);
          t.mode = _N;
        /* falls through */
        case _N:
          if (t.flags & 512) {
            for (; l < 16; ) {
              if (a === 0)
                break e;
              a--, u += n[s++] << l, l += 8;
            }
            if (t.wrap & 4 && u !== (t.check & 65535)) {
              r.msg = "header crc mismatch", t.mode = Zt;
              break;
            }
            u = 0, l = 0;
          }
          t.head && (t.head.hcrc = t.flags >> 9 & 1, t.head.done = !0), r.adler = t.check = 0, t.mode = Ro;
          break;
        case SN:
          for (; l < 32; ) {
            if (a === 0)
              break e;
            a--, u += n[s++] << l, l += 8;
          }
          r.adler = t.check = NN(u), u = 0, l = 0, t.mode = gv;
        /* falls through */
        case gv:
          if (t.havedict === 0)
            return r.next_out = o, r.avail_out = c, r.next_in = s, r.avail_in = a, t.hold = u, t.bits = l, jhe;
          r.adler = t.check = 1, t.mode = Ro;
        /* falls through */
        case Ro:
          if (e === Vhe || e === ey)
            break e;
        /* falls through */
        case W_:
          if (t.last) {
            u >>>= l & 7, l -= l & 7, t.mode = J_;
            break;
          }
          for (; l < 3; ) {
            if (a === 0)
              break e;
            a--, u += n[s++] << l, l += 8;
          }
          switch (t.last = u & 1, u >>>= 1, l -= 1, u & 3) {
            case 0:
              t.mode = EN;
              break;
            case 1:
              if (Xhe(t), t.mode = ty, e === ey) {
                u >>>= 2, l -= 2;
                break e;
              }
              break;
            case 2:
              t.mode = AN;
              break;
            case 3:
              r.msg = "invalid block type", t.mode = Zt;
          }
          u >>>= 2, l -= 2;
          break;
        case EN:
          for (u >>>= l & 7, l -= l & 7; l < 32; ) {
            if (a === 0)
              break e;
            a--, u += n[s++] << l, l += 8;
          }
          if ((u & 65535) !== (u >>> 16 ^ 65535)) {
            r.msg = "invalid stored block lengths", t.mode = Zt;
            break;
          }
          if (t.length = u & 65535, u = 0, l = 0, t.mode = Z_, e === ey)
            break e;
        /* falls through */
        case Z_:
          t.mode = xN;
        /* falls through */
        case xN:
          if (p = t.length, p) {
            if (p > a && (p = a), p > c && (p = c), p === 0)
              break e;
            i.set(n.subarray(s, s + p), o), a -= p, s += p, c -= p, o += p, t.length -= p;
            break;
          }
          t.mode = Ro;
          break;
        case AN:
          for (; l < 14; ) {
            if (a === 0)
              break e;
            a--, u += n[s++] << l, l += 8;
          }
          if (t.nlen = (u & 31) + 257, u >>>= 5, l -= 5, t.ndist = (u & 31) + 1, u >>>= 5, l -= 5, t.ncode = (u & 15) + 4, u >>>= 4, l -= 4, t.nlen > 286 || t.ndist > 30) {
            r.msg = "too many length or distance symbols", t.mode = Zt;
            break;
          }
          t.have = 0, t.mode = IN;
        /* falls through */
        case IN:
          for (; t.have < t.ncode; ) {
            for (; l < 3; ) {
              if (a === 0)
                break e;
              a--, u += n[s++] << l, l += 8;
            }
            t.lens[q[t.have++]] = u & 7, u >>>= 3, l -= 3;
          }
          for (; t.have < 19; )
            t.lens[q[t.have++]] = 0;
          if (t.lencode = t.lendyn, t.lenbits = 7, Z = { bits: t.lenbits }, C = Np(Mhe, t.lens, 0, 19, t.lencode, 0, t.work, Z), t.lenbits = Z.bits, C) {
            r.msg = "invalid code lengths set", t.mode = Zt;
            break;
          }
          t.have = 0, t.mode = CN;
        /* falls through */
        case CN:
          for (; t.have < t.nlen + t.ndist; ) {
            for (; v = t.lencode[u & (1 << t.lenbits) - 1], _ = v >>> 24, w = v >>> 16 & 255, E = v & 65535, !(_ <= l); ) {
              if (a === 0)
                break e;
              a--, u += n[s++] << l, l += 8;
            }
            if (E < 16)
              u >>>= _, l -= _, t.lens[t.have++] = E;
            else {
              if (E === 16) {
                for (Y = _ + 2; l < Y; ) {
                  if (a === 0)
                    break e;
                  a--, u += n[s++] << l, l += 8;
                }
                if (u >>>= _, l -= _, t.have === 0) {
                  r.msg = "invalid bit length repeat", t.mode = Zt;
                  break;
                }
                b = t.lens[t.have - 1], p = 3 + (u & 3), u >>>= 2, l -= 2;
              } else if (E === 17) {
                for (Y = _ + 3; l < Y; ) {
                  if (a === 0)
                    break e;
                  a--, u += n[s++] << l, l += 8;
                }
                u >>>= _, l -= _, b = 0, p = 3 + (u & 7), u >>>= 3, l -= 3;
              } else {
                for (Y = _ + 7; l < Y; ) {
                  if (a === 0)
                    break e;
                  a--, u += n[s++] << l, l += 8;
                }
                u >>>= _, l -= _, b = 0, p = 11 + (u & 127), u >>>= 7, l -= 7;
              }
              if (t.have + p > t.nlen + t.ndist) {
                r.msg = "invalid bit length repeat", t.mode = Zt;
                break;
              }
              for (; p--; )
                t.lens[t.have++] = b;
            }
          }
          if (t.mode === Zt)
            break;
          if (t.lens[256] === 0) {
            r.msg = "invalid code -- missing end-of-block", t.mode = Zt;
            break;
          }
          if (t.lenbits = 9, Z = { bits: t.lenbits }, C = Np(m8, t.lens, 0, t.nlen, t.lencode, 0, t.work, Z), t.lenbits = Z.bits, C) {
            r.msg = "invalid literal/lengths set", t.mode = Zt;
            break;
          }
          if (t.distbits = 6, t.distcode = t.distdyn, Z = { bits: t.distbits }, C = Np(y8, t.lens, t.nlen, t.ndist, t.distcode, 0, t.work, Z), t.distbits = Z.bits, C) {
            r.msg = "invalid distances set", t.mode = Zt;
            break;
          }
          if (t.mode = ty, e === ey)
            break e;
        /* falls through */
        case ty:
          t.mode = ry;
        /* falls through */
        case ry:
          if (a >= 6 && c >= 258) {
            r.next_out = o, r.avail_out = c, r.next_in = s, r.avail_in = a, t.hold = u, t.bits = l, Phe(r, f), o = r.next_out, i = r.output, c = r.avail_out, s = r.next_in, n = r.input, a = r.avail_in, u = t.hold, l = t.bits, t.mode === Ro && (t.back = -1);
            break;
          }
          for (t.back = 0; v = t.lencode[u & (1 << t.lenbits) - 1], _ = v >>> 24, w = v >>> 16 & 255, E = v & 65535, !(_ <= l); ) {
            if (a === 0)
              break e;
            a--, u += n[s++] << l, l += 8;
          }
          if (w && (w & 240) === 0) {
            for (I = _, S = w, T = E; v = t.lencode[T + ((u & (1 << I + S) - 1) >> I)], _ = v >>> 24, w = v >>> 16 & 255, E = v & 65535, !(I + _ <= l); ) {
              if (a === 0)
                break e;
              a--, u += n[s++] << l, l += 8;
            }
            u >>>= I, l -= I, t.back += I;
          }
          if (u >>>= _, l -= _, t.back += _, t.length = E, w === 0) {
            t.mode = $N;
            break;
          }
          if (w & 32) {
            t.back = -1, t.mode = Ro;
            break;
          }
          if (w & 64) {
            r.msg = "invalid literal/length code", t.mode = Zt;
            break;
          }
          t.extra = w & 15, t.mode = DN;
        /* falls through */
        case DN:
          if (t.extra) {
            for (Y = t.extra; l < Y; ) {
              if (a === 0)
                break e;
              a--, u += n[s++] << l, l += 8;
            }
            t.length += u & (1 << t.extra) - 1, u >>>= t.extra, l -= t.extra, t.back += t.extra;
          }
          t.was = t.length, t.mode = TN;
        /* falls through */
        case TN:
          for (; v = t.distcode[u & (1 << t.distbits) - 1], _ = v >>> 24, w = v >>> 16 & 255, E = v & 65535, !(_ <= l); ) {
            if (a === 0)
              break e;
            a--, u += n[s++] << l, l += 8;
          }
          if ((w & 240) === 0) {
            for (I = _, S = w, T = E; v = t.distcode[T + ((u & (1 << I + S) - 1) >> I)], _ = v >>> 24, w = v >>> 16 & 255, E = v & 65535, !(I + _ <= l); ) {
              if (a === 0)
                break e;
              a--, u += n[s++] << l, l += 8;
            }
            u >>>= I, l -= I, t.back += I;
          }
          if (u >>>= _, l -= _, t.back += _, w & 64) {
            r.msg = "invalid distance code", t.mode = Zt;
            break;
          }
          t.offset = E, t.extra = w & 15, t.mode = kN;
        /* falls through */
        case kN:
          if (t.extra) {
            for (Y = t.extra; l < Y; ) {
              if (a === 0)
                break e;
              a--, u += n[s++] << l, l += 8;
            }
            t.offset += u & (1 << t.extra) - 1, u >>>= t.extra, l -= t.extra, t.back += t.extra;
          }
          if (t.offset > t.dmax) {
            r.msg = "invalid distance too far back", t.mode = Zt;
            break;
          }
          t.mode = ON;
        /* falls through */
        case ON:
          if (c === 0)
            break e;
          if (p = f - c, t.offset > p) {
            if (p = t.offset - p, p > t.whave && t.sane) {
              r.msg = "invalid distance too far back", t.mode = Zt;
              break;
            }
            p > t.wnext ? (p -= t.wnext, y = t.wsize - p) : y = t.wnext - p, p > t.length && (p = t.length), g = t.window;
          } else
            g = i, y = o - t.offset, p = t.length;
          p > c && (p = c), c -= p, t.length -= p;
          do
            i[o++] = g[y++];
          while (--p);
          t.length === 0 && (t.mode = ry);
          break;
        case $N:
          if (c === 0)
            break e;
          i[o++] = t.length, c--, t.mode = ry;
          break;
        case J_:
          if (t.wrap) {
            for (; l < 32; ) {
              if (a === 0)
                break e;
              a--, u |= n[s++] << l, l += 8;
            }
            if (f -= c, r.total_out += f, t.total += f, t.wrap & 4 && f && (r.adler = t.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
            t.flags ? Lr(t.check, i, f, o - f) : ng(t.check, i, f, o - f)), f = c, t.wrap & 4 && (t.flags ? u : NN(u)) !== t.check) {
              r.msg = "incorrect data check", t.mode = Zt;
              break;
            }
            u = 0, l = 0;
          }
          t.mode = RN;
        /* falls through */
        case RN:
          if (t.wrap && t.flags) {
            for (; l < 32; ) {
              if (a === 0)
                break e;
              a--, u += n[s++] << l, l += 8;
            }
            if (t.wrap & 4 && u !== (t.total & 4294967295)) {
              r.msg = "incorrect length check", t.mode = Zt;
              break;
            }
            u = 0, l = 0;
          }
          t.mode = PN;
        /* falls through */
        case PN:
          C = zhe;
          break e;
        case Zt:
          C = v8;
          break e;
        case w8:
          return b8;
        case _8:
        /* falls through */
        default:
          return Yi;
      }
  return r.next_out = o, r.avail_out = c, r.next_in = s, r.avail_in = a, t.hold = u, t.bits = l, (t.wsize || f !== r.avail_out && t.mode < Zt && (t.mode < J_ || e !== hN)) && I8(r, r.output, r.next_out, f - r.avail_out), d -= r.avail_in, f -= r.avail_out, r.total_in += d, r.total_out += f, t.total += f, t.wrap & 4 && f && (r.adler = t.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
  t.flags ? Lr(t.check, i, f, r.next_out - f) : ng(t.check, i, f, r.next_out - f)), r.data_type = t.bits + (t.last ? 64 : 0) + (t.mode === Ro ? 128 : 0) + (t.mode === ty || t.mode === Z_ ? 256 : 0), (d === 0 && f === 0 || e === hN) && C === cl && (C = Hhe), C;
}, Qhe = (r) => {
  if (wl(r))
    return Yi;
  let e = r.state;
  return e.window && (e.window = null), r.state = null, cl;
}, efe = (r, e) => {
  if (wl(r))
    return Yi;
  const t = r.state;
  return (t.wrap & 2) === 0 ? Yi : (t.head = e, e.done = !1, cl);
}, tfe = (r, e) => {
  const t = e.length;
  let n, i, s;
  return wl(r) || (n = r.state, n.wrap !== 0 && n.mode !== gv) ? Yi : n.mode === gv && (i = 1, i = ng(i, e, t, 0), i !== n.check) ? v8 : (s = I8(r, e, t, t), s ? (n.mode = w8, b8) : (n.havedict = 1, cl));
};
var rfe = E8, nfe = x8, ife = S8, sfe = Jhe, ofe = A8, afe = Yhe, cfe = Qhe, ufe = efe, lfe = tfe, dfe = "pako inflate (from Nodeca project)", jo = {
  inflateReset: rfe,
  inflateReset2: nfe,
  inflateResetKeep: ife,
  inflateInit: sfe,
  inflateInit2: ofe,
  inflate: afe,
  inflateEnd: cfe,
  inflateGetHeader: ufe,
  inflateSetDictionary: lfe,
  inflateInfo: dfe
};
function hfe() {
  this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
}
var ffe = hfe;
const C8 = Object.prototype.toString, {
  Z_NO_FLUSH: pfe,
  Z_FINISH: gfe,
  Z_OK: og,
  Z_STREAM_END: Q_,
  Z_NEED_DICT: eS,
  Z_STREAM_ERROR: mfe,
  Z_DATA_ERROR: LN,
  Z_MEM_ERROR: yfe
} = em;
function nm(r) {
  this.options = T0.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, r || {});
  const e = this.options;
  e.raw && e.windowBits >= 0 && e.windowBits < 16 && (e.windowBits = -e.windowBits, e.windowBits === 0 && (e.windowBits = -15)), e.windowBits >= 0 && e.windowBits < 16 && !(r && r.windowBits) && (e.windowBits += 32), e.windowBits > 15 && e.windowBits < 48 && (e.windowBits & 15) === 0 && (e.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new p8(), this.strm.avail_out = 0;
  let t = jo.inflateInit2(
    this.strm,
    e.windowBits
  );
  if (t !== og)
    throw new Error(ol[t]);
  if (this.header = new ffe(), jo.inflateGetHeader(this.strm, this.header), e.dictionary && (typeof e.dictionary == "string" ? e.dictionary = sg.string2buf(e.dictionary) : C8.call(e.dictionary) === "[object ArrayBuffer]" && (e.dictionary = new Uint8Array(e.dictionary)), e.raw && (t = jo.inflateSetDictionary(this.strm, e.dictionary), t !== og)))
    throw new Error(ol[t]);
}
nm.prototype.push = function(r, e) {
  const t = this.strm, n = this.options.chunkSize, i = this.options.dictionary;
  let s, o, a;
  if (this.ended) return !1;
  for (e === ~~e ? o = e : o = e === !0 ? gfe : pfe, C8.call(r) === "[object ArrayBuffer]" ? t.input = new Uint8Array(r) : t.input = r, t.next_in = 0, t.avail_in = t.input.length; ; ) {
    for (t.avail_out === 0 && (t.output = new Uint8Array(n), t.next_out = 0, t.avail_out = n), s = jo.inflate(t, o), s === eS && i && (s = jo.inflateSetDictionary(t, i), s === og ? s = jo.inflate(t, o) : s === LN && (s = eS)); t.avail_in > 0 && s === Q_ && t.state.wrap > 0 && r[t.next_in] !== 0; )
      jo.inflateReset(t), s = jo.inflate(t, o);
    switch (s) {
      case mfe:
      case LN:
      case eS:
      case yfe:
        return this.onEnd(s), this.ended = !0, !1;
    }
    if (a = t.avail_out, t.next_out && (t.avail_out === 0 || s === Q_))
      if (this.options.to === "string") {
        let c = sg.utf8border(t.output, t.next_out), u = t.next_out - c, l = sg.buf2string(t.output, c);
        t.next_out = u, t.avail_out = n - u, u && t.output.set(t.output.subarray(c, c + u), 0), this.onData(l);
      } else
        this.onData(t.output.length === t.next_out ? t.output : t.output.subarray(0, t.next_out));
    if (!(s === og && a === 0)) {
      if (s === Q_)
        return s = jo.inflateEnd(this.strm), this.onEnd(s), this.ended = !0, !0;
      if (t.avail_in === 0) break;
    }
  }
  return !0;
};
nm.prototype.onData = function(r) {
  this.chunks.push(r);
};
nm.prototype.onEnd = function(r) {
  r === og && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = T0.flattenChunks(this.chunks)), this.chunks = [], this.err = r, this.msg = this.strm.msg;
};
function iD(r, e) {
  const t = new nm(e);
  if (t.push(r), t.err) throw t.msg || ol[t.err];
  return t.result;
}
function vfe(r, e) {
  return e = e || {}, e.raw = !0, iD(r, e);
}
var bfe = nm, wfe = iD, _fe = vfe, Sfe = iD, Efe = {
  Inflate: bfe,
  inflate: wfe,
  inflateRaw: _fe,
  ungzip: Sfe
};
const { Deflate: xfe, deflate: Afe, deflateRaw: Ife, gzip: Cfe } = $he, { Inflate: Dfe, inflate: Tfe, inflateRaw: kfe, ungzip: Ofe } = Efe;
var $fe = xfe, Rfe = Afe, Pfe = Ife, Nfe = Cfe, Bfe = Dfe, Lfe = Tfe, Ufe = kfe, Ffe = Ofe, Mfe = em, Vfe = {
  Deflate: $fe,
  deflate: Rfe,
  deflateRaw: Pfe,
  gzip: Nfe,
  Inflate: Bfe,
  inflate: Lfe,
  inflateRaw: Ufe,
  ungzip: Ffe,
  constants: Mfe
};
class zfe extends it {
  constructor(e, t) {
    super(e, "LedgerSyncAuthenticationError", t);
  }
}
var jfe = Object.getOwnPropertyDescriptor, Hfe = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? jfe(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, Kf = (r, e) => (t, n) => e(t, n, r);
const Gfe = 16;
let TI = class {
  constructor(r, e, t, n, i) {
    h(this, "logger");
    h(this, "_authContext");
    h(this, "lkrpAppKit");
    h(this, "keyPair");
    h(this, "trustChainId");
    this.loggerFactory = r, this.deviceManagementKitService = e, this.storageService = t, this.getOrCreateKeyPairUseCase = n, this.config = i, this.logger = this.loggerFactory("[Ledger Sync Service]");
    const s = this.deviceManagementKitService.dmk;
    this.lkrpAppKit = new rie({
      dmk: s,
      applicationId: Gfe,
      env: this.config.environment === "production" ? Wh.PROD : Wh.STAGING
    }).build();
  }
  authenticate() {
    return this.logger.info("Authenticating with ledger sync"), rn(this.getOrCreateKeyPairUseCase.execute()).pipe(
      Qr((r) => {
        const e = this.prepareAuthenticationData(r), t = this.createAuthenticateInput(e);
        return this.executeAuthentication(t);
      }),
      cr(
        (r) => this.mapAuthenticateResponse(r)
      )
    );
  }
  async decrypt(r) {
    var t, n;
    if (!((t = this.authContext) != null && t.encryptionKey)) {
      const i = new TB("No encryption key");
      throw this.logger.error("Missing encryption key for decrypt", { error: i }), i;
    }
    const e = await this.lkrpAppKit.decryptData(
      (n = this.authContext) == null ? void 0 : n.encryptionKey,
      r
    );
    return Vfe.inflate(e);
  }
  get authContext() {
    return this._authContext;
  }
  getClientName() {
    return `LedgerWalletProvider::${this.config.dAppIdentifier}`;
  }
  prepareAuthenticationData(r) {
    this.logger.info("Keypair retrieved", {
      keypair: r.getPublicKeyToHex()
    }), this.keyPair = r;
    const e = this.storageService.getTrustChainId().extract();
    return this.trustChainId = e, this.logger.info(`Trustchain ID : ${e}`), this.logger.info("Start DeviceAction for authenticate with ledger sync"), { keypair: r, trustChainId: e };
  }
  createAuthenticateInput(r) {
    const { keypair: e, trustChainId: t } = r;
    return this.logger.info("Create authenticate input", {
      trustChainId: t,
      keypair: e.getPublicKeyToHex()
    }), t ? this.createKeypairAuthenticateInput(e, t) : this.createDeviceAuthenticateInput(e);
  }
  createDeviceAuthenticateInput(r) {
    if (this.logger.info("Try to authenticate with a Ledger Device"), !this.deviceManagementKitService.sessionId)
      throw new Error("No session ID");
    return {
      keypair: r,
      clientName: this.getClientName(),
      permissions: gp.OWNER & ~gp.CAN_ADD_BLOCK,
      sessionId: this.deviceManagementKitService.sessionId,
      trustchainId: void 0
    };
  }
  createKeypairAuthenticateInput(r, e) {
    return this.logger.info("Try to authenticate with keypair"), {
      keypair: r,
      clientName: this.getClientName(),
      permissions: gp.OWNER & ~gp.CAN_ADD_BLOCK,
      trustchainId: e,
      sessionId: void 0
    };
  }
  executeAuthentication(r) {
    return this.lkrpAppKit.authenticate(r).observable;
  }
  mapAuthenticateResponse(r) {
    var e, t, n, i;
    switch (r.status) {
      case Oe.Completed: {
        const s = {
          jwt: r.output.jwt,
          trustChainId: r.output.trustchainId,
          encryptionKey: r.output.encryptionKey,
          applicationPath: r.output.applicationPath,
          keyPair: this.keyPair
        };
        return this.trustChainId = s.trustChainId, this.storageService.saveTrustChainId(this.trustChainId), this._authContext = s, {
          trustChainId: s.trustChainId,
          applicationPath: s.applicationPath
        };
      }
      case Oe.Error: {
        const s = ((e = r.error) == null ? void 0 : e.message) ?? "An unknown error occurred", o = new L8(s, {
          errorType: (n = (t = r.error) == null ? void 0 : t.constructor) == null ? void 0 : n.name,
          originalError: JSON.stringify(r.error)
        });
        return this.logger.error("LKRP authentication failed", { error: o }), o;
      }
      // TODO https://ledgerhq.atlassian.net/browse/LBD-199
      //  Handle error when members has been removed from the trustchain => Remove the trustchainId from the storage and retry the authentication
      case Oe.Pending:
        return {
          requiredUserInteraction: (i = r.intermediateValue) == null ? void 0 : i.requiredUserInteraction
        };
      default: {
        const s = new zfe("Unknown error");
        return this.logger.error("Unknown authentication status", { error: s }), s;
      }
    }
  }
};
TI = Hfe([
  ke(),
  Kf(0, H(Me.LoggerPublisher)),
  Kf(1, H(gt.DeviceManagementKitService)),
  Kf(2, H(zt.StorageService)),
  Kf(3, H(Ii.GetOrCreateKeyPairUseCase)),
  Kf(4, H(Dt.Config))
], TI);
function Kfe({ stub: r }) {
  return new $r(({ bind: e }) => {
    e(Xv.LedgerSyncService).to(TI).inSingletonScope();
  });
}
const tS = 10, UN = (r = 0) => (e) => `\x1B[${e + r}m`, FN = (r = 0) => (e) => `\x1B[${38 + r};5;${e}m`, MN = (r = 0) => (e, t, n) => `\x1B[${38 + r};2;${e};${t};${n}m`, Jt = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
};
Object.keys(Jt.modifier);
const qfe = Object.keys(Jt.color), Wfe = Object.keys(Jt.bgColor);
[...qfe, ...Wfe];
function Zfe() {
  const r = /* @__PURE__ */ new Map();
  for (const [e, t] of Object.entries(Jt)) {
    for (const [n, i] of Object.entries(t))
      Jt[n] = {
        open: `\x1B[${i[0]}m`,
        close: `\x1B[${i[1]}m`
      }, t[n] = Jt[n], r.set(i[0], i[1]);
    Object.defineProperty(Jt, e, {
      value: t,
      enumerable: !1
    });
  }
  return Object.defineProperty(Jt, "codes", {
    value: r,
    enumerable: !1
  }), Jt.color.close = "\x1B[39m", Jt.bgColor.close = "\x1B[49m", Jt.color.ansi = UN(), Jt.color.ansi256 = FN(), Jt.color.ansi16m = MN(), Jt.bgColor.ansi = UN(tS), Jt.bgColor.ansi256 = FN(tS), Jt.bgColor.ansi16m = MN(tS), Object.defineProperties(Jt, {
    rgbToAnsi256: {
      value(e, t, n) {
        return e === t && t === n ? e < 8 ? 16 : e > 248 ? 231 : Math.round((e - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(e / 255 * 5) + 6 * Math.round(t / 255 * 5) + Math.round(n / 255 * 5);
      },
      enumerable: !1
    },
    hexToRgb: {
      value(e) {
        const t = /[a-f\d]{6}|[a-f\d]{3}/i.exec(e.toString(16));
        if (!t)
          return [0, 0, 0];
        let [n] = t;
        n.length === 3 && (n = [...n].map((s) => s + s).join(""));
        const i = Number.parseInt(n, 16);
        return [
          /* eslint-disable no-bitwise */
          i >> 16 & 255,
          i >> 8 & 255,
          i & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: !1
    },
    hexToAnsi256: {
      value: (e) => Jt.rgbToAnsi256(...Jt.hexToRgb(e)),
      enumerable: !1
    },
    ansi256ToAnsi: {
      value(e) {
        if (e < 8)
          return 30 + e;
        if (e < 16)
          return 90 + (e - 8);
        let t, n, i;
        if (e >= 232)
          t = ((e - 232) * 10 + 8) / 255, n = t, i = t;
        else {
          e -= 16;
          const a = e % 36;
          t = Math.floor(e / 36) / 5, n = Math.floor(a / 6) / 5, i = a % 6 / 5;
        }
        const s = Math.max(t, n, i) * 2;
        if (s === 0)
          return 30;
        let o = 30 + (Math.round(i) << 2 | Math.round(n) << 1 | Math.round(t));
        return s === 2 && (o += 60), o;
      },
      enumerable: !1
    },
    rgbToAnsi: {
      value: (e, t, n) => Jt.ansi256ToAnsi(Jt.rgbToAnsi256(e, t, n)),
      enumerable: !1
    },
    hexToAnsi: {
      value: (e) => Jt.ansi256ToAnsi(Jt.hexToAnsi256(e)),
      enumerable: !1
    }
  }), Jt;
}
const Ks = Zfe(), VN = (() => {
  if (!("navigator" in globalThis))
    return 0;
  if (globalThis.navigator.userAgentData) {
    const r = navigator.userAgentData.brands.find(({ brand: e }) => e === "Chromium");
    if (r && r.version > 93)
      return 3;
  }
  return /\b(Chrome|Chromium)\//.test(globalThis.navigator.userAgent) ? 1 : 0;
})(), zN = VN !== 0 && {
  level: VN
}, Jfe = {
  stdout: zN,
  stderr: zN
};
function Xfe(r, e, t) {
  let n = r.indexOf(e);
  if (n === -1)
    return r;
  const i = e.length;
  let s = 0, o = "";
  do
    o += r.slice(s, n) + e + t, s = n + i, n = r.indexOf(e, s);
  while (n !== -1);
  return o += r.slice(s), o;
}
function Yfe(r, e, t, n) {
  let i = 0, s = "";
  do {
    const o = r[n - 1] === "\r";
    s += r.slice(i, o ? n - 1 : n) + e + (o ? `\r
` : `
`) + t, i = n + 1, n = r.indexOf(`
`, i);
  } while (n !== -1);
  return s += r.slice(i), s;
}
const { stdout: jN, stderr: HN } = Jfe, kI = Symbol("GENERATOR"), tf = Symbol("STYLER"), ag = Symbol("IS_EMPTY"), GN = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
], rf = /* @__PURE__ */ Object.create(null), Qfe = (r, e = {}) => {
  if (e.level && !(Number.isInteger(e.level) && e.level >= 0 && e.level <= 3))
    throw new Error("The `level` option should be an integer from 0 to 3");
  const t = jN ? jN.level : 0;
  r.level = e.level === void 0 ? t : e.level;
}, epe = (r) => {
  const e = (...t) => t.join(" ");
  return Qfe(e, r), Object.setPrototypeOf(e, im.prototype), e;
};
function im(r) {
  return epe(r);
}
Object.setPrototypeOf(im.prototype, Function.prototype);
for (const [r, e] of Object.entries(Ks))
  rf[r] = {
    get() {
      const t = mv(this, $I(e.open, e.close, this[tf]), this[ag]);
      return Object.defineProperty(this, r, { value: t }), t;
    }
  };
rf.visible = {
  get() {
    const r = mv(this, this[tf], !0);
    return Object.defineProperty(this, "visible", { value: r }), r;
  }
};
const OI = (r, e, t, ...n) => r === "rgb" ? e === "ansi16m" ? Ks[t].ansi16m(...n) : e === "ansi256" ? Ks[t].ansi256(Ks.rgbToAnsi256(...n)) : Ks[t].ansi(Ks.rgbToAnsi(...n)) : r === "hex" ? OI("rgb", e, t, ...Ks.hexToRgb(...n)) : Ks[t][r](...n), tpe = ["rgb", "hex", "ansi256"];
for (const r of tpe) {
  rf[r] = {
    get() {
      const { level: t } = this;
      return function(...n) {
        const i = $I(OI(r, GN[t], "color", ...n), Ks.color.close, this[tf]);
        return mv(this, i, this[ag]);
      };
    }
  };
  const e = "bg" + r[0].toUpperCase() + r.slice(1);
  rf[e] = {
    get() {
      const { level: t } = this;
      return function(...n) {
        const i = $I(OI(r, GN[t], "bgColor", ...n), Ks.bgColor.close, this[tf]);
        return mv(this, i, this[ag]);
      };
    }
  };
}
const rpe = Object.defineProperties(() => {
}, {
  ...rf,
  level: {
    enumerable: !0,
    get() {
      return this[kI].level;
    },
    set(r) {
      this[kI].level = r;
    }
  }
}), $I = (r, e, t) => {
  let n, i;
  return t === void 0 ? (n = r, i = e) : (n = t.openAll + r, i = e + t.closeAll), {
    open: r,
    close: e,
    openAll: n,
    closeAll: i,
    parent: t
  };
}, mv = (r, e, t) => {
  const n = (...i) => npe(n, i.length === 1 ? "" + i[0] : i.join(" "));
  return Object.setPrototypeOf(n, rpe), n[kI] = r, n[tf] = e, n[ag] = t, n;
}, npe = (r, e) => {
  if (r.level <= 0 || !e)
    return r[ag] ? "" : e;
  let t = r[tf];
  if (t === void 0)
    return e;
  const { openAll: n, closeAll: i } = t;
  if (e.includes("\x1B"))
    for (; t !== void 0; )
      e = Xfe(e, t.close, t.open), t = t.parent;
  const s = e.indexOf(`
`);
  return s !== -1 && (e = Yfe(e, i, n, s)), n + e + i;
};
Object.defineProperties(im.prototype, rf);
const Ul = im();
im({ level: HN ? HN.level : 0 });
var ipe = Object.getOwnPropertyDescriptor, spe = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? ipe(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, ope = (r, e) => (t, n) => e(t, n, r);
let RI = class {
  constructor(r) {
    this.config = r;
  }
  canLog(r) {
    return r <= this.config.logLevel;
  }
  formatMessage(r, e) {
    const n = {
      [Cr.debug]: Ul.cyan,
      [Cr.info]: Ul.green,
      [Cr.warn]: Ul.yellow,
      [Cr.error]: Ul.red,
      [Cr.fatal]: Ul.bgRed
    }[r];
    return n ? n(e) : Ul.white(e);
  }
  log(r, e, t) {
    if (!this.canLog(r))
      return;
    const n = `[${t.tag}]`;
    switch (console.group(this.formatMessage(r, `${n}: ${t.timestamp}`)), r) {
      case Cr.debug:
        console.debug(this.formatMessage(r, e), t.data);
        break;
      case Cr.info:
        console.info(this.formatMessage(r, e), t.data);
        break;
      case Cr.warn:
        console.warn(this.formatMessage(r, e), t.data);
        break;
      case Cr.error:
      case Cr.fatal:
        console.error(this.formatMessage(r, e), t.data);
        break;
    }
    console.groupEnd();
  }
};
RI = spe([
  ke(),
  ope(0, H(Dt.Config))
], RI);
var ape = Object.getOwnPropertyDescriptor, cpe = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? ape(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, upe = (r, e) => (t, n) => e(t, n, r);
let PI = class {
  constructor(r, e) {
    this.subscribers = r, this.tag = e;
  }
  _log(r, e, t) {
    const n = {
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      tag: this.tag,
      data: t
    };
    this.subscribers.forEach((i) => {
      i.log(r, e, n);
    });
  }
  error(r, e) {
    this._log(Cr.error, r, e);
  }
  warn(r, e) {
    this._log(Cr.warn, r, e);
  }
  info(r, e) {
    this._log(Cr.info, r, e);
  }
  debug(r, e) {
    this._log(Cr.debug, r, e);
  }
  fatal(r, e) {
    this._log(Cr.fatal, r, e);
  }
};
PI = cpe([
  ke(),
  upe(0, xG(Me.LoggerSubscriber))
], PI);
const lpe = ["ledger_sync_id"], dpe = (r) => {
  if (!r) return;
  const e = {};
  for (const [t, n] of Object.entries(r)) {
    const i = t.toLowerCase();
    lpe.some((s) => i.includes(s)) || (e[t] = n);
  }
  return Object.keys(e).length > 0 ? e : void 0;
}, hpe = {
  AccountNotSelectedError: "account",
  BlindSigningDisabledError: "blind-signing",
  DeviceConnectionError: "device",
  DeviceNotSupportedError: "device",
  DeviceDisconnectedError: "device",
  FailToOpenAppError: "device",
  IncorrectSeedError: "device",
  SignTransactionError: "transaction",
  UserRejectedTransactionError: "transaction",
  TransactionValidationError: "transaction",
  LedgerSyncConnectionError: "ledgersync",
  LedgerSyncAuthenticationError: "ledgersync",
  LedgerKeyringProtocolError: "ledgersync",
  LedgerSyncConnectionFailedError: "ledgersync",
  LedgerSyncError: "ledgersync",
  LedgerSyncAuthContextMissingError: "ledgersync",
  LedgerSyncNoSessionIdError: "ledgersync"
}, fpe = (r) => {
  const e = r.name;
  return hpe[e] ?? "unknown";
}, ppe = (r) => {
  const { error: e, sessionId: t, dAppId: n } = r, s = e instanceof it ? e.context : void 0, o = {
    event_id: Gr(),
    transaction_dapp_id: n,
    timestamp_ms: Date.now(),
    event_type: ze.ErrorOccurred,
    session_id: t,
    error_type: e.name,
    error_code: void 0,
    // TODO: Add when error codes are implemented
    error_message: e.message,
    error_category: fpe(e),
    error_data: dpe(s)
  };
  return {
    name: ze.ErrorOccurred,
    type: ze.ErrorOccurred,
    data: o
  };
};
var gpe = Object.getOwnPropertyDescriptor, mpe = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? gpe(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
};
let NI = class {
  constructor(r) {
    h(this, "config");
    h(this, "sessionId");
    h(this, "dAppId");
    h(this, "trackEvent");
    this.sessionId = r.sessionId, this.dAppId = r.dAppId, this.trackEvent = r.trackEvent, this.config = r.config ?? G4;
  }
  getSessionId() {
    return typeof this.sessionId == "function" ? this.sessionId() : this.sessionId;
  }
  getDAppId() {
    return typeof this.dAppId == "function" ? this.dAppId() : this.dAppId;
  }
  log(r, e, t) {
    if (r !== Cr.error && r !== Cr.fatal || !this.config.enabled)
      return;
    const n = this.extractError(t.data);
    if (!n || this.config.useWhitelist && !sle(n.name))
      return;
    const i = ppe({
      error: n,
      sessionId: this.getSessionId(),
      dAppId: this.getDAppId()
    });
    this.trackEvent(i);
  }
  extractError(r) {
    return r && r.error instanceof Error ? r.error : null;
  }
};
NI = mpe([
  ke()
], NI);
function ype({
  stub: r,
  errorTrackingConfig: e
} = {}) {
  return new $r(({ bind: t }) => {
    t(Me.LoggerSubscriber).to(
      RI
    ), (e == null ? void 0 : e.enabled) !== !1 && t(Me.LoggerSubscriber).toDynamicValue((n) => {
      const i = () => n.get(
        rt.EventTrackingService
      ).getSessionId(), s = () => n.get(Dt.Config).dAppIdentifier, o = (a) => n.get(
        rt.EventTrackingService
      ).trackEvent(a);
      return new NI({
        sessionId: i,
        dAppId: s,
        trackEvent: o,
        config: e
      });
    }).inSingletonScope(), t(Me.LoggerPublisher).toDynamicValue(
      (n) => (i) => {
        const s = n.getAll(
          Me.LoggerSubscriber
        );
        return new PI(s, i);
      }
    );
  });
}
var vpe = Object.defineProperty, bpe = Object.getOwnPropertyDescriptor, D8 = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? bpe(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = (n ? o(e, t, i) : o(i)) || i);
  return n && i && vpe(e, t, i), i;
}, KN = (r, e) => (t, n) => e(t, n, r);
let yv = class {
  constructor(r, e) {
    h(this, "_open", !1);
    h(this, "logger");
    h(this, "openTracked", !1);
    h(this, "openModal", () => {
      this.logger.info("ledger-core-modal-open"), this._open = !0, this.openTracked || (this.trackOpenSession.execute(), this.openTracked = !0);
    });
    h(this, "closeModal", () => {
      this.logger.info("ledger-core-modal-close"), this._open = !1;
    });
    this.trackOpenSession = e, this.logger = r("[ModalService]"), window && (window.addEventListener("ledger-core-modal-open", this.openModal), window.addEventListener("ledger-core-modal-close", this.closeModal));
  }
  onDeactivation() {
    window && (window.removeEventListener("ledger-core-modal-open", this.openModal), window.removeEventListener("ledger-core-modal-close", this.closeModal));
  }
  get open() {
    return this._open;
  }
};
D8([
  AG()
], yv.prototype, "onDeactivation", 1);
yv = D8([
  ke(),
  KN(0, H(Me.LoggerPublisher)),
  KN(1, H(rt.TrackOpenSession))
], yv);
function wpe() {
  return new $r(({ bind: r }) => {
    r(XC.ModalService).to(yv).inSingletonScope();
  });
}
const T8 = "X-Ledger-Client-Version", _pe = "X-Ledger-Origin-Token", Spe = {
  [T8]: "ll-web-tools/0.0.0",
  "Content-Type": "application/json"
  // TODO add from config [LEDGER_ORIGIN_TOKEN_HEADER]: "TO BE REPLACED",
};
function Wl(r, ...e) {
  if (e.length === 0)
    return r;
  for (const t of e)
    for (const n of Object.keys(t))
      if (!(["__proto__", "constructor", "prototype"].includes(n) || !Object.prototype.hasOwnProperty.call(t, n)) && t[n] !== null && t[n] !== void 0) {
        const i = t[n], s = r[n];
        s == null || typeof s != "object" ? r[n] = i : Array.isArray(i) ? Array.isArray(s) ? r[n] = [
          .../* @__PURE__ */ new Set([...s, ...i])
        ] : r[n] = i : typeof i == "object" && !Array.isArray(i) && typeof s == "object" && !Array.isArray(s) ? Wl(s, i) : r[n] = i;
      }
  return r;
}
const Epe = "1.0.2-local", xpe = {
  version: Epe
};
var Ape = Object.getOwnPropertyDescriptor, Ipe = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? Ape(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, Cpe = (r, e) => (t, n) => e(t, n, r);
let BI = class {
  constructor(r) {
    h(this, "headers", {});
    this.config = r;
    const e = {
      [_pe]: this.config.originToken,
      [T8]: `ledger-button/${xpe.version}/${this.config.dAppIdentifier}`
    };
    this.headers = {
      ...Spe,
      ...e
    };
  }
  async get(r, e) {
    const t = {
      headers: this.headers,
      method: "GET"
    };
    return me(async () => {
      const n = await fetch(r, Wl(t, e || {}));
      if (!n.ok)
        throw new Cf("GET request failed", {
          status: n.status,
          url: r,
          options: e
        });
      return n.json();
    });
  }
  async post(r, e, t) {
    const n = {
      headers: this.headers,
      method: "POST",
      body: e
    };
    return me(async () => {
      const i = await fetch(r, Wl(n, t || {}));
      if (!i.ok)
        throw new Cf("POST request failed", {
          status: i.status,
          url: r,
          options: t,
          body: e
        });
      return i.json();
    });
  }
  async put(r, e, t) {
    const n = {
      headers: this.headers,
      method: "PUT",
      body: e
    };
    return me(async () => {
      const i = await fetch(r, Wl(n, t || {}));
      if (!i.ok)
        throw new Cf("PUT request failed", {
          status: i.status,
          url: r,
          options: t,
          body: e
        });
      return i.json();
    });
  }
  async patch(r, e, t) {
    const n = {
      headers: this.headers,
      method: "PATCH",
      body: e
    };
    return me(async () => {
      const i = await fetch(r, Wl(n, t || {}));
      if (!i.ok)
        throw new Cf("PATCH request failed", {
          status: i.status,
          url: r,
          options: t,
          body: e
        });
      return i.json();
    });
  }
  async delete(r, e) {
    const t = {
      headers: this.headers,
      method: "DELETE"
    };
    return me(async () => {
      const n = await fetch(r, Wl(t, e || {}));
      if (!n.ok)
        throw new Cf("DELETE request failed", {
          status: n.status,
          url: r,
          options: e
        });
      return n.json();
    });
  }
};
BI = Ipe([
  ke(),
  Cpe(0, H(Dt.Config))
], BI);
function Dpe({ stub: r }) {
  return new $r(({ bind: e }) => {
    e(gl.NetworkService).to(BI);
  });
}
const Tpe = {
  DB_NAME: "ledger-button-db",
  DB_STORE_NAME: "ledger-button-store",
  DB_STORE_KEYPAIR_KEY: "keyPair",
  ENCRYPTION_KEY: "encryptionKey",
  USER_CONSENT: "userConsent",
  WELCOME_SCREEN_COMPLETED: "welcomeScreenCompleted"
}, kpe = 3, Ope = {
  PREFIX: "ledger-button",
  SELECTED_ACCOUNT: "selectedAccount",
  TRUST_CHAIN_ID: "trustChainId",
  TRUST_CHAIN_VALIDITY: "trustChainValidity",
  DB_VERSION: "dbVersion"
}, Ge = {
  ...Tpe,
  ...Ope
};
var $pe = Object.getOwnPropertyDescriptor, Rpe = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? $pe(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, Ppe = (r, e) => (t, n) => e(t, n, r);
let LI = class {
  constructor(r) {
    h(this, "logger");
    h(this, "initialization", ve);
    h(this, "idb", N(
      new F8("IDB not initialized")
    ));
    this.loggerFactory = r, this.logger = this.loggerFactory("[IndexedDB Service]");
  }
  async initIdb() {
    return this.idb.isRight() ? this.idb : this.initialization.isJust() ? (await this.initialization.orDefault(Promise.resolve()), this.idb) : (this.initialization = Le(
      new Promise((r) => {
        const e = indexedDB.open(
          Ge.DB_NAME,
          kpe
        );
        e.onsuccess = (t) => {
          this.logger.debug("IDB opened");
          const n = t.target.result;
          r(te(n));
        }, e.onerror = (t) => {
          this.logger.error("Error opening IDB", { event: t }), r(
            N(new U8("Error opening IDB", { event: t }))
          );
        }, e.onupgradeneeded = (t) => {
          const i = t.target.result.createObjectStore(Ge.DB_STORE_NAME);
          i.createIndex(
            Ge.DB_STORE_KEYPAIR_KEY,
            Ge.DB_STORE_KEYPAIR_KEY,
            { unique: !0 }
          ), i.createIndex(
            Ge.ENCRYPTION_KEY,
            Ge.ENCRYPTION_KEY,
            { unique: !0 }
          );
        };
      }).then((r) => {
        Pt.isEither(r) && (this.idb = r);
      })
    ), await this.initialization.orDefault(Promise.resolve()), this.idb);
  }
  async storeKeyPair(r) {
    const e = It(r);
    this.logger.debug("Storing encrypted keyPair in storage", {
      keyPair: e
    });
    const t = await this.initIdb();
    return new Promise((n) => {
      t.map((i) => {
        const a = i.transaction(
          Ge.DB_STORE_NAME,
          "readwrite"
        ).objectStore(Ge.DB_STORE_NAME).add(
          e,
          Ge.DB_STORE_KEYPAIR_KEY
        );
        a.onsuccess = () => {
          this.logger.debug("KeyPair stored", {
            keyPair: It(r)
          }), n(te(!0));
        }, a.onerror = (c) => {
          this.logger.error("Error storing key pair", { event: c }), n(
            N(
              new um("Error storing key pair", {
                event: c,
                keyPair: e
              })
            )
          );
        };
      });
    });
  }
  async getKeyPair() {
    const r = await this.initIdb();
    return new Promise((e) => {
      r.map((t) => {
        const s = t.transaction(
          Ge.DB_STORE_NAME,
          "readonly"
        ).objectStore(Ge.DB_STORE_NAME).get(Ge.DB_STORE_KEYPAIR_KEY);
        s.onsuccess = (o) => {
          var c;
          const a = (c = o.target) == null ? void 0 : c.result;
          if (!a) {
            this.logger.error("Error getting key pair from indexDB", { event: o }), e(
              N(new If("Error getting key pair", { event: o }))
            );
            return;
          }
          this.logger.info("KeyPair retrieved from indexDB", {
            keyPair: a
          }), e(te(_r(a)));
        }, s.onerror = (o) => {
          this.logger.error("Error getting key pair", { event: o }), e(
            N(
              new If("Error getting key pair", {
                event: o
              })
            )
          );
        };
      });
    });
  }
  async removeKeyPair() {
    const r = await this.initIdb();
    return new Promise((e) => {
      r.map((t) => {
        const s = t.transaction(
          Ge.DB_STORE_NAME,
          "readwrite"
        ).objectStore(Ge.DB_STORE_NAME).delete(Ge.DB_STORE_KEYPAIR_KEY);
        s.onsuccess = () => {
          this.logger.debug("Key pair removed"), e(te(!0));
        }, s.onerror = (o) => {
          this.logger.error("Error removing key pair", { event: o }), e(
            N(
              new M8("Error removing key pair", { event: o })
            )
          );
        };
      });
    });
  }
  async storeEncryptionKey(r) {
    const e = await this.initIdb();
    return new Promise((t, n) => {
      e.map((i) => {
        const a = i.transaction(
          Ge.DB_STORE_NAME,
          "readwrite"
        ).objectStore(Ge.DB_STORE_NAME).put(r, Ge.ENCRYPTION_KEY);
        a.onsuccess = () => {
          this.logger.debug("Encryption key stored successfully"), t();
        }, a.onerror = (c) => {
          this.logger.error("Error storing encryption key", { event: c }), n(new Error("Failed to store encryption key"));
        };
      }).caseOf({
        Left: (i) => {
          this.logger.error(
            "Error initializing IDB for encryption key storage",
            { error: i }
          ), n(i);
        },
        Right: () => {
        }
      });
    });
  }
  async getEncryptionKey() {
    const r = await this.initIdb();
    return new Promise((e) => {
      r.map((t) => {
        const s = t.transaction(
          Ge.DB_STORE_NAME,
          "readonly"
        ).objectStore(Ge.DB_STORE_NAME).get(Ge.ENCRYPTION_KEY);
        s.onsuccess = (o) => {
          var c;
          const a = (c = o.target) == null ? void 0 : c.result;
          a && a instanceof CryptoKey ? (this.logger.debug("Encryption key retrieved successfully"), e(Le(a))) : (this.logger.debug("No encryption key found in storage"), e(ve));
        }, s.onerror = (o) => {
          this.logger.error("Error retrieving encryption key", { event: o }), e(ve);
        };
      }).caseOf({
        Left: (t) => {
          this.logger.error(
            "Error initializing IDB for encryption key retrieval",
            { error: t }
          ), e(ve);
        },
        Right: () => {
        }
      });
    });
  }
  async setDbVersion(r) {
    const e = await this.initIdb();
    return new Promise((t) => {
      e.map((n) => {
        const o = n.transaction(
          Ge.DB_STORE_NAME,
          "readwrite"
        ).objectStore(Ge.DB_STORE_NAME).put(r, Ge.DB_VERSION);
        o.onsuccess = () => {
          this.logger.debug("DB version stored in IndexedDB", { version: r }), t(te(void 0));
        }, o.onerror = (a) => {
          this.logger.error("Error storing DB version in IndexedDB", {
            event: a,
            version: r
          }), t(
            N(
              new um("Error storing DB version", {
                event: a,
                version: r
              })
            )
          );
        };
      }).caseOf({
        Left: (n) => {
          this.logger.error("Error initializing IDB for DB version storage", {
            error: n
          }), t(N(n));
        },
        Right: () => {
        }
      });
    });
  }
  async getDbVersion() {
    const r = await this.initIdb();
    return new Promise((e) => {
      r.map((t) => {
        const s = t.transaction(
          Ge.DB_STORE_NAME,
          "readonly"
        ).objectStore(Ge.DB_STORE_NAME).get(Ge.DB_VERSION);
        s.onsuccess = (o) => {
          var c;
          const a = (c = o.target) == null ? void 0 : c.result;
          a !== void 0 && typeof a == "number" ? (this.logger.debug("DB version retrieved from IndexedDB", {
            version: a
          }), e(te(Le(a)))) : (this.logger.debug("No DB version found in IndexedDB"), e(te(ve)));
        }, s.onerror = (o) => {
          this.logger.error("Error retrieving DB version from IndexedDB", {
            event: o
          }), e(
            N(
              new If("Error retrieving DB version", {
                event: o
              })
            )
          );
        };
      }).caseOf({
        Left: (t) => {
          this.logger.error(
            "Error initializing IDB for DB version retrieval",
            { error: t }
          ), e(N(t));
        },
        Right: () => {
        }
      });
    });
  }
  async storeUserConsent(r) {
    const e = await this.initIdb();
    return new Promise((t) => {
      e.map((n) => {
        const o = n.transaction(
          Ge.DB_STORE_NAME,
          "readwrite"
        ).objectStore(Ge.DB_STORE_NAME).put(r, Ge.USER_CONSENT);
        o.onsuccess = () => {
          this.logger.debug("User consent stored in IndexedDB", { consent: r }), t(te(void 0));
        }, o.onerror = (a) => {
          this.logger.error("Error storing user consent in IndexedDB", {
            event: a,
            consent: r
          }), t(
            N(
              new um("Error storing user consent", {
                event: a,
                consent: r
              })
            )
          );
        };
      }).caseOf({
        Left: (n) => {
          this.logger.error(
            "Error initializing IDB for user consent storage",
            { error: n }
          ), t(N(n));
        },
        Right: () => {
        }
      });
    });
  }
  async getUserConsent() {
    const r = await this.initIdb();
    return new Promise(
      (e) => {
        r.map((t) => {
          const s = t.transaction(
            Ge.DB_STORE_NAME,
            "readonly"
          ).objectStore(Ge.DB_STORE_NAME).get(Ge.USER_CONSENT);
          s.onsuccess = (o) => {
            var c;
            const a = (c = o.target) == null ? void 0 : c.result;
            a !== void 0 ? (this.logger.debug("User consent retrieved from IndexedDB", {
              consent: a
            }), e(te(Le(a)))) : (this.logger.debug("No user consent found in IndexedDB"), e(te(ve)));
          }, s.onerror = (o) => {
            this.logger.error(
              "Error retrieving user consent from IndexedDB",
              {
                event: o
              }
            ), e(
              N(
                new If("Error retrieving user consent", {
                  event: o
                })
              )
            );
          };
        }).caseOf({
          Left: (t) => {
            this.logger.error(
              "Error initializing IDB for user consent retrieval",
              { error: t }
            ), e(N(t));
          },
          Right: () => {
          }
        });
      }
    );
  }
  async storeWelcomeScreenCompleted(r) {
    const e = await this.initIdb();
    return new Promise((t) => {
      e.map((n) => {
        const o = n.transaction(
          Ge.DB_STORE_NAME,
          "readwrite"
        ).objectStore(Ge.DB_STORE_NAME).put(
          r,
          Ge.WELCOME_SCREEN_COMPLETED
        );
        o.onsuccess = () => {
          this.logger.debug("Welcome screen status stored in IndexedDB", {
            completed: r
          }), t(te(void 0));
        }, o.onerror = (a) => {
          this.logger.error(
            "Error storing welcome screen status in IndexedDB",
            {
              event: a,
              completed: r
            }
          ), t(
            N(
              new um(
                "Error storing welcome screen status",
                {
                  event: a,
                  completed: r
                }
              )
            )
          );
        };
      }).caseOf({
        Left: (n) => {
          this.logger.error(
            "Error initializing IDB for welcome screen status storage",
            { error: n }
          ), t(N(n));
        },
        Right: () => {
        }
      });
    });
  }
  async getWelcomeScreenCompleted() {
    const r = await this.initIdb();
    return new Promise((e) => {
      r.map((t) => {
        const s = t.transaction(
          Ge.DB_STORE_NAME,
          "readonly"
        ).objectStore(Ge.DB_STORE_NAME).get(Ge.WELCOME_SCREEN_COMPLETED);
        s.onsuccess = (o) => {
          var c;
          const a = (c = o.target) == null ? void 0 : c.result;
          a !== void 0 && typeof a == "boolean" ? (this.logger.debug(
            "Welcome screen status retrieved from IndexedDB",
            {
              completed: a
            }
          ), e(te(Le(a)))) : (this.logger.debug("No welcome screen status found in IndexedDB"), e(te(ve)));
        }, s.onerror = (o) => {
          this.logger.error(
            "Error retrieving welcome screen status from IndexedDB",
            {
              event: o
            }
          ), e(
            N(
              new If(
                "Error retrieving welcome screen status",
                {
                  event: o
                }
              )
            )
          );
        };
      }).caseOf({
        Left: (t) => {
          this.logger.error(
            "Error initializing IDB for welcome screen status retrieval",
            { error: t }
          ), e(N(t));
        },
        Right: () => {
        }
      });
    });
  }
};
LI = Rpe([
  ke(),
  Ppe(0, H(Me.LoggerPublisher))
], LI);
var Npe = Object.getOwnPropertyDescriptor, Bpe = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? Npe(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, qf = (r, e) => (t, n) => e(t, n, r);
let UI = class {
  constructor(r, e, t, n, i) {
    h(this, "logger");
    this.loggerFactory = r, this.storageService = e, this.encryptKeyPairUseCase = t, this.getEncryptionKeyUseCase = n, this.getOrCreateKeyPairUseCase = i, this.logger = this.loggerFactory("[KeyPair Migration Service]");
  }
  async migrateKeyPairToEncrypted(r) {
    try {
      if (r.isRight()) {
        const e = r.extract();
        await this.encryptExistingKeyPair(e);
      } else
        await this.getOrCreateKeyPairUseCase.execute();
    } catch (e) {
      this.logger.error("Error migrating database to version 1", { error: e }), await this.storageService.removeKeyPair(), await this.getOrCreateKeyPairUseCase.execute();
    }
  }
  async encryptExistingKeyPair(r) {
    this.logger.info("KeyPair found in storage, need to encrypt it");
    const t = new m0().importKeyPair(r, Eo.K256), n = await this.getEncryptionKeyUseCase.execute(), i = await this.encryptKeyPairUseCase.execute(
      t,
      n
    );
    await this.storageService.removeKeyPair(), await this.storageService.storeKeyPair(i);
  }
};
UI = Bpe([
  ke(),
  qf(0, H(Me.LoggerPublisher)),
  qf(1, H(zt.StorageService)),
  qf(2, H(Ii.EncryptKeyPairUseCase)),
  qf(3, H(Ii.GetEncryptionKeyUseCase)),
  qf(4, H(Ii.GetOrCreateKeyPairUseCase))
], UI);
var Lpe = Object.getOwnPropertyDescriptor, Upe = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? Lpe(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, rS = (r, e) => (t, n) => e(t, n, r);
let FI = class {
  constructor(r, e, t) {
    h(this, "logger");
    this.loggerFactory = r, this.storageService = e, this.keyPairMigrationService = t, this.logger = this.loggerFactory("[MigrateDatabase Use Case]");
  }
  async execute() {
    const r = await this.storageService.getDbVersion();
    let e = r;
    e === 0 && (await this.migrateToV1(), e = 1), e === 1 && (await this.migrateToV2(), e = 2), this.logger.info(
      `Database migrated from version ${r} to version ${e}`
    );
  }
  /**
   * During the first iteration of the app, the keyPair wasn't encrypted.
   * After a dungeon review it was decided to encrypt the keyPair.
   */
  async migrateToV1() {
    const r = await this.storageService.getKeyPair();
    await this.keyPairMigrationService.migrateKeyPairToEncrypted(r);
    const e = await this.storageService.setDbVersion(1);
    if (e.isLeft())
      throw this.logger.error(
        "Failed to store DB version to already migrated database",
        {
          error: e.extract()
        }
      ), new Error(
        "Failed to store DB version to already migrated database"
      );
    this.logger.info("Database migrated to version 1");
  }
  /**
   * Migrates the database version storage from localStorage to IndexedDB.
   * This ensures the version is stored in a more persistent and reliable storage.
   */
  async migrateToV2() {
    const r = await this.storageService.setDbVersion(2);
    if (r.isLeft())
      throw this.logger.error("Failed to store DB version in IndexedDB", {
        error: r.extract()
      }), new Error("Failed to migrate DB version to IndexedDB");
    this.storageService.removeItem(Ge.DB_VERSION), this.logger.info("Database migrated to version 2");
  }
};
FI = Upe([
  ke(),
  rS(0, H(Me.LoggerPublisher)),
  rS(1, H(zt.StorageService)),
  rS(2, H(zt.KeyPairMigrationService))
], FI);
function Fpe(r) {
  return {
    address: r.freshAddress,
    currencyId: r.currencyId,
    derivationMode: r.derivationMode,
    index: r.index
  };
}
var Mpe = Object.getOwnPropertyDescriptor, Vpe = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? Mpe(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, qN = (r, e) => (t, n) => e(t, n, r);
let su = class {
  constructor(r, e) {
    h(this, "logger");
    this.loggerFactory = r, this.indexedDbService = e, this.logger = this.loggerFactory("[Storage Service]");
  }
  static formatKey(r) {
    return `${Ge.PREFIX}-${r}`;
  }
  async setDbVersion(r) {
    return this.indexedDbService.setDbVersion(r);
  }
  async getDbVersion() {
    return (await this.indexedDbService.getDbVersion()).caseOf({
      Right: (e) => e.orDefault(0),
      Left: () => this.getItem(Ge.DB_VERSION).orDefault(0)
    });
  }
  async storeKeyPair(r) {
    return this.indexedDbService.storeKeyPair(r);
  }
  async getKeyPair() {
    return this.indexedDbService.getKeyPair();
  }
  async removeKeyPair() {
    return this.indexedDbService.removeKeyPair();
  }
  async storeEncryptionKey(r) {
    return this.indexedDbService.storeEncryptionKey(r);
  }
  async getEncryptionKey() {
    return this.indexedDbService.getEncryptionKey();
  }
  // Trust Chain ID
  saveTrustChainId(r) {
    this.saveItem(Ge.TRUST_CHAIN_ID, r), this.saveItem(Ge.TRUST_CHAIN_VALIDITY, (/* @__PURE__ */ new Date()).getTime());
  }
  getTrustChainId() {
    return this.getItem(Ge.TRUST_CHAIN_ID);
  }
  removeTrustChainId() {
    this.removeItem(Ge.TRUST_CHAIN_ID), this.removeItem(Ge.TRUST_CHAIN_VALIDITY);
  }
  isTrustChainValid() {
    return this.getItem(Ge.TRUST_CHAIN_VALIDITY).map((r) => {
      const t = new Date(r);
      return new Date(t.getTime() + 2592e6) > /* @__PURE__ */ new Date();
    }).orDefault(!1);
  }
  // Selected Account
  saveSelectedAccount(r) {
    if (!r)
      return;
    const e = Fpe(r);
    this.saveItem(Ge.SELECTED_ACCOUNT, e);
  }
  getSelectedAccount() {
    return this.getItem(
      Ge.SELECTED_ACCOUNT
    ).caseOf({
      Just: (e) => Le({
        id: "",
        name: "",
        freshAddress: e.address,
        seedIdentifier: "",
        derivationMode: e.derivationMode,
        index: e.index,
        currencyId: e.currencyId,
        ticker: "",
        balance: "",
        tokens: []
      }),
      Nothing: () => ve
    });
  }
  removeSelectedAccount() {
    this.removeItem(Ge.SELECTED_ACCOUNT);
  }
  /***  Local Storage Primitives ***/
  // LocalStorage
  saveItem(r, e) {
    localStorage.setItem(
      su.formatKey(r),
      JSON.stringify(e)
    );
  }
  removeItem(r) {
    const e = su.formatKey(r);
    return this.hasItem(r) ? (localStorage.removeItem(e), this.logger.debug("Item removed", { key: r }), !0) : (this.logger.debug("Item not found", { key: r }), !1);
  }
  hasItem(r) {
    const e = su.formatKey(r);
    return localStorage.getItem(e) !== null;
  }
  resetStorage() {
    Object.keys(localStorage).forEach((r) => {
      this.logger.debug("Item", { key: r }), r.startsWith(Ge.PREFIX) && (localStorage.removeItem(r), this.logger.debug("Item removed", { key: r }));
    });
  }
  getItem(r) {
    const e = su.formatKey(r), t = localStorage.getItem(e);
    return pe.fromNullable(t).chain((n) => {
      try {
        return pe.of(JSON.parse(n));
      } catch (i) {
        return this.logger.error("Error parsing item", { error: i, key: r }), ve;
      }
    });
  }
  // Consent Management
  async saveUserConsent(r) {
    (await this.indexedDbService.storeUserConsent(r)).caseOf({
      Right: () => {
        this.logger.debug("User consent saved", { consent: r });
      },
      Left: (t) => {
        this.logger.error("Error saving user consent", { error: t, consent: r });
      }
    });
  }
  async getUserConsent() {
    return (await this.indexedDbService.getUserConsent()).caseOf({
      Right: (e) => e,
      Left: (e) => (this.logger.error("Error getting user consent", { error: e }), ve)
    });
  }
  async removeUserConsent() {
    const r = {
      consentGiven: !1,
      consentDate: (/* @__PURE__ */ new Date()).toISOString()
    };
    (await this.indexedDbService.storeUserConsent(r)).caseOf({
      Right: () => {
        this.logger.debug("User consent set to refused", { consent: r });
      },
      Left: (t) => {
        this.logger.error("Error removing user consent", { error: t });
      }
    });
  }
  // Welcome Screen Management
  async saveWelcomeScreenCompleted() {
    (await this.indexedDbService.storeWelcomeScreenCompleted(!0)).caseOf({
      Right: () => {
        this.logger.debug("Welcome screen completed saved");
      },
      Left: (e) => {
        this.logger.error("Error saving welcome screen completed", { error: e });
      }
    });
  }
  async isWelcomeScreenCompleted() {
    return (await this.indexedDbService.getWelcomeScreenCompleted()).caseOf({
      Right: (e) => e.orDefault(!1),
      Left: (e) => (this.logger.error("Error getting welcome screen completed", { error: e }), !1)
    });
  }
  async removeWelcomeScreenCompleted() {
    (await this.indexedDbService.storeWelcomeScreenCompleted(!1)).caseOf({
      Right: () => {
        this.logger.debug("Welcome screen completed set to false");
      },
      Left: (e) => {
        this.logger.error("Error removing welcome screen completed", { error: e });
      }
    });
  }
};
su = Vpe([
  ke(),
  qN(0, H(Me.LoggerPublisher)),
  qN(1, H(zt.IndexedDbService))
], su);
function zpe({ stub: r }) {
  return new $r(({ bind: e }) => {
    e(zt.StorageService).to(su).inSingletonScope(), e(zt.IndexedDbService).to(LI).inSingletonScope(), e(zt.MigrateDbUseCase).to(FI).inSingletonScope(), e(zt.KeyPairMigrationService).to(UI).inSingletonScope();
  });
}
function jpe(r) {
  return !!r && Array.isArray(r) && r.length === 3 && typeof r[0] == "string" && (typeof r[1] == "string" || r[1] instanceof Uint8Array) && typeof r[2] == "string" && (r[2] === "eth_sign" || r[2] === "personal_sign");
}
function Hpe(r) {
  return !!r && r !== null && typeof r == "object" && "transaction" in r && typeof r.transaction == "string" && "method" in r && typeof r.method == "string" && (r.method === "eth_sendRawTransaction" || r.method === "eth_signRawTransaction");
}
function Gpe(r) {
  return typeof r == "object" && r !== null && "transaction" in r && typeof r.transaction == "object" && "method" in r && typeof r.method == "string" && (r.method === "eth_sendTransaction" || r.method === "eth_signTransaction");
}
const Kpe = ["eth_signTypedData", "eth_signTypedData_v4"];
function qpe(r) {
  return !(typeof r != "object" || r === null || !("types" in r) || !("primaryType" in r) || !("domain" in r) || !("message" in r));
}
function Wpe(r) {
  if (!Array.isArray(r) || r.length !== 3)
    return !1;
  const [e, t, n] = r, i = typeof e == "string", s = qpe(t), o = typeof n == "string" && Kpe.includes(n);
  return i && s && o;
}
var Zpe = Object.getOwnPropertyDescriptor, Jpe = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? Zpe(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, Wf = (r, e) => (t, n) => e(t, n, r);
let MI = class {
  constructor(r, e, t, n, i) {
    h(this, "_pendingParams");
    h(this, "logger");
    this.signTransactionUseCase = r, this.signRawTransactionUseCase = e, this.signTypedDataUseCase = t, this.signPersonalMessageUseCase = n, this.logger = i("[DefaultTransactionService]");
  }
  sign(r) {
    this._pendingParams = r, this.logger.debug("[Sign] Signing intent received", { params: r });
    let e;
    switch (!0) {
      case Gpe(r):
        this.logger.debug("[Sign] Signing transaction"), e = this.signTransactionUseCase.execute(r);
        break;
      case Wpe(r):
        this.logger.debug("[Sign] Signing typed data"), e = this.signTypedDataUseCase.execute(r);
        break;
      case jpe(r):
        this.logger.debug("[Sign] Signing personal message"), e = this.signPersonalMessageUseCase.execute(r);
        break;
      case Hpe(r):
      default:
        this.logger.debug("[Sign] Signing raw transaction"), e = this.signRawTransactionUseCase.execute(r);
        break;
    }
    return e;
  }
  getPendingTransaction() {
    return this._pendingParams;
  }
  setPendingTransaction(r) {
    this._pendingParams = r;
  }
  reset() {
    this._pendingParams = void 0;
  }
};
MI = Jpe([
  ke(),
  Wf(0, H(gt.SignTransactionUseCase)),
  Wf(1, H(gt.SignRawTransactionUseCase)),
  Wf(2, H(gt.SignTypedDataUseCase)),
  Wf(3, H(gt.SignPersonalMessageUseCase)),
  Wf(4, H(Me.LoggerPublisher))
], MI);
const VI = {
  TransactionService: Symbol.for("TransactionService")
};
function Xpe({
  stub: r
}) {
  return new $r(({ bind: e }) => {
    e(VI.TransactionService).to(MI).inSingletonScope();
  });
}
class Ype extends it {
  constructor(e, t) {
    super(e, "TransactionHistoryError", t);
  }
}
var Qpe = Object.getOwnPropertyDescriptor, ege = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? Qpe(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, WN = (r, e) => (t, n) => e(t, n, r);
const tge = 20;
let zI = class {
  constructor(r, e) {
    this.networkService = r, this.config = e;
  }
  async getTransactions(r, e, t) {
    const n = this.buildQueryParams(t), i = this.buildRequestUrl(r, e, n);
    return (await this.networkService.get(i)).mapLeft(
      (o) => new Ype(
        `Failed to fetch transaction history for ${e}`,
        { address: e, blockchain: r, originalError: o.message }
      )
    );
  }
  buildQueryParams(r) {
    const e = new URLSearchParams();
    return e.set("batch_size", String((r == null ? void 0 : r.batchSize) ?? tge)), e.set("order", "descending"), e.set("noinput", "true"), e.set("filtering", "true"), r != null && r.pageToken && e.set("token", r.pageToken), e.toString();
  }
  buildRequestUrl(r, e, t) {
    return `${this.config.getExplorerUrl()}/blockchain/v4/${r}/address/${e}/txs?${t}`;
  }
};
zI = ege([
  ke(),
  WN(0, H(gl.NetworkService)),
  WN(1, H(Dt.Config))
], zI);
var rge = Object.getOwnPropertyDescriptor, nge = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? rge(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, ZN = (r, e) => (t, n) => e(t, n, r);
let jI = class {
  constructor(r, e) {
    h(this, "logger");
    this.dataSource = e, this.logger = r("[FetchTransactionHistoryUseCase]");
  }
  async execute(r, e, t) {
    return this.logger.debug("Fetching transaction history", {
      blockchain: r,
      address: e,
      options: t
    }), (await this.dataSource.getTransactions(
      r,
      e,
      t
    )).caseOf({
      Left: (i) => (this.logger.error("Failed to fetch transaction history", { error: i }), N(i)),
      Right: (i) => {
        const s = this.transformResponse(
          i,
          e.toLowerCase()
        );
        return this.logger.debug("Transaction history fetched successfully", {
          transactionCount: s.transactions.length,
          hasNextPage: !!s.nextPageToken
        }), te(s);
      }
    });
  }
  transformResponse(r, e) {
    return {
      transactions: r.data.map(
        (n) => this.transformTransaction(n, e)
      ),
      nextPageToken: r.token ?? void 0
    };
  }
  transformTransaction(r, e) {
    const t = this.determineTransactionType(r, e), n = this.calculateTransactionValue(r, e, t), i = this.extractTimestamp(r);
    return {
      hash: r.hash,
      type: t,
      value: n,
      timestamp: i
    };
  }
  determineTransactionType(r, e) {
    const t = r.from.toLowerCase() === e, n = r.transfer_events.some(
      (i) => i.to.toLowerCase() === e
    );
    return t && !n ? "sent" : n || r.to.toLowerCase() === e ? "received" : "sent";
  }
  calculateTransactionValue(r, e, t) {
    const n = this.getTokenTransferValue(
      r,
      e,
      t
    );
    return n !== "0" ? n : this.getNativeValue(r, e, t);
  }
  getTokenTransferValue(r, e, t) {
    const n = r.transfer_events.filter((s) => t === "received" ? s.to.toLowerCase() === e : s.from.toLowerCase() === e);
    return n.length === 0 ? "0" : n.reduce(
      (s, o) => s + BigInt(o.count),
      BigInt(0)
    ).toString();
  }
  getNativeValue(r, e, t) {
    const n = r.actions.filter((i) => t === "received" ? i.to.toLowerCase() === e : i.from.toLowerCase() === e);
    return n.length > 0 ? n.reduce(
      (s, o) => s + BigInt(o.value),
      BigInt(0)
    ).toString() : t === "received" && r.to.toLowerCase() === e && r.value !== "0" || t === "sent" && r.from.toLowerCase() === e ? r.value : "0";
  }
  extractTimestamp(r) {
    var e;
    return ((e = r.block) == null ? void 0 : e.time) ?? r.received_at;
  }
};
jI = nge([
  ke(),
  ZN(0, H(Me.LoggerPublisher)),
  ZN(1, H(Vy.TransactionHistoryDataSource))
], jI);
function ige({
  stub: r
}) {
  return new $r(({ bind: e }) => {
    e(
      Vy.TransactionHistoryDataSource
    ).to(zI).inSingletonScope(), e(
      Vy.FetchTransactionHistoryUseCase
    ).to(jI).inSingletonScope();
  });
}
var sge = Object.getOwnPropertyDescriptor, oge = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? sge(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, nS = (r, e) => (t, n) => e(t, n, r);
let vv = class {
  constructor(r, e, t) {
    h(this, "logger");
    this.loggerFactory = r, this.backendService = e, this.contextService = t, this.logger = this.loggerFactory("[LedgerRemoteDatasource]");
  }
  async JSONRPCRequest(r) {
    try {
      const e = await this.backendService.broadcast({
        blockchain: {
          name: "ethereum",
          chainId: this.contextService.getContext().chainId.toString()
        },
        rpc: r
      });
      return e.isLeft() ? N(
        new Error("Error in JSONRPCRequest", { cause: e.extract() })
      ) : e.isRight() && wC(e.extract()) ? te(e.extract()) : N(
        new Error("Error in JSONRPCRequest", { cause: e.extract() })
      );
    } catch (e) {
      return this.logger.error("Error in JSONRPCRequest", { error: e }), N(new Error("Error in JSONRPCRequest", { cause: e }));
    }
  }
};
vv = oge([
  ke(),
  nS(0, H(Me.LoggerPublisher)),
  nS(1, H(xc.BackendService)),
  nS(2, H(ci.ContextService))
], vv);
const age = {
  UserRejectedRequest: 4001,
  Unauthorized: 4100,
  UnsupportedMethod: 4200,
  Disconnected: 4900,
  ChainDisconnected: 4901,
  // Additional common error codes (JSON-RPC 2.0)
  ParseError: -32700,
  InvalidRequest: -32600,
  MethodNotFound: -32601,
  InvalidParams: -32602,
  InternalError: -32603
};
var cge = Object.getOwnPropertyDescriptor, uge = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? cge(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
};
let HI = class extends vv {
  async JSONRPCRequest(r) {
    return Promise.resolve(
      te({
        jsonrpc: "2.0",
        id: r.id,
        result: void 0,
        error: {
          code: age.UnsupportedMethod,
          message: `Method ${r.method} is not supported, { method: ${r.method}, params: ${JSON.stringify(r.params)} }`
        }
      })
    );
  }
};
HI = uge([
  ke()
], HI);
const Bp = {
  JSONRPCCallUseCase: Symbol.for("JSONRPCCallUseCase"),
  LedgerRemoteDatasource: Symbol.for("LedgerRemoteDatasource")
};
var lge = Object.getOwnPropertyDescriptor, dge = (r, e, t, n) => {
  for (var i = n > 1 ? void 0 : n ? lge(e, t) : e, s = r.length - 1, o; s >= 0; s--)
    (o = r[s]) && (i = o(i) || i);
  return i;
}, JN = (r, e) => (t, n) => e(t, n, r);
let GI = class {
  constructor(r, e) {
    h(this, "logger");
    this.datasource = e, this.logger = r("[JSONRPCCallUseCase UseCase]");
  }
  async execute(r) {
    return this.logger.debug("JSONRPCRequest", { args: r }), (await this.datasource.JSONRPCRequest(r)).caseOf({
      Right: (t) => (this.logger.debug("JSONRPCRequest response", { response: t }), t),
      Left: (t) => {
        this.logger.error("JSONRPCRequest failed", { error: t });
      }
    });
  }
};
GI = dge([
  ke(),
  JN(0, H(Me.LoggerPublisher)),
  JN(1, H(Bp.LedgerRemoteDatasource))
], GI);
function hge({ stub: r }) {
  return new $r(({ bind: e, rebindSync: t }) => {
    e(Bp.LedgerRemoteDatasource).to(
      vv
    ), e(Bp.JSONRPCCallUseCase).to(GI), r && t(Bp.LedgerRemoteDatasource).to(
      HI
    );
  });
}
function XN({
  loggerLevel: r = "info",
  dmkConfig: e,
  apiKey: t,
  dAppIdentifier: n,
  environment: i = "production",
  rpcUrls: s,
  devConfig: o = {
    stub: {
      base: !1,
      account: !1,
      device: !1,
      web3Provider: !1,
      balance: !1,
      dAppConfig: !1,
      transactionHistory: !1
    }
  }
}) {
  const a = new hK();
  return a.loadSync(
    HQ({
      loggerLevel: r,
      apiKey: t,
      dAppIdentifier: n,
      environment: i,
      rpcUrls: s
    }),
    LQ({ stub: o.stub.balance }),
    ype({
      stub: o.stub.base,
      errorTrackingConfig: G4
    }),
    RW({ stub: o.stub.account }),
    pQ({ stub: o.stub.base }),
    pie({ stub: o.stub.dAppConfig }),
    ile({ stub: o.stub.device, dmkConfig: e }),
    Gle({ stub: o.stub.base }),
    zpe({ stub: o.stub.base }),
    qQ(),
    Dpe({ stub: o.stub.base }),
    Xpe({ stub: o.stub.base }),
    ige({ stub: o.stub.transactionHistory }),
    hge({ stub: o.stub.web3Provider }),
    Kfe({ stub: o.stub.base }),
    lie({ stub: o.stub.base }),
    MQ({ stub: o.stub.base }),
    wpe(),
    XQ()
  ), a;
}
class C_e {
  constructor(e) {
    h(this, "container");
    h(this, "_pendingTransactionParams");
    h(this, "_pendingAccountId");
    h(this, "_logger");
    // ModalService is created for side effects (event wiring), not used directly.
    h(this, "_modalService");
    h(this, "_contextService");
    this.opts = e, this.container = XN(this.opts);
    const t = this.container.get(
      Me.LoggerPublisher
    );
    this._logger = t("[Ledger Button Core]"), this._modalService = this.container.get(
      XC.ModalService
    ), this._contextService = this.container.get(
      ci.ContextService
    ), this.initializeContext();
  }
  async initializeContext() {
    this._logger.debug("Initializing context"), await this.container.get(mc.DAppConfigService).getDAppConfig(), await this.container.get(zt.MigrateDbUseCase).execute();
    const e = this.container.get(zt.StorageService).getSelectedAccount().extract(), t = this.container.get(zt.StorageService).getTrustChainId().extract(), n = this.container.get(zt.StorageService).isTrustChainValid();
    t && !n && (this._logger.debug("Logging out, trust chain is expired"), await this.disconnect());
    const i = e ? qg(e.currencyId) : 1, s = await this.container.get(zt.StorageService).isWelcomeScreenCompleted(), o = await this.container.get(zt.StorageService).getUserConsent(), a = o.isJust() ? o.extract().consentGiven : void 0;
    this._contextService.onEvent({
      type: "initialize_context",
      context: {
        connectedDevice: void 0,
        selectedAccount: n ? e : void 0,
        trustChainId: n ? t : void 0,
        applicationPath: void 0,
        chainId: i,
        welcomeScreenCompleted: s,
        hasTrackingConsent: a
      }
    });
  }
  listenDevice() {
    var i;
    const e = this.container.get(
      gt.DeviceManagementKitService
    ), t = e.dmk, n = (i = e.connectedDevice) == null ? void 0 : i.sessionId;
    n && t.getDeviceSessionState({
      sessionId: n
    }).subscribe((s) => {
      s.deviceStatus === na.NOT_CONNECTED && (this._logger.info("Device disconnected"), this._contextService.onEvent({
        type: "device_disconnected"
      }));
    });
  }
  async disconnect() {
    this._logger.debug("Disconnecting from device"), await this.disconnectFromDevice(), this.container.get(zt.StorageService).resetStorage(), this._contextService.onEvent({
      type: "wallet_disconnected"
    });
    try {
      await this.container.unbindAll();
    } catch (e) {
      this._logger.error("Error unbinding container", { error: e });
    } finally {
      this._logger.debug("Recreating container"), this.container = XN(this.opts);
    }
  }
  // Device methods
  async connectToDevice(e) {
    this._logger.debug("Connecting to device", { type: e });
    const t = await this.container.get(gt.ConnectDeviceUseCase).execute({ type: e });
    return this._contextService.onEvent({
      type: "device_connected",
      device: t
    }), this.listenDevice(), t;
  }
  async disconnectFromDevice() {
    this._logger.debug("Disconnecting from device");
    const e = await this.container.get(gt.DisconnectDeviceUseCase).execute();
    return this._contextService.onEvent({
      type: "device_disconnected"
    }), e;
  }
  async getReferralUrl() {
    return this.container.get(mc.DAppConfigService).getDAppConfig().then((e) => e.referralUrl);
  }
  async switchDevice(e) {
    return this._logger.debug("Switching device", { type: e }), this.container.get(gt.SwitchDeviceUseCase).execute({ type: e });
  }
  // Account methods
  async fetchAccounts() {
    this._logger.debug("Fetching accounts");
    const e = this.container.get(
      Ot.FetchAccountsWithBalanceUseCase
    ).execute(), t = await S1(e);
    return this.container.get(Ot.AccountService).setAccounts(t), t;
  }
  /**
   * Fetches accounts with progressive balance loading.
   * Returns an Observable that emits:
   * - First: accounts with balance: undefined (accounts available, balances loading)
   * - Then: updated accounts as each balance loads
   * Use this for progressive UI updates with skeleton loading states.
   * Emits 'ledger-accounts-updated' event on window for UI reactivity.
   */
  fetchAccountsWithProgress() {
    return this._logger.debug("Fetching accounts with progress"), this.container.get(
      Ot.FetchAccountsWithBalanceUseCase
    ).execute().pipe(
      po((t) => {
        this.container.get(Ot.AccountService).setAccounts(t), typeof window < "u" && window.dispatchEvent(
          new CustomEvent("ledger-accounts-updated", {
            detail: { accounts: t }
          })
        );
      })
    );
  }
  getAccounts() {
    return this._logger.debug("Getting accounts"), this.container.get(Ot.AccountService).getAccounts();
  }
  selectAccount(e) {
    this._logger.debug("Selecting account", { account: e }), this.container.get(Ot.AccountService).selectAccount(e);
    const t = this.container.get(Ot.AccountService).getSelectedAccount();
    t && (this._contextService.onEvent({
      type: "account_changed",
      account: t
    }), this.container.get(rt.TrackOnboarding).execute(t));
  }
  getSelectedAccount() {
    return this._logger.debug("Getting selected account"), this.container.get(
      Ot.AccountService
    ).getSelectedAccount();
  }
  async getDetailedSelectedAccount() {
    return this._logger.debug("Getting detailed selected account"), this.container.get(
      Ot.GetDetailedSelectedAccountUseCase
    ).execute();
  }
  // Device methods
  getConnectedDevice() {
    return this._logger.debug("Getting connected device"), this.container.get(
      gt.DeviceManagementKitService
    ).connectedDevice;
  }
  async listAvailableDevices() {
    return this._logger.debug("Listing available devices"), this.container.get(gt.ListAvailableDevicesUseCase).execute();
  }
  // Transaction methods
  sign(e) {
    var t;
    return this._logger.debug("Signing transaction", { params: e }), (t = this.container) == null ? void 0 : t.get(VI.TransactionService).sign(e);
  }
  setPendingTransactionParams(e) {
    this._logger.debug("Setting pending transaction params", { params: e }), this._pendingTransactionParams = e;
  }
  getPendingTransactionParams() {
    return this._logger.debug("Getting pending transaction params"), this._pendingTransactionParams;
  }
  setPendingAccountId(e) {
    this._logger.debug("Setting pending account id", { id: e }), this._pendingAccountId = e;
  }
  getPendingAccountId() {
    return this._logger.debug("Getting pending account address"), this._pendingAccountId;
  }
  clearPendingAccountId() {
    this._logger.debug("Clearing pending account id"), this._pendingAccountId = void 0;
  }
  // Consent methods
  async hasConsent() {
    return this._logger.debug("Checking user consent"), await this.container.get(zl.ConsentService).hasConsent();
  }
  async hasRespondedToConsent() {
    return this._logger.debug("Checking if user has responded to consent"), await this.container.get(zl.ConsentService).hasRespondedToConsent();
  }
  async giveConsent() {
    this._logger.debug("Giving user consent"), await this.container.get(zl.ConsentService).giveConsent(), this._contextService.onEvent({
      type: "tracking_consent_given"
    });
  }
  async refuseConsent() {
    this._logger.debug("Refusing user consent"), await this.container.get(zl.ConsentService).refuseConsent(), this._contextService.onEvent({
      type: "tracking_consent_refused"
    });
  }
  async removeConsent() {
    this._logger.debug("Removing user consent"), await this.container.get(zl.ConsentService).removeConsent(), this._contextService.onEvent({
      type: "tracking_consent_refused"
    });
  }
  async setWelcomeScreenCompleted() {
    this._logger.debug("Setting welcome screen as completed"), await this.container.get(zt.StorageService).saveWelcomeScreenCompleted(), this._contextService.onEvent({
      type: "welcome_screen_completed"
    });
  }
  isWelcomeScreenCompleted() {
    return this._contextService.getContext().welcomeScreenCompleted;
  }
  getTransactionService() {
    return this._logger.debug("Getting transaction service"), this.container.get(
      VI.TransactionService
    );
  }
  async jsonRpcRequest(e) {
    return this._logger.debug("JSON RPC request", { args: e }), this.container.get(Bp.JSONRPCCallUseCase).execute(e);
  }
  getBackendService() {
    return this._logger.debug("Getting backend service"), this.container.get(
      xc.BackendService
    );
  }
  connectToLedgerSync() {
    return this._logger.debug("Connecting to ledger sync"), this.container.get(
      rt.TrackLedgerSyncOpened
    ).execute(), this.container.get(Xv.LedgerSyncService).authenticate().pipe(
      po(async (t) => {
        this.isAuthContext(t) && (this._contextService.onEvent({
          type: "trustchain_connected",
          trustChainId: t.trustChainId,
          applicationPath: t.applicationPath
        }), await this.container.get(
          rt.TrackLedgerSyncActivated
        ).execute());
      })
    );
  }
  isAuthContext(e) {
    return "trustChainId" in e && "applicationPath" in e;
  }
  observeContext() {
    return this._contextService.observeContext();
  }
  // Config methods
  getConfig() {
    return this.container.get(Dt.Config);
  }
  setLogLevel(e) {
    this.container.get(Dt.Config).setLogLevel(e);
  }
  isSupported() {
    return this.container.get(
      gt.DeviceManagementKitService
    ).dmk.isEnvironmentSupported();
  }
  setChainId(e) {
    this._contextService.onEvent({
      type: "chain_changed",
      chainId: e
    });
  }
  getChainId() {
    return this._contextService.getContext().chainId;
  }
  async trackFloatingButtonClick() {
    await this.container.get(
      rt.TrackFloatingButtonClick
    ).execute();
  }
  async trackWalletActionClicked(e) {
    await this.container.get(rt.TrackWalletAction).trackWalletActionClicked(e);
  }
  async trackWalletRedirectConfirmed(e) {
    await this.container.get(rt.TrackWalletAction).trackWalletRedirectConfirmed(e);
  }
  async trackWalletRedirectCancelled(e) {
    await this.container.get(rt.TrackWalletAction).trackWalletRedirectCancelled(e);
  }
}
export {
  K8 as AccountNotFoundError,
  qI as AccountNotSelectedError,
  kB as BlindSigningDisabledError,
  lm as BroadcastTransactionError,
  age as CommonEIP1193ErrorCode,
  uo as DeviceConnectionError,
  vge as DeviceDisconnectedError,
  V8 as DeviceNotSupportedError,
  pge as FailToOpenAppError,
  H8 as FailedToFetchEncryptedAccountsError,
  WI as IncorrectSeedError,
  C_e as LedgerButtonCore,
  it as LedgerButtonError,
  L8 as LedgerKeyringProtocolError,
  TB as LedgerSyncAuthContextMissingError,
  zfe as LedgerSyncAuthenticationError,
  yge as LedgerSyncConnectionFailedError,
  gge as LedgerSyncError,
  mge as LedgerSyncNoSessionIdError,
  Cf as NetworkError,
  j8 as NoAccountInSyncError,
  z8 as NoCompatibleAccountsError,
  G8 as NoSelectedAccountError,
  B8 as SignTransactionError,
  If as StorageIDBGetError,
  F8 as StorageIDBNotInitializedError,
  U8 as StorageIDBOpenError,
  M8 as StorageIDBRemoveError,
  um as StorageIDBStoreError,
  ZI as UserRejectedTransactionError,
  qg as getChainIdFromCurrencyId,
  hve as hexToUtf8,
  ZP as isBroadcastedTransactionResult,
  WC as isGetAddressResult,
  jpe as isSignPersonalMessageParams,
  Hpe as isSignRawTransactionParams,
  Gpe as isSignTransactionParams,
  Wpe as isSignTypedMessageParams,
  ZC as isSignedMessageOrTypedDataResult,
  WP as isSignedTransactionResult
};
